#!/usr/bin/env python3
"""
Export Bazel dependency graph to Neo4j-compatible format
Converts DOT files generated by visualize_deps.sh to CSV files for Neo4j import
"""

import re
import os
import argparse
import subprocess
from pathlib import Path

def parse_dot_file(dot_file):
    """Parse a DOT file into nodes and edges"""
    nodes = set()
    edges = []
    
    with open(dot_file, 'r') as f:
        content = f.read()
    
    # Extract digraph name
    graph_name = re.search(r'digraph (\w+)', content)
    graph_name = graph_name.group(1) if graph_name else "BazelDeps"
    
    # Extract nodes and edges
    for line in content.split('\n'):
        # Skip empty lines and digraph definition lines
        if not line.strip() or line.strip().startswith('digraph') or line.strip() == '}':
            continue
            
        # Check if this is an edge definition
        edge_match = re.search(r'"([^"]+)"\s*->\s*"([^"]+)"', line)
        if edge_match:
            source = edge_match.group(1)
            target = edge_match.group(2)
            nodes.add(source)
            nodes.add(target)
            edges.append((source, target))
        else:
            # Must be a node definition
            node_match = re.search(r'"([^"]+)"', line)
            if node_match:
                nodes.add(node_match.group(1))
    
    return list(nodes), edges, graph_name

def classify_node(node_name):
    """Classify a node based on its name/path"""
    if node_name.startswith('@'):
        return 'ExternalDependency'
    elif '//' in node_name:
        parts = node_name.split(':')
        if len(parts) > 1:
            if 'test' in parts[1].lower():
                return 'TestTarget'
            else:
                return 'BuildTarget'
        else:
            return 'Package'
    else:
        return 'Other'

def create_csv_files(nodes, edges, output_dir, graph_name):
    """Create CSV files for Neo4j import"""
    os.makedirs(output_dir, exist_ok=True)
    
    # Create nodes CSV
    with open(f"{output_dir}/nodes.csv", 'w') as f:
        f.write("nodeId:ID,name,type,graph\n")
        for i, node in enumerate(nodes):
            node_type = classify_node(node)
            f.write(f"{i},{node},{node_type},{graph_name}\n")
    
    # Create node ID mapping for edges
    node_id_map = {node: i for i, node in enumerate(nodes)}
    
    # Create edges CSV
    with open(f"{output_dir}/edges.csv", 'w') as f:
        f.write(":START_ID,:END_ID,type\n")
        for source, target in edges:
            source_id = node_id_map[source]
            target_id = node_id_map[target]
            f.write(f"{source_id},{target_id},DEPENDS_ON\n")
    
    print(f"Created CSV files in {output_dir}")
    print(f"Nodes: {len(nodes)}")
    print(f"Edges: {len(edges)}")

def generate_neo4j_import_script(output_dir, db_name):
    """Generate a script to import the CSV files into Neo4j"""
    script_path = f"{output_dir}/import_to_neo4j.sh"
    
    with open(script_path, 'w') as f:
        f.write("#!/bin/bash\n\n")
        f.write(f"# Import Bazel dependency graph into Neo4j\n")
        f.write(f"# Database name: {db_name}\n\n")
        
        f.write("# Stop Neo4j if it's running\n")
        f.write("echo 'Stopping Neo4j...'\n")
        f.write("neo4j stop\n\n")
        
        f.write(f"# Import data\n")
        f.write(f"echo 'Importing data into {db_name}...'\n")
        f.write(f"neo4j-admin database import full --nodes={output_dir}/nodes.csv --relationships={output_dir}/edges.csv {db_name}\n\n")
        
        f.write("# Start Neo4j\n")
        f.write("echo 'Starting Neo4j...'\n")
        f.write("neo4j start\n\n")
        
        f.write("echo 'Import complete. Access the database at http://localhost:7474/'\n")
        f.write("echo 'Use the following Cypher query to view the graph:'\n")
        f.write("echo 'MATCH (n) RETURN n LIMIT 100'\n")
        
        f.write("\n# Sample queries:\n")
        f.write("cat << 'EOT' > ${output_dir}/sample_queries.cypher\n")
        f.write("// Find all direct dependencies of a module\n")
        f.write("MATCH (n)-[:DEPENDS_ON]->(dep) WHERE n.name CONTAINS '//Sources/UmbraLogging' RETURN n, dep;\n\n")
        
        f.write("// Find all reverse dependencies (what depends on a module)\n")
        f.write("MATCH (n)-[:DEPENDS_ON]->(dep) WHERE dep.name CONTAINS '//Sources/UmbraLogging' RETURN n, dep;\n\n")
        
        f.write("// Find the shortest path between two modules\n")
        f.write("MATCH p=shortestPath((n)-[:DEPENDS_ON*]->(dep)) WHERE n.name CONTAINS 'ModuleA' AND dep.name CONTAINS 'ModuleB' RETURN p;\n\n")
        
        f.write("// Find circular dependencies\n")
        f.write("MATCH p=(n)-[:DEPENDS_ON*]->(n) RETURN p LIMIT 10;\n\n")
        
        f.write("// Find modules with most dependencies\n")
        f.write("MATCH (n)-[:DEPENDS_ON]->(dep) RETURN n.name, count(dep) AS dependencies ORDER BY dependencies DESC LIMIT 10;\n\n")
        
        f.write("// Find modules with most reverse dependencies\n")
        f.write("MATCH (n)-[:DEPENDS_ON]->(dep) RETURN dep.name, count(n) AS dependents ORDER BY dependents DESC LIMIT 10;\n")
        f.write("EOT\n\n")
        
        f.write("echo 'Sample Cypher queries saved to ${output_dir}/sample_queries.cypher'\n")
    
    os.chmod(script_path, 0o755)
    print(f"Generated Neo4j import script: {script_path}")

def generate_cypher_queries(output_dir, nodes):
    """Generate useful Cypher queries"""
    module_names = [n for n in nodes if '//' in n and not n.startswith('@')]
    
    with open(f"{output_dir}/custom_queries.cypher", 'w') as f:
        f.write("// UmbraCore Dependency Analysis Queries\n\n")
        
        f.write("// View the entire graph\n")
        f.write("MATCH (n) RETURN n LIMIT 100;\n\n")
        
        if module_names:
            sample_module = module_names[0]
            
            f.write(f"// Dependencies of {sample_module}\n")
            f.write(f"MATCH (n)-[:DEPENDS_ON]->(dep) WHERE n.name = '{sample_module}' RETURN n, dep;\n\n")
            
            f.write(f"// What depends on {sample_module}\n")
            f.write(f"MATCH (n)-[:DEPENDS_ON]->(dep) WHERE dep.name = '{sample_module}' RETURN n, dep;\n\n")
        
        f.write("// External dependencies\n")
        f.write("MATCH (n) WHERE n.type = 'ExternalDependency' RETURN n;\n\n")
        
        f.write("// Test targets\n")
        f.write("MATCH (n) WHERE n.type = 'TestTarget' RETURN n;\n\n")
        
        f.write("// Find potential circular dependencies\n")
        f.write("MATCH p=(n)-[:DEPENDS_ON*]->(n) RETURN p LIMIT 10;\n\n")
        
        f.write("// Modules with most dependencies\n")
        f.write("MATCH (n)-[:DEPENDS_ON]->(dep) RETURN n.name, count(dep) AS dependencies ORDER BY dependencies DESC LIMIT 10;\n\n")
        
        f.write("// Modules with most reverse dependencies\n")
        f.write("MATCH (n)-[:DEPENDS_ON]->(dep) RETURN dep.name, count(n) AS dependents ORDER BY dependents DESC LIMIT 10;\n\n")
        
        f.write("// Dependency chain depth\n")
        f.write("MATCH p=(n)-[:DEPENDS_ON*]->(dep) RETURN n.name as source, length(p) as chain_length ORDER BY chain_length DESC LIMIT 10;\n")
    
    print(f"Generated sample Cypher queries: {output_dir}/custom_queries.cypher")

def main():
    parser = argparse.ArgumentParser(description="Export Bazel dependency graph to Neo4j format")
    parser.add_argument("--dot-file", type=str, help="Path to DOT file generated by visualize_deps.sh")
    parser.add_argument("--target", type=str, help="Bazel target to visualize (e.g. //Sources/UmbraLogging)")
    parser.add_argument("--output-dir", type=str, default="analysis/neo4j", help="Output directory for Neo4j CSV files")
    parser.add_argument("--db-name", type=str, default="umbracore-deps", help="Neo4j database name")
    
    args = parser.parse_args()
    
    dot_file = args.dot_file
    
    # If no DOT file is provided, but a target is, run visualize_deps.sh
    if not dot_file and args.target:
        print(f"Generating dependency graph for {args.target}...")
        subprocess.run(["./visualize_deps.sh", args.target], check=True)
        dot_file = f"analysis/target_deps.dot"
    
    if not dot_file or not os.path.exists(dot_file):
        print("Please provide a valid DOT file or target")
        parser.print_help()
        return 1
    
    # Parse the DOT file
    nodes, edges, graph_name = parse_dot_file(dot_file)
    
    # Create CSV files
    create_csv_files(nodes, edges, args.output_dir, graph_name)
    
    # Generate Neo4j import script
    generate_neo4j_import_script(args.output_dir, args.db_name)
    
    # Generate Cypher queries
    generate_cypher_queries(args.output_dir, nodes)
    
    print("\nNext steps:")
    print("1. Install Neo4j if you haven't already:")
    print("   brew install neo4j")
    print("2. Run the generated import script:")
    print(f"   {args.output_dir}/import_to_neo4j.sh")
    print("3. Access Neo4j Browser at http://localhost:7474/")
    print("4. Use the queries in custom_queries.cypher")

if __name__ == "__main__":
    main()
