{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#umbracore-documentation","title":"UmbraCore Documentation","text":"<p>UmbraCore is built upon the foundation of Restic, a remarkable open-source backup programme that has set the standard for secure, efficient, and reliable backups. We are deeply grateful to the Restic team for their years of dedication in creating and maintaining such an exceptional tool.</p> <p>Our mission with UmbraCore is to extend Restic's capabilities specifically for macOS application developers, providing a type-safe, Swift-native interface while maintaining complete compatibility with Restic's core functionality. UmbraCore is not an alternative to Restic, but rather a complementary tool that makes Restic's powerful features more accessible in the macOS development ecosystem.</p>"},{"location":"#core-applications","title":"Core Applications","text":"<p>UmbraCore powers several macOS backup management tools: - ResticBar: macOS menu bar app for developers - Rbx: VS Code extension - Rbum: User-friendly GUI</p>"},{"location":"#features","title":"Features","text":""},{"location":"#implemented","title":"Implemented","text":"<ul> <li>Secure keychain operations with XPC service</li> <li>Comprehensive error handling and logging</li> <li>Thread-safe operations</li> <li>SwiftyBeaver logging integration</li> <li>Modular architecture</li> <li>Extensive test coverage</li> </ul>"},{"location":"#in-development","title":"In Development","text":"<ul> <li>SSH key management</li> <li>Cloud provider credentials</li> <li>Repository password handling</li> </ul>"},{"location":"#architecture","title":"Architecture","text":""},{"location":"#core-libraries","title":"Core Libraries","text":"<ul> <li>SecurityTypes: Base security primitives and protocols</li> <li>CryptoTypes: Cryptographic operations and types</li> <li>UmbraLogging: Centralised logging infrastructure</li> </ul>"},{"location":"#service-layer","title":"Service Layer","text":"<ul> <li>UmbraKeychainService: Secure keychain operations</li> <li>UmbraCryptoService: Cryptographic operations service</li> <li>UmbraBookmarkService: File system bookmark management</li> <li>UmbraXPC: XPC communication infrastructure</li> </ul>"},{"location":"#features_1","title":"Features","text":"<ul> <li>ResticCLIHelper: Command-line interface integration</li> <li>Repositories: Repository management and operations</li> <li>Snapshots: Snapshot creation and management</li> <li>Config: Configuration and settings management</li> <li>Logging: Privacy-aware structured logging</li> <li>ErrorHandling: Comprehensive error management</li> <li>Autocomplete: Context-aware command completion</li> </ul>"},{"location":"#project-status","title":"Project Status","text":"<p>UmbraCore is currently in active development with the following features:</p>"},{"location":"#tested-operable","title":"Tested &amp; Operable","text":"<ul> <li>Repository Management<ul> <li>Secure repository initialisation</li> <li>Repository health monitoring</li> <li>Multi-repository support</li> </ul> </li> <li>Core Restic Integration<ul> <li>Command execution system</li> <li>Output parsing</li> <li>Error handling</li> <li>Process management</li> </ul> </li> <li>Security Layer<ul> <li>XPC protocol consolidation</li> <li>Keychain integration</li> <li>Secure error handling</li> </ul> </li> <li>Testing Infrastructure<ul> <li>Unit testing framework</li> <li>Integration test suite</li> <li>Performance benchmarks</li> <li>Mock services</li> </ul> </li> </ul>"},{"location":"#future-development","title":"Future Development","text":"<ul> <li>Advanced Security Features<ul> <li>SSH key management</li> <li>Cloud provider credentials</li> <li>Enhanced repository password handling</li> </ul> </li> <li>Configuration System<ul> <li>Configuration file format</li> <li>Validation system</li> <li>Migration support</li> </ul> </li> <li>Analytics &amp; Monitoring<ul> <li>Progress reporting protocol</li> <li>Performance metrics</li> <li>Usage statistics</li> <li>System diagnostics</li> </ul> </li> <li>Event System<ul> <li>Event dispatching</li> <li>Notification management</li> <li>Webhook support</li> </ul> </li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Please refer to our Quick Start Guide for installation and basic usage instructions.</p>"},{"location":"#security","title":"Security","text":"<p>UmbraCore prioritises security in all aspects of its implementation. For details, see our Security Guide.</p>"},{"location":"#documentation","title":"Documentation","text":"<p>Key documentation sections:</p> <ul> <li>Configuration: Configuration Guide</li> <li>Features: Advanced Features</li> <li>Development: API Reference</li> <li>Support: Troubleshooting Guide</li> </ul>"},{"location":"#support","title":"Support","text":"<p>If you find UmbraCore useful, please consider:</p> <ol> <li>Contributing to the project</li> <li>Supporting Restic</li> <li>Starring us on GitHub</li> <li>Sharing your experience with others</li> </ol>"},{"location":"#license","title":"License","text":"<p>UmbraCore is available under the MIT license. See the LICENSE file for more info.</p>"},{"location":"ACKNOWLEDGMENTS/","title":"Acknowledgments","text":"<p>UmbraCore stands on the shoulders of open-source giants. We're deeply grateful to the following open-source projects and their maintainers:</p>"},{"location":"ACKNOWLEDGMENTS/#core-dependencies","title":"Core Dependencies","text":""},{"location":"ACKNOWLEDGMENTS/#restic","title":"Restic","text":"<p>Restic is the backbone of UmbraCore's backup capabilities. It's a modern backup program written in Go which provides: - Fast, secure, and efficient backups - Deduplication - Encryption - Multiple backend support - Outstanding performance</p> <p>We highly recommend supporting the Restic project: - GitHub Repository - Documentation - Contributing Guide - Donate</p>"},{"location":"ACKNOWLEDGMENTS/#swiftybeaver","title":"SwiftyBeaver","text":"<p>SwiftyBeaver powers UmbraCore's logging infrastructure. It's a sophisticated logging system that offers: - Colourised console output - File logging - Cloud logging - Custom formats - Filters and threading support</p> <p>Support SwiftyBeaver: - GitHub Repository - Documentation - Pro Features</p>"},{"location":"ACKNOWLEDGMENTS/#cryptoswift","title":"CryptoSwift","text":"<p>CryptoSwift provides UmbraCore's cryptographic operations. It's a comprehensive cryptography framework offering: - AES encryption - Hash functions - HMAC - PBKDF - Extensible architecture</p> <p>Support CryptoSwift: - GitHub Repository - Documentation - Sponsor</p>"},{"location":"ACKNOWLEDGMENTS/#development-tools","title":"Development Tools","text":""},{"location":"ACKNOWLEDGMENTS/#just-the-docs","title":"Just the Docs","text":"<p>The beautiful documentation theme you're currently viewing. Features: - Clean, responsive design - Full-text search - Dark/light mode - Navigation structure - Customisation options</p> <p>Support Just the Docs: - GitHub Repository - Documentation - Contributing Guide</p>"},{"location":"ACKNOWLEDGMENTS/#jazzy","title":"Jazzy","text":"<p>Jazzy generates our API documentation. It provides: - Clean documentation generation - Markdown support - Search functionality - Cross-references</p> <p>Support Jazzy: - GitHub Repository - Documentation - Contributing Guide</p>"},{"location":"ACKNOWLEDGMENTS/#swiftlint","title":"SwiftLint","text":"<p>SwiftLint helps maintain our code quality. It offers: - Style and convention checking - Customisable rules - Automatic fixing - Xcode integration</p> <p>Support SwiftLint: - GitHub Repository - Documentation - Contributing Guide</p>"},{"location":"ACKNOWLEDGMENTS/#security-tools","title":"Security Tools","text":""},{"location":"ACKNOWLEDGMENTS/#snyk","title":"Snyk","text":"<p>Snyk helps keep UmbraCore secure by providing: - Vulnerability scanning - Dependency monitoring - Security updates - License compliance</p> <p>Support Snyk: - Website - Documentation - Blog</p>"},{"location":"ACKNOWLEDGMENTS/#codecov","title":"Codecov","text":"<p>Codecov helps maintain our test coverage by offering: - Coverage reporting - PR checks - Trending analysis - Quality gates</p> <p>Support Codecov: - Website - Documentation - GitHub Repository</p>"},{"location":"ACKNOWLEDGMENTS/#contributing","title":"Contributing","text":"<p>If you'd like to contribute to UmbraCore, please see our Contributing Guidelines. We welcome all contributions, from code to documentation improvements.</p>"},{"location":"ACKNOWLEDGMENTS/#supporting-open-source","title":"Supporting Open Source","text":"<p>We encourage users of UmbraCore to consider supporting these projects through: - Code contributions - Documentation improvements - Bug reports - Financial support where available - Spreading the word about their excellent work</p> <p>The strength of UmbraCore comes from these outstanding open-source projects. Supporting them helps ensure a vibrant and sustainable open-source ecosystem.</p>"},{"location":"DEPENDENCIES/","title":"UmbraCore Dependencies Documentation","text":""},{"location":"DEPENDENCIES/#core-module-structure","title":"Core Module Structure","text":""},{"location":"DEPENDENCIES/#main-components","title":"Main Components","text":"<ol> <li>API Layer</li> <li><code>//Sources/API:Sources_API</code></li> <li> <p>Dependencies:</p> <ul> <li>Core/UmbraCore</li> </ul> </li> <li> <p>Core Services</p> </li> <li><code>//Sources/Core:Sources_Core</code></li> <li><code>//Sources/Core/Services:CoreServices</code></li> <li> <p><code>//Sources/Core/UmbraCore:Sources_Core_UmbraCore</code></p> </li> <li> <p>Security Components</p> </li> <li><code>//Sources/UmbraSecurity:Sources_UmbraSecurity</code></li> <li><code>//Sources/SecurityUtils:Sources_SecurityUtils</code></li> <li><code>//Sources/UmbraCrypto:UmbraCrypto</code></li> <li><code>//Sources/UmbraCryptoService:Sources_UmbraCryptoService</code></li> <li> <p><code>//Sources/CryptoTypes:CryptoTypes</code></p> </li> <li> <p>Restic Integration</p> </li> <li><code>//Sources/ResticCLIHelper:Sources_ResticCLIHelper</code></li> <li><code>//Sources/ResticCLIHelper/Protocols:Sources_ResticCLIHelper_Protocols</code></li> <li> <p><code>//Sources/ResticCLIHelper/Types:Sources_ResticCLIHelper_Types</code></p> </li> <li> <p>Storage &amp; Persistence</p> </li> <li><code>//Sources/UmbraBookmarkService:Sources_UmbraBookmarkService</code></li> <li><code>//Sources/UmbraKeychainService:UmbraKeychainService</code></li> <li><code>//Sources/Repositories:Sources_Repositories</code></li> <li> <p><code>//Sources/Snapshots:Sources_Snapshots</code></p> </li> <li> <p>Error Handling</p> </li> <li><code>//Sources/ErrorHandling:ErrorHandling</code></li> <li><code>//Sources/ErrorHandling/Common:Sources_ErrorHandling_Common</code></li> <li><code>//Sources/ErrorHandling/Models:Sources_ErrorHandling_Models</code></li> <li> <p><code>//Sources/ErrorHandling/Protocols:Sources_ErrorHandling_Protocols</code></p> </li> <li> <p>Features</p> </li> <li><code>//Sources/Features:Sources_Features</code></li> <li>Crypto Features:<ul> <li><code>//Sources/Features/Crypto/Models:Sources_Features_Crypto_Models</code></li> <li><code>//Sources/Features/Crypto/Protocols:Sources_Features_Crypto_Protocols</code></li> </ul> </li> <li> <p>Logging Features:</p> <ul> <li><code>//Sources/Features/Logging/Errors:Sources_Features_Logging_Errors</code></li> <li><code>//Sources/Features/Logging/Models:Models</code></li> <li><code>//Sources/Features/Logging/Protocols:Protocols</code></li> <li><code>//Sources/Features/Logging/Services:LoggingServices</code></li> </ul> </li> <li> <p>Testing Support</p> </li> <li><code>//Sources/UmbraTestKit:UmbraTestKit</code></li> <li><code>//Sources/UmbraMocks:UmbraMocks</code></li> </ol>"},{"location":"DEPENDENCIES/#dependency-graph","title":"Dependency Graph","text":""},{"location":"DEPENDENCIES/#key-dependencies","title":"Key Dependencies","text":"<ol> <li> <p>API Layer <pre><code>API\n\u2514\u2500\u2500 Core/UmbraCore\n</code></pre></p> </li> <li> <p>Security Stack <pre><code>UmbraSecurity\n\u251c\u2500\u2500 SecurityUtils\n\u2502   \u2514\u2500\u2500 Services/SecurityUtils/Services\n\u2514\u2500\u2500 CryptoTypes\n    \u251c\u2500\u2500 Protocols\n    \u251c\u2500\u2500 Services\n    \u2514\u2500\u2500 Types\n</code></pre></p> </li> <li> <p>Restic Integration <pre><code>ResticCLIHelper\n\u251c\u2500\u2500 Protocols\n\u2514\u2500\u2500 Types\n</code></pre></p> </li> <li> <p>Storage Stack <pre><code>UmbraBookmarkService\n\u251c\u2500\u2500 XPC/Core\n\u2514\u2500\u2500 SecurityUtils\n\nUmbraKeychainService\n\u2514\u2500\u2500 XPC/Core\n\nRepositories\n\u2514\u2500\u2500 Protocols\n\nSnapshots\n\u2514\u2500\u2500 Protocols\n</code></pre></p> </li> </ol>"},{"location":"DEPENDENCIES/#external-dependencies","title":"External Dependencies","text":"<ol> <li>Swift Package Manager Dependencies</li> <li><code>@swiftpkg_cryptoswift//:CryptoSwift</code></li> <li> <p><code>@swiftpkg_swiftybeaver//:SwiftyBeaver</code></p> </li> <li> <p>Build System</p> </li> <li><code>@build_bazel_rules_swift//swift:swift.bzl</code></li> <li><code>@bazel_gazelle//label:label.go</code></li> </ol>"},{"location":"DEPENDENCIES/#module-responsibilities","title":"Module Responsibilities","text":""},{"location":"DEPENDENCIES/#core-modules","title":"Core Modules","text":"<ol> <li>API (<code>//Sources/API</code>)</li> <li>Public interface for the UmbraCore framework</li> <li> <p>Entry point for external applications</p> </li> <li> <p>Core (<code>//Sources/Core</code>)</p> </li> <li>Core functionality and business logic</li> <li>Service coordination</li> <li> <p>Application state management</p> </li> <li> <p>Security (<code>//Sources/UmbraSecurity</code>, <code>//Sources/SecurityUtils</code>)</p> </li> <li>Encryption and decryption operations</li> <li>Key management</li> <li> <p>Security protocol implementations</p> </li> <li> <p>ResticCLIHelper (<code>//Sources/ResticCLIHelper</code>)</p> </li> <li>Restic command-line interface integration</li> <li>Backup and restore operations</li> <li>Repository management</li> </ol>"},{"location":"DEPENDENCIES/#support-modules","title":"Support Modules","text":"<ol> <li>Error Handling (<code>//Sources/ErrorHandling</code>)</li> <li>Error type definitions</li> <li>Error handling protocols</li> <li> <p>Error reporting and logging</p> </li> <li> <p>Features (<code>//Sources/Features</code>)</p> </li> <li>Feature-specific implementations</li> <li>Modular functionality</li> <li> <p>Feature configuration</p> </li> <li> <p>Testing (<code>//Sources/UmbraTestKit</code>, <code>//Sources/UmbraMocks</code>)</p> </li> <li>Test utilities</li> <li>Mock implementations</li> <li>Testing protocols</li> </ol>"},{"location":"DEPENDENCIES/#build-configuration","title":"Build Configuration","text":""},{"location":"DEPENDENCIES/#compiler-options","title":"Compiler Options","text":"<p>All Swift libraries are built with: <pre><code>copts = [\n    \"-target\",\n    \"arm64-apple-macos14.0\",\n    \"-strict-concurrency=complete\",\n    \"-warn-concurrency\",\n    \"-enable-actor-data-race-checks\",\n]\n</code></pre></p>"},{"location":"DEPENDENCIES/#visibility","title":"Visibility","text":"<p>Most modules have <code>visibility = [\"//visibility:public\"]</code> to allow for internal dependencies.</p>"},{"location":"DEPENDENCIES/#notes","title":"Notes","text":"<ol> <li>Concurrency Safety</li> <li>All modules are built with strict concurrency checking</li> <li>Actor data race checks are enabled</li> <li> <p>Concurrency warnings are treated as errors</p> </li> <li> <p>Module Independence</p> </li> <li>Each module has its own protocols package</li> <li>Clear separation between interfaces and implementations</li> <li> <p>Minimal cross-module dependencies</p> </li> <li> <p>Testing Support</p> </li> <li>Comprehensive mock implementations</li> <li>Dedicated test utilities</li> <li> <p>Protocol-based design for testability</p> </li> <li> <p>Security Considerations</p> </li> <li>XPC for secure inter-process communication</li> <li>Encrypted storage for sensitive data</li> <li>Secure bookmark management</li> </ol> <p>Last Updated: 2025-02-24</p>"},{"location":"ErrorDomainRefactoring/","title":"UmbraCore Error Domain Architecture Refactoring","text":""},{"location":"ErrorDomainRefactoring/#problem-statement","title":"Problem Statement","text":"<p>UmbraCore currently suffers from error type ambiguity across multiple modules, resulting in compiler errors and developer confusion. Specific issues include:</p> <ol> <li>Multiple modules define their own <code>SecurityError</code> enums with similar purposes but different case structures</li> <li>Module-level enums share names with their containing modules (e.g., <code>enum SecurityProtocolsCore</code> inside the SecurityProtocolsCore module)</li> <li>No clear hierarchical organisation of error types across the system</li> <li>Compiler struggles to resolve ambiguous type references</li> </ol>"},{"location":"ErrorDomainRefactoring/#proposed-solution-centralised-error-domain-architecture","title":"Proposed Solution: Centralised Error Domain Architecture","text":"<p>We propose a clean-break approach to establish a single source of truth for all error types in UmbraCore.</p>"},{"location":"ErrorDomainRefactoring/#core-principles","title":"Core Principles","text":"<ol> <li>Single Source of Truth: One module defines all error domains</li> <li>Hierarchical Organisation: Clear parent-child relationships between error domains</li> <li>Explicit Qualification: No ambiguous type names</li> <li>No Transitional Compatibility: Clean break from previous approach</li> </ol>"},{"location":"ErrorDomainRefactoring/#architecture-overview","title":"Architecture Overview","text":""},{"location":"ErrorDomainRefactoring/#1-new-module-umbraerrordomains","title":"1. New Module: <code>UmbraErrorDomains</code>","text":"<p>A dedicated module will house all error types in a hierarchical structure:</p> <pre><code>UmbraErrors (root namespace)\n\u251c\u2500\u2500 Security\n\u2502   \u251c\u2500\u2500 Core\n\u2502   \u251c\u2500\u2500 XPC\n\u2502   \u2514\u2500\u2500 Protocol\n\u251c\u2500\u2500 Storage\n\u251c\u2500\u2500 Network\n\u2514\u2500\u2500 ... (other domains)\n</code></pre>"},{"location":"ErrorDomainRefactoring/#2-error-domain-structure","title":"2. Error Domain Structure","text":"<p>Each error domain will be organised as an enum hierarchy:</p> <pre><code>public enum UmbraErrors {\n    public enum Security {\n        public enum Core: Error, Sendable, Equatable { \n            // Core security errors\n        }\n\n        public enum XPC: Error, Sendable, Equatable { \n            // XPC-specific security errors\n        }\n\n        public enum Protocol: Error, Sendable, Equatable { \n            // Protocol-related security errors\n        }\n    }\n\n    public enum Storage { /* ... */ }\n    // Other domains\n}\n</code></pre>"},{"location":"ErrorDomainRefactoring/#3-error-type-cases","title":"3. Error Type Cases","text":"<p>For each error domain, cases will be designed to: - Capture all existing error scenarios - Provide appropriate associated values for context - Support rich error handling</p> <p>Example:</p> <pre><code>// Core security errors\npublic enum Core: Error, Sendable, Equatable {\n    case encryptionFailed(reason: String)\n    case decryptionFailed(reason: String)\n    case keyGenerationFailed(reason: String)\n    case invalidKey(reason: String)\n    // Additional cases...\n}\n</code></pre>"},{"location":"ErrorDomainRefactoring/#4-module-version-information","title":"4. Module Version Information","text":"<p>Replace module-named enums with a dedicated structure:</p> <pre><code>public enum ModuleInfo {\n    public static let name = \"ModuleName\"\n    public static let version = \"1.0.0\"\n    public static let buildDate = \"2025-03-08\"\n}\n</code></pre>"},{"location":"ErrorDomainRefactoring/#5-error-mapping-utilities","title":"5. Error Mapping Utilities","text":"<p>Each module will provide extension methods for mapping between related error domains:</p> <pre><code>public extension UmbraErrors.Security.Core {\n    static func from(xpcError: UmbraErrors.Security.XPC) -&gt; Self {\n        // Mapping implementation\n    }\n}\n</code></pre>"},{"location":"ErrorDomainRefactoring/#migration-strategy","title":"Migration Strategy","text":""},{"location":"ErrorDomainRefactoring/#1-initial-implementation","title":"1. Initial Implementation","text":"<ul> <li>Create the <code>UmbraErrorDomains</code> module</li> <li>Define the complete error hierarchy</li> <li>Implement basic error mapping utilities</li> </ul>"},{"location":"ErrorDomainRefactoring/#2-coordinated-refactoring","title":"2. Coordinated Refactoring","text":"<ul> <li>Remove all module-specific error types</li> <li>Update all references to use the new error domains</li> <li>Fix any compilation issues</li> </ul>"},{"location":"ErrorDomainRefactoring/#3-testing-and-validation","title":"3. Testing and Validation","text":"<ul> <li>Ensure comprehensive test coverage for error handling</li> <li>Verify correct error propagation across module boundaries</li> <li>Confirm that error mapping preserves context</li> </ul>"},{"location":"ErrorDomainRefactoring/#backward-compatibility","title":"Backward Compatibility","text":"<p>This is a clean-break approach with no backward compatibility provisions. All code must be updated to use the new error domain structure in a single coordinated change.</p>"},{"location":"ErrorDomainRefactoring/#documentation-and-usage-guidelines","title":"Documentation and Usage Guidelines","text":""},{"location":"ErrorDomainRefactoring/#error-type-selection","title":"Error Type Selection","text":"<ul> <li>Use the most specific error domain for the current context</li> <li>Map to broader domains when crossing module boundaries</li> <li>Include contextual information in associated values</li> </ul>"},{"location":"ErrorDomainRefactoring/#error-handling-patterns","title":"Error Handling Patterns","text":"<pre><code>do {\n    try someOperation()\n} catch let error as UmbraErrors.Security.Core {\n    // Handle core security error\n} catch let error as UmbraErrors.Security.XPC {\n    // Handle XPC security error\n} catch {\n    // Handle other errors\n}\n</code></pre>"},{"location":"ErrorDomainRefactoring/#implementation-timeline","title":"Implementation Timeline","text":"<ol> <li>Design approval and refinement (1 week)</li> <li>Initial implementation of <code>UmbraErrorDomains</code> (1 week)</li> <li>Coordinated refactoring across all modules (2 weeks)</li> <li>Testing and validation (1 week)</li> <li>Documentation updates (1 week)</li> </ol>"},{"location":"ErrorDomainRefactoring/#next-steps","title":"Next Steps","text":"<ol> <li>Review this design document with the team</li> <li>Implement a proof-of-concept branch</li> <li>Develop a detailed refactoring plan</li> </ol>"},{"location":"ErrorDomainRefactoringTasks/","title":"UmbraCore Error Domain Refactoring: Implementation Plan","text":"<p>This document outlines the concrete tasks required to implement the error domain refactoring proposed in the design document. It provides a structured, phased approach to ensure the clean-break transition is carried out systematically across the codebase.</p>"},{"location":"ErrorDomainRefactoringTasks/#phase-1-foundation-setup-estimated-1-week","title":"Phase 1: Foundation Setup (Estimated: 1 week)","text":""},{"location":"ErrorDomainRefactoringTasks/#11-error-domain-structure","title":"1.1 Error Domain Structure","text":"<ul> <li>[x] Create UmbraErrors namespace</li> <li>[x] Implement Security error domain hierarchy (Core, XPC, Protocol)</li> <li>[x] Implement Storage error domain hierarchy</li> <li>[x] Implement Network error domain hierarchy</li> <li>[x] Implement Application error domain hierarchy</li> <li>[ ] Add comprehensive documentation for each error type</li> </ul>"},{"location":"ErrorDomainRefactoringTasks/#12-error-mapping-utilities","title":"1.2 Error Mapping Utilities","text":"<ul> <li>[x] Implement UmbraErrorMapper for Security domain</li> <li>[x] Implement mapping utilities for Storage domain</li> <li>[x] Implement mapping utilities for Network domain</li> <li>[x] Implement mapping utilities for Application domain</li> <li>[ ] Create unit tests for all mapping utilities</li> </ul>"},{"location":"ErrorDomainRefactoringTasks/#13-module-version-information","title":"1.3 Module Version Information","text":"<ul> <li>[x] Define ModuleInfo pattern</li> <li>[x] Create template for version information</li> <li>[x] Implement version checking utilities</li> </ul>"},{"location":"ErrorDomainRefactoringTasks/#phase-2-module-specific-refactoring-estimated-2-weeks","title":"Phase 2: Module-Specific Refactoring (Estimated: 2 weeks)","text":""},{"location":"ErrorDomainRefactoringTasks/#21-securityprotocolscore-module","title":"2.1 SecurityProtocolsCore Module","text":"<ul> <li>[x] Remove SecurityProtocolsCore.SecurityError enum</li> <li>[x] Replace with import of UmbraErrors.Security.Protocols</li> <li>[x] Update all type references</li> <li>[x] Replace module-named enum with ModuleInfo structure</li> <li>[x] Update unit tests to use new error types</li> </ul>"},{"location":"ErrorDomainRefactoringTasks/#22-xpcprotocolscore-module","title":"2.2 XPCProtocolsCore Module","text":"<ul> <li>[x] Remove XPCProtocolsCore.SecurityError enum</li> <li>[x] Replace with import of UmbraErrors.Security.XPC</li> <li>[x] Update all type references</li> <li>[x] Replace module-named enum with ModuleInfo structure</li> <li>[x] Update unit tests to use new error types</li> </ul>"},{"location":"ErrorDomainRefactoringTasks/#23-coreerrors-module","title":"2.3 CoreErrors Module","text":"<ul> <li>[x] Remove CoreErrors.SecurityError enum</li> <li>[x] Replace with import of UmbraErrors.Security.Core</li> <li>[x] Update all type references</li> <li>[x] Update unit tests to use new error types</li> </ul>"},{"location":"ErrorDomainRefactoringTasks/#24-securitybridge-module","title":"2.4 SecurityBridge Module","text":"<ul> <li>[x] Update imports to use UmbraErrors</li> <li>[x] Replace all references to SecurityProtocolsCore.SecurityError</li> <li>[x] Replace all references to XPCProtocolsCore.SecurityError</li> <li>[x] Replace all references to CoreErrors.SecurityError</li> <li>[x] Update error handling in XPCServiceAdapter</li> <li>[x] Update error handling in CryptoServiceAdapter</li> <li>[ ] Update unit tests to use new error types</li> </ul>"},{"location":"ErrorDomainRefactoringTasks/#25-other-security-related-modules","title":"2.5 Other Security-Related Modules","text":"<ul> <li>[x] Identify all modules using existing SecurityError types</li> <li>[x] Update imports for each module</li> <li>[x] Replace all type references</li> <li>[x] Update error handling code</li> <li>[ ] Update unit tests</li> </ul>"},{"location":"ErrorDomainRefactoringTasks/#phase-3-testing-validation-estimated-1-week","title":"Phase 3: Testing &amp; Validation (Estimated: 1 week)","text":""},{"location":"ErrorDomainRefactoringTasks/#31-comprehensive-testing","title":"3.1 Comprehensive Testing","text":"<ul> <li>[ ] Create test suite for error domain usage</li> <li>[ ] Verify error propagation across module boundaries</li> <li>[ ] Test error mapping in diverse scenarios</li> <li>[ ] Verify error handling in XPC bridge</li> <li>[ ] Run all existing unit tests with new error structure</li> </ul>"},{"location":"ErrorDomainRefactoringTasks/#32-build-verification","title":"3.2 Build Verification","text":"<pre><code># Run full build with verbose errors to catch any issues\nbazelisk build --verbose_failures //...\n\n# Run all tests to ensure error handling works correctly\nbazelisk test --verbose_failures //...\n</code></pre>"},{"location":"ErrorDomainRefactoringTasks/#33-edge-case-validation","title":"3.3 Edge Case Validation","text":"<ul> <li>[x] Fix warnings related to unused <code>self</code> references</li> <li>[x] Address non-exhaustive switch statements for Swift 6 compatibility</li> <li>[x] Fix conditional downcasting issues</li> <li>[x] Fix warnings about unused results from function calls</li> <li>[ ] Verify error handling with nil values</li> <li>[ ] Test behavior with nested errors</li> <li>[ ] Validate serialisation/deserialisation of errors</li> <li>[ ] Check performance impact of new error domain structure</li> </ul>"},{"location":"ErrorDomainRefactoringTasks/#phase-4-documentation-guidelines-estimated-3-days","title":"Phase 4: Documentation &amp; Guidelines (Estimated: 3 days)","text":""},{"location":"ErrorDomainRefactoringTasks/#41-developer-documentation","title":"4.1 Developer Documentation","text":"<ul> <li>[ ] Update API documentation to reflect new error domains</li> <li>[ ] Create guide for error handling best practices</li> <li>[ ] Document error mapping patterns</li> <li>[ ] Create examples of typical error handling scenarios</li> </ul>"},{"location":"ErrorDomainRefactoringTasks/#42-migration-guide","title":"4.2 Migration Guide","text":"<ul> <li>[ ] Document how to migrate custom error types</li> <li>[ ] Provide guidance for handling errors across module boundaries</li> <li>[ ] Explain pattern for extending error domains</li> </ul>"},{"location":"ErrorDomainRefactoringTasks/#43-code-reviews-knowledge-transfer","title":"4.3 Code Reviews &amp; Knowledge Transfer","text":"<ul> <li>[x] Successfully merged error-domain-refactoring branch into umbracore-alpha</li> <li>[ ] Schedule code walkthrough sessions</li> <li>[ ] Create review checklist for error handling patterns</li> <li>[ ] Document lessons learned from the refactoring</li> </ul>"},{"location":"ErrorDomainRefactoringTasks/#implementation-approach","title":"Implementation Approach","text":""},{"location":"ErrorDomainRefactoringTasks/#command-line-execution","title":"Command-line Execution","text":"<p>For each phase, use the following commands to test your changes:</p> <pre><code># Check if the changes compile\nbazelisk build --verbose_failures //Sources/ErrorHandling/...\n\n# Run tests for the error handling domain\nbazelisk test --verbose_failures //Sources/ErrorHandling/...\n\n# Check if your changes affect other modules\nbazelisk build --verbose_failures //Sources/SecurityBridge/...\nbazelisk test --verbose_failures //Sources/SecurityBridge/...\n\n# Run all tests to ensure no regressions\nbazelisk test --verbose_failures //...\n</code></pre>"},{"location":"ErrorDomainRefactoringTasks/#risk-mitigation","title":"Risk Mitigation","text":"<ul> <li>Work in feature branches for each module refactoring</li> <li>Create detailed tests before major modifications</li> <li>Implement changes incrementally, focusing on one module at a time</li> <li>Use pair programming for complex error handling transitions</li> </ul>"},{"location":"ErrorDomainRefactoringTasks/#next-steps","title":"Next Steps","text":"<ol> <li>Address remaining compilation errors in SecurityBridge module</li> <li>Complete unit test updates for all modified modules</li> <li>Focus on Phase 2 remaining tasks - removing old error enums</li> <li>Enhance documentation with comprehensive examples</li> <li>Validate error serialisation/deserialisation across module boundaries</li> </ol>"},{"location":"ErrorHandlingArchitecture/","title":"UmbraCore Error Handling Architecture","text":""},{"location":"ErrorHandlingArchitecture/#design-goals","title":"Design Goals","text":"<ol> <li>Uniform Error Structure: Establish a single source of truth for each error domain</li> <li>Clear Module Boundaries: Each module has distinct responsibilities with well-defined interfaces</li> <li>Consistent Error Mapping: Standardised approach to converting between error types</li> <li>Improved Maintainability: Reduce duplication and ensure consistency</li> </ol>"},{"location":"ErrorHandlingArchitecture/#module-structure","title":"Module Structure","text":""},{"location":"ErrorHandlingArchitecture/#errorhandlingdomains","title":"ErrorHandlingDomains","text":"<p>Primary responsibility: Define the core error namespace (<code>UmbraErrors</code>) containing domain-specific errors</p> <pre><code>UmbraErrors\n\u2502\n\u251c\u2500\u2500 Security\n\u2502   \u251c\u2500\u2500 Core           - Core security errors\n\u2502   \u251c\u2500\u2500 Protocols      - Protocol-level security errors\n\u2502   \u2514\u2500\u2500 XPC            - XPC-specific security errors\n\u2502\n\u251c\u2500\u2500 Application\n\u2502   \u251c\u2500\u2500 Core           - Core application errors\n\u2502   \u251c\u2500\u2500 UI             - User interface errors\n\u2502   \u2514\u2500\u2500 Lifecycle      - Application lifecycle errors\n\u2502\n\u251c\u2500\u2500 Network\n\u2502   \u251c\u2500\u2500 HTTP           - HTTP-specific errors\n\u2502   \u2514\u2500\u2500 Socket         - Socket-level errors\n\u2502\n\u2514\u2500\u2500 Storage\n    \u251c\u2500\u2500 Database       - Database-related errors\n    \u2514\u2500\u2500 FileSystem     - File system errors\n</code></pre>"},{"location":"ErrorHandlingArchitecture/#errorhandlingtypes","title":"ErrorHandlingTypes","text":"<p>Primary responsibility: Provide consolidated error types for external consumption</p> <pre><code>ErrorHandlingTypes\n\u2502\n\u251c\u2500\u2500 SecurityError      - Consolidated security errors\n\u251c\u2500\u2500 ApplicationError   - Consolidated application errors\n\u251c\u2500\u2500 NetworkError       - Consolidated network errors\n\u2514\u2500\u2500 StorageError       - Consolidated storage errors\n</code></pre>"},{"location":"ErrorHandlingArchitecture/#errorhandlinginterfaces","title":"ErrorHandlingInterfaces","text":"<p>Primary responsibility: Define the protocols for error mapping and handling</p> <pre><code>ErrorHandlingInterfaces\n\u2502\n\u251c\u2500\u2500 ErrorMapper            - Basic error mapping protocol\n\u251c\u2500\u2500 BidirectionalMapper    - Two-way mapping protocol\n\u2514\u2500\u2500 ErrorHandlingProtocol  - Error handling strategy protocol\n</code></pre>"},{"location":"ErrorHandlingArchitecture/#errorhandlingmapping","title":"ErrorHandlingMapping","text":"<p>Primary responsibility: Implement concrete error mappers between domains and types</p> <pre><code>ErrorHandlingMapping\n\u2502\n\u251c\u2500\u2500 SecurityErrorMapper    - Maps security domain errors\n\u251c\u2500\u2500 ApplicationErrorMapper - Maps application domain errors\n\u251c\u2500\u2500 NetworkErrorMapper     - Maps network domain errors\n\u251c\u2500\u2500 StorageErrorMapper     - Maps storage domain errors\n\u2514\u2500\u2500 UmbraErrorMapper       - Central mapper for all domains\n</code></pre>"},{"location":"ErrorHandlingArchitecture/#key-interfaces","title":"Key Interfaces","text":""},{"location":"ErrorHandlingArchitecture/#errormapper-protocol","title":"ErrorMapper Protocol","text":"<pre><code>/// A protocol for defining a one-way mapping between error types\npublic protocol ErrorMapper&lt;SourceType, TargetType&gt; {\n  /// The source error type\n  associatedtype SourceType: Error\n\n  /// The target error type\n  associatedtype TargetType: Error\n\n  /// Maps from the source error type to the target error type\n  /// - Parameter error: The source error\n  /// - Returns: The mapped target error\n  func mapError(_ error: SourceType) -&gt; TargetType\n}\n</code></pre>"},{"location":"ErrorHandlingArchitecture/#bidirectionalerrormapper-protocol","title":"BidirectionalErrorMapper Protocol","text":"<pre><code>/// A protocol for defining a bidirectional mapping between error types\npublic protocol BidirectionalErrorMapper&lt;ErrorTypeA, ErrorTypeB&gt;: ErrorMapper {\n  /// The first error type\n  associatedtype ErrorTypeA: Error\n\n  /// The second error type\n  associatedtype ErrorTypeB: Error\n\n  /// Maps from ErrorTypeA to ErrorTypeB\n  /// - Parameter error: The source error\n  /// - Returns: The mapped target error\n  func mapAtoB(_ error: ErrorTypeA) -&gt; ErrorTypeB\n\n  /// Maps from ErrorTypeB to ErrorTypeA\n  /// - Parameter error: The source error\n  /// - Returns: The mapped target error\n  func mapBtoA(_ error: ErrorTypeB) -&gt; ErrorTypeA\n}\n</code></pre>"},{"location":"ErrorHandlingArchitecture/#implementation-strategy","title":"Implementation Strategy","text":"<ol> <li>Refine Domain Errors:</li> <li>Ensure all domain errors have consistent naming patterns</li> <li> <p>Complete documentation for all error cases</p> </li> <li> <p>Standardise Consolidated Types:</p> </li> <li>Make Types use the Domains as the canonical source</li> <li> <p>Maintain compatibility while improving internal structure</p> </li> <li> <p>Update Error Mappers:</p> </li> <li>Implement proper protocol conformance</li> <li> <p>Fix ambiguous references with full qualification</p> </li> <li> <p>Dependency Management:</p> </li> <li>Ensure BUILD files reflect the proper dependency graph</li> <li>Types depend on Domains, not vice versa</li> </ol>"},{"location":"ErrorHandlingStyleGuide/","title":"UmbraCore Error Handling Style Guide","text":"<p>This style guide establishes a standard approach for defining and using error types and cases throughout the UmbraCore project. Following these conventions will ensure consistency, improve readability, and facilitate easier maintenance.</p>"},{"location":"ErrorHandlingStyleGuide/#1-error-namespace-structure","title":"1. Error Namespace Structure","text":""},{"location":"ErrorHandlingStyleGuide/#11-namespace-hierarchy","title":"1.1 Namespace Hierarchy","text":"<p>All UmbraCore errors should be organised within the <code>UmbraErrors</code> namespace using a hierarchical structure:</p> <pre><code>UmbraErrors                          // Root namespace\n\u251c\u2500\u2500 Security                         // Domain-specific namespace\n\u2502   \u251c\u2500\u2500 Protocols                    // Subdomain-specific namespace\n\u2502   \u2502   \u251c\u2500\u2500 missingProtocolImplementation\n\u2502   \u2502   \u251c\u2500\u2500 invalidFormat\n\u2502   \u2502   \u2514\u2500\u2500 ...\n\u2502   \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 Application                      // Another domain\n\u2502   \u251c\u2500\u2500 ...\n\u2514\u2500\u2500 ...\n</code></pre>"},{"location":"ErrorHandlingStyleGuide/#12-domain-organisation","title":"1.2 Domain Organisation","text":"<ul> <li>Group errors by their functional domain (e.g., Security, Network, Storage)</li> <li>Use subdomains to further categorise errors where appropriate</li> <li>Ensure each error belongs to exactly one domain</li> </ul>"},{"location":"ErrorHandlingStyleGuide/#2-error-type-naming-conventions","title":"2. Error Type Naming Conventions","text":""},{"location":"ErrorHandlingStyleGuide/#21-general-rules","title":"2.1 General Rules","text":"<ul> <li>Use PascalCase for all error type names</li> <li>Append \"Error\" to the type name</li> <li>Use descriptive, specific names that indicate the domain</li> <li>Avoid generic terms unless part of a broader domain</li> </ul>"},{"location":"ErrorHandlingStyleGuide/#22-error-type-examples","title":"2.2 Error Type Examples","text":"<pre><code>enum SecurityError: Error { ... }        // \u2713 Good\nenum UmbraSecurityError: Error { ... }   // \u2713 Good (explicitly indicates UmbraCore origin)\nenum GenericError: Error { ... }         // \u2717 Bad (too generic)\nenum ErrorSecurity: Error { ... }        // \u2717 Bad (Error suffix should come last)\n</code></pre>"},{"location":"ErrorHandlingStyleGuide/#3-error-case-naming-conventions","title":"3. Error Case Naming Conventions","text":""},{"location":"ErrorHandlingStyleGuide/#31-general-rules","title":"3.1 General Rules","text":"<ul> <li>Use camelCase for all error case names</li> <li>Begin with a verb or noun that describes the error condition</li> <li>Be consistent with tense (prefer past tense for failures)</li> <li>Avoid abbreviations unless widely understood</li> <li>Parameter names should be clear and concise</li> </ul>"},{"location":"ErrorHandlingStyleGuide/#32-common-error-case-patterns","title":"3.2 Common Error Case Patterns","text":"<p>For consistency, use these standard patterns across domains:</p> Error Pattern Recommended Format Example Authentication <code>authenticationFailed(reason: String)</code> <code>authenticationFailed(reason: \"Invalid credentials\")</code> Permission <code>permissionDenied(resource: String)</code> <code>permissionDenied(resource: \"AccountData\")</code> Validation <code>validationFailed(field: String, reason: String)</code> <code>validationFailed(field: \"email\", reason: \"Invalid format\")</code> Format <code>invalidFormat(reason: String)</code> <code>invalidFormat(reason: \"Unexpected character\")</code> Operation <code>operationFailed(name: String, reason: String)</code> <code>operationFailed(name: \"dataSync\", reason: \"Network unavailable\")</code> State <code>invalidState(current: String, expected: String)</code> <code>invalidState(current: \"terminated\", expected: \"running\")</code> Configuration <code>invalidConfiguration(component: String, issue: String)</code> <code>invalidConfiguration(component: \"cipher\", issue: \"Invalid key size\")</code> Timeout <code>timeout(operation: String, limit: TimeInterval)</code> <code>timeout(operation: \"networkRequest\", limit: 30.0)</code> Not Found <code>notFound(item: String)</code> <code>notFound(item: \"userProfile\")</code> Unknown <code>unknown(details: String)</code> <code>unknown(details: \"Unexpected system failure\")</code>"},{"location":"ErrorHandlingStyleGuide/#33-parameter-requirements","title":"3.3 Parameter Requirements","text":"<ul> <li>Always include descriptive parameters rather than using bare cases</li> <li>Use <code>String</code> type for descriptive parameters when possible</li> <li>Include type-specific parameters where appropriate (e.g., <code>TimeInterval</code> for timeouts)</li> <li>Consider using typed enums for constrained value sets</li> </ul>"},{"location":"ErrorHandlingStyleGuide/#4-error-domain-definition","title":"4. Error Domain Definition","text":""},{"location":"ErrorHandlingStyleGuide/#41-domain-constant-format","title":"4.1 Domain Constant Format","text":"<p>Define error domains using constants with consistent naming:</p> <pre><code>static let SecurityErrorDomain = \"security.umbracore.dev\"\n</code></pre>"},{"location":"ErrorHandlingStyleGuide/#42-domain-naming-conventions","title":"4.2 Domain Naming Conventions","text":"<ul> <li>Use reverse DNS notation with the umbracore.dev domain</li> <li>Match the domain component to the error type name</li> <li>Define domains as static constants within the error type</li> </ul>"},{"location":"ErrorHandlingStyleGuide/#5-documentation-standards","title":"5. Documentation Standards","text":""},{"location":"ErrorHandlingStyleGuide/#51-general-guidelines","title":"5.1 General Guidelines","text":"<ul> <li>Use British English spelling in all documentation</li> <li>Document each error type with a clear description of its purpose</li> <li>Document each error case with:</li> <li>Description of the error condition</li> <li>Potential causes</li> <li>Recommended recovery actions</li> </ul>"},{"location":"ErrorHandlingStyleGuide/#52-documentation-format","title":"5.2 Documentation Format","text":"<pre><code>/// Represents errors that occur within the security protocol subsystem.\n/// These errors typically relate to issues with protocol implementation,\n/// format validation, or unsupported operations.\nenum UmbraErrors.Security.Protocols: Error {\n    /// Thrown when a required protocol implementation cannot be found.\n    /// - Parameter protocolName: The name of the missing protocol\n    case missingProtocolImplementation(protocolName: String)\n\n    /// Thrown when data is in an invalid format for the requested operation.\n    /// - Parameter reason: Detailed description of the format issue\n    case invalidFormat(reason: String)\n\n    // Additional cases...\n}\n</code></pre>"},{"location":"ErrorHandlingStyleGuide/#6-migration-path-for-existing-code","title":"6. Migration Path for Existing Code","text":"<p>When refactoring existing error types:</p> <ol> <li>Identify semantically similar error cases across different domains</li> <li>Standardise naming and parameter patterns according to this guide</li> <li>Update calling code to use the new pattern</li> <li>Add comprehensive documentation in British English</li> <li>Ensure all error cases have appropriate parameters</li> </ol>"},{"location":"ErrorHandlingStyleGuide/#7-examples","title":"7. Examples","text":""},{"location":"ErrorHandlingStyleGuide/#71-before-and-after-examples","title":"7.1 Before and After Examples","text":"<p>Before: <pre><code>enum SecurityError: Error {\n    case authFailed\n    case permissionError(String)\n    case invalidState(String, String)\n}\n\nenum ApplicationError: Error {\n    case authenticationError(message: String)\n    case permissionDenied(resource: String)\n    case state_invalid(cur: String, expected: String)\n}\n</code></pre></p> <p>After: <pre><code>enum UmbraErrors.Security: Error {\n    /// Thrown when authentication fails due to the provided reason.\n    /// - Parameter reason: Detailed description of the authentication failure\n    case authenticationFailed(reason: String)\n\n    /// Thrown when permission to the specified resource is denied.\n    /// - Parameter resource: The resource for which permission was denied\n    case permissionDenied(resource: String)\n\n    /// Thrown when the system is in an invalid state for the requested operation.\n    /// - Parameters:\n    ///   - current: The current state of the system\n    ///   - expected: The state required for the operation\n    case invalidState(current: String, expected: String)\n}\n\nenum UmbraErrors.Application: Error {\n    /// Thrown when authentication fails due to the provided reason.\n    /// - Parameter reason: Detailed description of the authentication failure\n    case authenticationFailed(reason: String)\n\n    /// Thrown when permission to the specified resource is denied.\n    /// - Parameter resource: The resource for which permission was denied\n    case permissionDenied(resource: String)\n\n    /// Thrown when the system is in an invalid state for the requested operation.\n    /// - Parameters:\n    ///   - current: The current state of the system\n    ///   - expected: The state required for the operation\n    case invalidState(current: String, expected: String)\n}\n</code></pre></p>"},{"location":"ErrorHandlingStyleGuide/#72-error-domain-examples","title":"7.2 Error Domain Examples","text":"<p>Before: <pre><code>static let SecurityErrorDomain = \"com.umbra.security\"\nstatic let ApplicationErrorDomain = \"com.umbra.app\"\n</code></pre></p> <p>After: <pre><code>static let SecurityErrorDomain = \"security.umbracore.dev\"\nstatic let ApplicationErrorDomain = \"application.umbracore.dev\"\n</code></pre></p> <p>By following this style guide, the UmbraCore error handling will become more consistent, maintainable, and user-friendly. The standardised approach will also facilitate easier debugging and error recovery throughout the project.</p>"},{"location":"IDE_INTEGRATION/","title":"IDE Integration Guide for UmbraCore","text":"<p>This guide provides instructions for integrating UmbraCore's coding standards and tools with your preferred IDE.</p>"},{"location":"IDE_INTEGRATION/#swiftformat-integration","title":"SwiftFormat Integration","text":"<p>UmbraCore uses SwiftFormat version 0.55.5 to maintain consistent code style. Here's how to integrate it with various IDEs:</p>"},{"location":"IDE_INTEGRATION/#xcode","title":"Xcode","text":"<ol> <li>Using Xcode Source Editor Extension:</li> <li>Install the SwiftFormat for Xcode extension</li> <li>Configure it to use the project's <code>.swiftformat</code> file</li> <li> <p>Format code with: Editor &gt; SwiftFormat &gt; Format File (or use the keyboard shortcut)</p> </li> <li> <p>Using Xcode Build Phase:</p> </li> <li>Add a new \"Run Script\" build phase to your target</li> <li>Add the following script:      <pre><code>if which swiftformat &gt;/dev/null; then\n  swiftformat \"${SRCROOT}\" --config \"${SRCROOT}/.swiftformat\"\nelse\n  echo \"warning: SwiftFormat not installed, install with 'brew install swiftformat'\"\nfi\n</code></pre></li> </ol>"},{"location":"IDE_INTEGRATION/#visual-studio-code","title":"Visual Studio Code","text":"<ol> <li>Install the Swift Format extension for VS Code</li> <li>Configure it to use the project's <code>.swiftformat</code> file in settings.json:    <pre><code>{\n  \"swiftformat.configSearchPaths\": [\".swiftformat\"],\n  \"editor.formatOnSave\": true,\n  \"[swift]\": {\n    \"editor.defaultFormatter\": \"vknabel.vscode-swiftformat\"\n  }\n}\n</code></pre></li> </ol>"},{"location":"IDE_INTEGRATION/#jetbrains-appcode-clion","title":"JetBrains AppCode / CLion","text":"<ol> <li>Install the Swift Format plugin</li> <li>Go to Preferences &gt; Tools &gt; SwiftFormat</li> <li>Configure it to use the project's <code>.swiftformat</code> file</li> <li>Enable \"Format on Save\" if desired</li> </ol>"},{"location":"IDE_INTEGRATION/#command-line","title":"Command Line","text":"<p>You can also format code from the command line using our script:</p> <pre><code># Format all files in the project\n./scripts/format_code.sh\n\n# Check formatting without making changes\n./scripts/format_code.sh --check\n\n# Format only staged files\n./scripts/format_code.sh --staged-only\n\n# Format specific files or directories\n./scripts/format_code.sh path/to/file.swift path/to/directory\n</code></pre>"},{"location":"IDE_INTEGRATION/#git-hooks","title":"Git Hooks","text":"<p>We provide a script to install Git hooks that enforce code style standards:</p> <pre><code># Install Git hooks\n./scripts/install-git-hooks.sh\n</code></pre> <p>This will install a pre-commit hook that checks the formatting of staged Swift files before committing.</p>"},{"location":"IDE_INTEGRATION/#continuous-integration","title":"Continuous Integration","text":"<p>Our CI pipeline includes SwiftFormat checks to ensure all code adheres to the style guidelines. If your PR fails due to formatting issues, you can fix them by running:</p> <pre><code>./scripts/format_code.sh\n</code></pre>"},{"location":"IDE_INTEGRATION/#troubleshooting","title":"Troubleshooting","text":"<p>If you encounter issues with SwiftFormat:</p> <ol> <li>Ensure you have the correct version installed: <code>swiftformat --version</code> should show 0.55.5</li> <li>Update using: <code>brew upgrade swiftformat</code></li> <li>Check for conflicting configurations in your home directory (~/.swiftformat)</li> <li>For IDE-specific issues, consult the documentation for your IDE's SwiftFormat plugin</li> </ol>"},{"location":"LICENSE/","title":"MIT License","text":"<p>Copyright (c) 2025 MPY Development</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"PROJECT_STATUS/","title":"UmbraCore Project Status and Roadmap","text":""},{"location":"PROJECT_STATUS/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Current Status</li> <li>Style Guide Compliance Plan</li> <li>Functional Refactoring Plan</li> <li>Implementation Timeline</li> </ul>"},{"location":"PROJECT_STATUS/#current-status","title":"Current Status","text":""},{"location":"PROJECT_STATUS/#core-components","title":"Core Components","text":""},{"location":"PROJECT_STATUS/#1-resticclihelper-integration","title":"1. ResticCLIHelper Integration","text":"<ul> <li>Status: Partially Implemented</li> <li>Features:</li> <li>Core command support (backup, restore, init)</li> <li>Repository management commands</li> <li>Well-typed command results</li> <li>Needs Improvement:</li> <li>Error handling mechanisms</li> <li>Retry logic</li> <li>Progress reporting</li> <li>Cancellation support</li> </ul>"},{"location":"PROJECT_STATUS/#2-security-encryption","title":"2. Security &amp; Encryption","text":"<ul> <li>Status: Well Implemented</li> <li>Components:</li> <li><code>UmbraCrypto</code> for core cryptographic operations</li> <li><code>CryptoTypes</code> for type-safe crypto operations</li> <li><code>UmbraKeychainService</code> for secure storage</li> <li>XPC support for secure IPC</li> <li>Strengths:</li> <li>Strong encryption implementation</li> <li>Secure key management</li> <li>Protected data storage</li> </ul>"},{"location":"PROJECT_STATUS/#3-core-architecture","title":"3. Core Architecture","text":"<ul> <li>Status: Solid Foundation</li> <li>Features:</li> <li>Modular design</li> <li>Protocol-oriented architecture</li> <li>Comprehensive error handling</li> <li>Robust logging system</li> </ul>"},{"location":"PROJECT_STATUS/#areas-of-concern","title":"Areas of Concern","text":""},{"location":"PROJECT_STATUS/#1-integration-points","title":"1. Integration Points","text":"<ul> <li>Rbum Integration</li> <li>Current Status: Incomplete</li> <li>Missing core functionality</li> <li> <p>Integration points undefined</p> </li> <li> <p>Rbx Support</p> </li> <li>Current Status: Missing</li> <li>Implementation needed</li> <li> <p>Requirements to be defined</p> </li> <li> <p>ResticBar Integration</p> </li> <li>Current Status: Partial</li> <li>Needs better documentation</li> <li>Error handling improvements required</li> </ul>"},{"location":"PROJECT_STATUS/#2-code-quality-issues","title":"2. Code Quality Issues","text":"<ul> <li>Inconsistent concurrency patterns</li> <li>Documentation gaps</li> <li>Test coverage needs improvement</li> <li>Some tight coupling between components</li> </ul>"},{"location":"PROJECT_STATUS/#style-guide-compliance-plan","title":"Style Guide Compliance Plan","text":""},{"location":"PROJECT_STATUS/#phase-1-documentation-naming-2-weeks","title":"Phase 1: Documentation &amp; Naming (2 weeks)","text":"<ul> <li>Documentation Updates</li> <li>Add proper documentation for all public APIs</li> <li>Include usage examples</li> <li>Document error conditions</li> <li> <p>Add inline comments for complex logic</p> </li> <li> <p>Naming Standardization</p> </li> <li>Function names: Use verb phrases</li> <li>Consistent acronym capitalization</li> <li>Clear, self-documenting names</li> <li>Follow Swift API guidelines</li> </ul>"},{"location":"PROJECT_STATUS/#phase-2-code-structure-2-weeks","title":"Phase 2: Code Structure (2 weeks)","text":"<ul> <li>Formatting</li> <li>Implement 2-space indentation</li> <li>Standardize brace placement</li> <li> <p>Fix line wrapping issues</p> </li> <li> <p>File Organization</p> </li> <li>Properties</li> <li>Initializers</li> <li>Methods</li> <li>Protocol conformances in extensions</li> </ul>"},{"location":"PROJECT_STATUS/#phase-3-language-features-2-weeks","title":"Phase 3: Language Features (2 weeks)","text":"<ul> <li>Swift Best Practices</li> <li>Audit access control</li> <li>Convert <code>var</code> to <code>let</code> where possible</li> <li>Implement type inference</li> <li>Add early returns</li> <li>Use proper optionals handling</li> </ul>"},{"location":"PROJECT_STATUS/#functional-refactoring-plan","title":"Functional Refactoring Plan","text":""},{"location":"PROJECT_STATUS/#a-architecture-improvements","title":"A. Architecture Improvements","text":""},{"location":"PROJECT_STATUS/#1-service-layer-abstraction","title":"1. Service Layer Abstraction","text":"<pre><code>public protocol UmbraService {\n    var serviceIdentifier: String { get }\n    func initialize() async throws\n    func shutdown() async\n}\n</code></pre>"},{"location":"PROJECT_STATUS/#2-dependency-injection","title":"2. Dependency Injection","text":"<pre><code>public final class ServiceContainer {\n    private var services: [String: any UmbraService]\n\n    public func register&lt;T: UmbraService&gt;(_ service: T)\n    public func resolve&lt;T: UmbraService&gt;(_ type: T.Type) -&gt; T?\n}\n</code></pre>"},{"location":"PROJECT_STATUS/#3-module-boundaries","title":"3. Module Boundaries","text":"<ul> <li>Split large modules</li> <li>Define clear interfaces</li> <li>Implement proper dependency management</li> </ul>"},{"location":"PROJECT_STATUS/#b-specific-improvements","title":"B. Specific Improvements","text":""},{"location":"PROJECT_STATUS/#1-resticclihelper-enhancement","title":"1. ResticCLIHelper Enhancement","text":"<ul> <li>Add retry mechanisms</li> <li>Implement cancellation</li> <li>Add progress reporting</li> <li>Improve error handling</li> </ul>"},{"location":"PROJECT_STATUS/#2-security-layer","title":"2. Security Layer","text":"<ul> <li>Centralize encryption</li> <li>Improve key management</li> <li>Add audit logging</li> <li>Enhance error reporting</li> </ul>"},{"location":"PROJECT_STATUS/#3-performance-optimization","title":"3. Performance Optimization","text":"<ul> <li>Implement caching</li> <li>Add async/await support</li> <li>Optimize resource usage</li> <li>Add performance metrics</li> </ul>"},{"location":"PROJECT_STATUS/#c-testing-infrastructure","title":"C. Testing Infrastructure","text":""},{"location":"PROJECT_STATUS/#1-test-coverage","title":"1. Test Coverage","text":"<ul> <li>Unit tests for public APIs</li> <li>Integration tests</li> <li>Performance tests</li> <li>Mock objects improvement</li> </ul>"},{"location":"PROJECT_STATUS/#2-cicd-improvements","title":"2. CI/CD Improvements","text":"<ul> <li>Style checking automation</li> <li>Performance regression tests</li> <li>Security scanning</li> <li>Build process optimization</li> </ul>"},{"location":"PROJECT_STATUS/#implementation-timeline","title":"Implementation Timeline","text":""},{"location":"PROJECT_STATUS/#high-priority-1-2-months","title":"High Priority (1-2 months)","text":"<ul> <li>[ ] Service layer abstraction</li> <li>[ ] Security improvements</li> <li>[ ] Critical bug fixes</li> <li>[ ] Basic test coverage</li> </ul>"},{"location":"PROJECT_STATUS/#medium-priority-2-3-months","title":"Medium Priority (2-3 months)","text":"<ul> <li>[ ] Dependency injection</li> <li>[ ] Module boundary cleanup</li> <li>[ ] Performance optimization</li> <li>[ ] Integration tests</li> </ul>"},{"location":"PROJECT_STATUS/#lower-priority-3-4-months","title":"Lower Priority (3-4 months)","text":"<ul> <li>[ ] Additional test coverage</li> <li>[ ] Documentation improvements</li> <li>[ ] Nice-to-have features</li> <li>[ ] Performance tuning</li> </ul>"},{"location":"PROJECT_STATUS/#contributing","title":"Contributing","text":"<p>When contributing to this project:</p> <ol> <li>Follow the Google Swift Style Guide</li> <li>Ensure all new code has tests</li> <li>Update documentation</li> <li>Add inline comments for complex logic</li> <li>Follow the existing architectural patterns</li> </ol>"},{"location":"PROJECT_STATUS/#notes","title":"Notes","text":"<ul> <li>British English should be used in comments and documentation</li> <li>American English is acceptable in code</li> <li>All new features must include proper error handling</li> <li>Security-related changes require review</li> <li>Performance-critical code must include benchmarks</li> </ul> <p>Last Updated: 2025-02-24</p>"},{"location":"README_build_system/","title":"UmbraCore Build System Restructuring","text":"<p>This document outlines the build system restructuring process for UmbraCore, explaining the changes made and how to use the new build system.</p>"},{"location":"README_build_system/#overview","title":"Overview","text":"<p>The UmbraCore build system has been restructured to improve modularity, build performance, and separation of concerns between production and test code.</p>"},{"location":"README_build_system/#key-changes","title":"Key Changes","text":"<ol> <li>Directory Structure Reorganisation</li> <li>Created dedicated <code>TestSupport</code> directories for test-only code</li> <li>Separated test utilities by domain (Security, Core, Common)</li> <li> <p>Created missing packages like <code>CoreServicesTypes</code></p> </li> <li> <p>Build Configuration</p> </li> <li>Added build configurations for production, development, and test-only builds</li> <li>Improved dependency management between modules</li> <li> <p>Fixed target configuration issues</p> </li> <li> <p>Build Scripts</p> </li> <li>Added convenience scripts for common build operations</li> <li>Created selective build capability for affected targets</li> </ol>"},{"location":"README_build_system/#directory-structure","title":"Directory Structure","text":"<p>The new structure follows this pattern:</p> <pre><code>/UmbraCore\n\u251c\u2500\u2500 Sources/            # Production code only\n\u2502   \u251c\u2500\u2500 Core/\n\u2502   \u251c\u2500\u2500 CoreTypes/\n\u2502   \u251c\u2500\u2500 CoreServicesTypes/\n\u2502   \u251c\u2500\u2500 Security/\n\u2502   \u251c\u2500\u2500 SecurityInterfaces/\n\u2502   \u2514\u2500\u2500 SecurityTypes/\n\u251c\u2500\u2500 Tests/              # Test code\n\u2502   \u251c\u2500\u2500 CoreTests/\n\u2502   \u251c\u2500\u2500 SecurityTests/\n\u2502   \u2514\u2500\u2500 XPCTests/\n\u2514\u2500\u2500 TestSupport/        # Test utilities and mocks\n    \u251c\u2500\u2500 Security/\n    \u251c\u2500\u2500 Core/\n    \u2514\u2500\u2500 Common/\n</code></pre>"},{"location":"README_build_system/#restructuring-tool","title":"Restructuring Tool","text":"<p>A Go-based restructuring tool (<code>umbra_restructure.go</code>) has been created to automate the migration process. This tool:</p> <ol> <li>Creates the necessary directory structure</li> <li>Moves test-related code to appropriate TestSupport directories</li> <li>Creates and updates BUILD.bazel files</li> <li>Configures Bazel build settings</li> <li>Creates build scripts</li> </ol>"},{"location":"README_build_system/#using-the-restructuring-tool","title":"Using the Restructuring Tool","text":"<pre><code># Perform a dry run to see planned changes without applying them\ngo run umbra_restructure.go --dry-run\n\n# Execute the restructuring\ngo run umbra_restructure.go\n\n# Additional options\ngo run umbra_restructure.go --help\n</code></pre> <p>Options: - <code>--root</code>: Specify the project root directory (default: current directory) - <code>--dry-run</code>: Perform a dry run without making changes - <code>--verbose</code>: Enable verbose output - <code>--skip-bazel</code>: Skip Bazel configuration updates - <code>--skip-scripts</code>: Skip build script creation</p>"},{"location":"README_build_system/#build-scripts","title":"Build Scripts","text":"<p>The restructuring adds several convenience scripts:</p> <ol> <li> <p>build_prod.sh: Builds only production code    <pre><code>./build_prod.sh\n</code></pre></p> </li> <li> <p>build_test.sh: Builds and runs all tests    <pre><code>./build_test.sh\n</code></pre></p> </li> <li> <p>build_affected.sh: Builds only targets affected by recent changes    <pre><code>./build_affected.sh\n</code></pre></p> </li> </ol>"},{"location":"README_build_system/#bazel-configuration","title":"Bazel Configuration","text":"<p>The <code>.bazelrc</code> file has been updated with configurations for different build types:</p> <ul> <li><code>--config=prod</code>: Production build (no tests)</li> <li><code>--config=dev</code>: Development build with tests</li> <li><code>--config=test</code>: Test-only build</li> </ul> <p>Example usage: <pre><code>bazel build --config=prod //Sources/...\nbazel test --config=dev //...\n</code></pre></p>"},{"location":"README_build_system/#troubleshooting","title":"Troubleshooting","text":"<p>If you encounter build issues after restructuring:</p> <ol> <li>Check that all dependencies are correctly specified in BUILD.bazel files</li> <li>Verify that imports have been updated to reflect the new package structure</li> <li>Run <code>bazel clean --expunge</code> to clear the build cache</li> <li>Check for any remaining test code in production directories</li> </ol>"},{"location":"README_build_system/#future-improvements","title":"Future Improvements","text":"<p>Planned improvements for the build system:</p> <ol> <li>Dependency visualization tools</li> <li>Comprehensive CI/CD pipeline integration</li> <li>Build performance metrics and optimization</li> <li>Automated dependency management</li> </ol>"},{"location":"REFACTORING_PLAN/","title":"UmbraCore Refactoring Plan","text":""},{"location":"REFACTORING_PLAN/#overview","title":"Overview","text":"<p>This document outlines our approach to refactoring UmbraCore, using the Security and Crypto modules as templates. The plan combines functional improvements with progressive style guide compliance.</p>"},{"location":"REFACTORING_PLAN/#completed-work","title":"Completed Work","text":""},{"location":"REFACTORING_PLAN/#phase-1-service-architecture","title":"Phase 1: Service Architecture","text":"<p>\u2713 Core Service Infrastructure - Implemented UmbraService protocol - Created service state management - Established actor-based architecture</p> <p>\u2713 Security Service Implementation - Implemented CryptoService with XPC support - Created SecurityService with bookmark management - Integrated KeyManager and CredentialManager - Added security-scoped resource handling</p> <p>\u2713 Resource Management Foundation - Implemented ManagedResource protocol - Created ResourcePool implementation - Added SecureStorageResource - Integrated KeychainResource</p>"},{"location":"REFACTORING_PLAN/#current-phase-core-features-implementation","title":"Current Phase: Core Features Implementation","text":""},{"location":"REFACTORING_PLAN/#1-repository-management-2-weeks","title":"1. Repository Management (2 weeks)","text":""},{"location":"REFACTORING_PLAN/#week-1-core-repository-types","title":"Week 1: Core Repository Types","text":"<pre><code>public protocol Repository: Actor {\n    var identifier: String { get }\n    var state: RepositoryState { get }\n    var location: URL { get }\n\n    func initialize() async throws\n    func validate() async throws -&gt; Bool\n    func lock() async throws\n    func unlock() async throws\n}\n\npublic enum RepositoryState {\n    case uninitialized\n    case ready\n    case locked\n    case error(Error)\n}\n</code></pre>"},{"location":"REFACTORING_PLAN/#week-2-repository-service","title":"Week 2: Repository Service","text":"<pre><code>public actor RepositoryService {\n    private var repositories: [String: Repository]\n    private let securityService: SecurityService\n    private let cryptoService: CryptoService\n\n    public func register(_ repository: Repository) async throws\n    public func unregister(_ identifier: String) async\n    public func getRepository(_ identifier: String) async throws -&gt; Repository\n}\n</code></pre>"},{"location":"REFACTORING_PLAN/#2-snapshot-management-2-weeks","title":"2. Snapshot Management (2 weeks)","text":""},{"location":"REFACTORING_PLAN/#week-1-snapshot-types","title":"Week 1: Snapshot Types","text":"<pre><code>public struct Snapshot: Identifiable {\n    public let id: String\n    public let timestamp: Date\n    public let tags: Set&lt;String&gt;\n    public let paths: [URL]\n    public let size: UInt64\n    public let stats: SnapshotStats\n}\n\npublic protocol SnapshotManager: Actor {\n    func create(_ paths: [URL], tags: Set&lt;String&gt;) async throws -&gt; Snapshot\n    func list() async throws -&gt; [Snapshot]\n    func restore(_ snapshot: Snapshot, to: URL) async throws\n    func delete(_ snapshot: Snapshot) async throws\n}\n</code></pre>"},{"location":"REFACTORING_PLAN/#week-2-snapshot-service-implementation","title":"Week 2: Snapshot Service Implementation","text":"<pre><code>public actor SnapshotService: SnapshotManager {\n    private let repository: Repository\n    private let securityService: SecurityService\n    private let fileManager: FileManager\n\n    public func create(_ paths: [URL], tags: Set&lt;String&gt;) async throws -&gt; Snapshot\n    public func restore(_ snapshot: Snapshot, to: URL) async throws\n}\n</code></pre>"},{"location":"REFACTORING_PLAN/#3-cli-integration-2-weeks","title":"3. CLI Integration (2 weeks)","text":""},{"location":"REFACTORING_PLAN/#week-1-command-framework","title":"Week 1: Command Framework","text":"<ul> <li>Design command execution system</li> <li>Implement process management</li> <li>Add output parsing</li> </ul>"},{"location":"REFACTORING_PLAN/#week-2-restic-integration","title":"Week 2: Restic Integration","text":"<ul> <li>Repository operations</li> <li>Snapshot management</li> <li>Backup and restore</li> <li>Error handling</li> </ul>"},{"location":"REFACTORING_PLAN/#next-phases","title":"Next Phases","text":""},{"location":"REFACTORING_PLAN/#phase-4-configuration-management-2-weeks","title":"Phase 4: Configuration Management (2 weeks)","text":"<ul> <li>Repository settings</li> <li>Backup policies</li> <li>Security preferences</li> <li>Logging configuration</li> </ul>"},{"location":"REFACTORING_PLAN/#phase-5-logging-enhancement-2-weeks","title":"Phase 5: Logging Enhancement (2 weeks)","text":"<ul> <li>Privacy-aware logging</li> <li>Log rotation</li> <li>Performance metrics</li> <li>Debug information</li> </ul>"},{"location":"REFACTORING_PLAN/#phase-6-error-handling-2-weeks","title":"Phase 6: Error Handling (2 weeks)","text":"<ul> <li>Error categorization</li> <li>Recovery strategies</li> <li>User feedback</li> <li>Diagnostic tools</li> </ul>"},{"location":"REFACTORING_PLAN/#timeline","title":"Timeline","text":"<ul> <li>Current Phase (Core Features): March 2025</li> <li>Phase 4 (Configuration): April 2025</li> <li>Phase 5 (Logging): April 2025</li> <li>Phase 6 (Error Handling): May 2025</li> </ul>"},{"location":"REFACTORING_PLAN/#style-guide-compliance","title":"Style Guide Compliance","text":""},{"location":"REFACTORING_PLAN/#documentation-standards","title":"Documentation Standards","text":"<ul> <li>Use /// for documentation comments</li> <li>Document all public APIs</li> <li>Include parameter descriptions</li> <li>Document error conditions</li> <li>Add usage examples</li> </ul>"},{"location":"REFACTORING_PLAN/#code-organization","title":"Code Organization","text":"<ul> <li>Properties first</li> <li>Then initializers</li> <li>Then methods</li> <li>Protocol conformance in extensions</li> </ul>"},{"location":"REFACTORING_PLAN/#naming-conventions","title":"Naming Conventions","text":"<ul> <li>Use verb phrases for functions</li> <li>Clear, self-documenting names</li> <li>Consistent capitalization</li> <li>Follow Swift API guidelines</li> </ul>"},{"location":"REFACTORING_PLAN/#swift-best-practices","title":"Swift Best Practices","text":"<ul> <li>Use let over var</li> <li>Early returns with guard</li> <li>Proper access control</li> <li>Type inference where clear</li> </ul>"},{"location":"REFACTORING_PLAN/#implementation-strategy","title":"Implementation Strategy","text":""},{"location":"REFACTORING_PLAN/#1-service-layer-weeks-1-4","title":"1. Service Layer (Weeks 1-4)","text":"<ul> <li>[ ] Define base protocols</li> <li>[ ] Implement service container</li> <li>[ ] Refactor crypto service</li> <li>[ ] Refactor security service</li> </ul>"},{"location":"REFACTORING_PLAN/#2-resource-management-weeks-5-8","title":"2. Resource Management (Weeks 5-8)","text":"<ul> <li>[ ] Define resource protocols</li> <li>[ ] Implement resource pool</li> <li>[ ] Refactor secure storage</li> <li>[ ] Refactor keychain access</li> </ul>"},{"location":"REFACTORING_PLAN/#3-error-handling-weeks-9-12","title":"3. Error Handling (Weeks 9-12)","text":"<ul> <li>[ ] Define error protocols</li> <li>[ ] Implement error context</li> <li>[ ] Refactor crypto errors</li> <li>[ ] Refactor security errors</li> </ul>"},{"location":"REFACTORING_PLAN/#testing-strategy","title":"Testing Strategy","text":""},{"location":"REFACTORING_PLAN/#1-unit-tests","title":"1. Unit Tests","text":"<ul> <li>Test each component in isolation</li> <li>Mock dependencies</li> <li>Test error conditions</li> <li>Verify resource cleanup</li> </ul>"},{"location":"REFACTORING_PLAN/#2-integration-tests","title":"2. Integration Tests","text":"<ul> <li>Test service interactions</li> <li>Verify resource management</li> <li>Test error recovery</li> <li>Check memory handling</li> </ul>"},{"location":"REFACTORING_PLAN/#3-performance-tests","title":"3. Performance Tests","text":"<ul> <li>Measure operation timing</li> <li>Check resource usage</li> <li>Test under load</li> <li>Verify cleanup efficiency</li> </ul>"},{"location":"REFACTORING_PLAN/#success-metrics","title":"Success Metrics","text":""},{"location":"REFACTORING_PLAN/#1-code-quality","title":"1. Code Quality","text":"<ul> <li>Reduced coupling</li> <li>Improved cohesion</li> <li>Better error handling</li> <li>Cleaner interfaces</li> </ul>"},{"location":"REFACTORING_PLAN/#2-performance","title":"2. Performance","text":"<ul> <li>Faster operations</li> <li>Lower memory usage</li> <li>Better resource utilization</li> <li>Quicker error recovery</li> </ul>"},{"location":"REFACTORING_PLAN/#3-maintainability","title":"3. Maintainability","text":"<ul> <li>Easier to test</li> <li>Simpler to debug</li> <li>Clearer documentation</li> <li>More consistent style</li> </ul> <p>Last Updated: 2025-02-24</p>"},{"location":"SECURITY_ARCHITECTURE/","title":"UmbraCore Security Architecture","text":""},{"location":"SECURITY_ARCHITECTURE/#overview","title":"Overview","text":"<p>The UmbraCore security architecture is built on multiple layers to provide secure data handling, encryption, and access control. This document details the security components and their interactions.</p>"},{"location":"SECURITY_ARCHITECTURE/#component-architecture","title":"Component Architecture","text":""},{"location":"SECURITY_ARCHITECTURE/#1-cryptographic-stack","title":"1. Cryptographic Stack","text":""},{"location":"SECURITY_ARCHITECTURE/#cryptotypes-module","title":"CryptoTypes Module","text":"<ul> <li>Purpose: Core cryptographic type definitions and protocols</li> <li>Location: <code>//Sources/CryptoTypes</code></li> <li>Key Components:   <pre><code>CryptoTypes\n\u251c\u2500\u2500 Protocols\n\u2502   \u2514\u2500\u2500 CryptoService.swift\n\u251c\u2500\u2500 Services\n\u2502   \u2514\u2500\u2500 DefaultCryptoService.swift\n\u2514\u2500\u2500 Types\n    \u251c\u2500\u2500 CryptoConfig.swift\n    \u251c\u2500\u2500 CryptoConfiguration.swift\n    \u2514\u2500\u2500 CredentialManager.swift\n</code></pre></li> <li>External Dependencies:</li> <li><code>CryptoSwift</code> for cryptographic operations</li> </ul>"},{"location":"SECURITY_ARCHITECTURE/#umbracrypto-module","title":"UmbraCrypto Module","text":"<ul> <li>Purpose: Implementation of cryptographic operations</li> <li>Location: <code>//Sources/UmbraCrypto</code></li> <li>Dependencies:</li> <li><code>CryptoTypes</code></li> <li><code>CryptoSwift</code></li> <li>Testing Status: Test-only module</li> </ul>"},{"location":"SECURITY_ARCHITECTURE/#2-security-services","title":"2. Security Services","text":""},{"location":"SECURITY_ARCHITECTURE/#umbracryptoservice","title":"UmbraCryptoService","text":"<ul> <li>Purpose: XPC-based secure crypto service</li> <li>Location: <code>//Sources/UmbraCryptoService</code></li> <li>Key Components:   <pre><code>UmbraCryptoService\n\u251c\u2500\u2500 CryptoServiceListener.swift\n\u251c\u2500\u2500 CryptoXPCService.swift\n\u2514\u2500\u2500 UmbraCryptoService.swift\n</code></pre></li> <li>Entitlements:</li> <li>App sandbox enabled</li> <li>Keychain access groups</li> <li>Application group access</li> <li>Network client capabilities</li> </ul>"},{"location":"SECURITY_ARCHITECTURE/#umbrasecurity","title":"UmbraSecurity","text":"<ul> <li>Purpose: High-level security interface</li> <li>Location: <code>//Sources/UmbraSecurity</code></li> <li>Components:</li> <li>Security service implementation</li> <li>Security-scoped bookmark handling</li> <li>URL security extensions</li> </ul>"},{"location":"SECURITY_ARCHITECTURE/#3-security-utils","title":"3. Security Utils","text":""},{"location":"SECURITY_ARCHITECTURE/#securityutils-module","title":"SecurityUtils Module","text":"<ul> <li>Purpose: Common security utilities</li> <li>Location: <code>//Sources/SecurityUtils</code></li> <li>Features:</li> <li>Encrypted bookmark service</li> <li>Security bookmark service</li> <li>Security protocols</li> </ul>"},{"location":"SECURITY_ARCHITECTURE/#security-features","title":"Security Features","text":""},{"location":"SECURITY_ARCHITECTURE/#1-encryption","title":"1. Encryption","text":"<ul> <li>AES-256 encryption (via CryptoSwift)</li> <li>Secure key generation and management</li> <li>IV (Initialization Vector) handling</li> <li>Secure memory handling</li> </ul>"},{"location":"SECURITY_ARCHITECTURE/#2-access-control","title":"2. Access Control","text":"<ul> <li>Security-scoped bookmarks</li> <li>Keychain integration</li> <li>Sandboxed operations</li> <li>XPC service isolation</li> </ul>"},{"location":"SECURITY_ARCHITECTURE/#3-credential-management","title":"3. Credential Management","text":"<pre><code>public struct CredentialManager {\n    public let keyLength: Int\n    public let ivLength: Int\n\n    // Secure credential storage\n    private let secureStorage: SecureStorageProvider\n\n    // Credential lifecycle management\n    public func store(_ credentials: Credentials) async throws\n    public func retrieve() async throws -&gt; Credentials\n    public func clear() async throws\n}\n</code></pre>"},{"location":"SECURITY_ARCHITECTURE/#external-dependencies","title":"External Dependencies","text":""},{"location":"SECURITY_ARCHITECTURE/#1-cryptoswift","title":"1. CryptoSwift","text":"<ul> <li>Version: Latest stable</li> <li>Usage: Core cryptographic operations</li> <li>Features Used:</li> <li>AES encryption</li> <li>Key generation</li> <li>Secure random number generation</li> <li>Hash functions</li> </ul>"},{"location":"SECURITY_ARCHITECTURE/#2-apple-security-framework","title":"2. Apple Security Framework","text":"<ul> <li>Features Used:</li> <li>Keychain Services</li> <li>Security-scoped bookmarks</li> <li>Certificate handling</li> <li>Secure enclave operations</li> </ul>"},{"location":"SECURITY_ARCHITECTURE/#security-protocols","title":"Security Protocols","text":""},{"location":"SECURITY_ARCHITECTURE/#1-cryptoservice-protocol","title":"1. CryptoService Protocol","text":"<pre><code>public protocol CryptoService {\n    func encrypt(_ data: Data, using key: SymmetricKey) async throws -&gt; EncryptedData\n    func decrypt(_ data: EncryptedData, using key: SymmetricKey) async throws -&gt; Data\n    func generateKey(length: Int) async throws -&gt; SymmetricKey\n    func generateIV(length: Int) async throws -&gt; Data\n}\n</code></pre>"},{"location":"SECURITY_ARCHITECTURE/#2-securestorageprovider-protocol","title":"2. SecureStorageProvider Protocol","text":"<pre><code>public protocol SecureStorageProvider {\n    func store(_ data: Data, for identifier: String) async throws\n    func retrieve(for identifier: String) async throws -&gt; Data\n    func remove(for identifier: String) async throws\n}\n</code></pre>"},{"location":"SECURITY_ARCHITECTURE/#security-configuration","title":"Security Configuration","text":""},{"location":"SECURITY_ARCHITECTURE/#1-default-configuration","title":"1. Default Configuration","text":"<pre><code>public struct CryptoConfig {\n    public static let `default` = CryptoConfig(\n        keyLength: 256,  // AES-256\n        ivLength: 16     // 128 bits\n    )\n}\n</code></pre>"},{"location":"SECURITY_ARCHITECTURE/#2-xpc-service-configuration","title":"2. XPC Service Configuration","text":"<ul> <li>Sandboxed environment</li> <li>Limited file system access</li> <li>Specific keychain access groups</li> <li>Application group sharing</li> </ul>"},{"location":"SECURITY_ARCHITECTURE/#known-issues-and-mitigations","title":"Known Issues and Mitigations","text":""},{"location":"SECURITY_ARCHITECTURE/#1-memory-management","title":"1. Memory Management","text":"<ul> <li>Issue: Sensitive data in memory</li> <li>Mitigation: Secure memory wiping after use</li> </ul>"},{"location":"SECURITY_ARCHITECTURE/#2-key-storage","title":"2. Key Storage","text":"<ul> <li>Issue: Secure key storage</li> <li>Mitigation: Keychain with access control</li> </ul>"},{"location":"SECURITY_ARCHITECTURE/#3-ipc-security","title":"3. IPC Security","text":"<ul> <li>Issue: Inter-process communication security</li> <li>Mitigation: XPC with entitlement checking</li> </ul>"},{"location":"SECURITY_ARCHITECTURE/#testing","title":"Testing","text":""},{"location":"SECURITY_ARCHITECTURE/#1-security-testing","title":"1. Security Testing","text":"<ul> <li>Unit tests for all crypto operations</li> <li>Integration tests for service communication</li> <li>Fuzzing tests for input validation</li> <li>Memory leak detection</li> </ul>"},{"location":"SECURITY_ARCHITECTURE/#2-mock-implementations","title":"2. Mock Implementations","text":"<pre><code>public final class MockCryptoService: CryptoService {\n    public var encryptionBehavior: EncryptionBehavior\n    public var decryptionBehavior: DecryptionBehavior\n    // Implementation for testing\n}\n</code></pre>"},{"location":"SECURITY_ARCHITECTURE/#future-improvements","title":"Future Improvements","text":"<ol> <li>Hardware Security</li> <li>Secure Enclave integration</li> <li>Touch ID/Apple Watch authentication</li> <li> <p>Smart card support</p> </li> <li> <p>Key Management</p> </li> <li>Key rotation policies</li> <li>Multi-factor key derivation</li> <li> <p>Quantum-resistant algorithms</p> </li> <li> <p>Audit Logging</p> </li> <li>Comprehensive security event logging</li> <li>Real-time alerts</li> <li>Compliance reporting</li> </ol>"},{"location":"SECURITY_ARCHITECTURE/#security-guidelines","title":"Security Guidelines","text":"<ol> <li>Development</li> <li>Always use secure random number generation</li> <li>Implement proper error handling</li> <li> <p>Clear sensitive data from memory</p> </li> <li> <p>Testing</p> </li> <li>Test with different key sizes</li> <li>Validate all error paths</li> <li> <p>Check memory handling</p> </li> <li> <p>Deployment</p> </li> <li>Review entitlements</li> <li>Validate sandbox configuration</li> <li>Check keychain access groups</li> </ol> <p>Last Updated: 2025-02-24</p>"},{"location":"SWIFTFORMAT_UPDATE/","title":"SwiftFormat Configuration Update (5 March 2025)","text":""},{"location":"SWIFTFORMAT_UPDATE/#summary-of-changes","title":"Summary of Changes","text":"<p>We've completed a comprehensive update to UmbraCore's SwiftFormat configuration and tooling to standardize code formatting across the project. This update includes:</p> <ol> <li> <p>Updated Configuration File - <code>.swiftformat</code> now works with SwiftFormat 0.55.5 using the current syntax and rule names.</p> </li> <li> <p>Formatting Scripts - Created <code>scripts/format_code.sh</code> for easy code formatting with options for checking, formatting specific files, and working with staged files.</p> </li> <li> <p>Git Pre-commit Hook - Added <code>scripts/install-git-hooks.sh</code> to install a pre-commit hook that checks formatting of staged Swift files.</p> </li> <li> <p>Documentation Updates:</p> </li> <li>Added SwiftFormat section to <code>swift_style_guide.md</code></li> <li>Created <code>IDE_INTEGRATION.md</code> for IDE-specific setup instructions</li> <li>Updated <code>UmbraCore_Refactoring_Plan.md</code> to reflect completion of this task</li> </ol>"},{"location":"SWIFTFORMAT_UPDATE/#key-formatting-rules","title":"Key Formatting Rules","text":"<p>The updated SwiftFormat configuration enforces these key style elements:</p> <ul> <li>2-space indentation</li> <li>100 character line length</li> <li>Same-line opening braces</li> <li>Consistent spacing around operators and parentheses</li> <li>Alphabetized imports</li> <li>Standardized modifier ordering</li> <li>Hoisted pattern let bindings</li> <li>No trailing whitespace</li> </ul>"},{"location":"SWIFTFORMAT_UPDATE/#usage-instructions","title":"Usage Instructions","text":""},{"location":"SWIFTFORMAT_UPDATE/#command-line-formatting","title":"Command Line Formatting","text":"<pre><code># Format all files\n./scripts/format_code.sh\n\n# Check formatting without making changes\n./scripts/format_code.sh --check\n\n# Format only staged files\n./scripts/format_code.sh --staged-only\n\n# Format specific files or directories\n./scripts/format_code.sh path/to/file.swift path/to/directory\n</code></pre>"},{"location":"SWIFTFORMAT_UPDATE/#git-hook-installation","title":"Git Hook Installation","text":"<pre><code># Install git hooks\n./scripts/install-git-hooks.sh\n</code></pre>"},{"location":"SWIFTFORMAT_UPDATE/#ide-integration","title":"IDE Integration","text":"<p>See <code>docs/IDE_INTEGRATION.md</code> for detailed instructions on integrating with: - Xcode - Visual Studio Code - JetBrains AppCode/CLion</p>"},{"location":"SWIFTFORMAT_UPDATE/#next-steps","title":"Next Steps","text":"<p>To fully adopt the updated formatting standards across the project:</p> <ol> <li>Install the Git hooks on your local development environment</li> <li>Configure your IDE to use SwiftFormat with our rules</li> <li>Consider adding SwiftFormat checks to the CI pipeline</li> <li>Run the formatter on all files before merging significant changes</li> </ol>"},{"location":"SWIFTFORMAT_UPDATE/#compatibility-notes","title":"Compatibility Notes","text":"<ul> <li>The configuration is compatible with SwiftFormat 0.55.5</li> <li>Ensure your local installation is up to date using <code>brew upgrade swiftformat</code></li> <li>All formatting rules align with the Google Swift Style Guide</li> <li>Some older rules have been updated to their newer equivalents</li> </ul> <p>If you encounter any issues with the formatting configuration, please report them to the team.</p>"},{"location":"UmbraCore_Architecture_Guide/","title":"UmbraCore Architecture Guide","text":""},{"location":"UmbraCore_Architecture_Guide/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Introduction</li> <li>Architectural Principles</li> <li>Module Structure</li> <li>Foundation-Free Architecture</li> <li>Namespace Resolution</li> <li>Error Handling Strategy</li> <li>Build System</li> <li>Cross-Platform Support</li> <li>Testing Strategy</li> <li>Appendix: Common Patterns</li> </ol>"},{"location":"UmbraCore_Architecture_Guide/#introduction","title":"Introduction","text":"<p>UmbraCore is a modular Swift framework designed to provide secure, cross-platform functionality with a focus on maintainability, type safety, and clear API boundaries. This document consolidates the architectural principles, patterns, and guidelines established across multiple implementation guides into a single, comprehensive reference.</p>"},{"location":"UmbraCore_Architecture_Guide/#architectural-principles","title":"Architectural Principles","text":""},{"location":"UmbraCore_Architecture_Guide/#core-design-goals","title":"Core Design Goals","text":"<ol> <li>Modular Architecture: Clear separation of concerns with well-defined interfaces</li> <li>Foundation Independence: Core modules remain Foundation-free to support cross-platform usage</li> <li>Type Safety: Leverage Swift's type system to catch errors at compile time</li> <li>Clear API Boundaries: Explicit interfaces between modules with controlled visibility</li> <li>Testability: Design for comprehensive testing at all levels</li> </ol>"},{"location":"UmbraCore_Architecture_Guide/#architectural-constraints","title":"Architectural Constraints","text":"<ol> <li>Cross-Platform Compatibility: Core functionality must work on all supported platforms</li> <li>Security as a First-Class Concern: Security protocols and implementations follow rigorous separation</li> <li>Minimal Dependencies: External dependencies limited to essential functionality</li> </ol>"},{"location":"UmbraCore_Architecture_Guide/#module-structure","title":"Module Structure","text":"<p>UmbraCore follows a layered architecture with clear separation between:</p>"},{"location":"UmbraCore_Architecture_Guide/#core-layers","title":"Core Layers","text":"<ol> <li>Interfaces Layer: Protocol definitions without implementation details</li> <li>Foundation-free APIs</li> <li>Type definitions</li> <li> <p>Minimal dependencies</p> </li> <li> <p>Implementation Layer: Concrete implementations of interfaces</p> </li> <li>May be platform-specific</li> <li>Contains business logic</li> <li> <p>May depend on specific frameworks</p> </li> <li> <p>Adapters Layer: Bridges between different module implementations</p> </li> <li>Handles type conversion</li> <li>Maps between error domains</li> <li>Provides compatibility between different module versions</li> </ol>"},{"location":"UmbraCore_Architecture_Guide/#key-module-categories","title":"Key Module Categories","text":"<ol> <li>Core Types: Base types used throughout the system</li> <li><code>UmbraCoreTypes</code>: Foundation-free type definitions</li> <li> <p><code>CoreTypesInterfaces</code>: Interface definitions for core types</p> </li> <li> <p>Security Modules:</p> </li> <li><code>SecurityInterfaces</code>: Foundation-free security protocol definitions</li> <li><code>SecurityProtocolsCore</code>: Core security protocol implementations</li> <li> <p><code>SecurityBridgeProtocolAdapters</code>: Connects security providers to Foundation-free interfaces</p> </li> <li> <p>Service Modules:</p> </li> <li><code>CoreServices</code>: Foundation-dependent service implementations</li> <li> <p><code>CoreServicesTypes</code>: Foundation-free service type definitions</p> </li> <li> <p>Error Handling:</p> </li> <li><code>ErrorHandling</code>: Central error definition and handling</li> <li><code>ErrorHandlingDomains</code>: Domain-specific error types</li> </ol>"},{"location":"UmbraCore_Architecture_Guide/#foundation-free-architecture","title":"Foundation-Free Architecture","text":"<p>The Foundation-free architecture is a core design principle that enables cross-platform compatibility and clear separation of concerns.</p>"},{"location":"UmbraCore_Architecture_Guide/#principles","title":"Principles","text":"<ol> <li>Interface/Implementation Separation:</li> <li>Interfaces (protocols, type definitions) remain Foundation-free</li> <li> <p>Implementations may use Foundation when necessary</p> </li> <li> <p>Type Isolation:</p> </li> <li>Core types defined without Foundation dependencies</li> <li> <p>Bridge types provided for conversion when necessary</p> </li> <li> <p>Error Domain Isolation:</p> </li> <li>Error types defined without Foundation dependencies</li> <li>Error mapping functions provided for cross-domain conversion</li> </ol>"},{"location":"UmbraCore_Architecture_Guide/#implementation-strategy","title":"Implementation Strategy","text":"<ol> <li>Foundation-Free Interfaces:</li> <li>Use Swift's native types (<code>UInt8</code>, arrays, etc.) instead of Foundation types</li> <li>Define protocols without Foundation dependencies</li> <li> <p>Isolate Foundation-dependent code in dedicated modules</p> </li> <li> <p>Platform-Specific Implementations:</p> </li> <li>Implement interfaces with platform-specific code when necessary</li> <li>Use conditional compilation for platform differences</li> <li> <p>Provide adapter layers for Foundation-dependent implementations</p> </li> <li> <p>Type Conversion:</p> </li> <li>Provide explicit conversion between Foundation and non-Foundation types</li> <li>Use extension methods for seamless conversion</li> <li>Document conversion paths clearly</li> </ol>"},{"location":"UmbraCore_Architecture_Guide/#namespace-resolution","title":"Namespace Resolution","text":"<p>Swift's namespace handling presents unique challenges when working with modules with similar type names. UmbraCore employs specific patterns to resolve these conflicts.</p>"},{"location":"UmbraCore_Architecture_Guide/#namespace-conflict-patterns","title":"Namespace Conflict Patterns","text":"<ol> <li>Module Name vs. Type Name Conflicts:</li> <li>Example: <code>SecurityProtocolsCore</code> module containing a <code>SecurityProtocolsCore</code> enum</li> <li> <p>Resolution: Use explicit module qualification for references</p> </li> <li> <p>Similar Type Names Across Modules:</p> </li> <li>Example: Multiple modules defining <code>SecurityError</code> types</li> <li>Resolution: Use type aliases with consistent prefixes</li> </ol>"},{"location":"UmbraCore_Architecture_Guide/#resolution-techniques","title":"Resolution Techniques","text":"<ol> <li>Enhanced Isolation Pattern:</li> <li>Create dedicated files that only import one conflicting module at a time</li> <li>Use subpackages with distinct module names for complete isolation</li> <li> <p>Add private type aliases to clarify which type is being used</p> </li> <li> <p>Type Qualification:</p> </li> <li>Use fully qualified names (<code>ModuleName.TypeName</code>)</li> <li>Add consistent type aliases with prefixes (e.g., <code>SPCProvider</code>)</li> <li> <p>Document expected type paths in comments</p> </li> <li> <p>Subpackage Approach:</p> </li> <li>Main module depends on isolated subpackage</li> <li>Subpackage handles all direct interactions with potentially conflicting module</li> <li> <p>Public re-exports provide a clean API</p> </li> <li> <p>Build System Configuration:</p> </li> <li>Use <code>-enable-implicit-module-import-name-qualification</code> when available</li> <li>Document module import constraints</li> </ol>"},{"location":"UmbraCore_Architecture_Guide/#error-handling-strategy","title":"Error Handling Strategy","text":"<p>UmbraCore employs a structured approach to error handling, focusing on clarity, domain separation, and type safety.</p>"},{"location":"UmbraCore_Architecture_Guide/#error-hierarchy","title":"Error Hierarchy","text":"<ol> <li>Root Error Namespace: <code>UmbraErrors</code></li> <li>Domain-specific subnamespaces (e.g., <code>UmbraErrors.Security</code>)</li> <li> <p>Feature-specific error types (e.g., <code>UmbraErrors.Security.Protocols</code>)</p> </li> <li> <p>Error Categories:</p> </li> <li>Interface errors: Defined in interface modules, Foundation-free</li> <li>Implementation errors: May include platform-specific details</li> <li>Cross-cutting errors: Defined in central error module</li> </ol>"},{"location":"UmbraCore_Architecture_Guide/#error-mapping","title":"Error Mapping","text":"<ol> <li>Cross-Module Error Conversion:</li> <li>Explicit mapping functions between error domains</li> <li>Consistent error property mapping</li> <li> <p>Preservation of error context</p> </li> <li> <p>Error Propagation:</p> </li> <li>Define clear error boundaries</li> <li>Document expected error types in function signatures</li> <li>Use Swift's <code>throws</code> consistently</li> </ol>"},{"location":"UmbraCore_Architecture_Guide/#build-system","title":"Build System","text":"<p>UmbraCore uses Bazel as its build system, with specific configurations to ensure consistent builds across environments.</p>"},{"location":"UmbraCore_Architecture_Guide/#build-configuration","title":"Build Configuration","text":"<ol> <li>Standard Targets:</li> <li>Library targets with clear dependencies</li> <li>Test targets for each module</li> <li> <p>Conditional compilation for platform-specific code</p> </li> <li> <p>Build Flags:</p> </li> <li>Foundation-free compilation flags</li> <li>Library evolution support where needed</li> <li> <p>Conditional dependencies based on target platform</p> </li> <li> <p>Dependency Management:</p> </li> <li>External dependencies defined in WORKSPACE</li> <li>Version pinning for reproducible builds</li> <li>Conditional inclusion of platform-specific dependencies</li> </ol>"},{"location":"UmbraCore_Architecture_Guide/#cross-module-compatibility","title":"Cross-Module Compatibility","text":"<ol> <li>Library Evolution:</li> <li>Enable library evolution for stable APIs</li> <li>Conditional compilation for non-compliant dependencies (e.g., CryptoSwift)</li> <li> <p>Document evolution constraints</p> </li> <li> <p>Module Structure:</p> </li> <li>Consistent naming pattern for modules</li> <li>Clear dependency graph</li> <li>Minimal cyclic dependencies</li> </ol>"},{"location":"UmbraCore_Architecture_Guide/#cross-platform-support","title":"Cross-Platform Support","text":"<p>UmbraCore supports multiple platforms through careful API design and conditional implementation.</p>"},{"location":"UmbraCore_Architecture_Guide/#platform-abstraction","title":"Platform Abstraction","text":"<ol> <li>Platform-Agnostic Interfaces:</li> <li>Foundation-free API definitions</li> <li>Platform capability detection</li> <li> <p>Feature availability flags</p> </li> <li> <p>Platform-Specific Implementations:</p> </li> <li>Dedicated implementation modules for each platform</li> <li>Common patterns across platforms</li> <li>Clear separation of platform-specific code</li> </ol>"},{"location":"UmbraCore_Architecture_Guide/#conditional-compilation","title":"Conditional Compilation","text":"<ol> <li>Feature Flags:</li> <li><code>USE_FOUNDATION_CRYPTO</code> for cryptographic implementations</li> <li> <p>Platform-specific compilation flags</p> </li> <li> <p>Implementation Selection:</p> </li> <li>Runtime feature detection where possible</li> <li>Compile-time platform selection</li> <li>Dependency injection for platform-specific components</li> </ol>"},{"location":"UmbraCore_Architecture_Guide/#testing-strategy","title":"Testing Strategy","text":"<p>UmbraCore employs a comprehensive testing strategy to ensure quality and maintainability.</p>"},{"location":"UmbraCore_Architecture_Guide/#test-categories","title":"Test Categories","text":"<ol> <li>Unit Tests:</li> <li>Module-level functionality testing</li> <li>Mock dependencies for isolation</li> <li> <p>High coverage targets for core modules</p> </li> <li> <p>Integration Tests:</p> </li> <li>Cross-module interaction testing</li> <li>Focused on API boundaries</li> <li> <p>Validation of error propagation</p> </li> <li> <p>Cross-Platform Tests:</p> </li> <li>Validation of platform-agnostic behaviour</li> <li>Platform-specific feature testing</li> <li>Compatibility verification</li> </ol>"},{"location":"UmbraCore_Architecture_Guide/#testing-patterns","title":"Testing Patterns","text":"<ol> <li>Mock Objects:</li> <li>Protocol-based mock implementations</li> <li>Testable injection points</li> <li> <p>Consistent approach to verification</p> </li> <li> <p>Test Helpers:</p> </li> <li>Shared test utilities</li> <li>Test data generators</li> <li>Error validation helpers</li> </ol>"},{"location":"UmbraCore_Architecture_Guide/#appendix-common-patterns","title":"Appendix: Common Patterns","text":""},{"location":"UmbraCore_Architecture_Guide/#type-conversion-patterns","title":"Type Conversion Patterns","text":"<ol> <li> <p>SecureBytes Conversion:    <pre><code>// Converting SecureBytes to raw bytes\nlet rawBytes = Array(secureBytes)\n\n// Converting raw bytes to SecureBytes\nlet secureBytes = SecureBytes(bytes: rawBytes)\n</code></pre></p> </li> <li> <p>Error Domain Conversion:    <pre><code>// Converting from one error domain to another\nfunc convert(_ error: SecurityProtocolsCore.SecurityError) -&gt; CoreErrors.SecurityError {\n    switch error {\n    case .encryptionFailed(let reason):\n        return .encryptionFailed(reason: reason)\n    // Other cases...\n    }\n}\n</code></pre></p> </li> </ol>"},{"location":"UmbraCore_Architecture_Guide/#namespace-resolution-patterns","title":"Namespace Resolution Patterns","text":"<ol> <li> <p>Type Alias Approach:    <pre><code>// In a file that needs both types\nimport SecurityProtocolsCore\nimport CoreErrors\n\n// Create clear aliases\ntypealias SPCSecurityError = SecurityProtocolsCore.SecurityError\ntypealias CESecurityError = CoreErrors.SecurityError\n</code></pre></p> </li> <li> <p>Module Isolation:    <pre><code>// SecurityInterfaces_SecurityProtocolsCore.swift\nimport SecurityProtocolsCore\n\n// Export types with clear naming\npublic typealias SPCProvider = SecurityProtocolsCore.SecurityProviderProtocol\n\n// Main module only imports the isolation layer\n</code></pre></p> </li> </ol>"},{"location":"UmbraCore_Architecture_Guide/#conditional-implementation","title":"Conditional Implementation","text":"<ol> <li> <p>Platform-Specific Code:    <pre><code>#if USE_FOUNDATION_CRYPTO\nimport Foundation\n// Foundation-based implementation\n#else\nimport CryptoSwift\n// CryptoSwift-based implementation\n#endif\n</code></pre></p> </li> <li> <p>Feature Detection:    <pre><code>func createHasher() -&gt; any Hasher {\n    #if canImport(CryptoKit) &amp;&amp; !DISABLE_CRYPTOKIT\n    return CryptoKitHasher()\n    #else\n    return StandardHasher()\n    #endif\n}\n</code></pre></p> </li> </ol>"},{"location":"UmbraCore_Refactoring_Plan/","title":"UmbraCore Foundation Decoupling and Architecture Refactoring Plan","text":""},{"location":"UmbraCore_Refactoring_Plan/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Current State Analysis</li> <li>Core Issues Identified</li> <li>Refactoring Strategy</li> <li>Proposed Architecture</li> <li>Implementation Plan</li> <li>Refactoring Priority Matrix</li> <li>Module Consolidation Strategy</li> <li>Module Structure and Organization</li> <li>Build System Integration</li> <li>Code Examples</li> <li>Implementation Workflow</li> <li>Design Decisions and Rationale</li> <li>Performance Considerations</li> <li>Versioning and Compatibility</li> <li>Error Handling Strategy</li> <li>Alternatives to @objc for XPC Protocols</li> <li>Swift Library Evolution Compatibility in Dependency Chains</li> <li>Bazelisk and Build System Integration Lessons</li> <li>Implementation Status (Updated 1 March 2025)</li> </ol> <p>{{ ... }}</p> <p>We have updated our priority matrix to include these consolidation tasks, with SecureBytes implementation and SecurityInterfaces consolidation as our highest priorities.</p>"},{"location":"UmbraCore_Refactoring_Plan/#module-consolidation-strategy","title":"Module Consolidation Strategy","text":"<p>After analyzing the codebase, we've identified several areas where multiple bridging modules have been created in attempts to break circular dependencies. This section outlines a consolidation strategy to simplify the architecture while achieving our dependency-breaking goals.</p>"},{"location":"UmbraCore_Refactoring_Plan/#1-current-module-fragmentation-analysis","title":"1. Current Module Fragmentation Analysis","text":"<p>We've identified three main areas with significant module fragmentation:</p> Area Fragmented Modules Severity Root Cause Security Interfaces 8+ modules including SecurityInterfaces, SecurityInterfacesBase, SecurityInterfacesFoundation, etc. High Multiple iterations of attempting to break Foundation dependencies Umbra Security Services 4 modules including UmbraSecurity, UmbraSecurityFoundation, UmbraSecurityNoFoundation, etc. Medium Segregating Foundation dependencies Core Services Types CoreServicesTypes, CoreServicesTypesNoFoundation Low Early stage fragmentation <p>This fragmentation has led to: - Complex dependency graphs - Unclear ownership of functionality - Redundant code across modules - Higher maintenance burden - Difficult onboarding for new developers</p>"},{"location":"UmbraCore_Refactoring_Plan/#2-consolidation-approach","title":"2. Consolidation Approach","text":"<p>For each fragmented area, we will apply the following consolidation pattern:</p>"},{"location":"UmbraCore_Refactoring_Plan/#foundation-free-core","title":"Foundation-Free Core","text":"<ul> <li>Create/consolidate into a single core module (e.g., <code>SecurityProtocolsCore</code>)</li> <li>Use only domain-specific types (SecureBytes, ResourceLocator, etc.)</li> <li>No Foundation imports whatsoever</li> <li>Clear, focused protocols with minimal surface area</li> </ul>"},{"location":"UmbraCore_Refactoring_Plan/#single-bridge-module","title":"Single Bridge Module","text":"<ul> <li>Create one consolidated bridge module per functional area</li> <li>This module handles all Foundation conversions</li> <li>Acts as the only module with both Foundation and core module imports</li> <li>Contains adapter classes and conversion utilities</li> </ul>"},{"location":"UmbraCore_Refactoring_Plan/#implementation-modules","title":"Implementation Module(s)","text":"<ul> <li>May have one or more implementation modules</li> <li>Each implementation has a clear purpose (e.g., Foundation-based, XPC-based)</li> <li>Dependencies flow in one direction through the bridge</li> </ul>"},{"location":"UmbraCore_Refactoring_Plan/#3-consolidation-targets-and-plan","title":"3. Consolidation Targets and Plan","text":""},{"location":"UmbraCore_Refactoring_Plan/#31-security-interfaces-highest-priority","title":"3.1 Security Interfaces (Highest Priority)","text":"<p>Current State: - 8+ fragmented modules - Circular dependencies between Foundation and security protocols - Overlapping responsibilities</p> <p>Consolidation Plan: 1. Create <code>SecurityProtocolsCore</code> with foundation-free types and protocols 2. Implement <code>SecurityBridge</code> for all Foundation conversions 3. Remove redundant modules:    - SecurityInterfacesFoundationBase    - SecurityInterfacesFoundationBridge    - SecurityInterfacesFoundationCore    - SecurityInterfacesFoundationMinimal    - SecurityInterfacesFoundationNoFoundation</p> <p>Module Reduction: 8+ \u2192 2-3 modules</p>"},{"location":"UmbraCore_Refactoring_Plan/#32-umbra-security-services-medium-priority","title":"3.2 Umbra Security Services (Medium Priority)","text":"<p>Current State: - 4 fragmented modules - Similar pattern to Security Interfaces - Implementation-specific fragmentation</p> <p>Consolidation Plan: 1. Create <code>UmbraSecurityCore</code> with foundation-free implementation 2. Implement <code>UmbraSecurityBridge</code> for Foundation interop 3. Remove redundant modules:    - UmbraSecurityNoFoundation    - UmbraSecurityServicesNoFoundation    - UmbraSecurityFoundation</p> <p>Module Reduction: 4 \u2192 2 modules</p>"},{"location":"UmbraCore_Refactoring_Plan/#33-core-services-types-medium-priority","title":"3.3 Core Services Types (Medium Priority)","text":"<p>Current State: - Beginning signs of fragmentation - Foundation dependencies creeping in</p> <p>Consolidation Plan: 1. Create <code>CoreTypesProtocols</code> for foundation-free definitions 2. Implement <code>CoreTypesBridge</code> for Foundation interop 3. Migrate and consolidate existing types</p> <p>Module Reduction: 2+ \u2192 2 focused modules</p>"},{"location":"UmbraCore_Refactoring_Plan/#34-objc-bridging-types-medium-priority","title":"3.4 ObjC Bridging Types (Medium Priority)","text":"<p>Current State: - ObjCBridgingTypes and ObjCBridgingTypesFoundation - Foundation dependencies causing cycles</p> <p>Consolidation Plan: 1. Create foundation-free base interfaces 2. Implement single bridge module for Foundation 3. Clear separation of ObjC and Foundation concerns</p> <p>Module Reduction: 2+ \u2192 2 focused modules</p>"},{"location":"UmbraCore_Refactoring_Plan/#35-cryptoswift-integration-lower-priority","title":"3.5 CryptoSwift Integration (Lower Priority)","text":"<p>Current State: - CryptoSwiftNoFoundation attempts to remove Foundation - Not fully integrated with domain types</p> <p>Consolidation Plan: 1. Integrate with domain-specific types 2. Provide clean crypto interfaces</p> <p>Module Reduction: 2 \u2192 1-2 focused modules</p>"},{"location":"UmbraCore_Refactoring_Plan/#4-implementation-approach-for-securityinterfaces","title":"4. Implementation Approach for SecurityInterfaces","text":"<p>As a prototype for our consolidation approach, we will tackle SecurityInterfaces first with the following steps:</p> <ol> <li>Initial scaffolding (1-2 days):</li> <li>Create the new SecurityProtocolsCore module</li> <li>Define basic domain types and protocols</li> <li> <p>Set up the bridge module structure</p> </li> <li> <p>Migration (3-5 days):</p> </li> <li>Port essential functionality from existing modules to the new structure</li> <li>Update imports and type usage</li> <li> <p>Create necessary bridging functions</p> </li> <li> <p>Integration testing (2-3 days):</p> </li> <li>Ensure all functionality works with the new structure</li> <li>Test boundary cases and error conditions</li> <li> <p>Validate no circular dependencies exist</p> </li> <li> <p>Cleanup (1-2 days):</p> </li> <li>Once the new structure is proven, remove the redundant modules</li> <li>Update all references to use the new modules</li> <li>Document the new architecture</li> </ol>"},{"location":"UmbraCore_Refactoring_Plan/#5-benefits-of-consolidation","title":"5. Benefits of Consolidation","text":"<p>This consolidation approach will deliver several key benefits:</p> <ol> <li>Architectural Clarity</li> <li>Clear module boundaries and responsibilities</li> <li>One-way dependency flow</li> <li> <p>Simplified mental model</p> </li> <li> <p>Reduced Codebase Size</p> </li> <li>Elimination of redundant code</li> <li>Fewer files to maintain</li> <li> <p>Consolidated build artifacts</p> </li> <li> <p>Improved Build Performance</p> </li> <li>Fewer module boundaries to cross</li> <li>Reduced compile-time dependencies</li> <li> <p>More efficient incremental builds</p> </li> <li> <p>Better Developer Experience</p> </li> <li>Easier navigation of the codebase</li> <li>Clear patterns to follow for new development</li> <li> <p>More intuitive organization</p> </li> <li> <p>Foundation Independence</p> </li> <li>Core functionality isolated from Foundation</li> <li>Easier to port to other platforms</li> <li>Better testing without Foundation dependencies</li> </ol>"},{"location":"UmbraCore_Refactoring_Plan/#6-integration-with-priority-matrix","title":"6. Integration with Priority Matrix","text":"<p>This consolidation strategy aligns with our priority matrix by:</p> <ol> <li>Focusing first on high-impact, high-dependency areas</li> <li>Breaking circular dependencies as a primary goal</li> <li>Starting with clear architectural boundaries</li> <li>Providing quick wins through module simplification</li> </ol> <p>We have updated our priority matrix to include these consolidation tasks, with SecureBytes implementation and SecurityInterfaces consolidation as our highest priorities.</p>"},{"location":"UmbraCore_Refactoring_Plan/#module-structure-and-organization","title":"Module Structure and Organization","text":"<p>This section details the specific structure and organization of the consolidated modules. The architecture follows a clean, modular design with clear boundaries between Foundation-dependent and Foundation-free code.</p>"},{"location":"UmbraCore_Refactoring_Plan/#1-overall-project-structure","title":"1. Overall Project Structure","text":"<p>The consolidated project structure will organize modules by their primary responsibility and Foundation dependency status:</p> <pre><code>UmbraCore/\n\u251c\u2500\u2500 UmbraCoreTypes/                          # Domain-specific foundation-free types\n\u251c\u2500\u2500 SecurityProtocolsCore/                   # Foundation-free protocol definitions\n\u251c\u2500\u2500 SecurityBridge/                          # Bridge between core types and Foundation\n\u251c\u2500\u2500 SecurityImplementation/                  # Concrete implementation (Foundation-free)\n\u251c\u2500\u2500 SecurityImplementationFoundation/        # Foundation-dependent implementation\n\u251c\u2500\u2500 XPCProtocolsCore/                        # Foundation-free XPC protocol definitions\n\u251c\u2500\u2500 XPCBridge/                               # XPC bridge for Foundation interoperability\n\u2514\u2500\u2500 [other domain-specific modules]          # Following the same pattern\n</code></pre>"},{"location":"UmbraCore_Refactoring_Plan/#2-detailed-module-structure","title":"2. Detailed Module Structure","text":""},{"location":"UmbraCore_Refactoring_Plan/#21-umbracoretypes","title":"2.1 UmbraCoreTypes","text":"<p>This module contains foundational, domain-specific types that replace Foundation dependencies:</p> <pre><code>UmbraCoreTypes/\n\u251c\u2500\u2500 BUILD.bazel\n\u251c\u2500\u2500 Sources/\n\u2502   \u251c\u2500\u2500 SecureBytes.swift                # Replacement for Data\n\u2502   \u251c\u2500\u2500 ResourceLocator.swift            # Replacement for URL\n\u2502   \u251c\u2500\u2500 TimePoint.swift                  # Replacement for Date\n\u2502   \u251c\u2500\u2500 Result.swift                     # Domain-specific result type\n\u2502   \u2514\u2500\u2500 Errors/\n\u2502       \u251c\u2500\u2500 ErrorProtocol.swift          # Base error protocol\n\u2502       \u2514\u2500\u2500 CommonErrors.swift           # Common error definitions\n\u2514\u2500\u2500 Tests/\n    \u2514\u2500\u2500 [unit tests]\n</code></pre> <p>Key characteristics: - Zero Foundation imports - All types conform to <code>Sendable</code> - Comprehensive value semantics - Full Swift concurrency support</p>"},{"location":"UmbraCore_Refactoring_Plan/#22-securityprotocolscore","title":"2.2 SecurityProtocolsCore","text":"<p>This module defines security interfaces using only core types with no Foundation dependencies:</p> <pre><code>SecurityProtocolsCore/\n\u251c\u2500\u2500 BUILD.bazel\n\u251c\u2500\u2500 Sources/\n\u2502   \u251c\u2500\u2500 Protocols/\n\u2502   \u2502   \u251c\u2500\u2500 CryptoServiceProtocol.swift\n\u2502   \u2502   \u251c\u2500\u2500 KeyManagementProtocol.swift\n\u2502   \u2502   \u2514\u2500\u2500 SecurityProviderProtocol.swift\n\u2502   \u251c\u2500\u2500 Types/\n\u2502   \u2502   \u251c\u2500\u2500 SecurityOperation.swift\n\u2502   \u2502   \u2514\u2500\u2500 SecurityErrors.swift\n\u2502   \u2514\u2500\u2500 DTOs/\n\u2502       \u251c\u2500\u2500 SecurityConfigDTO.swift\n\u2502       \u2514\u2500\u2500 SecurityResultDTO.swift\n\u2514\u2500\u2500 Tests/\n    \u2514\u2500\u2500 [unit tests]\n</code></pre> <p>Key characteristics: - Depends only on UmbraCoreTypes - Zero Foundation imports - Protocol-based design - Clear, focused interfaces</p>"},{"location":"UmbraCore_Refactoring_Plan/#23-securitybridge","title":"2.3 SecurityBridge","text":"<p>This module bridges between Foundation types and domain-specific types:</p> <pre><code>SecurityBridge/\n\u251c\u2500\u2500 BUILD.bazel\n\u251c\u2500\u2500 Sources/\n\u2502   \u251c\u2500\u2500 Adapters/\n\u2502   \u2502   \u251c\u2500\u2500 DataAdapter.swift            # SecureBytes &lt;-&gt; Data conversion\n\u2502   \u2502   \u251c\u2500\u2500 URLAdapter.swift             # ResourceLocator &lt;-&gt; URL conversion\n\u2502   \u2502   \u2514\u2500\u2500 DateAdapter.swift            # TimePoint &lt;-&gt; Date conversion\n\u2502   \u251c\u2500\u2500 ProtocolAdapters/\n\u2502   \u2502   \u251c\u2500\u2500 CryptoServiceAdapter.swift   # Adapts Foundation implementation to core protocol\n\u2502   \u2502   \u2514\u2500\u2500 KeyManagementAdapter.swift   # Adapts Foundation implementation to core protocol\n\u2502   \u2514\u2500\u2500 XPCBridge/\n\u2502       \u251c\u2500\u2500 XPCServiceAdapter.swift      # Adapts XPC protocols for Foundation\n\u2502       \u2514\u2500\u2500 FoundationConversions.swift  # Utility conversions\n\u2514\u2500\u2500 Tests/\n    \u2514\u2500\u2500 [unit tests]\n</code></pre> <p>Key characteristics: - Only module with both Foundation and Core imports - Clear boundary between type systems - Comprehensive conversion utilities - Adapter pattern implementation</p>"},{"location":"UmbraCore_Refactoring_Plan/#24-implementation-modules","title":"2.4 Implementation Modules","text":"<p>Concrete implementations are divided by their Foundation dependency:</p> <pre><code>SecurityImplementation/                  # Foundation-free implementation\n\u251c\u2500\u2500 BUILD.bazel\n\u251c\u2500\u2500 Sources/\n\u2502   \u251c\u2500\u2500 Services/\n\u2502   \u2502   \u251c\u2500\u2500 CryptoServiceImpl.swift      # Implementation using only core types\n\u2502   \u2502   \u2514\u2500\u2500 KeyManagementImpl.swift      # Implementation using only core types\n\u2502   \u251c\u2500\u2500 Utilities/\n\u2502   \u2502   \u2514\u2500\u2500 SecurityHelpers.swift        # Utility functions\n\u2502   \u2514\u2500\u2500 Factory/\n\u2502       \u2514\u2500\u2500 SecurityFactory.swift        # Creates service instances\n\u2514\u2500\u2500 Tests/\n    \u2514\u2500\u2500 [unit tests]\n\nSecurityImplementationFoundation/        # Foundation-dependent implementation\n\u251c\u2500\u2500 BUILD.bazel\n\u251c\u2500\u2500 Sources/\n\u2502   \u251c\u2500\u2500 Services/\n\u2502   \u2502   \u251c\u2500\u2500 CryptoKitService.swift       # Implementation using CryptoKit/Foundation\n\u2502   \u2502   \u2514\u2500\u2500 KeychainService.swift        # Implementation using Keychain/Foundation\n\u2502   \u251c\u2500\u2500 Extensions/\n\u2502   \u2502   \u2514\u2500\u2500 FoundationExtensions.swift   # Extensions on Foundation types\n\u2502   \u2514\u2500\u2500 Factory/\n\u2502       \u2514\u2500\u2500 FoundationSecurityFactory.swift  # Creates Foundation-based services\n\u2514\u2500\u2500 Tests/\n    \u2514\u2500\u2500 [unit tests]\n</code></pre> <p>Key characteristics: - Clear separation of Foundation and non-Foundation implementations - Dependency injection design pattern - Factory-based instantiation - Comprehensive unit tests</p>"},{"location":"UmbraCore_Refactoring_Plan/#3-module-dependencies","title":"3. Module Dependencies","text":"<p>The dependency relationships between modules follow a strict pattern to eliminate circular dependencies:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  UmbraCoreTypes  \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                             \u2502\n         \u25b2                                       \u2502\n         \u2502                                       \u2502\n         \u2502                                       \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 SecurityProtocols\u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502    XPCProtocols  \u2502\n\u2502      Core        \u2502                    \u2502       Core       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u25b2                                       \u25b2\n         \u2502                                       \u2502\n         \u2502                                       \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502    Security      \u2502                    \u2502       XPC        \u2502\n\u2502  Implementation  \u2502                    \u2502  Implementation   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u25b2                                       \u25b2\n         \u2502                                       \u2502\n         \u2502                                       \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 SecurityBridge   \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502    XPCBridge     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u25b2                                       \u25b2\n         \u2502                                       \u2502\n         \u2502                                       \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 SecurityImplFdn  \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502  XPCImplFdn      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"UmbraCore_Refactoring_Plan/#4-foundation-dependency-boundary","title":"4. Foundation Dependency Boundary","text":"<p>A critical aspect of this architecture is the clear boundary between Foundation-dependent and Foundation-free code:</p> <pre><code>                        \u2502             \u2502\n Foundation-Free        \u2502  BOUNDARY   \u2502  Foundation-Dependent\n                        \u2502             \u2502\n                        V             V\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 UmbraCoreTypes     \u2502  \u2502  \u2502                            \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  \u2502  \u2502                            \u2502\n\u2502 ProtocolsCore      \u2502  \u2502  \u2502       Bridge Modules       \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  \u2502  \u2502                            \u2502\n\u2502 Implementation     \u2502  \u2502  \u2502                            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                        \u2502             \u2502\n                        \u2502             V\n                        \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                        \u2502  \u2502 Implementation             \u2502\n                        \u2502  \u2502 Foundation                 \u2502\n                        \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"UmbraCore_Refactoring_Plan/#5-module-naming-conventions","title":"5. Module Naming Conventions","text":"<p>For consistency across the project, we adopt these naming conventions:</p> Module Type Naming Pattern Example Core Types UmbraCoreTypes UmbraCoreTypes Protocol Definitions [Domain]ProtocolsCore SecurityProtocolsCore Foundation Bridge [Domain]Bridge SecurityBridge Foundation-Free Implementation [Domain]Implementation SecurityImplementation Foundation-Dependent Implementation [Domain]ImplementationFoundation SecurityImplementationFoundation"},{"location":"UmbraCore_Refactoring_Plan/#6-implementation-guidelines","title":"6. Implementation Guidelines","text":"<p>When implementing code within these modules, follow these guidelines:</p>"},{"location":"UmbraCore_Refactoring_Plan/#61-umbracoretypes","title":"6.1 UmbraCoreTypes","text":"<ul> <li>Use only Swift standard library types</li> <li>Ensure all types conform to <code>Sendable</code></li> <li>Implement value semantics (struct-based design)</li> <li>Provide comprehensive initializers and conversion methods</li> <li>Include clear documentation and examples</li> </ul>"},{"location":"UmbraCore_Refactoring_Plan/#62-protocol-modules","title":"6.2 Protocol Modules","text":"<ul> <li>Define protocols using only UmbraCoreTypes and Swift standard library</li> <li>Keep protocols focused and cohesive</li> <li>Use Swift concurrency patterns (async/await)</li> <li>Define clear error types</li> <li>Include documentation comments</li> </ul>"},{"location":"UmbraCore_Refactoring_Plan/#63-bridge-modules","title":"6.3 Bridge Modules","text":"<ul> <li>Provide bidirectional conversion between type systems</li> <li>Implement the Adapter pattern</li> <li>Handle all edge cases and error conditions</li> <li>Document conversion limitations</li> <li>Implement type erasure where needed</li> </ul>"},{"location":"UmbraCore_Refactoring_Plan/#64-implementation-modules","title":"6.4 Implementation Modules","text":"<ul> <li>Implement protocols from core modules</li> <li>Use dependency injection for extensibility</li> <li>Provide factory methods for object creation</li> <li>Implement comprehensive error handling</li> <li>Include detailed logging</li> </ul>"},{"location":"UmbraCore_Refactoring_Plan/#7-interaction-flows","title":"7. Interaction Flows","text":"<p>This section illustrates how common operations flow through this module structure:</p>"},{"location":"UmbraCore_Refactoring_Plan/#71-data-encryption-flow","title":"7.1 Data Encryption Flow","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Client Code \u2502\u2500\u2500\u2500\u25ba\u2502 CryptoProtocol \u2502\u2500\u2500\u2500\u25ba\u2502 CryptoService   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2502 Implementation  \u2502\n                                         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                                  \u2502\n                   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510             \u2502\n                   \u2502 SecureBytes    \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>For Foundation interoperability:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Client with \u2502\u2500\u2500\u2500\u25ba\u2502 SecurityBridge \u2502\u2500\u2500\u2500\u25ba\u2502 Data            \u2502\n\u2502 SecureBytes \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"UmbraCore_Refactoring_Plan/#72-xpc-service-call-flow","title":"7.2 XPC Service Call Flow","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Client Code \u2502\u2500\u2500\u2500\u25ba\u2502 XPCProtocolCore\u2502\u2500\u2500\u2500\u25ba\u2502 XPCService      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2502 Implementation  \u2502\n                                         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                                  \u2502\n                   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510             \u2502\n                   \u2502 Bridge Module  \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                           \u2502\n                           \u25bc\n                   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                   \u2502 Foundation API \u2502\n                   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"UmbraCore_Refactoring_Plan/#8-example-implementation","title":"8. Example Implementation","text":"<p>Below is an example of how a protocol would be defined in the new structure:</p> <p>Before (SecurityInterfaces with Foundation dependency):</p> <pre><code>import Foundation\n\npublic protocol CryptoServiceProtocol {\n    func encrypt(_ data: Data, key: Data) throws -&gt; Data\n    func decrypt(_ data: Data, key: Data) throws -&gt; Data\n    func generateKey(size: Int) -&gt; Data\n}\n</code></pre> <p>After (SecurityProtocolsCore with no Foundation):</p> <pre><code>import UmbraCoreTypes\n\npublic protocol CryptoServiceProtocol {\n    func encrypt(_ data: SecureBytes, key: SecureBytes) throws -&gt; SecureBytes\n    func decrypt(_ data: SecureBytes, key: SecureBytes) throws -&gt; SecureBytes\n    func generateKey(size: Int) -&gt; SecureBytes\n}\n</code></pre> <p>Bridge Implementation:</p> <pre><code>import Foundation\nimport UmbraCoreTypes\nimport SecurityProtocolsCore\n\npublic class CryptoServiceBridge: CryptoServiceProtocol {\n    private let foundationService: FoundationCryptoService\n\n    public init(foundationService: FoundationCryptoService) {\n        self.foundationService = foundationService\n    }\n\n    public func encrypt(_ data: SecureBytes, key: SecureBytes) throws -&gt; SecureBytes {\n        let foundationData = Data(secureBytes: data)\n        let foundationKey = Data(secureBytes: key)\n        let result = try foundationService.encrypt(foundationData, key: foundationKey)\n        return SecureBytes(data: result)\n    }\n\n    // Other methods follow similar pattern\n}\n</code></pre> <p>This example demonstrates how the architecture cleanly separates Foundation dependencies while maintaining type safety and clear interfaces.</p>"},{"location":"UmbraCore_Refactoring_Plan/#build-system-integration","title":"Build System Integration","text":""},{"location":"UmbraCore_Refactoring_Plan/#custom-starlark-rules","title":"Custom Starlark Rules","text":"<p>These rules enforce architectural boundaries and validate module dependencies:</p>"},{"location":"UmbraCore_Refactoring_Plan/#foundation-free-module-rule","title":"Foundation-Free Module Rule","text":"<pre><code># In //:bazel/macros/swift.bzl\ndef foundation_free_swift_library(name, srcs, deps = [], **kwargs):\n    \"\"\"\n    A swift_library that enforces no Foundation dependencies.\n    \"\"\"\n    # Validation aspects\n    _validate_no_foundation_imports(name = name + \"_validation\", srcs = srcs)\n\n    # Standard swift_library with constraints\n    swift_library(\n        name = name,\n        srcs = srcs,\n        deps = deps,\n        copts = [\n            \"-strict-concurrency=complete\",\n            \"-warn-concurrency\",\n            \"-enable-actor-data-race-checks\",\n        ] + kwargs.get(\"copts\", []),\n        **{k: v for k, v in kwargs.items() if k != \"copts\"}\n    )\n</code></pre>"},{"location":"UmbraCore_Refactoring_Plan/#layer-aware-module-rule","title":"Layer-Aware Module Rule","text":"<pre><code>def umbra_module(name, layer, srcs, deps = [], **kwargs):\n    \"\"\"\n    Defines a module with explicit layer membership that enforces\n    architectural boundaries.\n    \"\"\"\n    if layer not in _MODULE_LAYERS:\n        fail(\"Unknown layer: %s\" % layer)\n\n    # Validate dependencies against layer rules\n    for dep in deps:\n        if dep.startswith(\"//Sources/\"):\n            module_name = dep.split(\"/\")[-1].split(\":\")[0]\n            dep_layer = _get_module_layer(module_name)\n\n            if dep_layer in _MODULE_LAYERS[layer][\"forbidden_deps\"]:\n                fail(\"Module %s (%s) cannot depend on %s (%s)\" % (\n                    name, layer, module_name, dep_layer\n                ))\n\n    # Select appropriate library rule\n    if layer == \"core\":\n        foundation_free_swift_library(name = name, srcs = srcs, deps = deps, **kwargs)\n    elif layer == \"foundation_bridge\":\n        foundation_bridge_swift_library(name = name, srcs = srcs, deps = deps, **kwargs)\n    else:\n        swift_library(name = name, srcs = srcs, deps = deps, **kwargs)\n</code></pre>"},{"location":"UmbraCore_Refactoring_Plan/#validation-and-enforcement","title":"Validation and Enforcement","text":"<p>Build-time validation to ensure compliance:</p> <ol> <li>Dependency Validation: Ensures modules only depend on appropriate layers</li> <li>Import Validation: Scans source files for forbidden imports</li> <li>Type Usage Validation: Validates no Foundation types are used in core modules</li> <li>XPC Interface Validation: Ensures XPC interfaces follow proper patterns</li> </ol> <p>For detailed lessons learned from our Bazelisk implementation on macOS 15.4 with arm64 architecture, including AES-GCM IV size standardization and architecture-specific configuration, see the Bazelisk and Build System Integration Lessons section.</p>"},{"location":"UmbraCore_Refactoring_Plan/#code-examples","title":"Code Examples","text":""},{"location":"UmbraCore_Refactoring_Plan/#domain-specific-types","title":"Domain-Specific Types","text":"<pre><code>// Sources/UmbraCoreTypes/SecureBytes.swift\n// NO import Foundation!\n\npublic struct SecureBytes: Hashable, Sendable {\n    private let bytes: [UInt8]\n\n    public init(_ bytes: [UInt8]) {\n        self.bytes = bytes\n    }\n\n    public var isEmpty: Bool { bytes.isEmpty }\n    public var count: Int { bytes.count }\n\n    public func subdata(in range: Range&lt;Int&gt;) -&gt; SecureBytes {\n        SecureBytes(Array(bytes[range]))\n    }\n\n    // Method to securely clear contents when no longer needed\n    public func secureClear() -&gt; SecureBytes {\n        var mutableBytes = Array(bytes)\n        for i in 0..&lt;mutableBytes.count {\n            mutableBytes[i] = 0\n        }\n        return SecureBytes([])\n    }\n}\n</code></pre>"},{"location":"UmbraCore_Refactoring_Plan/#foundation-free-protocol","title":"Foundation-Free Protocol","text":"<pre><code>// Sources/SecurityProtocolsCore/SecurityProvider.swift\n// NO import Foundation!\nimport UmbraCoreTypes\n\npublic protocol SecurityProvider: Sendable {\n    func encrypt(_ content: SecureBytes, using key: EncryptionKey) async throws -&gt; SecureBytes\n    func decrypt(_ content: SecureBytes, using key: EncryptionKey) async throws -&gt; SecureBytes\n    func generateKey() async throws -&gt; EncryptionKey\n}\n</code></pre>"},{"location":"UmbraCore_Refactoring_Plan/#bridge-implementation","title":"Bridge Implementation","text":"<pre><code>// Sources/FoundationBridge/SecureBytesBridge.swift\nimport Foundation\nimport UmbraCoreTypes\n\npublic extension SecureBytes {\n    init(_ data: Foundation.Data) {\n        self.init([UInt8](data))\n    }\n\n    func asData() -&gt; Foundation.Data {\n        return Foundation.Data(self.bytes)\n    }\n}\n\npublic extension Foundation.Data {\n    func asSecureBytes() -&gt; SecureBytes {\n        return SecureBytes([UInt8](self))\n    }\n}\n</code></pre>"},{"location":"UmbraCore_Refactoring_Plan/#xpc-protocol-with-sendable","title":"XPC Protocol with @Sendable","text":"<pre><code>// Sources/XPCProtocolsBridge/XPCCryptoServiceProtocol.swift\nimport Foundation\n\n@objc public protocol XPCCryptoServiceProtocol: NSObjectProtocol {\n    @objc func encryptData(_ data: NSData, \n                        withReply reply: @escaping @Sendable (NSData?, NSError?) -&gt; Void)\n\n    @objc func decryptData(_ data: NSData, \n                        withReply reply: @escaping @Sendable (NSData?, NSError?) -&gt; Void)\n\n    @objc func generateKey(withReply reply: @escaping @Sendable (NSData?, NSError?) -&gt; Void)\n}\n</code></pre>"},{"location":"UmbraCore_Refactoring_Plan/#implementation-workflow","title":"Implementation Workflow","text":""},{"location":"UmbraCore_Refactoring_Plan/#branching-strategy","title":"Branching Strategy","text":"<p>To facilitate our refactoring effort while minimizing risk and ensuring proper testing, we will implement a structured branching strategy:</p>"},{"location":"UmbraCore_Refactoring_Plan/#1-long-running-integration-branch","title":"1. Long-running Integration Branch","text":"<p>We will create a long-running integration branch called <code>umbracore-alpha</code> from <code>main</code>:</p> <pre><code>git checkout main\ngit checkout -b umbracore-alpha\n</code></pre> <p>This branch serves as: - An integration branch for all refactoring changes - A safe testing ground without affecting production code - A complete implementation of the new architecture before merging to main</p>"},{"location":"UmbraCore_Refactoring_Plan/#2-feature-branches-for-each-module","title":"2. Feature Branches for Each Module","text":"<p>For each module identified in our consolidation strategy, we will create focused feature branches from <code>umbracore-alpha</code>:</p> <pre><code>git checkout umbracore-alpha\ngit checkout -b feature/UmbraCoreTypes\ngit checkout umbracore-alpha\ngit checkout -b feature/SecurityProtocolsCore\ngit checkout umbracore-alpha\ngit checkout -b feature/SecurityBridge\n# And so on for each module\n</code></pre> <p>The primary feature branches will include: - <code>feature/UmbraCoreTypes</code> - Foundation-free domain types - <code>feature/SecurityProtocolsCore</code> - Core security protocols - <code>feature/SecurityBridge</code> - Foundation bridging layer - <code>feature/SecurityImplementation</code> - Foundation-free implementation - <code>feature/SecurityImplementationFoundation</code> - Foundation-dependent implementation - <code>feature/XPCProtocolsCore</code> - XPC protocol definitions</p>"},{"location":"UmbraCore_Refactoring_Plan/#3-integration-process","title":"3. Integration Process","text":"<p>Our workflow for integrating changes follows these steps:</p> <ol> <li>Develop in Feature Branch</li> <li>Complete implementation of a specific module</li> <li>Add unit tests and documentation</li> <li> <p>Ensure code compiles and tests pass</p> </li> <li> <p>Create Pull Request to umbracore-alpha</p> </li> <li>Submit PR for code review</li> <li>Address review feedback</li> <li> <p>Verify that integration tests still pass</p> </li> <li> <p>Merge to Integration Branch</p> </li> <li>Once approved, merge feature branch to <code>umbracore-alpha</code></li> <li>Run integration tests on <code>umbracore-alpha</code></li> <li> <p>Verify no regressions occur</p> </li> <li> <p>Update Dependent Feature Branches</p> </li> <li> <p>For in-progress feature branches that depend on the merged changes:    <pre><code>git checkout feature/DependentFeature\ngit fetch origin\ngit merge origin/umbracore-alpha\n# Resolve any conflicts\ngit push origin feature/DependentFeature\n</code></pre></p> </li> <li> <p>Repeat Process</p> </li> <li>Continue with remaining feature branches</li> <li>Follow priority order from our refactoring matrix</li> </ol>"},{"location":"UmbraCore_Refactoring_Plan/#4-final-integration-to-main","title":"4. Final Integration to Main","text":"<p>Once all modules have been merged and thoroughly tested in <code>umbracore-alpha</code>:</p> <ol> <li>Complete Integration Testing</li> <li>Run comprehensive test suite on <code>umbracore-alpha</code></li> <li>Verify all functionality across the system</li> <li> <p>Perform performance benchmarking</p> </li> <li> <p>Create Final PR</p> </li> <li>Create a PR to merge <code>umbracore-alpha</code> into <code>main</code></li> <li> <p>Request thorough review of the complete architecture</p> </li> <li> <p>Deploy to Production</p> </li> <li>Once approved, merge to <code>main</code></li> <li>Tag with appropriate version</li> <li>Deploy through normal CI/CD process</li> </ol>"},{"location":"UmbraCore_Refactoring_Plan/#migration-strategy-for-existing-code","title":"Migration Strategy for Existing Code","text":"<p>When refactoring existing functionality, follow these guidelines:</p> <ol> <li>Parallel Implementation</li> <li>Begin by implementing the new structure alongside existing code</li> <li> <p>Don't remove old code until the new implementation is proven</p> </li> <li> <p>Feature Flagging</p> </li> <li>Use feature flags to toggle between old and new implementations</li> <li> <p>This enables gradual migration and easy rollback if needed</p> </li> <li> <p>Incremental Migration</p> </li> <li>Move functionality one module at a time</li> <li>Maintain backward compatibility where possible</li> <li> <p>Update clients to use new APIs incrementally</p> </li> <li> <p>Comprehensive Testing</p> </li> <li>Write tests that verify equivalent functionality between old and new implementations</li> <li>Test both implementations with the same input data</li> <li>Verify outputs match or any differences are expected and documented</li> </ol>"},{"location":"UmbraCore_Refactoring_Plan/#commit-guidelines","title":"Commit Guidelines","text":"<p>For all work within this refactoring project, adhere to these commit guidelines:</p> <ol> <li>Atomic Commits</li> <li>Each commit should represent a single logical change</li> <li>Group related changes within a single commit</li> <li> <p>Keep unrelated changes in separate commits</p> </li> <li> <p>Descriptive Commit Messages</p> </li> <li>Format: <code>[Module] Brief description of change</code></li> <li>Example: <code>[UmbraCoreTypes] Implement SecureBytes with Sendable conformance</code></li> <li> <p>Include detailed description in commit body when necessary</p> </li> <li> <p>Reference Plan in Commits</p> </li> <li>Link commits to the relevant section of this refactoring plan</li> <li> <p>Example: <code>Implements Section 2.1 of refactoring plan</code></p> </li> <li> <p>Code Quality</p> </li> <li>Run linters and formatters before committing</li> <li>Ensure tests pass for all commits</li> <li>Follow the style guidelines established for the project</li> </ol> <p>By following this structured branching and implementation strategy, we can manage the complexity of this large refactoring project, maintain code quality, and minimize disruption to ongoing development.</p>"},{"location":"UmbraCore_Refactoring_Plan/#design-decisions-and-rationale","title":"Design Decisions and Rationale","text":"<p>This section documents the reasoning behind key architectural decisions to aid future maintainers and developers.</p>"},{"location":"UmbraCore_Refactoring_Plan/#domain-specific-type-names","title":"Domain-Specific Type Names","text":"<p>We've chosen more specific type names to better reflect their security-focused purpose:</p> <ul> <li> <p>SecureBytes (vs. BinaryContent): This name clearly indicates the security-sensitive nature of the data and that it contains binary information requiring secure handling.</p> </li> <li> <p>ResourceLocator (vs. ResourceIdentifier): This emphasizes the purpose of locating resources rather than just identifying them, aligning better with URL's primary function.</p> </li> <li> <p>TimePoint (vs. Timestamp): This better represents a moment in time rather than just a marker, making it conceptually closer to Date's purpose.</p> </li> </ul> <p>Rationale: More precise naming helps developers understand the purpose and proper usage of these types, reduces confusion when mapping between Foundation and domain types, and makes security-sensitive operations more explicit.</p>"},{"location":"UmbraCore_Refactoring_Plan/#layered-architecture","title":"Layered Architecture","text":"<p>The decision to use a strict layered architecture with Foundation bridge modules serves multiple purposes:</p> <p>Rationale: 1. Maintainability: Clear separation makes the codebase easier to understand and maintain 2. Testability: Foundation-free core is easier to test without complex mocking 3. Evolution: Foundation and Swift evolution can be accommodated by updating only bridge modules 4. Security: Security-critical code can be isolated from Foundation dependencies 5. Performance: Foundation-dependent code can be optimized separately from core business logic</p>"},{"location":"UmbraCore_Refactoring_Plan/#type-erasure-vs-protocol-inheritance","title":"Type Erasure vs. Protocol Inheritance","text":"<p>We've chosen type erasure patterns over protocol inheritance to break dependencies:</p> <p>Rationale: 1. Avoids Circular Dependencies: Type erasure allows bridging between type systems without circular imports 2. Static Typing: Maintains Swift's static type safety while allowing flexibility 3. Performance: Compared to protocol witnesses, type erasure has better performance characteristics 4. Evolution: Easier to evolve individual components without breaking compatibility</p>"},{"location":"UmbraCore_Refactoring_Plan/#single-bridge-module-vs-multiple-adapters","title":"Single Bridge Module vs. Multiple Adapters","text":"<p>We've consolidated all bridging in a single module rather than distributed adapters:</p> <p>Rationale: 1. Centralized Maintenance: Easier to update when Foundation changes 2. Consistent Conversion: Single source of truth for type conversion 3. Dependency Control: Clear, single point of dependency on Foundation 4. Build Performance: Fewer module boundaries to cross during compilation</p>"},{"location":"UmbraCore_Refactoring_Plan/#swift-evolution-watch","title":"Swift Evolution Watch","text":"<p>We'll monitor these Swift Evolution proposals:</p> <ul> <li>SE-0302: Sendable and @Sendable closures</li> <li>SE-0336: Distributed Actor Runtime</li> </ul> <p>As Swift evolves, we'll adapt our strategy to take advantage of new capabilities that reduce or eliminate the need for @objc in XPC communication.</p>"},{"location":"UmbraCore_Refactoring_Plan/#performance-considerations","title":"Performance Considerations","text":"<p>The refactoring introduces several changes that may impact performance. This section analyzes these impacts and proposes mitigations.</p>"},{"location":"UmbraCore_Refactoring_Plan/#type-conversion-overhead","title":"Type Conversion Overhead","text":"<p>The bridge layer introduces type conversion overhead when crossing module boundaries:</p> <pre><code>// Foundation type \u2192 Domain type \u2192 Foundation type conversion\nlet originalData: Data = getData()\nlet secureBytes = SecureBytes(originalData)  // Conversion 1\nlet processedData = process(secureBytes)\nlet resultData = processedData.asData()  // Conversion 2\n</code></pre> <p>Mitigation Strategies: 1. Lazy Conversion: Convert types only when necessary 2. Bulk Operations: Batch conversions where possible 3. Compiler Optimizations: Use whole-module optimization to potentially eliminate conversions 4. Benchmarking: Establish baseline performance metrics before and after refactoring</p>"},{"location":"UmbraCore_Refactoring_Plan/#module-boundary-overhead","title":"Module Boundary Overhead","text":"<p>Additional module boundaries can affect performance:</p> <p>Mitigation Strategies: 1. Whole-Module Optimization: Enable for production builds 2. Strategic Inlining: Mark key conversion functions as @inlinable 3. Reduce Cross-Module Calls: Design APIs to minimize boundary crossings</p>"},{"location":"UmbraCore_Refactoring_Plan/#memory-usage","title":"Memory Usage","text":"<p>The refactoring may introduce additional memory usage due to type conversion:</p> <p>Mitigation Strategies: 1. Copy-on-Write Semantics: Implement for large data structures 2. Secure Memory Management: Implement secure clearing for sensitive data 3. Memory Profiling: Monitor memory usage before and after changes</p>"},{"location":"UmbraCore_Refactoring_Plan/#build-performance","title":"Build Performance","text":"<p>The new architecture may impact build times:</p> <p>Mitigation Strategies: 1. Module Size Optimization: Right-size modules for compile time 2. Dependency Graph Optimization: Minimize cross-module dependencies 3. Parallel Compilation: Ensure modules can be compiled in parallel</p>"},{"location":"UmbraCore_Refactoring_Plan/#versioning-and-compatibility","title":"Versioning and Compatibility","text":"<p>This section addresses how the refactoring impacts versioning and compatibility with dependent projects.</p>"},{"location":"UmbraCore_Refactoring_Plan/#semantic-versioning","title":"Semantic Versioning","text":"<p>The refactoring constitutes a major version change:</p> <pre><code>UmbraCore 2.0.0 \u2192 UmbraCore 3.0.0\n</code></pre> <p>Rationale: The architectural changes break backward compatibility and require client code changes.</p>"},{"location":"UmbraCore_Refactoring_Plan/#migration-path-for-dependents","title":"Migration Path for Dependents","text":"<p>For projects depending on UmbraCore:</p> <ol> <li>Compatibility Layer: Provide temporary adapters to ease migration</li> <li>Migration Guide: Document required changes for dependent code</li> <li>Deprecation Period: Support previous architecture for 6-12 months with deprecation warnings</li> </ol>"},{"location":"UmbraCore_Refactoring_Plan/#api-stability","title":"API Stability","text":"<p>Ensure API stability for the new architecture:</p> <ol> <li>API Documentation: Thorough documentation of new interfaces</li> <li>Backward Compatibility Tests: Validate against common usage patterns</li> <li>API Evolution: Plan for future evolution without breaking changes</li> </ol>"},{"location":"UmbraCore_Refactoring_Plan/#binary-compatibility","title":"Binary Compatibility","text":"<p>Address binary compatibility concerns:</p> <ol> <li>Module Stability: Use @frozen for key types where appropriate</li> <li>ABI Stability: Consider ABI implications for public interfaces</li> <li>Library Evolution: Enable library evolution mode for framework targets</li> </ol>"},{"location":"UmbraCore_Refactoring_Plan/#error-handling-strategy","title":"Error Handling Strategy","text":"<p>A consistent error handling approach is essential for the new architecture. This section outlines the error management strategy.</p>"},{"location":"UmbraCore_Refactoring_Plan/#domain-specific-error-types","title":"Domain-Specific Error Types","text":"<p>Create a hierarchy of error types without Foundation dependencies:</p> <pre><code>// Sources/UmbraCoreTypes/Errors.swift\n// NO import Foundation!\n\npublic enum SecurityError: Error, Sendable {\n    case encryptionFailed(reason: String)\n    case decryptionFailed(reason: String)\n    case keyGenerationFailed(reason: String)\n    case invalidKey\n    case dataCorrupted\n}\n\npublic enum StorageError: Error, Sendable {\n    case resourceNotFound(identifier: String)\n    case accessDenied(reason: String)\n    case storageFailure(reason: String)\n}\n\npublic enum NetworkError: Error, Sendable {\n    case connectionFailed(reason: String)\n    case requestTimedOut(afterSeconds: Int)\n    case invalidResponse(description: String)\n}\n</code></pre>"},{"location":"UmbraCore_Refactoring_Plan/#error-translation-in-bridge-layer","title":"Error Translation in Bridge Layer","text":"<p>The bridge layer will translate between domain errors and Foundation/Cocoa errors:</p> <pre><code>// Sources/FoundationBridge/ErrorBridge.swift\nimport Foundation\nimport UmbraCoreTypes\n\npublic extension SecurityError {\n    func asNSError() -&gt; NSError {\n        switch self {\n        case .encryptionFailed(let reason):\n            return NSError(domain: \"UmbraSecurityErrorDomain\", \n                           code: 1001, \n                           userInfo: [NSLocalizedDescriptionKey: \"Encryption failed: \\(reason)\"])\n        // Other cases...\n        }\n    }\n\n    static func fromNSError(_ error: NSError) -&gt; SecurityError? {\n        if error.domain == \"UmbraSecurityErrorDomain\" {\n            switch error.code {\n            case 1001:\n                return .encryptionFailed(reason: error.localizedDescription)\n            // Other cases...\n            default:\n                return nil\n            }\n        }\n        return nil\n    }\n}\n</code></pre>"},{"location":"UmbraCore_Refactoring_Plan/#error-propagation-across-module-boundaries","title":"Error Propagation Across Module Boundaries","text":"<p>Guidelines for error propagation:</p> <ol> <li>Domain Errors in Core Modules: Use only domain-specific error types</li> <li>Error Translation at Boundaries: Convert between error types only at module boundaries</li> <li>Context Preservation: Ensure error context is preserved during translation</li> <li>Async/Await Error Handling: Leverage Swift's built-in error handling with try/catch</li> </ol>"},{"location":"UmbraCore_Refactoring_Plan/#error-documentation-and-recovery","title":"Error Documentation and Recovery","text":"<p>For each error type:</p> <ol> <li>Document Causes: Clearly document what can cause each error</li> <li>Recovery Strategies: Provide recommended recovery strategies</li> <li>Error Codes: Maintain consistent error codes across versions</li> </ol>"},{"location":"UmbraCore_Refactoring_Plan/#xpc-error-handling","title":"XPC Error Handling","text":"<p>Special considerations for XPC services:</p> <ol> <li>NSError Bridging: Converting domain errors to NSError for Objective-C compatibility</li> <li>Error Serialization: Ensuring errors can be properly serialized across XPC boundaries</li> <li>Consistent Error Domains: Establishing consistent error domains for XPC services</li> </ol>"},{"location":"UmbraCore_Refactoring_Plan/#alternatives-to-objc-for-xpc-protocols","title":"Alternatives to @objc for XPC Protocols","text":"<p>While @objc is currently required for XPC protocols, we've investigated alternatives and future possibilities:</p>"},{"location":"UmbraCore_Refactoring_Plan/#current-state","title":"Current State","text":"<p>XPC services in macOS/iOS require NSXPCConnection and @objc protocols. This creates an inherent dependency on Foundation and Objective-C runtime.</p>"},{"location":"UmbraCore_Refactoring_Plan/#potential-alternatives","title":"Potential Alternatives","text":"<ol> <li>Swift-native XPC (Hypothetical)</li> <li>Not currently available but being discussed in the Swift community</li> <li> <p>Would allow pure Swift protocols without @objc requirements</p> </li> <li> <p>gRPC or Protocol Buffers</p> </li> <li>Could be used for some inter-process communication needs</li> <li>Provides strongly-typed interfaces without @objc</li> <li> <p>Not a direct replacement for XPC's security model</p> </li> <li> <p>Swift Distributed Actors</p> </li> <li>Part of Swift's distributed actors proposal</li> <li>Could potentially replace some XPC use cases in the future</li> <li>Currently experimental</li> </ol>"},{"location":"UmbraCore_Refactoring_Plan/#short-term-strategy","title":"Short-term Strategy","text":"<p>Until Swift-native XPC becomes available:</p> <ol> <li>Minimize @objc Surface Area</li> <li>Keep @objc protocols as thin as possible</li> <li>Implement minimal interfaces at the boundary</li> <li> <p>Use Swift-native protocols for all internal communication</p> </li> <li> <p>Foundation-Free Protocol Definitions</p> </li> <li>Define protocols without Foundation, then bridge to @objc implementations</li> <li>Use type erasure to break dependency cycles</li> </ol>"},{"location":"UmbraCore_Refactoring_Plan/#swift-evolution-watch_1","title":"Swift Evolution Watch","text":"<p>We'll monitor these Swift Evolution proposals:</p> <ul> <li>SE-0302: Sendable and @Sendable closures</li> <li>SE-0336: Distributed Actor Runtime</li> </ul> <p>As Swift evolves, we'll adapt our strategy to take advantage of new capabilities that reduce or eliminate the need for @objc in XPC communication.</p>"},{"location":"UmbraCore_Refactoring_Plan/#swift-library-evolution-compatibility-in-dependency-chains","title":"Swift Library Evolution Compatibility in Dependency Chains","text":"<p>During our refactoring work, we discovered critical constraints when working with Swift library evolution in module dependency chains.</p>"},{"location":"UmbraCore_Refactoring_Plan/#key-findings","title":"Key Findings","text":"<ol> <li>Dependency Chain Constraints</li> <li>All modules in a dependency chain must be compiled with consistent library evolution settings</li> <li>If any module in a chain doesn't support library evolution, none of the modules in that chain can use it</li> <li> <p>External dependencies (especially via SPM) may not be compiled with library evolution support</p> </li> <li> <p>Specific Example: CryptoSwift Dependency Chain    We encountered this issue specifically with:</p> </li> <li>CryptoSwift (SPM dependency lacking library evolution)</li> <li>CryptoSwiftFoundationIndependent (our wrapper)</li> <li>SecureBytes (depends on the wrapper)</li> <li> <p>SecurityProtocolsCore and SecurityImplementation (depend on SecureBytes)</p> </li> <li> <p>Error Signature    Attempting to force library evolution in a module that depends on a non-library-evolution module causes:    <pre><code>error: module 'CryptoSwift' was not compiled with library evolution support; \nusing it means binary compatibility for 'CryptoSwiftFoundationIndependent' can't be guaranteed\n</code></pre></p> </li> </ol>"},{"location":"UmbraCore_Refactoring_Plan/#solution-approaches","title":"Solution Approaches","text":"<ol> <li>Dependency Chain Alignment</li> <li> <p>For dependency chains that include modules without library evolution support:</p> <ul> <li>Remove <code>-Xfrontend -enable-library-evolution</code> compiler flags from all BUILD.bazel files in the chain</li> <li>Ensure consistent compilation settings across the entire dependency graph</li> <li>Make sure target triples are consistent (arm64-apple-macos15.4)</li> </ul> </li> <li> <p>Module Isolation Strategy</p> </li> <li> <p>When library evolution is required for certain modules:</p> <ul> <li>Create separate dependency chains that don't cross module boundaries</li> <li>Isolate evolution-required modules from non-supporting dependencies</li> <li>Consider using protocol boundaries and dependency injection for isolation</li> </ul> </li> <li> <p>Build System Configuration</p> </li> <li>Cannot override external SPM dependency build settings using standard MODULE.bazel configurations</li> <li>May need to consider creating custom SPM package resolution that adds library evolution support</li> <li>Always test the entire dependency chain with consistent build settings</li> </ol>"},{"location":"UmbraCore_Refactoring_Plan/#implementation-guidance","title":"Implementation Guidance","text":"<p>For UmbraCore modules, we've adopted the following practice:</p> <ol> <li>Identify Dependency Chains</li> <li>Map out complete dependency chains before setting library evolution flags</li> <li> <p>Check all external dependencies for their library evolution support status</p> </li> <li> <p>Consistent Flag Application</p> </li> <li>Either all modules in a chain have library evolution enabled, or none do</li> <li> <p>Document dependency chains and their evolution status in module metadata</p> </li> <li> <p>Testing Protocol</p> </li> <li>Test binary compatibility across module versions when library evolution is enabled</li> <li>Verify binary compatibility guarantees are maintained</li> </ol> <p>This finding has significant implications for our architecture design, particularly around module boundaries and dependency management. We must carefully consider library evolution requirements when planning module dependencies.</p>"},{"location":"UmbraCore_Refactoring_Plan/#bazelisk-and-build-system-integration-lessons","title":"Bazelisk and Build System Integration Lessons","text":"<p>During our refactoring work on the UmbraCore Security module, we uncovered several important lessons about build system integration with Bazelisk and cryptographic implementation details that impact cross-platform compatibility.</p>"},{"location":"UmbraCore_Refactoring_Plan/#1-aes-gcm-implementation-details","title":"1. AES-GCM Implementation Details","text":"<p>We discovered a critical inconsistency in the IV (Initialization Vector) size assumptions across our codebase:</p> <ul> <li>Correct IV Size for AES-GCM: 12 bytes (96 bits) is the recommended size for AES-GCM mode</li> <li>Inconsistent Assumptions: Different parts of our codebase were making different assumptions:</li> <li>CryptoWrapper correctly used 12 bytes</li> <li>KeyManagementImpl incorrectly assumed 16 bytes</li> <li>CryptoService was configured to use 128 bits (16 bytes)</li> </ul> <p>This inconsistency caused failures in key rotation operations, as combined data was being incorrectly parsed.</p>"},{"location":"UmbraCore_Refactoring_Plan/#resolution","title":"Resolution:","text":"<ol> <li>Standardized on 12-byte IVs across the entire codebase</li> <li>Updated all related documentation to clearly indicate the expected IV size</li> <li>Added explicit parameter documentation to prevent future confusion</li> <li>Modified CryptoService configuration defaults to use 96 bits instead of 128 bits</li> </ol>"},{"location":"UmbraCore_Refactoring_Plan/#2-bazelisk-environment-configuration","title":"2. Bazelisk Environment Configuration","text":"<p>Working with Bazelisk 8.1.0 on macOS 15.4 (Apple Silicon) required precise configuration:</p> <ul> <li>Architecture Specifics: </li> <li>Target triples must consistently specify arm64-apple-macos15.4</li> <li>Native arm64 build tools perform significantly better than Rosetta-translated x86_64 tools</li> <li> <p>.bazelrc modifications were necessary to ensure architecture consistency</p> </li> <li> <p>Testing Configuration:</p> </li> <li><code>bazel test --test_output=all</code> provides full test output including debug logs</li> <li>Test filters require precise formatting that matches Objective-C/Swift test naming conventions</li> <li>Cached test results may hide recent changes; use <code>--nocache_test_results</code> when needed</li> </ul>"},{"location":"UmbraCore_Refactoring_Plan/#example-bazelrc-configuration","title":"Example .bazelrc Configuration:","text":"<pre><code># Architecture-specific settings\nbuild --cpu=darwin_arm64\nbuild --apple_platform_type=macos\nbuild --macos_cpus=arm64\n\n# Swift compiler settings for Apple Silicon\nbuild:swift --swiftcopt=\"-target arm64-apple-macos15.4\"\n\n# Test caching controls\ntest --test_env=APPLE_TEST_RUNNER_DEBUG=1\n</code></pre>"},{"location":"UmbraCore_Refactoring_Plan/#3-lessons-for-cross-platform-security-implementation","title":"3. Lessons for Cross-Platform Security Implementation","text":"<p>Our refactoring efforts revealed several principles for maintaining secure, cross-platform cryptographic implementations:</p> <ol> <li>Explicit Parameterization: Never rely on defaults for cryptographic parameters; explicitly specify key sizes, IV sizes, and other critical values</li> <li>Consistent Documentation: Document expected parameter sizes and formats in all related functions</li> <li>Platform-Independent Base Layer: Ensure core cryptographic operations work identically across all supported platforms</li> <li>Thorough Test Cases: Include test cases that verify proper handling of combined data formats (IV+ciphertext)</li> <li>Defensive Parameter Checks: Add guard statements to verify parameter sizes before cryptographic operations</li> </ol>"},{"location":"UmbraCore_Refactoring_Plan/#4-build-system-integration-best-practices","title":"4. Build System Integration Best Practices","text":"<p>Based on our experiences, we've established the following best practices for build system integration:</p> <ol> <li>Consistent Toolchain: Use the same Bazelisk version across all development environments</li> <li>Architecture-Specific Configuration: Maintain separate configuration blocks for different architectures</li> <li>Compile-Time Flag Consistency: Ensure compiler flags like library evolution support are consistent across dependency chains</li> <li>Testing Workflow: Standardize on test commands that reveal all necessary information for debugging</li> <li>CI/CD Integration: Configure CI systems with the same Bazelisk version and configuration as development environments</li> </ol> <p>These lessons have been incorporated into our development workflows and will guide future security implementation work across the UmbraCore project.</p>"},{"location":"UmbraCore_Refactoring_Plan/#19-implementation-status-updated-1-march-2025","title":"19. Implementation Status (Updated 1 March 2025)","text":"<p>This section tracks the implementation progress of the refactoring plan and identifies what should be prioritised next.</p>"},{"location":"UmbraCore_Refactoring_Plan/#security-interfaces-consolidation-priority-31","title":"Security Interfaces Consolidation (Priority 3.1)","text":"<p>Completed: - \u2705 Created <code>SecurityProtocolsCore</code> with foundation-free types and protocols - \u2705 Implemented <code>SecurityBridge</code> for Foundation conversions - \u2705 Added tests for both modules to validate functionality - \u2705 Established correct dependency structure (SecurityBridge depends on SecurityProtocolsCore)</p> <p>In Progress: - \ud83d\udd04 Migrating client code to use the new modules - \ud83d\udd04 Comprehensive test coverage for all functionality</p> <p>Pending: - \u274c Remove redundant modules:   - SecurityInterfacesFoundationBase   - SecurityInterfacesFoundationBridge   - SecurityInterfacesFoundationCore   - SecurityInterfacesFoundationMinimal   - SecurityInterfacesFoundationNoFoundation</p> <p>Next Steps: 1. Complete comprehensive testing of the new modules 2. Create a migration guide for client code 3. Begin phased removal of redundant modules 4. Update all import statements across the codebase</p>"},{"location":"UmbraCore_Refactoring_Plan/#umbra-security-services-priority-32","title":"Umbra Security Services (Priority 3.2)","text":"<p>Completed: - \u2705 Initial structure for consolidated UmbraSecurity module</p> <p>In Progress: - \ud83d\udd04 Refactoring implementation to be foundation-free where possible</p> <p>Pending: - \u274c Create dedicated <code>UmbraSecurityBridge</code> for Foundation interop - \u274c Remove redundant modules:   - UmbraSecurityNoFoundation   - UmbraSecurityServicesNoFoundation   - UmbraSecurityFoundation</p> <p>Next Steps: 1. Define clear interfaces in UmbraSecurity that don't depend on Foundation 2. Create UmbraSecurityBridge module following the same pattern as SecurityBridge 3. Implement tests that validate the new structure</p>"},{"location":"UmbraCore_Refactoring_Plan/#core-services-types-priority-33","title":"Core Services Types (Priority 3.3)","text":"<p>Status: Not started</p> <p>Next Steps: 1. Analyse current usage patterns 2. Define foundation-free interfaces 3. Create CoreTypesBridge module</p>"},{"location":"UmbraCore_Refactoring_Plan/#objc-bridging-types-priority-34","title":"ObjC Bridging Types (Priority 3.4)","text":"<p>Status: Not started</p> <p>Next Steps: 1. Evaluate current implementation and identify Foundation dependencies 2. Create foundation-free base interfaces 3. Implement bridge module for Foundation interoperability</p>"},{"location":"UmbraCore_Refactoring_Plan/#cryptoswift-integration-priority-35","title":"CryptoSwift Integration (Priority 3.5)","text":"<p>Status: Not started</p> <p>Next Steps: 1. Assess current usage and dependencies 2. Define integration strategy with domain-specific types</p>"},{"location":"UmbraCore_Refactoring_Plan/#recommended-focus-areas","title":"Recommended Focus Areas","text":"<p>Based on current progress and priorities:</p> <ol> <li>High Priority:</li> <li>Complete security interfaces migration (3.1)</li> <li> <p>Begin UmbraSecurityBridge implementation (3.2)</p> </li> <li> <p>Medium Priority:</p> </li> <li>Create test plan for validating module refactoring</li> <li> <p>Document migration patterns for client code</p> </li> <li> <p>Low Priority:</p> </li> <li>Start planning for Core Services Types refactoring (3.3)</li> <li>Update build system to better support the new architecture</li> </ol>"},{"location":"UmbraCore_Refactoring_Plan/#build-and-test-status","title":"Build and Test Status","text":"<p>Current build status with new modules: - Security modules building successfully with correct target triple (arm64-apple-macos15.4) - All tests passing for SecurityProtocolsCore and SecurityBridge - Library evolution disabled on SecurityProtocolsCore for compatibility with CryptoSwift</p>"},{"location":"UmbraCore_Refactoring_Plan/#timeline-update","title":"Timeline Update","text":"<ul> <li>March 2025: Complete Security Interfaces consolidation</li> <li>April 2025: Complete Umbra Security Services consolidation</li> <li>May 2025: Address Core Services Types and ObjC Bridging Types</li> <li>June 2025: Complete CryptoSwift integration and final cleanup</li> </ul>"},{"location":"XPCMigrationChecklist/","title":"UmbraCore XPC Protocol Migration Checklist","text":""},{"location":"XPCMigrationChecklist/#code-standardisation","title":"Code Standardisation","text":"<ul> <li>[x] Fix spacing in Core module files</li> <li>[x] KeyManager.swift</li> <li>[x] XPCServiceProtocol.swift</li> <li>[x] XPCServiceProtocolAlias.swift</li> <li>[x] Fix spacing in SecurityBridge module files</li> <li>[x] SecurityBridgeErrorMapper.swift</li> <li>[x] SecurityProviderProtocolAdapter.swift</li> <li>[x] Fix spacing in SecurityInterfaces files</li> <li>[x] XPCProtocolsMigration.swift</li> </ul>"},{"location":"XPCMigrationChecklist/#error-handling-updates","title":"Error Handling Updates","text":"<ul> <li>[x] Update to CoreErrors</li> <li>[x] Standardise on Result pattern <li>[x] Remove deprecated local error types</li>"},{"location":"XPCMigrationChecklist/#type-safety-improvements","title":"Type Safety Improvements","text":"<ul> <li>[x] Use proper typealias references</li> <li>[x] Ensure protocol inheritance follows the three-tier hierarchy</li> <li>[x] Fix parameter and return type declarations</li> </ul>"},{"location":"XPCMigrationChecklist/#documentation","title":"Documentation","text":"<ul> <li>[x] Create migration guide (XPCProtocolMigration.md)</li> <li>[ ] Update README.md with migration status</li> <li>[ ] Add inline documentation to key protocol files</li> </ul>"},{"location":"XPCMigrationChecklist/#testing","title":"Testing","text":"<ul> <li>[ ] Verify all typealias references resolve correctly</li> <li>[ ] Fix build errors in dependencies</li> <li>[ ] Run unit tests for Core module</li> <li>[ ] Run integration tests for XPC communication</li> </ul>"},{"location":"XPCMigrationChecklist/#swift-6-preparation","title":"Swift 6 Preparation","text":"<ul> <li>[x] Remove deprecated syntax</li> <li>[x] Use modern Result type</li> <li>[x] Ensure Sendable conformance on protocol types</li> </ul>"},{"location":"XPCMigrationChecklist/#final-review","title":"Final Review","text":"<ul> <li>[ ] Audit for any remaining spacing issues</li> <li>[ ] Ensure consistent import order</li> <li>[ ] Check for any remaining deprecated APIs</li> <li>[ ] Verify no circular dependencies exist</li> </ul>"},{"location":"XPCProtocolMigration/","title":"UmbraCore XPC Protocol Migration Guide","text":""},{"location":"XPCProtocolMigration/#overview","title":"Overview","text":"<p>This document outlines the migration of UmbraCore's XPC protocol architecture to a standardised three-tier system. The migration ensures better type safety, improved error handling, and prepares the codebase for Swift 6 compatibility.</p>"},{"location":"XPCProtocolMigration/#protocol-hierarchy","title":"Protocol Hierarchy","text":"<p>The XPC protocol architecture now follows a three-tier hierarchy:</p> <ol> <li>Basic Protocol (<code>XPCServiceProtocolBasic</code>)</li> <li>Core functionality required by all XPC services</li> <li>Foundation-free implementation</li> <li> <p>Minimal public API surface</p> </li> <li> <p>Standard Protocol (<code>XPCServiceProtocolStandard</code>)</p> </li> <li>Inherits from Basic</li> <li>Adds common security and cryptographic operations</li> <li> <p>Default implementation for most services</p> </li> <li> <p>Complete Protocol (<code>XPCServiceProtocolComplete</code>)</p> </li> <li>Inherits from Standard</li> <li>Adds advanced functionality for specific use cases</li> <li>Full-featured implementation</li> </ol>"},{"location":"XPCProtocolMigration/#error-handling","title":"Error Handling","text":"<p>All XPC protocols now use the <code>Result&lt;Value, XPCSecurityError&gt;</code> pattern for error handling:</p> <pre><code>func operation() async -&gt; Result&lt;ReturnType, XPCSecurityError&gt;\n</code></pre>"},{"location":"XPCProtocolMigration/#benefits","title":"Benefits:","text":"<ul> <li>Type-safe error handling</li> <li>Clear error propagation</li> <li>Consistent error reporting across module boundaries</li> </ul>"},{"location":"XPCProtocolMigration/#type-aliases","title":"Type Aliases","text":"<p>For backward compatibility and clarity, we provide type aliases:</p> <pre><code>// Core module\npublic typealias XPCServiceProtocol = XPCProtocolsCore.XPCServiceProtocolStandard\npublic typealias XPCServiceProtocolBase = XPCProtocolsCore.XPCServiceProtocolBasic\npublic typealias XPCServiceProtocolComplete = XPCProtocolsCore.XPCServiceProtocolComplete\npublic typealias XPCSecurityError = UmbraCoreTypes.CoreErrors.SecurityError\n</code></pre>"},{"location":"XPCProtocolMigration/#migration-strategy","title":"Migration Strategy","text":"<p>When migrating existing code:</p> <ol> <li>Replace direct protocol implementations with the appropriate tier</li> <li>Update error handling to use Result <li>Use type aliases for backward compatibility</li> <li>Add CoreErrors import where needed</li> <li>Ensure proper spacing in assignments (x = y instead of x=y)</li>"},{"location":"XPCProtocolMigration/#deprecation-warnings","title":"Deprecation Warnings","text":"<p>Legacy protocol implementations are marked with deprecation warnings:</p> <pre><code>@available(\n  *,\n  deprecated,\n  message: \"Use XPCServiceProtocol instead which points to XPCProtocolsCore.XPCServiceProtocolStandard\"\n)\npublic typealias LegacyXPCServiceProtocol = XPCServiceProtocol\n</code></pre> <p>Follow deprecation guidance to ensure future compatibility.</p>"},{"location":"architecture_and_style_guide/","title":"UmbraCore Architecture and Style Guide","text":""},{"location":"architecture_and_style_guide/#core-principles","title":"Core Principles","text":"<p>Our architecture and coding practices aim to support:</p> <ol> <li>Scalability: As our codebase grows to potentially millions of lines</li> <li>Modularity: Supporting multiple apps built on our shared foundations</li> <li>Readability: Code should be self-documenting and consistent</li> <li>Maintainability: Easy to understand, modify, and extend</li> <li>Testability: Code designed with testing in mind from the start</li> </ol>"},{"location":"architecture_and_style_guide/#module-organization","title":"Module Organization","text":""},{"location":"architecture_and_style_guide/#naming-conventions","title":"Naming Conventions","text":"<ul> <li>Module names: CamelCase, descriptive, and focused on functionality (e.g., <code>SecurityInterfaces</code>, not <code>SecurityStuff</code>)</li> <li>Clear boundaries: Each module should have a single, well-defined responsibility</li> <li>Consistent depth: Avoid deep nesting of modules; aim for a flat hierarchy with clear dependencies</li> </ul>"},{"location":"architecture_and_style_guide/#dependency-structure","title":"Dependency Structure","text":"<ul> <li>Diamond dependency problem: Avoid multiple dependency paths to the same module</li> <li>Explicit dependencies: All dependencies must be explicitly declared in BUILD files</li> <li>Layered architecture: Maintain strict layering with unidirectional dependencies:   <pre><code>Foundation Layer \u2192 Protocol Layer \u2192 Implementation Layer \u2192 Service Layer \u2192 Application Layer\n</code></pre></li> <li>No circular dependencies: Absolutely no circular dependencies between modules</li> </ul>"},{"location":"architecture_and_style_guide/#module-types","title":"Module Types","text":"<ol> <li>Foundation modules: Minimal, stable modules with few dependencies</li> <li>Protocol modules: Define interfaces without implementations</li> <li>Implementation modules: Concrete implementations of protocols</li> <li>Service modules: Business logic that coordinates implementations</li> <li>Application modules: End-user facing functionality</li> </ol>"},{"location":"architecture_and_style_guide/#code-style-based-on-google-swift-style-guide","title":"Code Style (Based on Google Swift Style Guide)","text":""},{"location":"architecture_and_style_guide/#file-organization","title":"File Organization","text":"<ul> <li>File length: Generally &lt; 1000 lines, split logically if longer</li> <li>Type length: Generally &lt; 400 lines, split into extensions if longer</li> <li>Function length: Generally &lt; 40 lines</li> <li>Standard header: All files begin with copyright notice and import statements</li> <li>Import organization: Alphabetical order, Foundation and system imports first</li> </ul>"},{"location":"architecture_and_style_guide/#naming","title":"Naming","text":"<ul> <li>Types: UpperCamelCase for classes, structs, enums, protocols, typealiases</li> <li>Variables/Constants: lowerCamelCase</li> <li>Functions: lowerCamelCase, verb phrases describing actions</li> <li>Acronyms: Treat acronyms as words (e.g., <code>urlString</code> not <code>URLString</code>)</li> <li>Clear naming: Names should be self-explanatory without needing comments</li> </ul>"},{"location":"architecture_and_style_guide/#documentation","title":"Documentation","text":"<ul> <li>Module documentation: Every module has a README.md explaining purpose and usage</li> <li>Public APIs: All public methods/properties have documentation comments</li> <li>Documentation format: Use Swift's standard documentation format:   <pre><code>/// Returns the numeric value at the specified index.\n///\n/// - Parameter index: The index of the value to return.\n/// - Returns: The numeric value at the specified index.\n/// - Throws: `CollectionError.outOfBounds` if the index is invalid.\nfunc value(at index: Int) throws -&gt; Double\n</code></pre></li> </ul>"},{"location":"architecture_and_style_guide/#swift-features","title":"Swift Features","text":"<ul> <li>Access control: Be explicit about access control (<code>public</code>, <code>internal</code>, <code>private</code>)</li> <li>Value types: Prefer structs over classes when appropriate</li> <li>Protocol-oriented: Use protocols to define behavior contracts</li> <li>Extensions: Use extensions to organize code by functionality</li> <li>Error handling: Use Swift's <code>throw</code>/<code>catch</code> system, not optionals, for error cases</li> <li>Concurrency: Use modern Swift concurrency (async/await) where possible</li> </ul>"},{"location":"architecture_and_style_guide/#bazel-build-practices","title":"Bazel Build Practices","text":""},{"location":"architecture_and_style_guide/#build-file-organization","title":"BUILD File Organization","text":"<ul> <li>Target naming: Clear, consistent naming for targets</li> <li>Dependency specification: Explicit, minimized dependencies</li> <li>Visibility: Restrict visibility appropriately</li> <li>Clean structure:   <pre><code>load(\"//:bazel/macros/swift.bzl\", \"umbra_swift_library\")\n\numbra_swift_library(\n    name = \"ModuleName\",\n    srcs = glob([\"*.swift\"]),\n    deps = [\n        \"//Sources/DependencyOne\",\n        \"//Sources/DependencyTwo\",\n    ],\n    visibility = [\"//visibility:public\"],\n)\n</code></pre></li> </ul>"},{"location":"architecture_and_style_guide/#target-triple-consistency","title":"Target Triple Consistency","text":"<ul> <li>All Swift targets must use <code>arm64-apple-macos14.0</code> consistently</li> <li>Set at the target level, not globally</li> </ul>"},{"location":"architecture_and_style_guide/#multi-app-architecture","title":"Multi-App Architecture","text":""},{"location":"architecture_and_style_guide/#shared-core","title":"Shared Core","text":"<ul> <li>Core modules: Maximum reuse across apps</li> <li>Clean interfaces: App-facing interfaces must be stable and well-documented</li> <li>Versioning: Clear versioning of shared components</li> </ul>"},{"location":"architecture_and_style_guide/#app-specific-code","title":"App-Specific Code","text":"<ul> <li>Minimal duplication: Avoid duplicating functionality across apps</li> <li>App-specific directories: Clear separation of app-specific code</li> <li>Dependency injection: Apps should be configurable through dependency injection</li> </ul>"},{"location":"architecture_and_style_guide/#testing-strategy","title":"Testing Strategy","text":"<ul> <li>Unit tests: All modules have comprehensive unit tests</li> <li>Integration tests: Test module interactions</li> <li>Test-first development: Consider writing tests before implementation</li> <li>Test isolation: Tests must not depend on each other</li> <li>Test coverage: Aim for high test coverage, especially of business logic</li> </ul>"},{"location":"architecture_and_style_guide/#documentation_1","title":"Documentation","text":"<ul> <li>Architecture documentation: Overview of system architecture, regularly updated</li> <li>Module documentation: Purpose, responsibilities, and usage of each module</li> <li>API documentation: Complete documentation of public APIs</li> <li>Dependency graphs: Visual representation of module dependencies</li> </ul>"},{"location":"architecture_and_style_guide/#implementation-timeline","title":"Implementation Timeline","text":"<ol> <li>Phase 1: Protocol layer refactoring and circular dependency removal</li> <li>Phase 2: Code style standardization across codebase</li> <li>Phase 3: Documentation improvements</li> <li>Phase 4: Multi-app support architecture</li> <li>Phase 5: Test coverage expansion</li> </ol>"},{"location":"architecture_and_style_guide/#tools-and-enforcement","title":"Tools and Enforcement","text":"<ul> <li>SwiftLint: Automated style checking</li> <li>Documentation generators: Generate API docs from source comments</li> <li>CI checks: Automated checks for style, circular dependencies, and test coverage</li> <li>Code review checklist: Standard checklist for reviewers to ensure quality</li> </ul>"},{"location":"architecture_and_style_guide/#references","title":"References","text":"<ul> <li>Google Swift Style Guide</li> <li>Swift API Design Guidelines</li> <li>Bazel Best Practices</li> </ul>"},{"location":"bazel_dependencies/","title":"UmbraCore Bazel Dependencies Guide","text":""},{"location":"bazel_dependencies/#overview","title":"Overview","text":"<p>This document explains how dependencies are managed in the UmbraCore project using Bazel, with a focus on Swift module dependencies and their impact on namespace resolution.</p>"},{"location":"bazel_dependencies/#bazel-dependency-management","title":"Bazel Dependency Management","text":"<p>UmbraCore uses Bazel as its primary build system, which provides precise control over dependencies through explicit declaration in BUILD files.</p>"},{"location":"bazel_dependencies/#key-concepts","title":"Key Concepts","text":"<ul> <li>Visibility: Controls which targets can depend on each other</li> <li>deps: Explicit dependencies required for compilation</li> <li>Module imports: How Swift modules are imported and referenced</li> <li>Toolchains: Configure compiler flags and build environments</li> </ul>"},{"location":"bazel_dependencies/#swift-module-dependencies","title":"Swift Module Dependencies","text":"<p>Swift modules in UmbraCore follow specific dependency patterns to avoid circular dependencies and namespace conflicts:</p>"},{"location":"bazel_dependencies/#foundation-free-module-dependencies","title":"Foundation-Free Module Dependencies","text":"<p>Foundation-free modules (<code>umbracore_foundation_free_module</code>) have the following dependency constraints:</p> <ul> <li>No dependencies on Foundation or other Apple frameworks</li> <li>May only depend on other foundation-free modules</li> <li>Must use primitive Swift types for interfaces</li> </ul> <p>Example: <pre><code>umbracore_foundation_free_module(\n    name = \"SecureBytes\",\n    srcs = glob([\"Sources/**/*.swift\"]),\n    visibility = [\"//visibility:public\"],\n)\n</code></pre></p>"},{"location":"bazel_dependencies/#foundation-independent-module-dependencies","title":"Foundation-Independent Module Dependencies","text":"<p>Foundation-independent modules (<code>umbracore_foundation_independent_module</code>) have these constraints:</p> <ul> <li>No direct imports of Foundation</li> <li>May depend on bridge modules that provide Foundation-compatible interfaces</li> <li>May use type-erased wrappers for Foundation types</li> </ul> <p>Example: <pre><code>umbracore_foundation_independent_module(\n    name = \"SecurityImplementation\",\n    srcs = glob([\"Sources/**/*.swift\"]),\n    deps = [\n        \"//Sources/SecurityProtocolsCore\",\n        \"//Sources/SecurityBridge\",\n    ],\n    visibility = [\"//visibility:public\"],\n)\n</code></pre></p>"},{"location":"bazel_dependencies/#foundation-dependent-module-dependencies","title":"Foundation-Dependent Module Dependencies","text":"<p>Foundation-dependent modules (<code>umbracore_module</code>) have these constraints:</p> <ul> <li>May directly import Foundation and other Apple frameworks</li> <li>Should isolate Foundation dependencies behind clear interfaces</li> <li>Must follow specific import ordering</li> </ul> <p>Example: <pre><code>umbracore_module(\n    name = \"UmbraKeychainService\",\n    srcs = glob([\"Sources/**/*.swift\"]),\n    deps = [\n        \"//Sources/SecurityBridge\",\n        \"//Sources/UmbraSecurity\",\n    ],\n    visibility = [\"//visibility:public\"],\n)\n</code></pre></p>"},{"location":"bazel_dependencies/#managing-namespace-conflicts","title":"Managing Namespace Conflicts","text":"<p>Bazel configuration can help manage namespace conflicts through:</p> <ol> <li>Import qualification: Using the <code>-enable-implicit-module-import-name-qualification</code> flag</li> <li>Module mapping: Creating explicit module maps for dependencies</li> <li>Visibility control: Preventing inappropriate dependencies</li> </ol> <p>Example BUILD file with namespace conflict prevention: <pre><code>swift_library(\n    name = \"SecurityBridgeProtocolAdapters\",\n    srcs = glob([\"Sources/**/*.swift\"]),\n    copts = [\n        \"-enable-implicit-module-import-name-qualification\",\n    ],\n    deps = [\n        \"//Sources/SecurityProtocolsCore\",\n        \"//Sources/XPCProtocolsCore\",\n    ],\n    visibility = [\"//visibility:public\"],\n)\n</code></pre></p>"},{"location":"bazel_dependencies/#dependency-graph-tools","title":"Dependency Graph Tools","text":"<p>Bazel provides several tools to help visualize and analyze dependencies:</p> <ul> <li><code>bazelisk query --output=graph \"deps(//Sources/TARGET:TARGET)\"</code> - Generate a dependency graph</li> <li><code>bazelisk query --output=build \"deps(//Sources/TARGET:TARGET)\"</code> - List all dependencies</li> <li><code>bazelisk query --output=xml \"deps(//Sources/TARGET:TARGET, 1)\"</code> - Direct dependencies only</li> </ul> <p>These tools are invaluable for identifying and resolving dependency issues, especially when dealing with namespace conflicts.</p>"},{"location":"crypto-strategy/","title":"UmbraCore Cryptographic Strategy","text":""},{"location":"crypto-strategy/#overview","title":"Overview","text":"<p>UmbraCore implements a sophisticated dual-library cryptographic strategy to support both native macOS security features and cross-process operations. This document outlines the technical details of this implementation.</p>"},{"location":"crypto-strategy/#architecture","title":"Architecture","text":""},{"location":"crypto-strategy/#dual-library-implementation","title":"Dual-Library Implementation","text":""},{"location":"crypto-strategy/#1-cryptokit-apples-framework","title":"1. CryptoKit (Apple's Framework)","text":"<ul> <li>Primary Use: ResticBar and native macOS operations</li> <li>Key Features:</li> <li>Hardware-backed security through Secure Enclave</li> <li>Native integration with macOS security features</li> <li>Optimised for sandboxed environments</li> <li>Secure key storage with Keychain integration</li> </ul>"},{"location":"crypto-strategy/#2-cryptoswift-third-party-library","title":"2. CryptoSwift (Third-party Library)","text":"<ul> <li>Primary Use: Rbum and Rbx cross-process operations</li> <li>Key Features:</li> <li>Platform-independent implementation</li> <li>XPC service compatibility</li> <li>Flexible deployment options</li> <li>Cross-process encryption support</li> </ul>"},{"location":"crypto-strategy/#keymanager","title":"KeyManager","text":"<p>The KeyManager serves as the orchestration layer between these implementations:</p>"},{"location":"crypto-strategy/#core-responsibilities","title":"Core Responsibilities","text":"<ol> <li>Implementation Selection</li> <li>Context-aware routing between CryptoKit and CryptoSwift</li> <li>Security boundary enforcement</li> <li> <p>Operation validation</p> </li> <li> <p>Key Lifecycle Management</p> </li> <li>Key generation and storage</li> <li>Rotation policies and execution</li> <li>Validation and verification</li> <li> <p>Cross-process synchronisation</p> </li> <li> <p>Security Context Management</p> </li> <li>Sandbox compliance</li> <li>XPC service coordination</li> <li>Permission management</li> <li>Resource access control</li> </ol>"},{"location":"crypto-strategy/#implementation-details","title":"Implementation Details","text":"<pre><code>actor KeyManager {\n    // Context-aware implementation selection\n    func selectImplementation(for operation: CryptoOperation) -&gt; CryptoImplementation\n\n    // Key lifecycle operations\n    func generateKey(for context: SecurityContext) async throws -&gt; Key\n    func rotateKey(id: KeyIdentifier) async throws\n    func validateKey(id: KeyIdentifier) async throws -&gt; ValidationResult\n\n    // Cross-process coordination\n    func synchroniseKeys() async throws\n    func validateSecurityBoundaries() async throws\n}\n</code></pre>"},{"location":"crypto-strategy/#security-considerations","title":"Security Considerations","text":""},{"location":"crypto-strategy/#1-sandbox-compliance","title":"1. Sandbox Compliance","text":"<ul> <li>Proper security-scoped bookmark usage</li> <li>Explicit permission management</li> <li>Resource access tracking</li> <li>Clean-up and resource release</li> </ul>"},{"location":"crypto-strategy/#2-cross-process-security","title":"2. Cross-Process Security","text":"<ul> <li>XPC service isolation</li> <li>Secure message passing</li> <li>State synchronisation</li> <li>Error handling and recovery</li> </ul>"},{"location":"crypto-strategy/#3-key-management","title":"3. Key Management","text":"<ul> <li>Secure storage strategies</li> <li>Rotation policies</li> <li>Access control</li> <li>Audit logging</li> </ul>"},{"location":"crypto-strategy/#implementation-strategy","title":"Implementation Strategy","text":""},{"location":"crypto-strategy/#phase-1-foundation","title":"Phase 1: Foundation","text":"<ol> <li>Core KeyManager implementation</li> <li>Basic routing logic</li> <li>Key lifecycle management</li> <li>Error handling framework</li> </ol>"},{"location":"crypto-strategy/#phase-2-security-integration","title":"Phase 2: Security Integration","text":"<ol> <li>CryptoKit integration</li> <li>Sandbox compliance</li> <li>Keychain integration</li> <li>Security boundary enforcement</li> </ol>"},{"location":"crypto-strategy/#phase-3-cross-process-support","title":"Phase 3: Cross-Process Support","text":"<ol> <li>CryptoSwift integration</li> <li>XPC service implementation</li> <li>Cross-process synchronisation</li> <li>Error recovery</li> </ol>"},{"location":"crypto-strategy/#phase-4-advanced-features","title":"Phase 4: Advanced Features","text":"<ol> <li>Key rotation policies</li> <li>Audit logging</li> <li>Performance optimisation</li> <li>Advanced security features</li> </ol>"},{"location":"crypto-strategy/#testing-strategy","title":"Testing Strategy","text":""},{"location":"crypto-strategy/#unit-tests","title":"Unit Tests","text":"<ol> <li>Implementation routing</li> <li>Key lifecycle operations</li> <li>Error conditions</li> <li>Security boundaries</li> </ol>"},{"location":"crypto-strategy/#integration-tests","title":"Integration Tests","text":"<ol> <li>Cross-process operations</li> <li>Sandbox compliance</li> <li>Security features</li> <li>Performance metrics</li> </ol>"},{"location":"crypto-strategy/#security-tests","title":"Security Tests","text":"<ol> <li>Boundary violations</li> <li>Error handling</li> <li>Resource cleanup</li> <li>State consistency</li> </ol>"},{"location":"crypto-strategy/#performance-considerations","title":"Performance Considerations","text":""},{"location":"crypto-strategy/#1-operation-routing","title":"1. Operation Routing","text":"<ul> <li>Minimal overhead for implementation selection</li> <li>Efficient context switching</li> <li>Optimised security checks</li> </ul>"},{"location":"crypto-strategy/#2-key-management","title":"2. Key Management","text":"<ul> <li>Efficient key storage</li> <li>Quick key rotation</li> <li>Fast validation</li> </ul>"},{"location":"crypto-strategy/#3-cross-process-operations","title":"3. Cross-Process Operations","text":"<ul> <li>Minimal latency</li> <li>Efficient synchronisation</li> <li>Resource usage optimisation</li> </ul>"},{"location":"crypto-strategy/#error-handling","title":"Error Handling","text":""},{"location":"crypto-strategy/#1-error-categories","title":"1. Error Categories","text":"<ul> <li>Implementation selection errors</li> <li>Key lifecycle errors</li> <li>Security boundary violations</li> <li>Cross-process errors</li> </ul>"},{"location":"crypto-strategy/#2-recovery-strategies","title":"2. Recovery Strategies","text":"<ul> <li>Automatic retry policies</li> <li>Fallback implementations</li> <li>State recovery</li> <li>Resource cleanup</li> </ul>"},{"location":"crypto-strategy/#documentation-requirements","title":"Documentation Requirements","text":""},{"location":"crypto-strategy/#1-api-documentation","title":"1. API Documentation","text":"<ul> <li>Clear interface descriptions</li> <li>Usage examples</li> <li>Security considerations</li> <li>Best practices</li> </ul>"},{"location":"crypto-strategy/#2-security-documentation","title":"2. Security Documentation","text":"<ul> <li>Security model overview</li> <li>Threat model</li> <li>Mitigation strategies</li> <li>Audit requirements</li> </ul>"},{"location":"crypto-strategy/#success-criteria","title":"Success Criteria","text":""},{"location":"crypto-strategy/#1-functionality","title":"1. Functionality","text":"<ul> <li>Successful implementation routing</li> <li>Proper key lifecycle management</li> <li>Effective cross-process operations</li> <li>Reliable error handling</li> </ul>"},{"location":"crypto-strategy/#2-security","title":"2. Security","text":"<ul> <li>Sandbox compliance</li> <li>Secure key management</li> <li>Proper boundary enforcement</li> <li>Audit trail availability</li> </ul>"},{"location":"crypto-strategy/#3-performance","title":"3. Performance","text":"<ul> <li>Minimal routing overhead</li> <li>Fast key operations</li> <li>Efficient cross-process communication</li> <li>Resource usage within bounds</li> </ul>"},{"location":"crypto-strategy/#future-considerations","title":"Future Considerations","text":""},{"location":"crypto-strategy/#1-extensibility","title":"1. Extensibility","text":"<ul> <li>New implementation support</li> <li>Additional security features</li> <li>Enhanced monitoring</li> <li>Advanced audit capabilities</li> </ul>"},{"location":"crypto-strategy/#2-integration","title":"2. Integration","text":"<ul> <li>Additional application support</li> <li>Cloud service integration</li> <li>Enhanced security features</li> <li>Performance optimisations</li> </ul>"},{"location":"error_migration_strategy/","title":"UmbraCore Error Migration Strategy","text":""},{"location":"error_migration_strategy/#overview","title":"Overview","text":"<p>This document outlines our strategy for consolidating error types across the UmbraCore project. The goal is to eliminate duplication, improve consistency, and enable better error handling throughout the codebase.</p>"},{"location":"error_migration_strategy/#current-issues","title":"Current Issues","text":"<p>Our error analysis has identified several issues with the current error handling approach:</p> <ol> <li>Duplicated Error Types: Many error types are defined in multiple modules with varying cases:</li> <li><code>SecurityError</code> is defined in 7 different modules</li> <li><code>ResourceError</code> is defined in 4 different modules</li> <li><code>LoggingError</code> is defined in 5 different modules</li> <li> <p>Other duplicated errors include <code>CredentialError</code> and <code>ResticError</code></p> </li> <li> <p>Inconsistent Error Handling: The same logical errors have different names and structures across modules, making error handling inconsistent.</p> </li> <li> <p>Coupling Issues: Error definitions create implicit dependencies between modules that should be independent.</p> </li> <li> <p>Ambiguity Problems: When multiple modules define the same error type, it creates import ambiguities that lead to build failures.</p> </li> </ol>"},{"location":"error_migration_strategy/#migration-approach","title":"Migration Approach","text":"<p>We are implementing a comprehensive error migration strategy with these key components:</p> <ol> <li> <p>Error Analysis Tool: We have developed an <code>error_analyzer</code> tool that scans the codebase to identify all error types, their locations, and usage patterns.</p> </li> <li> <p>Error Migration Tool: We have created an <code>error_migrator</code> tool that automates the consolidation of error types into a central <code>CoreErrors</code> module.</p> </li> <li> <p>Phased Migration: The migration will be performed in phases, starting with the most problematic error types (like <code>SecurityError</code>).</p> </li> </ol>"},{"location":"error_migration_strategy/#coreerrors-module","title":"CoreErrors Module","text":"<p>The foundation of our strategy is a new <code>CoreErrors</code> module that will serve as the central location for all common error types. This module will:</p> <ol> <li>Contain consolidated definitions of error types used across multiple modules</li> <li>Provide a consistent error hierarchy and naming conventions</li> <li>Support error wrapping and contextual information</li> <li>Maintain backward compatibility through type aliases</li> </ol>"},{"location":"error_migration_strategy/#migration-process","title":"Migration Process","text":"<p>The migration process consists of these steps:</p> <ol> <li> <p>Analysis: Run the <code>error_analyzer</code> tool to generate a comprehensive report of all error types, their definitions, and usage.</p> </li> <li> <p>Planning: Create a migration configuration file that specifies which error types to migrate and their source modules.</p> </li> <li> <p>Code Generation: Run the <code>error_migrator</code> tool to:</p> </li> <li>Create consolidated error definitions in the <code>CoreErrors</code> module</li> <li>Generate type aliases in original modules for backward compatibility</li> <li> <p>Update import statements where necessary</p> </li> <li> <p>Validation: Verify that the migrated code compiles and behaves correctly.</p> </li> <li> <p>Integration: Merge the changes into the main codebase incrementally to minimize disruption.</p> </li> </ol>"},{"location":"error_migration_strategy/#tooling-details","title":"Tooling Details","text":""},{"location":"error_migration_strategy/#error-analyzer-tool","title":"Error Analyzer Tool","text":"<p>The <code>error_analyzer</code> tool: - Scans Swift files across the project - Identifies error type definitions - Tracks error references and imports - Generates a detailed analysis report</p>"},{"location":"error_migration_strategy/#error-migrator-tool","title":"Error Migrator Tool","text":"<p>The <code>error_migrator</code> tool: - Parses the error analysis report - Constructs a migration plan based on configuration - Generates consolidated error definitions - Creates type aliases for backward compatibility - Updates import statements</p>"},{"location":"error_migration_strategy/#example-migration","title":"Example Migration","text":"<p>For a concrete example, let's consider the <code>SecurityError</code> that is defined in both <code>SecurityProtocolsCore</code> and <code>XPCProtocolsCore</code>:</p> <ol> <li>Create a consolidated <code>SecurityError</code> in <code>CoreErrors</code> that includes all cases from both modules.</li> <li>Create type aliases in both original modules: <code>public typealias SecurityError = CoreErrors.SecurityError</code>.</li> <li>Update import statements in files that referenced the original error types.</li> </ol>"},{"location":"error_migration_strategy/#timeline-and-priorities","title":"Timeline and Priorities","text":"<ol> <li>Phase 1: Migrate <code>SecurityError</code> to resolve the immediate build ambiguity issues</li> <li>Phase 2: Migrate other high-priority error types (<code>ResourceError</code>, <code>LoggingError</code>)</li> <li>Phase 3: Migrate remaining duplicated error types</li> <li>Phase 4: Standardize error patterns across the codebase</li> </ol>"},{"location":"error_migration_strategy/#development-guidelines","title":"Development Guidelines","text":"<p>Moving forward, developers should follow these guidelines:</p> <ol> <li>Define new error types in the <code>CoreErrors</code> module when they are likely to be used across multiple modules.</li> <li>Use consistent naming patterns for error types and cases.</li> <li>Include descriptive error messages and context information.</li> <li>Leverage type safety through enums with associated values for complex errors.</li> </ol>"},{"location":"error_migration_strategy/#conclusion","title":"Conclusion","text":"<p>This error migration strategy will significantly improve the error handling in UmbraCore by:</p> <ol> <li>Eliminating duplication and ambiguity</li> <li>Providing a consistent error handling pattern</li> <li>Reducing coupling between modules</li> <li>Enabling better error reporting and debugging</li> </ol> <p>The automated tooling we've developed ensures that this migration can be performed efficiently and with minimal manual effort, reducing the risk of errors and inconsistencies.</p>"},{"location":"module_structure/","title":"UmbraCore Module Structure","text":""},{"location":"module_structure/#overview","title":"Overview","text":"<p>This document outlines the modular architecture of UmbraCore, explaining how the various modules interact and depend on each other.</p>"},{"location":"module_structure/#core-module-organisation","title":"Core Module Organisation","text":"<p>UmbraCore follows a layered architecture with clearly defined responsibilities:</p>"},{"location":"module_structure/#foundation-free-core-layer","title":"Foundation-Free Core Layer","text":"<p>These modules have no dependencies on Foundation or other Apple frameworks, making them portable and easier to test:</p> <ul> <li>UmbraCoreTypes: Core type definitions used throughout the system</li> <li>SecurityProtocolsCore: Security protocol definitions without Foundation dependencies</li> <li>XPCProtocolsCore: XPC communication protocols without Foundation dependencies</li> <li>SecureBytes: Foundation-free binary data handling</li> </ul>"},{"location":"module_structure/#bridge-layer","title":"Bridge Layer","text":"<p>These modules bridge between Foundation-free and Foundation-dependent code:</p> <ul> <li>SecurityBridge: Adapts between Foundation-free security protocols and Foundation types</li> <li>XPCBridge: Provides Foundation-compatible XPC service implementations</li> </ul>"},{"location":"module_structure/#implementation-layer","title":"Implementation Layer","text":"<p>These modules provide concrete implementations of the protocols:</p> <ul> <li>SecurityImplementation: Implements security protocols using CryptoKit</li> <li>UmbraSecurity: High-level security services</li> <li>UmbraXPC: XPC service implementations</li> </ul>"},{"location":"module_structure/#application-services","title":"Application Services","text":"<p>These modules provide application-specific functionality:</p> <ul> <li>UmbraKeychainService: Keychain access and management</li> <li>ResticCLIHelper: Interface to the Restic command-line tool</li> <li>RepositoryManager: Repository configuration and management</li> <li>BackupCoordinator: Coordinates backup operations</li> <li>Configuration: Application and service configuration</li> </ul>"},{"location":"module_structure/#dependency-graph","title":"Dependency Graph","text":"<pre><code>Application Services\n      \u2191\nImplementation Layer\n      \u2191\n   Bridge Layer\n      \u2191\nFoundation-Free Core\n</code></pre>"},{"location":"module_structure/#module-import-guidelines","title":"Module Import Guidelines","text":"<p>When importing modules, follow these guidelines:</p> <ol> <li>Always import the most specific module required</li> <li>Avoid importing both a module and its submodules</li> <li>Use explicit imports instead of <code>@_exported import</code></li> <li>Be consistent with import ordering</li> <li>Keep Foundation imports separate from project module imports</li> </ol>"},{"location":"module_structure/#circular-dependency-prevention","title":"Circular Dependency Prevention","text":"<p>The layered architecture is designed to prevent circular dependencies:</p> <ul> <li>Foundation-free modules must not import Foundation-dependent modules</li> <li>Lower-layer modules must not import higher-layer modules</li> <li>Use protocol-based design to maintain separation of concerns</li> </ul>"},{"location":"namespace_resolution_guide/","title":"UmbraCore Namespace Resolution Guide","text":""},{"location":"namespace_resolution_guide/#overview","title":"Overview","text":"<p>This document outlines best practices for resolving Swift namespace conflicts in the UmbraCore project, with a specific focus on error handling patterns and the <code>UmbraErrors</code> namespace. It is intended to help developers avoid common pitfalls when working with module imports and type references across the codebase.</p>"},{"location":"namespace_resolution_guide/#the-challenge-swift-module-namespaces","title":"The Challenge: Swift Module Namespaces","text":"<p>Swift's module system can sometimes lead to ambiguous references, particularly in a large, modular codebase like UmbraCore. The key challenges include:</p> <ol> <li>Nested namespaces: Types defined within enums that share the same name as their module</li> <li>Type aliases: Different modules may define similar types or use type aliases</li> <li>Module structure: The actual definition of a type may be in a submodule rather than the main module</li> <li>Re-exported types: Types may be re-exported through parent modules</li> </ol>"},{"location":"namespace_resolution_guide/#umbraerrors-case-study","title":"UmbraErrors Case Study","text":""},{"location":"namespace_resolution_guide/#problem","title":"Problem","text":"<p>A common issue encountered is correctly referencing the <code>UmbraErrors</code> namespace, which is defined in the <code>ErrorHandlingDomains</code> module but often accessed through the parent <code>ErrorHandling</code> module. This can lead to build errors such as:</p> <pre><code>error: cannot find type 'UmbraErrors' in scope\n</code></pre> <p>or </p> <pre><code>error: 'UmbraErrors' is not a member type of enum 'ErrorHandling.ErrorHandling'\n</code></pre>"},{"location":"namespace_resolution_guide/#solution-pattern","title":"Solution Pattern","text":"<p>To properly reference the <code>UmbraErrors</code> namespace and its nested types:</p> <ol> <li> <p>Import the specific module that actually contains the definition:    <pre><code>import ErrorHandlingDomains  // Contains UmbraErrors definition\nimport ErrorHandling         // May be needed for other functionality\n</code></pre></p> </li> <li> <p>Use fully qualified type names when referencing error types:    <pre><code>// INCORRECT\nfunc handleError() -&gt; Result&lt;Data, UmbraErrors.GeneralSecurity.Core&gt; { ... }\n\n// CORRECT\nfunc handleError() -&gt; Result&lt;Data, ErrorHandlingDomains.UmbraErrors.GeneralSecurity.Core&gt; { ... }\n</code></pre></p> </li> <li> <p>Update BUILD.bazel files to include explicit dependencies:    <pre><code>deps = [\n    \"//Sources/ErrorHandling\",\n    \"//Sources/ErrorHandling/Domains:ErrorHandlingDomains\",  // Add this direct dependency\n    // Other dependencies...\n],\n</code></pre></p> </li> </ol>"},{"location":"namespace_resolution_guide/#error-handling-structure-in-umbracore","title":"Error Handling Structure in UmbraCore","text":"<p>Understanding the organisation of error types in UmbraCore is crucial:</p>"},{"location":"namespace_resolution_guide/#namespace-hierarchy","title":"Namespace Hierarchy","text":"<ul> <li><code>UmbraErrors</code> serves as the root namespace</li> <li>Domain-specific errors are nested within (e.g., <code>UmbraErrors.GeneralSecurity</code>)</li> <li>Specific error categories are nested further (e.g., <code>UmbraErrors.GeneralSecurity.Core</code>)</li> </ul>"},{"location":"namespace_resolution_guide/#common-error-domains","title":"Common Error Domains","text":"Domain Module Example Usage GeneralSecurity ErrorHandlingDomains <code>ErrorHandlingDomains.UmbraErrors.GeneralSecurity.Core</code> Security ErrorHandlingDomains <code>ErrorHandlingDomains.UmbraErrors.Security.Protocols</code> Network ErrorHandlingDomains <code>ErrorHandlingDomains.UmbraErrors.Network.Core</code> Application ErrorHandlingDomains <code>ErrorHandlingDomains.UmbraErrors.Application.Lifecycle</code>"},{"location":"namespace_resolution_guide/#best-practices","title":"Best Practices","text":"<ol> <li>Always use explicit imports for modules containing the types you need</li> <li>Favour fully qualified names for types that exist in multiple modules</li> <li>Check BUILD.bazel files to ensure all necessary module dependencies are included</li> <li>Create type aliases for commonly used but verbose type references</li> <li>Document type references in comments to help other developers</li> </ol>"},{"location":"namespace_resolution_guide/#debugging-tips","title":"Debugging Tips","text":"<p>When encountering namespace resolution issues:</p> <ol> <li> <p>Use <code>grep_search</code> to find where the type is defined:    <pre><code>grep -r \"extension UmbraErrors\" Sources/\n</code></pre></p> </li> <li> <p>Look for example usages in the codebase:    <pre><code>grep -r \"UmbraErrors.GeneralSecurity\" Sources/\n</code></pre></p> </li> <li> <p>Check for fully qualified references in error handler code:    <pre><code>grep -r \"ErrorHandlingDomains.UmbraErrors\" Sources/\n</code></pre></p> </li> <li> <p>Examine BUILD.bazel dependencies for the module containing your code</p> </li> </ol>"},{"location":"namespace_resolution_guide/#conclusion","title":"Conclusion","text":"<p>Properly handling Swift namespace resolution in UmbraCore requires understanding the modular structure of the codebase and being explicit about imports and type references. By following the patterns outlined in this guide, you can avoid common errors and ensure your code remains maintainable.</p>"},{"location":"namespace_resolution_guide/#further-reading","title":"Further Reading","text":"<ul> <li>UmbraCore Module Structure Documentation</li> <li>Swift Import Declaration Documentation</li> <li>Bazel Dependencies Guide</li> </ul>"},{"location":"phase1_implementation/","title":"UmbraCore Phase 1 Implementation Plan","text":"<p>This document outlines the specific steps for implementing Phase 1 of the UmbraCore refactoring plan: the restructuring of protocol definitions with a clear separation between Sources and Tests.</p>"},{"location":"phase1_implementation/#1-create-securityinterfacesbase-module-in-sources","title":"1. Create SecurityInterfacesBase Module in Sources","text":""},{"location":"phase1_implementation/#11-create-directory-structure","title":"1.1 Create Directory Structure","text":"<pre><code>mkdir -p Sources/SecurityInterfacesBase\n</code></pre>"},{"location":"phase1_implementation/#12-create-buildbazel-for-securityinterfacesbase","title":"1.2 Create BUILD.bazel for SecurityInterfacesBase","text":"<p>Create a new BUILD.bazel file in the SecurityInterfacesBase directory with minimal dependencies:</p> <pre><code>load(\"//:bazel/macros/swift.bzl\", \"umbra_swift_library\")\n\numbra_swift_library(\n    name = \"SecurityInterfacesBase\",\n    srcs = [\n        \"XPCServiceBaseProtocol.swift\",\n        \"XPCServiceProtocolDefinition.swift\",\n    ],\n    additional_copts = [],\n    deps = [\n        \"//Sources/CoreTypes\",\n    ],\n    visibility = [\"//visibility:public\"],\n)\n</code></pre>"},{"location":"phase1_implementation/#13-create-base-xpc-protocol","title":"1.3 Create Base XPC Protocol","text":"<p>Create a new file called <code>XPCServiceBaseProtocol.swift</code> in SecurityInterfacesBase:</p> <pre><code>import Foundation\n\n/// Base protocol for XPC service interfaces\n/// Provides minimal Foundation dependencies\n@objc public protocol XPCServiceBaseProtocol: NSObjectProtocol, Sendable {\n    // Basic functionality all XPC services need\n}\n\n// Use extensions to provide NSObjectProtocol conformance\nextension XPCServiceBaseProtocol {\n    // Extension methods to aid conformance\n}\n</code></pre>"},{"location":"phase1_implementation/#14-move-xpcserviceprotocoldefinition","title":"1.4 Move XPCServiceProtocolDefinition","text":"<p>Create <code>XPCServiceProtocolDefinition.swift</code> in SecurityInterfacesBase with a cleaner definition that inherits from XPCServiceBaseProtocol:</p> <pre><code>import Foundation\n\n/// Protocol defining the XPC service interface for key management\n@objc public protocol XPCServiceProtocolDefinition: XPCServiceBaseProtocol {\n    /// Base method to test connectivity\n    @objc func ping(withReply reply: @escaping (Bool, Error?) -&gt; Void)\n\n    /// Synchronize keys across processes with raw bytes using NSData\n    /// - Parameter data: The key data to synchronize\n    @objc func synchroniseKeys(_ data: NSData, withReply reply: @escaping (Error?) -&gt; Void)\n\n    /// Reset all security data\n    @objc func resetSecurityData(withReply reply: @escaping (Error?) -&gt; Void)\n\n    /// Get the XPC service version\n    @objc func getVersion(withReply reply: @escaping (NSString?, Error?) -&gt; Void)\n\n    /// Get the host identifier\n    @objc func getHostIdentifier(withReply reply: @escaping (NSString?, Error?) -&gt; Void)\n\n    /// Register a client application\n    @objc func registerClient(clientId: NSString, withReply reply: @escaping (Bool, Error?) -&gt; Void)\n\n    /// Deregister a client application\n    @objc func deregisterClient(clientId: NSString, withReply reply: @escaping (Bool, Error?) -&gt; Void)\n\n    /// Check if a client is registered\n    @objc func isClientRegistered(clientId: NSString, withReply reply: @escaping (Bool, Error?) -&gt; Void)\n}\n</code></pre>"},{"location":"phase1_implementation/#2-update-securityinterfaces-module-in-sources","title":"2. Update SecurityInterfaces Module in Sources","text":""},{"location":"phase1_implementation/#21-update-securityinterfaces-buildbazel","title":"2.1 Update SecurityInterfaces BUILD.bazel","text":"<p>Modify the existing SecurityInterfaces BUILD.bazel to depend on the new SecurityInterfacesBase:</p> <pre><code>load(\"//:bazel/macros/swift.bzl\", \"umbra_swift_library\")\n\numbra_swift_library(\n    name = \"SecurityInterfaces\",\n    srcs = [\n        \"SecurityInterfaces.swift\",\n        \"SecurityProvider.swift\",\n        \"SecurityProviderBase.swift\",\n        \"SecurityProviderFoundation.swift\",\n        \"XPCServiceProtocol.swift\",\n    ],\n    additional_copts = [],\n    deps = [\n        \"//Sources/CoreTypes\",\n        \"//Sources/SecurityInterfacesBase\",\n        \"//Sources/SecurityTypes\",\n    ],\n    visibility = [\"//visibility:public\"],\n)\n</code></pre>"},{"location":"phase1_implementation/#22-update-xpcserviceprotocolswift","title":"2.2 Update XPCServiceProtocol.swift","text":"<p>Update the protocol to use the new base:</p> <pre><code>import Foundation\nimport SecurityInterfacesBase\n\n/// The protocol for the XPC service\npublic typealias XPCServiceProtocol = XPCServiceProtocolDefinition\n</code></pre>"},{"location":"phase1_implementation/#23-remove-obsolete-files-from-sources","title":"2.3 Remove Obsolete Files from Sources","text":"<ul> <li>Remove Sources/SecurityInterfaces/XPCServiceProtocolBase.swift</li> <li>Remove Sources/SecurityInterfaces/XPCServiceProtocolDefinitionBase.swift</li> </ul>"},{"location":"phase1_implementation/#3-update-core-services-in-sources","title":"3. Update Core Services in Sources","text":""},{"location":"phase1_implementation/#31-update-xpcserviceprotocolaliasswift","title":"3.1 Update XPCServiceProtocolAlias.swift","text":"<pre><code>import Foundation\nimport SecurityInterfacesBase\n\n/// Alias for the XPC service protocol\npublic typealias XPCServiceProtocol = XPCServiceProtocolDefinition\n</code></pre>"},{"location":"phase1_implementation/#32-update-coreservices-buildbazel-dependencies","title":"3.2 Update Core/Services BUILD.bazel Dependencies","text":"<p>Make sure Core/Services BUILD.bazel references SecurityInterfacesBase instead of SecurityInterfaces for protocol definitions:</p> <pre><code>load(\"//:bazel/macros/swift.bzl\", \"umbra_swift_library\")\n\numbra_swift_library(\n    name = \"CoreServices\",\n    srcs = glob([\n        \"*.swift\",\n        \"TypeAliases/*.swift\",\n    ]),\n    additional_copts = [],\n    deps = [\n        \"//Sources/CoreServicesTypes\",\n        \"//Sources/CoreTypes\",\n        \"//Sources/SecurityInterfacesBase\",  # Updated dependency\n        # Other dependencies as needed\n    ],\n    visibility = [\"//visibility:public\"],\n)\n</code></pre>"},{"location":"phase1_implementation/#4-create-umbrella-targets","title":"4. Create Umbrella Targets","text":""},{"location":"phase1_implementation/#41-add-to-root-buildbazel","title":"4.1 Add to Root BUILD.bazel","text":"<p>Add umbrella targets to the root BUILD.bazel for building Sources and Tests separately:</p> <pre><code>umbrella_target(\n    name = \"umbracore_sources\",\n    deps = [\n        \"//Sources/API\",\n        \"//Sources/Core\",\n        \"//Sources/CoreServicesTypes\",\n        \"//Sources/CoreTypes\",\n        \"//Sources/SecurityInterfaces\",\n        \"//Sources/SecurityInterfacesBase\",\n        # Other production modules\n    ],\n)\n\numbrella_target(\n    name = \"umbracore_tests\",\n    deps = [\n        \"//Tests/CoreTests\",\n        \"//Tests/UmbraSecurityTests\",\n        # Other test modules\n    ],\n)\n</code></pre>"},{"location":"phase1_implementation/#5-test-the-changes","title":"5. Test the Changes","text":""},{"location":"phase1_implementation/#51-build-production-code-only","title":"5.1 Build Production Code Only","text":"<pre><code># Build just the new module\nbazel build //Sources/SecurityInterfacesBase --platforms=//:macos_arm64\n\n# Build affected modules\nbazel build //Sources/SecurityInterfaces --platforms=//:macos_arm64\nbazel build //Sources/Core/Services:CoreServices --platforms=//:macos_arm64\n\n# Build all Sources\nbazel build //Sources/... --platforms=//:macos_arm64\n</code></pre>"},{"location":"phase1_implementation/#52-verify-tests-still-work-with-new-structure","title":"5.2 Verify Tests Still Work with New Structure","text":"<pre><code># Run relevant tests\nbazel test //Tests/CoreTests --platforms=//:macos_arm64\nbazel test //Tests/UmbraSecurityTests --platforms=//:macos_arm64\n\n# Or run all tests\nbazel test //Tests/... --platforms=//:macos_arm64\n</code></pre>"},{"location":"phase1_implementation/#53-verify-no-circular-dependencies","title":"5.3 Verify No Circular Dependencies","text":"<pre><code># Check for circular dependencies between critical modules\nbazel query \"allpaths(//Sources/SecurityInterfacesBase, //Sources/SecurityInterfaces)\"\nbazel query \"allpaths(//Sources/SecurityInterfaces, //Sources/SecurityInterfacesBase)\"\n</code></pre>"},{"location":"phase1_implementation/#6-commit-changes","title":"6. Commit Changes","text":"<p>Once verified that both Sources and Tests build properly, commit the changes with a clear description of the architectural improvements made.</p>"},{"location":"project_structure/","title":"Project structure","text":"<p>/Users/mpy/CascadeProjects/UmbraCore |-- Sources |   |-- API |   |   <code>-- UmbraAPI.swift |   |-- Autocomplete |   |   |-- Errors |   |   |-- Extensions |   |   |-- Models |   |   |-- Protocols |   |   |</code>-- AutocompleteProtocol.swift |   |   |-- Services |   |   <code>-- README.md |   |-- Config |   |   |-- Errors |   |   |-- Extensions |   |   |-- Models |   |   |-- Protocols |   |   |</code>-- ConfigurationProtocol.swift |   |   |-- Services |   |   <code>-- README.md |   |-- Core |   |   |-- CryptoTypes |   |   |-- Protocols |   |   |-- SecurityTypes |   |   |-- Services |   |   |</code>-- CoreService.swift |   |   |-- Types |   |   <code>-- UmbraCore |   |       |-- Security |   |</code>-- UmbraCore.swift |   |-- CryptoTypes |   |   |-- Models |   |   |   <code>-- SecureStorageData.swift |   |   |-- Protocols |   |   |</code>-- CryptoServiceProtocol.swift |   |   |-- Services |   |   |   |-- CredentialManager.swift |   |   |   <code>-- CryptoService.swift |   |</code>-- Types |   |       |-- CryptoConfiguration.swift |   |       <code>-- CryptoError.swift |   |-- ErrorHandling |   |   |-- Errors |   |   |-- Extensions |   |   |</code>-- Error+Context.swift |   |   |-- Models |   |   |   |-- CommonError.swift |   |   |   |-- CoreError.swift |   |   |   |-- ErrorContext.swift |   |   |   <code>-- ServiceErrorTypes.swift |   |   |-- Protocols |   |   |   |-- ErrorHandlingProtocol.swift |   |   |   |-- ErrorReporting.swift |   |   |</code>-- ServiceErrorProtocol.swift |   |   |-- Services |   |   <code>-- README.md |   |-- Features |   |   |-- Crypto |   |   |   |-- Errors |   |   |   |-- Models |   |   |   |</code>-- SecureStorageData.swift |   |   |   |-- Protocols |   |   |   |   <code>-- SecureStorageProvider.swift |   |   |</code>-- Services |   |   <code>-- Logging |   |       |-- Errors |   |       |</code>-- LoggingError.swift |   |       |-- Extensions |   |       |-- Models |   |       |   <code>-- LogEntry.swift |   |       |-- Protocols |   |       |</code>-- LoggingProtocol.swift |   |       |-- Services |   |       |   |-- LoggingService.swift |   |       |   <code>-- SwiftyBeaverLoggingService.swift |   |</code>-- README.md |   |-- Mocks |   |   |-- MockKeychain.swift |   |   |-- MockSecurityProvider.swift |   |   <code>-- MockURLProvider.swift |   |-- Repositories |   |   |-- Errors |   |   |-- Extensions |   |   |-- Models |   |   |-- Protocols |   |   |</code>-- RepositoryProtocol.swift |   |   |-- Services |   |   <code>-- README.md |   |-- ResticCLIHelper |   |   |-- Errors |   |   |-- Extensions |   |   |-- Models |   |   |-- Protocols |   |   |</code>-- ResticCLIHelperProtocol.swift |   |   |-- Services |   |   <code>-- README.md |   |-- SecurityTypes |   |   |-- Models |   |   |   |-- FilePermission.swift |   |   |</code>-- SecurityError.swift |   |   |-- Protocols |   |   |   |-- SecureStorageProvider.swift |   |   |   <code>-- SecurityProvider.swift |   |   |-- Testing |   |</code>-- Types |   |       <code>-- SecurityErrorHandler.swift |   |-- Services |   |</code>-- SecurityUtils |   |       |-- Extensions |   |       |-- Protocols |   |       |   <code>-- URLProvider.swift |   |       |-- Services |   |       |   |-- EncryptedBookmarkService.swift |   |       |</code>-- SecurityBookmarkService.swift |   |       |-- Testing |   |       <code>-- Types |   |-- Snapshots |   |   |-- Errors |   |   |-- Extensions |   |   |-- Models |   |   |-- Protocols |   |   |</code>-- SnapshotProtocol.swift |   |   |-- Services |   |   <code>-- README.md |   |-- UmbraCore |   |</code>-- UmbraCore.swift |   |-- UmbraMocks |   |   |-- MockCryptoService.swift |   |   |-- MockKeychain.swift |   |   <code>-- MockSecurityProvider.swift |   |-- UmbraSecurity |   |   |-- Extensions |   |   |</code>-- URL+SecurityScoped.swift |   |   <code>-- Services |   |</code>-- SecurityService.swift |   <code>-- XPC |       |-- Core |       |   |-- XPCConnectionManager.swift |       |   |-- XPCError.swift |       |</code>-- XPCServiceProtocols.swift |       |-- CryptoService |       <code>-- SecurityService |-- Tests |   |-- AutocompleteTests |   |   |-- Errors |   |   |-- Extensions |   |   |-- Models |   |   |-- Protocols |   |</code>-- Services |   |-- ConfigTests |   |   |-- Errors |   |   |-- Extensions |   |   |-- Models |   |   |-- Protocols |   |   <code>-- Services |   |-- CoreTests |   |   |-- CoreServiceTests.swift |   |</code>-- URLSecurityTests.swift |   |-- CryptoTests |   |   |-- Mocks |   |   |-- CredentialManagerTests.swift |   |   <code>-- CryptoServiceTests.swift |   |-- ErrorHandlingTests |   |   |-- Errors |   |   |-- Extensions |   |   |-- Models |   |   |-- Protocols |   |   |-- Services |   |   |-- CommonErrorTests.swift |   |</code>-- CoreErrorTests.swift |   |-- LoggingTests |   |   |-- Errors |   |   |-- Extensions |   |   |-- Models |   |   |-- Protocols |   |   |-- Services |   |   <code>-- LoggingServiceTests.swift |   |-- RepositoriesTests |   |   |-- Errors |   |   |-- Extensions |   |   |-- Models |   |   |-- Protocols |   |</code>-- Services |   |-- ResticCLIHelperTests |   |   |-- Errors |   |   |-- Extensions |   |   |-- Models |   |   |-- Protocols |   |   <code>-- Services |   |-- SecurityTypesTests |   |   |-- MockSecurityProviderTests.swift |   |</code>-- SecurityErrorTests.swift |   |-- SecurityUtilsTests |   |   |-- EncryptedBookmarkServiceTests.swift |   |   <code>-- SecurityBookmarkServiceTests.swift |   |-- SnapshotsTests |   |   |-- Errors |   |   |-- Extensions |   |   |-- Models |   |   |-- Protocols |   |</code>-- Services |   |-- UmbraCoreTests |   |   <code>-- UmbraCoreTests.swift |</code>-- UmbraSecurityTests |       <code>-- SecurityServiceTests.swift |-- .gitignore |-- LICENSE |-- Package.resolved |-- Package.swift |-- README.md |-- STRUCTURE.md |-- UmbraCore.md</code>-- project_structure.md</p> <p>136 directories, 77 files</p>"},{"location":"project_structure/#umbracore-project-structure-documentation","title":"UmbraCore Project Structure Documentation","text":""},{"location":"project_structure/#project-overview","title":"Project Overview","text":"<ul> <li>Name: UmbraCore</li> <li>Version: 1.0.0</li> <li>Swift Version: 5.9.2/6.0.3</li> <li>Platform: macOS 14+</li> <li>Package Manager: Swift Package Manager (SPM)</li> </ul>"},{"location":"project_structure/#key-dependencies","title":"Key Dependencies","text":"<ul> <li>SwiftyBeaver: v2.1.1 (logging)</li> <li>CryptoSwift: v1.8.4 (crypto operations)</li> </ul>"},{"location":"project_structure/#core-components","title":"Core Components","text":""},{"location":"project_structure/#security-infrastructure","title":"Security Infrastructure","text":"<ul> <li>SecurityTypes Module: Core security types and protocols</li> <li>CryptoTypes Module: Cryptographic operations and types</li> <li>UmbraMocks Module: Mock implementations for testing</li> </ul>"},{"location":"project_structure/#implementation-details","title":"Implementation Details","text":"<ul> <li>Encryption: AES-256-GCM with combined auth mode</li> <li>Key Derivation: PBKDF2 with SHA-256 (10,000 iterations)</li> <li>IV Length: 12 bytes (GCM requirement)</li> <li>Salt Length: 32 bytes</li> <li>HMAC: SHA-256 based</li> </ul>"},{"location":"project_structure/#xpc-integration-in-progress","title":"XPC Integration (In Progress)","text":"<ul> <li>Core XPC infrastructure</li> <li>CryptoService XPC implementation</li> <li>SecurityService XPC implementation</li> </ul>"},{"location":"project_structure/#build-instructions","title":"Build Instructions","text":"<pre><code>swift build\nswift test\n</code></pre>"},{"location":"project_structure/#note","title":"Note","text":"<p>This structure snapshot was created on 2025-02-17 before implementing XPC services. Keep this file for reference in case rollback is needed.</p>"},{"location":"roadmap/","title":"UmbraCore Development Roadmap","text":"<p>This document outlines the development roadmap for UmbraCore, detailing both completed and planned features.</p>"},{"location":"roadmap/#common-requirements-across-applications","title":"Common Requirements Across Applications","text":"<p>UmbraCore serves as the foundation for multiple applications (Rbum, Rbx, ResticBar), sharing these core requirements:</p> <ul> <li>Core Restic Integration: Repository initialisation, backup operations, restoration</li> <li>Security &amp; Credentials: Password management, SSH keys, secure storage</li> <li>Configuration Management: Backup sources, exclusions, retention policies</li> <li>Progress &amp; Status: Monitoring, metrics, notifications</li> <li>Repository Management: Multi-repository support, health checks</li> <li>Scheduling System: Timed operations, maintenance</li> <li>State Management: History, status tracking, preferences</li> <li>Network Operations: Remote repository access, bandwidth control</li> </ul>"},{"location":"roadmap/#implementation-status","title":"Implementation Status","text":""},{"location":"roadmap/#tested-operable","title":"Tested &amp; Operable","text":"<ul> <li>Core Restic Integration<ul> <li>Command execution system</li> <li>Process management</li> <li>Output parsing</li> <li>Error handling</li> <li>Basic repository operations</li> </ul> </li> <li>Security Layer<ul> <li>Keychain integration</li> <li>XPC service implementation</li> <li>Secure data handling</li> <li>XPC protocol consolidation</li> </ul> </li> <li>Repository Management<ul> <li>Repository initialisation</li> <li>Repository health monitoring</li> <li>Multi-repository support</li> </ul> </li> <li>Testing Infrastructure<ul> <li>Unit testing framework</li> <li>Integration test suite</li> <li>Performance benchmarks</li> <li>Mock services</li> </ul> </li> </ul>"},{"location":"roadmap/#current-development-focus","title":"Current Development Focus","text":"<ul> <li>Security Enhancements<ul> <li>SSH key management</li> <li>Cloud provider credentials</li> <li>Repository password handling</li> </ul> </li> <li>Configuration System<ul> <li>Configuration format design</li> <li>Validation system</li> <li>Migration framework</li> </ul> </li> <li>Progress Monitoring<ul> <li>Progress protocol design</li> <li>Status update system</li> <li>Metrics collection</li> </ul> </li> </ul>"},{"location":"roadmap/#future-development","title":"Future Development","text":""},{"location":"roadmap/#short-term-goals-3-6-months","title":"Short-term Goals (3-6 months)","text":"<ul> <li>Advanced Repository Management<ul> <li>Statistics collection</li> <li>Space management</li> <li>Cache handling</li> </ul> </li> <li>Scheduling System<ul> <li>Schedule format design</li> <li>Timer implementation</li> <li>Queue management</li> <li>Conflict resolution</li> </ul> </li> <li>Network Operations<ul> <li>Connection management</li> <li>Protocol handlers</li> <li>Retry logic</li> <li>Rate limiting</li> </ul> </li> <li>State Management<ul> <li>State persistence design</li> <li>History tracking</li> <li>Recovery management</li> <li>Preference storage</li> </ul> </li> </ul>"},{"location":"roadmap/#mid-term-goals-6-12-months","title":"Mid-term Goals (6-12 months)","text":"<ul> <li>Statistics &amp; Analytics<ul> <li>Performance metrics</li> <li>Usage statistics</li> <li>Trend analysis</li> <li>Report generation</li> </ul> </li> <li>Health Monitoring<ul> <li>System diagnostics</li> <li>Performance monitoring</li> <li>Resource tracking</li> <li>Alert system</li> </ul> </li> <li>Event System<ul> <li>Event dispatching</li> <li>Notification management</li> <li>Webhook support</li> <li>Custom triggers</li> </ul> </li> <li>Cache Optimisation<ul> <li>Memory usage optimisation</li> <li>Disk cache management</li> <li>Network caching</li> <li>Cold/warm/hot cache strategies</li> </ul> </li> </ul>"},{"location":"roadmap/#long-term-goals-12-months","title":"Long-term Goals (12+ months)","text":"<ul> <li>Enhanced User Experience<ul> <li>Improved error messaging</li> <li>Contextual help</li> <li>Smart suggestions</li> <li>Accessibility features</li> </ul> </li> <li>Extended Platform Support<ul> <li>Linux compatibility</li> <li>Windows compatibility (where feasible)</li> <li>Cross-platform testing</li> </ul> </li> <li>Enterprise Features<ul> <li>Advanced logging</li> <li>Audit trails</li> <li>Team management</li> <li>Policy enforcement</li> </ul> </li> <li>Integration Ecosystem<ul> <li>Plugin architecture</li> <li>Integration with monitoring tools</li> <li>Backup verification workflows</li> <li>Scripting support</li> </ul> </li> </ul>"},{"location":"roadmap/#development-principles","title":"Development Principles","text":""},{"location":"roadmap/#1-security-first","title":"1. Security First","text":"<ul> <li>Defence in depth approach</li> <li>Zero trust architecture</li> <li>Regular security reviews</li> <li>Secure by default</li> </ul>"},{"location":"roadmap/#2-performance","title":"2. Performance","text":"<ul> <li>Minimal resource usage</li> <li>Responsive user interface</li> <li>Efficient background operations</li> <li>Optimised network usage</li> </ul>"},{"location":"roadmap/#3-reliability","title":"3. Reliability","text":"<ul> <li>Comprehensive error handling</li> <li>Graceful degradation</li> <li>Automatic recovery where possible</li> <li>Thorough logging</li> </ul>"},{"location":"roadmap/#4-maintainability","title":"4. Maintainability","text":"<ul> <li>Clean architecture</li> <li>Comprehensive documentation</li> <li>Consistent coding standards</li> <li>Automated testing</li> </ul>"},{"location":"roadmap/#5-user-experience","title":"5. User Experience","text":"<ul> <li>Intuitive interfaces</li> <li>Clear error messages</li> <li>Predictable behaviour</li> <li>Focus on developer workflows</li> </ul>"},{"location":"security-module-cleanup/","title":"UmbraCore Security Module Cleanup","text":"<p>This document tracks the progress of our security module consolidation efforts as outlined in the security-module-refactoring-architecture.md.</p>"},{"location":"security-module-cleanup/#progress-summary","title":"Progress Summary","text":""},{"location":"security-module-cleanup/#phase-1-establish-foundation-free-core-completed","title":"Phase 1: Establish Foundation-Free Core (Completed)","text":"<ul> <li>[x] Merged SecurityInterfacesProtocols and SecurityInterfacesBase into SecurityProtocolsCore</li> <li>[x] Consolidated duplicate SecurityError implementations</li> <li>[x] Added Equatable conformance to SecurityError and SecurityProtocolError</li> <li>[x] Removed self-imports in Swift files</li> <li>[x] Consolidated XPCServiceProtocolBase definitions</li> <li>[x] Created XPCServiceProtocolExtended protocol that builds upon XPCServiceProtocolBase</li> <li>[x] Standardized on SecureBytes for binary data consistently</li> <li>[x] Created BinaryData typealias for backward compatibility</li> <li>[x] Ensured all types in SecurityProtocolsCore are Sendable</li> </ul>"},{"location":"security-module-cleanup/#phase-2-implement-single-bridge-layer-completed","title":"Phase 2: Implement Single Bridge Layer (Completed)","text":"<ul> <li>[x] Consolidated all Foundation bridges into SecurityBridge</li> <li>[x] Implemented type converters for all domain types</li> <li>[x] Created SecurityBridgeErrorMapper for bidirectional error mapping</li> <li>[x] Created factory functions for module integration</li> <li>[x] Ensured proper error propagation</li> </ul>"},{"location":"security-module-cleanup/#phase-3-clean-implementation-layer-completed","title":"Phase 3: Clean Implementation Layer (Completed)","text":"<ul> <li>[x] Updated SecurityImplementation to use SecurityProtocolsCore</li> <li>[x] Refactored UmbraSecurity for clean service integration</li> <li>[x] Implemented generateRandomData across security module layers</li> <li>[x] Removed direct Foundation dependencies where possible</li> <li>[x] Enhanced test coverage with SecurityBridgeMigrationTests</li> </ul>"},{"location":"security-module-cleanup/#phase-4-remove-redundant-modules-completed","title":"Phase 4: Remove Redundant Modules (Completed)","text":"<ul> <li>[x] Remove SecurityInterfacesFoundationBase</li> <li>[x] Remove SecurityInterfacesFoundationBridge</li> <li>[x] Remove SecurityInterfacesFoundationCore</li> <li>[x] Remove SecurityInterfacesFoundationMinimal</li> <li>[x] Remove SecurityInterfacesFoundationNoFoundation</li> <li>[x] Remove SecurityProviderBridge (functionality moved to SecurityBridge)</li> <li>[x] Remove UmbraSecurityFoundation</li> </ul>"},{"location":"security-module-cleanup/#recently-completed-tasks","title":"Recently Completed Tasks","text":"<ol> <li>Removed Redundant Security Modules</li> <li>Successfully migrated all references from redundant modules to consolidated modules</li> <li>Created backups of all removed modules in security_module_removal_backup directory</li> <li>Updated imports across the codebase to use SecurityBridge and SecurityProtocolsCore</li> <li> <p>Cleaned up BUILD.bazel files to remove redundant dependencies</p> </li> <li> <p>Refactored Security Modules to Break Circular Dependencies</p> </li> <li>Created SecurityBridgeErrorMapper for bidirectional error mapping</li> <li>Fixed type conversion in XPCServiceProtocolBridge</li> <li>Implemented generateRandomData method in SecurityProviderBridge</li> <li> <p>Added appropriate tests for the bridge implementations</p> </li> <li> <p>Standardized on SecureBytes for Binary Data</p> </li> <li>Replaced BinaryData struct with SecureBytes in XPCServiceProtocolBase.swift</li> <li>Updated XPCServiceProtocolExtended.swift to use SecureBytes consistently</li> <li>Added import SecureBytes to affected files</li> <li> <p>Created BinaryDataTypealias.swift for backward compatibility</p> </li> <li> <p>Fixed Duplicate SecurityError Definitions</p> </li> <li>Removed duplicated SecurityProtocolError enum from SecurityError.swift</li> <li>Added Equatable conformance to SecurityProtocolError in XPCServiceProtocolBase.swift</li> <li> <p>Ensured consistent error handling across protocols</p> </li> <li> <p>Updated Import References</p> </li> <li>Changed SecurityInterfacesFoundationBridge.SecurityProviderFoundationAdapter to SecurityBridge.SecurityProviderFoundationAdapter</li> <li>Updated type references in SecurityService.swift and SecurityProviderFactory.swift</li> <li>Ensured consistent namespace usage across the project</li> </ol>"},{"location":"security-module-cleanup/#next-tasks","title":"Next Tasks","text":"<ol> <li>Documentation Updates</li> <li>Update architecture documentation to reflect the current state</li> <li>Document the bridge pattern usage and type conversion patterns</li> <li> <p>Create migration guides for other teams who may depend on our modules</p> </li> <li> <p>Performance Profiling</p> </li> <li>Measure the performance impact of bridge implementations</li> <li> <p>Optimize type conversions where necessary</p> </li> <li> <p>Testing and Verification</p> </li> <li>Run the complete test suite to ensure no regressions</li> <li>Verify all functionality works as expected post-module removal</li> <li>Check build times to measure improvement from reduced module count</li> </ol>"},{"location":"security-module-cleanup/#build-status","title":"Build Status","text":"<ul> <li>Current build state: Passing</li> <li>Last successful build: Merged to feature/remove-redundant-security-modules branch</li> <li>Known issues: None significant, completed module removal phase</li> </ul>"},{"location":"security-module-cleanup/#module-removal-process-summary","title":"Module Removal Process Summary","text":""},{"location":"security-module-cleanup/#redundant-modules-removed","title":"Redundant Modules Removed","text":"<p>The following modules were identified as redundant and successfully removed:</p> <ol> <li>UmbraSecurityFoundation (0 imports)</li> <li> <p>Replacement: UmbraSecurityBridge</p> </li> <li> <p>SecurityInterfacesFoundationBridge (9 imports, 9 files)</p> </li> <li> <p>Replacement: SecurityBridge</p> </li> <li> <p>SecurityProviderBridge (4 imports, 4 files)</p> </li> <li>Replacement: SecurityBridge</li> </ol>"},{"location":"security-module-cleanup/#module-analyser-tool","title":"Module Analyser Tool","text":"<p>A dedicated tool was created to safely analyse, verify, and remove the redundant security modules:</p> <ul> <li><code>module_analyser.go</code>: Identifies redundant modules and their dependencies</li> <li><code>analyse_modules.sh</code>: Helper script to run the analyser with the correct environment</li> </ul> <p>The tools provide the following functionality:</p> <ol> <li>Identify redundant modules and their dependencies</li> <li>Determine if modules are safe to remove</li> <li>Create backups before removal</li> <li>Update import statements automatically</li> <li>Remove redundant module directories and files</li> </ol>"},{"location":"security-module-cleanup/#safety-features","title":"Safety Features","text":"<p>The module analyser includes several safety features:</p> <ul> <li>Creates full backups of all removed modules</li> <li>Detailed logging of all actions</li> <li>Verification step to ensure modules can be safely removed</li> <li>Support for both analysis and automated removal</li> </ul>"},{"location":"security-module-cleanup/#notes","title":"Notes","text":"<ul> <li>The major architectural improvements have been completed</li> <li>We've successfully broken all circular dependencies</li> <li>Module count has been reduced from 56 to 53</li> <li>Import statements have been updated to use the consolidated modules</li> <li>The project structure is now more maintainable and follows the architectural guidelines</li> <li>The security module architecture now aligns with the UmbraCore Refactoring Plan</li> </ul>"},{"location":"security-module-cleanup/#current-architecture","title":"Current Architecture","text":"<p>The security module architecture now follows the simplified structure outlined in the Security Module Refactoring Plan:</p> <ol> <li>Core Foundation-Free Layer</li> <li> <p>SecurityProtocolsCore: Core protocols and types with no Foundation dependencies</p> </li> <li> <p>Bridge Layer</p> </li> <li> <p>SecurityBridge: Single bridge module that handles Foundation and foundation-free type conversions</p> </li> <li> <p>Implementation Layer</p> </li> <li>SecurityImplementation: Concrete implementations of security interfaces</li> <li>UmbraSecurity: Higher-level security services and providers</li> </ol>"},{"location":"security-module-refactoring-architecture/","title":"UmbraCore Security Module Refactoring Architecture","text":""},{"location":"security-module-refactoring-architecture/#executive-summary","title":"Executive Summary","text":"<p>This document outlines the architecture for refactoring the UmbraCore security modules based on the UmbraCore Refactoring Plan and Security Module Migration. The goal is to consolidate redundant modules, break circular dependencies, and establish a clean architecture with clear separation between Foundation-dependent and Foundation-free components.</p>"},{"location":"security-module-refactoring-architecture/#current-module-analysis","title":"Current Module Analysis","text":""},{"location":"security-module-refactoring-architecture/#module-fragmentation-issues","title":"Module Fragmentation Issues","text":"<p>The security components are currently fragmented across multiple modules:</p> Module Category Current Modules Issues Protocol Definitions SecurityInterfaces, SecurityInterfacesBase, SecurityInterfacesProtocols, SecurityProtocolsCore Duplicate protocols, unclear ownership, circular dependencies Foundation Bridges SecurityInterfacesFoundation, SecurityInterfacesFoundationBridge, SecurityProviderBridge Overlapping responsibilities, ambiguous type references Implementations UmbraSecurity, SecurityImplementation Mixed concerns, direct Foundation dependencies Supporting Types SecurityTypes, SecureBytes, CryptoTypes Inconsistent usage, multiple versions of similar types"},{"location":"security-module-refactoring-architecture/#key-circular-dependencies","title":"Key Circular Dependencies","text":"<ol> <li><code>SecurityInterfaces</code> \u2194 <code>SecurityInterfacesFoundation</code></li> <li><code>SecurityBridge</code> \u2194 <code>SecurityInterfacesFoundationBridge</code></li> <li><code>UmbraSecurity</code> \u2194 <code>SecurityImplementation</code></li> </ol>"},{"location":"security-module-refactoring-architecture/#target-architecture","title":"Target Architecture","text":"<p>We will consolidate the modules into a clean, layered architecture:</p>"},{"location":"security-module-refactoring-architecture/#1-core-foundation-free-layer","title":"1. Core Foundation-Free Layer","text":"<p>Primary Module: <code>SecurityProtocolsCore</code></p> <ul> <li>Contains only foundation-free protocols and types</li> <li>Uses <code>SecureBytes</code> for binary data representation</li> <li>No direct or indirect Foundation dependencies</li> <li>Core protocols:</li> <li><code>SecurityProviderProtocol</code></li> <li><code>CryptoServiceProtocol</code></li> <li><code>KeyManagementProtocol</code></li> <li>Core types:</li> <li><code>SecurityError</code></li> <li><code>SecurityOperation</code></li> <li><code>SecurityConfigDTO</code></li> <li><code>SecurityResultDTO</code></li> </ul>"},{"location":"security-module-refactoring-architecture/#2-foundation-bridge-layer","title":"2. Foundation Bridge Layer","text":"<p>Primary Module: <code>SecurityBridge</code></p> <ul> <li>Single point of integration between Foundation and foundation-free types</li> <li>Contains adapters and type converters</li> <li>Depends on <code>SecurityProtocolsCore</code> and Foundation</li> <li>Key components:</li> <li><code>DataAdapter</code>: Converts between <code>Data</code> and <code>SecureBytes</code></li> <li><code>URLAdapter</code>: Converts between <code>URL</code> and <code>ResourceLocator</code></li> <li><code>FoundationSecurityProvider</code>: Foundation-specific security provider</li> <li>Protocol adapters for all core protocols</li> </ul>"},{"location":"security-module-refactoring-architecture/#3-implementation-layer","title":"3. Implementation Layer","text":"<p>Primary Module: <code>SecurityImplementation</code></p> <ul> <li>Concrete implementations of security protocols</li> <li>May have Foundation dependencies (through <code>SecurityBridge</code>)</li> <li>Contains service implementations and factories</li> <li>Example components:</li> <li><code>DefaultSecurityProvider</code></li> <li><code>CryptoServiceImpl</code></li> <li><code>KeyManagementImpl</code></li> </ul> <p>Primary Module: <code>UmbraSecurity</code></p> <ul> <li>High-level security service used by client code</li> <li>Orchestrates security operations</li> <li>Handles security-scoped bookmarks</li> <li>Key components:</li> <li><code>SecurityService</code></li> <li><code>BookmarkService</code></li> </ul>"},{"location":"security-module-refactoring-architecture/#4-binary-data-foundation","title":"4. Binary Data Foundation","text":"<p>Primary Module: <code>SecureBytes</code></p> <ul> <li>Core binary data representation</li> <li>Zero Foundation dependencies</li> <li>Fully Sendable for Swift concurrency</li> <li>Memory-secure implementations</li> <li>Used by all foundation-free modules</li> </ul>"},{"location":"security-module-refactoring-architecture/#module-dependency-diagram","title":"Module Dependency Diagram","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Client Code   \u2502\u2500\u2500\u2500\u2500\u2500\u25ba\u2502 UmbraSecurity \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                 \u2502\n                                 \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   SecureBytes   \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2524SecurityBridge \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u25b2                       \u2502\n         \u2502                       \u25bc\n         \u2502               \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524SecurityProtocolsCore\u2502\n                         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"security-module-refactoring-architecture/#type-mapping-strategy","title":"Type Mapping Strategy","text":"Domain Concept Foundation-Free Type Foundation Type Bridge Function Binary Data <code>SecureBytes</code> <code>Data</code> <code>DataAdapter.toSecureBytes(data)</code> Resource Location <code>ResourceLocator</code> <code>URL</code> <code>URLAdapter.toResourceLocator(url)</code> Error <code>SecurityError</code> <code>NSError</code> <code>ErrorAdapter.toSecurityError(error)</code> Configuration <code>SecurityConfigDTO</code> <code>SecurityConfiguration</code> <code>ConfigAdapter.toDTO(config)</code>"},{"location":"security-module-refactoring-architecture/#module-consolidation-plan","title":"Module Consolidation Plan","text":""},{"location":"security-module-refactoring-architecture/#phase-1-establish-foundation-free-core","title":"Phase 1: Establish Foundation-Free Core","text":"<ol> <li>Audit and consolidate <code>SecurityProtocolsCore</code></li> <li>Ensure all core protocols are defined here</li> <li>Remove any Foundation dependencies</li> <li>Ensure Sendable conformance</li> <li> <p>Standardize on <code>SecureBytes</code> for binary data</p> </li> <li> <p>Create comprehensive error model in <code>SecurityProtocolsCore.SecurityError</code></p> </li> <li>Define all security error cases</li> <li>Provide localization keys</li> <li>Document error recovery options</li> </ol>"},{"location":"security-module-refactoring-architecture/#phase-2-implement-single-bridge-layer","title":"Phase 2: Implement Single Bridge Layer","text":"<ol> <li>Consolidate all Foundation bridges into <code>SecurityBridge</code></li> <li>Migrate adapters from <code>SecurityInterfacesFoundationBridge</code></li> <li>Implement type converters for all domain types</li> <li> <p>Ensure proper error propagation</p> </li> <li> <p>Create factory functions for module integration</p> </li> <li>Simplify creation of security services</li> <li>Provide default implementations</li> <li>Support dependency injection</li> </ol>"},{"location":"security-module-refactoring-architecture/#phase-3-clean-implementation-layer","title":"Phase 3: Clean Implementation Layer","text":"<ol> <li>Update <code>SecurityImplementation</code> to use <code>SecurityProtocolsCore</code></li> <li>Remove direct Foundation dependencies</li> <li>Use bridge layer for Foundation operations</li> <li> <p>Implement all required protocols</p> </li> <li> <p>Refactor <code>UmbraSecurity</code> for clean service integration</p> </li> <li>Focus on high-level security operations</li> <li>Use factories from bridge layer</li> <li>Maintain backward compatibility</li> </ol>"},{"location":"security-module-refactoring-architecture/#phase-4-remove-redundant-modules","title":"Phase 4: Remove Redundant Modules","text":"<p>After successful migration, remove these redundant modules: - <code>SecurityInterfacesFoundationBase</code> - <code>SecurityInterfacesFoundationBridge</code> - <code>SecurityInterfacesFoundationCore</code> - <code>SecurityInterfacesFoundationMinimal</code> - <code>SecurityInterfacesFoundationNoFoundation</code> - <code>SecurityProviderBridge</code> (functionality moved to <code>SecurityBridge</code>)</p>"},{"location":"security-module-refactoring-architecture/#implementation-guidelines","title":"Implementation Guidelines","text":""},{"location":"security-module-refactoring-architecture/#protocol-consolidation","title":"Protocol Consolidation","text":"<p>For each protocol currently defined in multiple places:</p> <ol> <li>Choose one canonical location in <code>SecurityProtocolsCore</code></li> <li>Update all implementations to conform to this protocol</li> <li>Create adapters in <code>SecurityBridge</code> if Foundation types are needed</li> </ol>"},{"location":"security-module-refactoring-architecture/#error-handling","title":"Error Handling","text":"<ol> <li>Define a single <code>SecurityError</code> enum in <code>SecurityProtocolsCore</code></li> <li>Use Result for error propagation <li>Create mapping functions in <code>SecurityBridge</code> for NSError conversion</li>"},{"location":"security-module-refactoring-architecture/#sendable-conformance","title":"Sendable Conformance","text":"<ol> <li>All types in <code>SecurityProtocolsCore</code> must be Sendable</li> <li>Use actor isolation for state management</li> <li>Avoid shared mutable state</li> </ol>"},{"location":"security-module-refactoring-architecture/#module-verification","title":"Module Verification","text":"<p>After implementing each phase, verify: 1. No circular dependencies (use <code>dependency_analyzer.sh</code>) 2. All tests pass (run appropriate test suites) 3. Client code integrates correctly</p>"},{"location":"security-module-refactoring-architecture/#migration-path-for-client-code","title":"Migration Path for Client Code","text":"<ol> <li>Update import statements</li> <li>Replace <code>import SecurityInterfaces</code> with <code>import SecurityProtocolsCore</code></li> <li> <p>Replace <code>import SecurityInterfacesFoundation*</code> with <code>import SecurityBridge</code></p> </li> <li> <p>Update type usage</p> </li> <li>Replace Foundation types with domain types</li> <li> <p>Use adapters for type conversion</p> </li> <li> <p>Verify protocol conformance</p> </li> <li>Ensure all required methods are implemented</li> <li>Check Sendable conformance where needed</li> </ol>"},{"location":"security-module-refactoring-architecture/#conclusion","title":"Conclusion","text":"<p>This architecture provides a clean separation of concerns, breaks circular dependencies, and reduces module count while maintaining functionality and performance. By following this plan, we will achieve the goals outlined in the UmbraCore Refactoring Plan while ensuring a smooth migration path for client code.</p>"},{"location":"security-module-refactoring-summary/","title":"Security Module Refactoring - Summary","text":""},{"location":"security-module-refactoring-summary/#objectives-completed","title":"Objectives Completed","text":"<p>We have successfully completed the refactoring of UmbraCore's security modules with the following key improvements:</p> <ol> <li>Broken Circular Dependencies: </li> <li>Eliminated circular dependencies between Foundation and security modules</li> <li> <p>Created clear architectural boundaries between Foundation-dependent and Foundation-free code</p> </li> <li> <p>Improved Type Bridging:</p> </li> <li>Implemented robust type conversion adapters between Foundation types and core types</li> <li>Added error mapping utilities for bidirectional error conversion</li> <li> <p>Enhanced the binary data conversion to ensure type safety</p> </li> <li> <p>Enhanced Protocol Adapters:</p> </li> <li>Added the <code>generateRandomData</code> method to bridge protocols</li> <li>Updated XPC service protocol bridges for consistent Foundation/non-Foundation type handling</li> <li> <p>Implemented robust error handling throughout the bridge implementations</p> </li> <li> <p>Test Infrastructure:</p> </li> <li>Fixed and enhanced test coverage for the bridge implementations</li> <li>Ensured all tests pass with the new architecture</li> </ol>"},{"location":"security-module-refactoring-summary/#architectural-benefits","title":"Architectural Benefits","text":"<p>The refactored security module architecture now provides:</p> <ol> <li>Clear Layer Separation:</li> <li>Core Foundation-Free Layer (SecurityProtocolsCore)</li> <li>Foundation Bridge Layer (SecurityBridge, SecurityInterfacesFoundationBridge)</li> <li> <p>Implementation Layer (SecurityImplementation and UmbraSecurity)</p> </li> <li> <p>Improved Modularity:</p> </li> <li>Each module has a clear responsibility</li> <li>Dependency flow is unidirectional</li> <li> <p>Foundation dependencies are isolated to specific bridge modules</p> </li> <li> <p>Enhanced Testability:</p> </li> <li>Foundation-free protocols can be tested without Foundation</li> <li>Bridge layers can be mocked and tested separately</li> <li>Implementation can be tested against protocols</li> </ol>"},{"location":"security-module-refactoring-summary/#next-steps","title":"Next Steps","text":"<p>To complete the security module refactoring:</p> <ol> <li>Documentation Update:</li> <li>Update the architecture documentation to reflect current state</li> <li> <p>Document the bridge pattern usage and type conversion guidance</p> </li> <li> <p>Performance Profiling:</p> </li> <li>Measure the performance impact of the bridge implementations</li> <li> <p>Optimize type conversions where necessary</p> </li> <li> <p>Further Consolidation:</p> </li> <li>Consider further module consolidation where appropriate</li> <li>Remove any redundant code that was kept for backward compatibility</li> </ol> <p>This refactoring represents a significant improvement in UmbraCore's architecture, making it more modular, testable, and maintainable.</p>"},{"location":"swift_style_guide/","title":"UmbraCore Swift Style Guide","text":"<p>This style guide is adapted from the Google Swift Style Guide and customized for UmbraCore development. It's designed to ensure consistency and maintainability as our codebase grows.</p>"},{"location":"swift_style_guide/#file-basics","title":"File Basics","text":""},{"location":"swift_style_guide/#file-names","title":"File Names","text":"<ul> <li>Match the name of the primary type declared in the file</li> <li>Use <code>.swift</code> extension</li> <li>Use UpperCamelCase (PascalCase)</li> <li>Be descriptive and avoid abbreviations</li> </ul> <pre><code>// Good\nNetworkManager.swift\nUserAuthentication.swift\n\n// Bad\nNetMgr.swift\nUserAuth.swift\n</code></pre>"},{"location":"swift_style_guide/#file-organization","title":"File Organization","text":"<ol> <li>Copyright notice and license information</li> <li>Import statements</li> <li>Type and extension declarations</li> </ol>"},{"location":"swift_style_guide/#import-statements","title":"Import Statements","text":"<ul> <li>Sort imports alphabetically</li> <li>Foundation and system imports first, then other imports</li> <li>No duplicate imports</li> </ul> <pre><code>import Foundation\nimport OSLog\nimport SwiftUI\n\nimport CoreServices\nimport SecurityTypes\nimport UmbraLogging\n</code></pre>"},{"location":"swift_style_guide/#naming","title":"Naming","text":""},{"location":"swift_style_guide/#general-naming-rules","title":"General Naming Rules","text":"<ul> <li>Names should be self-explanatory and descriptive</li> <li>Avoid abbreviations except for widely accepted ones (URL, ID)</li> <li>Use British English for user-facing strings</li> <li>Use American English for code identifiers to match Swift standard library</li> </ul>"},{"location":"swift_style_guide/#type-names","title":"Type Names","text":"<ul> <li>Use UpperCamelCase (PascalCase) for all types</li> <li>Use nouns for types that represent things</li> <li>Prefix protocols that describe what something is with a noun</li> <li>Suffix protocols that describe a capability with <code>-able</code>, <code>-ible</code>, or <code>-ing</code></li> </ul> <pre><code>// Types\nstruct DatabaseConnection\nclass SecurityManager\n\n// Protocols\nprotocol Document  // describes what something is\nprotocol Searchable  // describes a capability\nprotocol Encrypting  // describes a capability\n</code></pre>"},{"location":"swift_style_guide/#variable-and-constant-names","title":"Variable and Constant Names","text":"<ul> <li>Use lowerCamelCase</li> <li>Be descriptive but concise</li> <li>Avoid single-letter names except in mathematical contexts</li> <li>Include type information in the name only when it adds clarity</li> </ul> <pre><code>// Good\nlet maxRetryCount = 3\nvar currentUserProfile: UserProfile\n\n// Bad\nlet max = 3\nvar profile = UserProfile()\n</code></pre>"},{"location":"swift_style_guide/#function-and-method-names","title":"Function and Method Names","text":"<ul> <li>Use lowerCamelCase</li> <li>Use verb phrases to describe what the function does</li> <li>Use descriptive parameter labels</li> <li>When the first parameter is part of the natural phrase, omit its label</li> </ul> <pre><code>// Good\nfunc remove(at index: Int)\nfunc convertToMeters(from length: Double, unit: LengthUnit) -&gt; Double\n\n// Bad\nfunc remove(index: Int)\nfunc convertToMeters(length: Double, unit: LengthUnit) -&gt; Double\n</code></pre>"},{"location":"swift_style_guide/#formatting","title":"Formatting","text":""},{"location":"swift_style_guide/#indentation-and-line-wrapping","title":"Indentation and Line Wrapping","text":"<ul> <li>Use 4 spaces for indentation (not tabs)</li> <li>Limit line length to 100 characters where possible</li> <li>When wrapping lines, indent continuation lines by 4 spaces</li> </ul>"},{"location":"swift_style_guide/#braces","title":"Braces","text":"<ul> <li>Opening braces on the same line as the statement</li> <li>Closing braces on a new line</li> <li>Always include braces for control flow statements, even for single-line bodies</li> </ul> <pre><code>if condition {\n    doSomething()\n} else {\n    doSomethingElse()\n}\n</code></pre>"},{"location":"swift_style_guide/#spacing","title":"Spacing","text":"<ul> <li>Single space after keywords (if, guard, for, etc.)</li> <li>No space between function name and opening parenthesis</li> <li>No spaces inside parentheses</li> <li>Single space around binary operators</li> </ul> <pre><code>let result = (a + b) * (c - d)\nif condition {\n    func(param1, param2)\n}\n</code></pre>"},{"location":"swift_style_guide/#types-and-declarations","title":"Types and Declarations","text":""},{"location":"swift_style_guide/#value-vs-reference-types","title":"Value vs. Reference Types","text":"<ul> <li>Prefer structs over classes when:</li> <li>The primary purpose is to encapsulate data</li> <li>Copying behavior is desired</li> <li> <p>There's no need for inheritance</p> </li> <li> <p>Use classes when:</p> </li> <li>Identity is important</li> <li>Inheritance is needed</li> <li>The lifetime of instances needs to be controlled</li> </ul>"},{"location":"swift_style_guide/#properties","title":"Properties","text":"<ul> <li>Use computed properties rather than methods when the operation:</li> <li>Does not modify self</li> <li>Is cheap to compute</li> <li>Returns the same value each time it's called with the same inputs</li> <li>Does not have side effects</li> </ul> <pre><code>// Good\nvar diameter: Double {\n    return radius * 2\n}\n\n// Instead of\nfunc calculateDiameter() -&gt; Double {\n    return radius * 2\n}\n</code></pre>"},{"location":"swift_style_guide/#access-control","title":"Access Control","text":"<ul> <li>Be explicit about access control modifiers</li> <li>Use the most restrictive level that makes sense</li> <li>Order from most restrictive to least restrictive: <code>private</code>, <code>fileprivate</code>, <code>internal</code>, <code>public</code>, <code>open</code></li> </ul> <pre><code>public class NetworkManager {\n    private let apiKey: String\n    internal var session: URLSession\n\n    public func fetch(url: URL) -&gt; Data { ... }\n}\n</code></pre>"},{"location":"swift_style_guide/#functions-and-methods","title":"Functions and Methods","text":""},{"location":"swift_style_guide/#parameter-lists","title":"Parameter Lists","text":"<ul> <li>Keep parameter lists short when possible</li> <li>Consider grouping related parameters into structures</li> <li>Use default parameter values when appropriate</li> </ul>"},{"location":"swift_style_guide/#in-out-parameters","title":"In-Out Parameters","text":"<ul> <li>Use sparingly and only when the behavior would be otherwise surprising</li> <li>Place in-out parameters at the end of the parameter list when possible</li> </ul> <pre><code>func swap(_ a: inout Int, _ b: inout Int)\n</code></pre>"},{"location":"swift_style_guide/#control-flow","title":"Control Flow","text":""},{"location":"swift_style_guide/#guard-statements","title":"Guard Statements","text":"<ul> <li>Use <code>guard</code> statements for early returns</li> <li>Handle the \"failure\" case immediately after the guard</li> <li>Keep the guarded code at the same indentation level as the guard</li> </ul> <pre><code>guard let value = optionalValue else {\n    return\n}\n// Use value...\n</code></pre>"},{"location":"swift_style_guide/#optionals","title":"Optionals","text":"<ul> <li>Avoid force unwrapping (<code>!</code>) except in tests or when you're certain</li> <li>Prefer optional binding and nil coalescing over force unwrapping</li> <li>Use implicitly unwrapped optionals (<code>!</code> in type) only when appropriate</li> </ul> <pre><code>// Good\nif let value = optionalValue {\n    use(value)\n}\n\nlet value = optionalValue ?? defaultValue\n\n// Avoid when possible\nlet value = optionalValue!\n</code></pre>"},{"location":"swift_style_guide/#documentation","title":"Documentation","text":""},{"location":"swift_style_guide/#documentation-comments","title":"Documentation Comments","text":"<ul> <li>Document all public declarations</li> <li>Use Swift's standard documentation format (triple-slash <code>///</code> comments)</li> <li>Include parameter, returns, and throws descriptions</li> <li>Document edge cases and preconditions</li> </ul> <pre><code>/// Retrieves the user profile from the server.\n///\n/// - Parameters:\n///   - userId: The ID of the user to fetch\n///   - includeDetails: Whether to include detailed information\n/// - Returns: The user profile\n/// - Throws: `NetworkError` if the request fails\npublic func fetchUserProfile(userId: String, includeDetails: Bool = false) throws -&gt; UserProfile\n</code></pre>"},{"location":"swift_style_guide/#code-comments","title":"Code Comments","text":"<ul> <li>Use comments to explain \"why\", not \"what\"</li> <li>Keep comments up to date when code changes</li> <li>Use <code>// MARK: - Section Name</code> to organize code into logical sections</li> </ul>"},{"location":"swift_style_guide/#swift-specific-features","title":"Swift Specific Features","text":""},{"location":"swift_style_guide/#error-handling","title":"Error Handling","text":"<ul> <li>Use Swift's <code>throw</code>/<code>catch</code> system for error handling</li> <li>Define dedicated error types with clear case names</li> <li>Provide descriptive error messages</li> </ul> <pre><code>enum NetworkError: Error {\n    case invalidURL\n    case connectionFailed(reason: String)\n    case serverError(statusCode: Int)\n}\n</code></pre>"},{"location":"swift_style_guide/#extensions","title":"Extensions","text":"<ul> <li>Use extensions to organize code by functionality</li> <li>Put protocol conformances in separate extensions</li> <li>Name extensions for clarity when extending external types</li> </ul> <pre><code>// Protocol conformance in extension\nextension User: Equatable {\n    static func == (lhs: User, rhs: User) -&gt; Bool {\n        return lhs.id == rhs.id\n    }\n}\n\n// Functionality extension\nextension User {\n    func promoteToAdmin() {\n        role = .admin\n        permissionLevel = .full\n    }\n}\n</code></pre>"},{"location":"swift_style_guide/#concurrency","title":"Concurrency","text":"<ul> <li>Prefer modern Swift concurrency (async/await) over completion handlers</li> <li>Mark functions that can throw or suspend with appropriate keywords</li> <li>Use task groups for concurrent operations</li> <li>Avoid explicit use of <code>DispatchQueue</code> when Swift concurrency can be used</li> </ul> <pre><code>// Modern concurrency\nfunc fetchData() async throws -&gt; Data {\n    let (data, response) = try await URLSession.shared.data(from: url)\n    guard let httpResponse = response as? HTTPURLResponse,\n          httpResponse.statusCode == 200 else {\n        throw NetworkError.invalidResponse\n    }\n    return data\n}\n</code></pre>"},{"location":"swift_style_guide/#bazel-and-build-system","title":"Bazel and Build System","text":""},{"location":"swift_style_guide/#build-file-organization","title":"BUILD File Organization","text":"<ul> <li>Sort dependencies alphabetically</li> <li>Group dependencies by type (internal, external)</li> <li>Keep BUILD files minimal and focused</li> </ul> <pre><code>umbra_swift_library(\n    name = \"NetworkService\",\n    srcs = glob([\"*.swift\"]),\n    deps = [\n        # Internal dependencies\n        \"//Sources/CoreTypes\",\n        \"//Sources/LoggingService\",\n\n        # External dependencies\n        \"@swift_protobuf//:SwiftProtobuf\",\n    ],\n)\n</code></pre>"},{"location":"swift_style_guide/#memory-management","title":"Memory Management","text":""},{"location":"swift_style_guide/#capturing-variables","title":"Capturing Variables","text":"<ul> <li>Be explicit about capturing variables in closures to avoid retain cycles</li> <li>Use <code>[weak self]</code> or <code>[unowned self]</code> when appropriate</li> <li>Always check if <code>[weak self]</code> is nil before using it</li> </ul> <pre><code>networkManager.fetchData { [weak self] result in\n    guard let self = self else { return }\n    self.handleResult(result)\n}\n</code></pre>"},{"location":"swift_style_guide/#testing","title":"Testing","text":""},{"location":"swift_style_guide/#test-structure","title":"Test Structure","text":"<ul> <li>Use descriptive names for test methods</li> <li>Structure tests as \"given-when-then\" or \"arrange-act-assert\"</li> <li>Test edge cases and error conditions</li> <li>One assertion per test when possible</li> </ul> <pre><code>func testUserAuthentication_WithValidCredentials_ReturnsSuccess() {\n    // Given\n    let validCredentials = Credentials(username: \"test\", password: \"password\")\n\n    // When\n    let result = authenticator.authenticate(credentials: validCredentials)\n\n    // Then\n    XCTAssertEqual(result, .success)\n}\n</code></pre>"},{"location":"swift_style_guide/#references","title":"References","text":"<ul> <li>Google Swift Style Guide</li> <li>Swift API Design Guidelines</li> <li>Swift.org Documentation</li> </ul>"},{"location":"swift_style_guide/#automated-formatting-with-swiftformat","title":"Automated Formatting with SwiftFormat","text":"<p>UmbraCore uses SwiftFormat version 0.55.5 to automatically enforce many style rules in this guide. The configuration is defined in the <code>.swiftformat</code> file at the project root.</p>"},{"location":"swift_style_guide/#usage","title":"Usage","text":"<p>Run the formatting script to format all Swift files in the project:</p> <pre><code>./scripts/format_code.sh\n</code></pre> <p>To only check if files are formatted without modifying them:</p> <pre><code>./scripts/format_code.sh --check\n</code></pre> <p>To format only staged files:</p> <pre><code>./scripts/format_code.sh --staged-only\n</code></pre>"},{"location":"swift_style_guide/#key-formatting-rules","title":"Key Formatting Rules","text":"<p>The SwiftFormat configuration enforces the following key style elements:</p> <ul> <li>2-space indentation</li> <li>100 character line length</li> <li>Consistent brace styles (same-line opening braces)</li> <li>Trailing commas in multi-line arrays and dictionaries</li> <li>Consistent spacing around operators and parentheses</li> <li>Alphabetized imports</li> <li>Standard modifier ordering (<code>public</code>, <code>open</code>, <code>package</code>, <code>internal</code>, <code>private</code>, <code>fileprivate</code>, etc.)</li> <li>Hoisted pattern let bindings</li> <li>No trailing whitespace</li> <li>And many other rules...</li> </ul> <p>For a complete list of rules, refer to the SwiftFormat documentation and the <code>.swiftformat</code> file in the project root.</p>"},{"location":"swift_style_guide/#integration-with-build-system","title":"Integration with Build System","text":"<p>To ensure consistent code style across the project, consider adding the SwiftFormat check to your pre-commit hook or CI pipeline.</p>"},{"location":"swift_style_guide/#conflicts-with-existing-style-guide","title":"Conflicts with Existing Style Guide","text":"<p>In cases where the automated formatting conflicts with this style guide, the SwiftFormat configuration takes precedence. If you believe the configuration should be adjusted, please open a discussion with the team.</p>"},{"location":"xpc_implementation_plan/","title":"UmbraCore XPC Implementation Plan","text":""},{"location":"xpc_implementation_plan/#overview","title":"Overview","text":"<p>Document Version: 1.0.0 Date: 2025-02-17 Status: In Progress</p>"},{"location":"xpc_implementation_plan/#1-architecture-changes","title":"1. Architecture Changes","text":""},{"location":"xpc_implementation_plan/#current-architecture","title":"Current Architecture","text":"<pre><code>UmbraCore/\n\u251c\u2500\u2500 CryptoTypes/\n\u2502   \u2514\u2500\u2500 Services/\n\u2502       \u251c\u2500\u2500 CryptoService.swift       # Direct crypto operations\n\u2502       \u2514\u2500\u2500 CredentialManager.swift    # Direct credential management\n\u2514\u2500\u2500 SecurityTypes/\n    \u2514\u2500\u2500 Protocols/\n        \u2514\u2500\u2500 SecurityProvider.swift     # Direct security operations\n</code></pre>"},{"location":"xpc_implementation_plan/#target-architecture","title":"Target Architecture","text":"<pre><code>UmbraCore/\n\u251c\u2500\u2500 XPC/\n\u2502   \u251c\u2500\u2500 Core/                         # XPC infrastructure\n\u2502   \u2502   \u251c\u2500\u2500 XPCError.swift\n\u2502   \u2502   \u251c\u2500\u2500 XPCServiceProtocols.swift\n\u2502   \u2502   \u2514\u2500\u2500 XPCConnectionManager.swift\n\u2502   \u251c\u2500\u2500 CryptoService/               # Crypto XPC service\n\u2502   \u2502   \u251c\u2500\u2500 CryptoXPCService.swift\n\u2502   \u2502   \u2514\u2500\u2500 Info.plist\n\u2502   \u2514\u2500\u2500 SecurityService/             # Security XPC service\n\u2502       \u251c\u2500\u2500 SecurityXPCService.swift\n\u2502       \u2514\u2500\u2500 Info.plist\n\u2514\u2500\u2500 [existing modules remain]\n</code></pre>"},{"location":"xpc_implementation_plan/#2-migration-strategy","title":"2. Migration Strategy","text":""},{"location":"xpc_implementation_plan/#phase-1-infrastructure-current","title":"Phase 1: Infrastructure (Current)","text":"<ul> <li>[x] Create XPC Core module</li> <li>[x] Define XPC protocols</li> <li>[x] Implement connection management</li> <li>[x] Add error handling</li> </ul>"},{"location":"xpc_implementation_plan/#phase-2-service-implementation","title":"Phase 2: Service Implementation","text":"<ul> <li>[ ] Create CryptoXPCService</li> <li>[ ] Implement service bundle</li> <li>[ ] Add privilege separation</li> <li>[ ] Set up entitlements</li> <li> <p>[ ] Configure sandbox</p> </li> <li> <p>[ ] Create SecurityXPCService</p> </li> <li>[ ] Implement service bundle</li> <li>[ ] Add privilege separation</li> <li>[ ] Set up entitlements</li> <li>[ ] Configure sandbox</li> </ul>"},{"location":"xpc_implementation_plan/#phase-3-client-updates","title":"Phase 3: Client Updates","text":"<ul> <li>[ ] Update CredentialManager</li> <li>[ ] Add XPC client implementation</li> <li>[ ] Implement fallback mechanism</li> <li> <p>[ ] Add connection recovery</p> </li> <li> <p>[ ] Update SecurityProvider clients</p> </li> <li>[ ] Add XPC client implementation</li> <li>[ ] Implement fallback mechanism</li> <li>[ ] Add connection recovery</li> </ul>"},{"location":"xpc_implementation_plan/#phase-4-testing-validation","title":"Phase 4: Testing &amp; Validation","text":"<ul> <li>[ ] Create XPCTests target</li> <li>[ ] Implement service tests</li> <li>[ ] Add connection tests</li> <li>[ ] Test error scenarios</li> <li>[ ] Validate security boundaries</li> </ul>"},{"location":"xpc_implementation_plan/#3-security-considerations","title":"3. Security Considerations","text":""},{"location":"xpc_implementation_plan/#privilege-separation","title":"Privilege Separation","text":"<pre><code>// Example service configuration\nlet connection = NSXPCConnection(serviceName: \"com.umbracore.cryptoservice\")\nconnection.remoteObjectInterface = NSXPCInterface(with: CryptoXPCServiceProtocol.self)\nconnection.auditSessionIdentifier = au_session_self()\n</code></pre>"},{"location":"xpc_implementation_plan/#entitlements","title":"Entitlements","text":"<pre><code>&lt;!-- Required entitlements --&gt;\n&lt;key&gt;com.apple.security.app-sandbox&lt;/key&gt;\n&lt;true/&gt;\n&lt;key&gt;com.apple.security.temporary-exception.files.home-relative-path.read-write&lt;/key&gt;\n&lt;string&gt;Library/Application Support/UmbraCore/&lt;/string&gt;\n</code></pre>"},{"location":"xpc_implementation_plan/#4-error-handling-strategy","title":"4. Error Handling Strategy","text":""},{"location":"xpc_implementation_plan/#error-categories","title":"Error Categories","text":"<ol> <li>Connection Errors</li> <li>Service Errors</li> <li>Security Validation Errors</li> <li>Resource Errors</li> </ol>"},{"location":"xpc_implementation_plan/#recovery-strategy","title":"Recovery Strategy","text":"<pre><code>public protocol XPCErrorRecoverable {\n    var isRecoverable: Bool { get }\n    var retryCount: Int { get }\n    var retryDelay: TimeInterval { get }\n}\n</code></pre>"},{"location":"xpc_implementation_plan/#5-performance-considerations","title":"5. Performance Considerations","text":""},{"location":"xpc_implementation_plan/#connection-management","title":"Connection Management","text":"<ul> <li>Connection pooling</li> <li>Request batching</li> <li>Async operations</li> <li>Resource cleanup</li> </ul>"},{"location":"xpc_implementation_plan/#monitoring","title":"Monitoring","text":"<ul> <li>Connection status</li> <li>Operation latency</li> <li>Error rates</li> <li>Resource usage</li> </ul>"},{"location":"xpc_implementation_plan/#6-testing-strategy","title":"6. Testing Strategy","text":""},{"location":"xpc_implementation_plan/#unit-tests","title":"Unit Tests","text":"<pre><code>func testCryptoXPCService() async throws {\n    let service = CryptoXPCService()\n    let data = Data([1, 2, 3])\n    let key = try await service.generateSecureRandomKey(length: 32)\n    let encrypted = try await service.encrypt(data, using: key)\n    XCTAssertNotEqual(data, encrypted)\n}\n</code></pre>"},{"location":"xpc_implementation_plan/#integration-tests","title":"Integration Tests","text":"<ul> <li>Service lifecycle</li> <li>Error propagation</li> <li>Recovery mechanisms</li> <li>Security boundaries</li> </ul>"},{"location":"xpc_implementation_plan/#7-rollback-plan","title":"7. Rollback Plan","text":""},{"location":"xpc_implementation_plan/#trigger-conditions","title":"Trigger Conditions","text":"<ol> <li>Critical security issues</li> <li>Performance degradation</li> <li>Stability problems</li> <li>Data integrity issues</li> </ol>"},{"location":"xpc_implementation_plan/#rollback-steps","title":"Rollback Steps","text":"<ol> <li>Revert to pre-XPC commits</li> <li>Restore original service implementations</li> <li>Update client code</li> <li>Run validation tests</li> </ol>"},{"location":"xpc_implementation_plan/#8-success-criteria","title":"8. Success Criteria","text":""},{"location":"xpc_implementation_plan/#functional","title":"Functional","text":"<ul> <li>All operations work through XPC</li> <li>Error handling works correctly</li> <li>Recovery mechanisms function</li> <li>Performance meets targets</li> </ul>"},{"location":"xpc_implementation_plan/#security","title":"Security","text":"<ul> <li>Process isolation verified</li> <li>Privilege separation effective</li> <li>Sandbox rules working</li> <li>Entitlements correct</li> </ul>"},{"location":"xpc_implementation_plan/#performance","title":"Performance","text":"<ul> <li>Latency within bounds</li> <li>Resource usage acceptable</li> <li>Connection management efficient</li> <li>Error recovery timely</li> </ul>"},{"location":"xpc_implementation_plan/#9-documentation-requirements","title":"9. Documentation Requirements","text":""},{"location":"xpc_implementation_plan/#api-documentation","title":"API Documentation","text":"<ul> <li>XPC protocol documentation</li> <li>Error handling guidance</li> <li>Security considerations</li> <li>Best practices</li> </ul>"},{"location":"xpc_implementation_plan/#operational-documentation","title":"Operational Documentation","text":"<ul> <li>Deployment guide</li> <li>Monitoring guide</li> <li>Troubleshooting guide</li> <li>Recovery procedures</li> </ul>"},{"location":"xpc_implementation_plan/#10-future-enhancements","title":"10. Future Enhancements","text":""},{"location":"xpc_implementation_plan/#planned-features","title":"Planned Features","text":"<ul> <li>[ ] Enhanced monitoring</li> <li>[ ] Performance metrics</li> <li>[ ] Automatic recovery</li> <li>[ ] Load balancing</li> </ul>"},{"location":"xpc_implementation_plan/#security-improvements","title":"Security Improvements","text":"<ul> <li>[ ] Additional sandbox rules</li> <li>[ ] Enhanced audit logging</li> <li>[ ] Security event monitoring</li> <li>[ ] Threat detection</li> </ul> <p>unction - Performance meets targets</p>"},{"location":"xpc_implementation_plan/#security_1","title":"Security","text":"<ul> <li>Process isolation verified</li> <li>Privilege separation effective</li> <li>Sandbox rules working</li> <li>Entitlements correct</li> </ul>"},{"location":"xpc_implementation_plan/#performance_1","title":"Performance","text":"<ul> <li>Latency within bounds</li> <li>Resource usage acceptable</li> <li>Connection management efficient</li> <li>Error recovery timely</li> </ul>"},{"location":"xpc_implementation_plan/#9-documentation-requirements_1","title":"9. Documentation Requirements","text":""},{"location":"xpc_implementation_plan/#api-documentation_1","title":"API Documentation","text":"<ul> <li>XPC protocol documentation</li> <li>Error handling guidance</li> <li>Security considerations</li> <li>Best practices</li> </ul>"},{"location":"xpc_implementation_plan/#operational-documentation_1","title":"Operational Documentation","text":"<ul> <li>Deployment guide</li> <li>Monitoring guide</li> <li>Troubleshooting guide</li> <li>Recovery procedures</li> </ul>"},{"location":"xpc_implementation_plan/#10-future-enhancements_1","title":"10. Future Enhancements","text":""},{"location":"xpc_implementation_plan/#planned-features_1","title":"Planned Features","text":"<ul> <li>[ ] Enhanced monitoring</li> <li>[ ] Performance metrics</li> <li>[ ] Automatic recovery</li> <li>[ ] Load balancing</li> </ul>"},{"location":"xpc_implementation_plan/#security-improvements_1","title":"Security Improvements","text":"<ul> <li>[ ] Additional sandbox rules</li> <li>[ ] Enhanced audit logging</li> <li>[ ] Security event monitoring</li> <li>[ ] Threat detection</li> </ul>"},{"location":"xpc_implementation_plan/#version-history","title":"Version History","text":"Version Date Changes 1.0.0 2025-02-17 Initial XPC implementation plan document"},{"location":"TechnicalDesign/EnhancedErrorHandling/","title":"UmbraCore Enhanced Error Handling - Technical Design Document","text":"<p>Date: 7 March 2025 Status: Draft Author: UmbraCore Team  </p>"},{"location":"TechnicalDesign/EnhancedErrorHandling/#1-introduction","title":"1. Introduction","text":"<p>This document outlines the technical design for enhancing the error handling system in UmbraCore. The current approach has several limitations that can be addressed through a more unified and robust architecture. This design proposes a new error hierarchy, type-safe mapping, and improved context preservation to create a more maintainable and developer-friendly error handling system.</p>"},{"location":"TechnicalDesign/EnhancedErrorHandling/#2-goals-and-non-goals","title":"2. Goals and Non-Goals","text":""},{"location":"TechnicalDesign/EnhancedErrorHandling/#goals","title":"Goals","text":"<ul> <li>Create a unified error type hierarchy across the codebase</li> <li>Implement type-safe error mapping between domains</li> <li>Enhance error context with source information and cause chains</li> <li>Provide a centralized error management system</li> <li>Improve developer experience with better error diagnostics</li> </ul>"},{"location":"TechnicalDesign/EnhancedErrorHandling/#non-goals","title":"Non-Goals","text":"<ul> <li>Maintaining backward compatibility with existing error handling</li> <li>Modifying external API contracts for error reporting</li> <li>Redesigning the Swift standard error handling approach</li> </ul>"},{"location":"TechnicalDesign/EnhancedErrorHandling/#3-table-of-contents","title":"3. Table of Contents","text":"<ol> <li>Introduction</li> <li>Goals and Non-Goals</li> <li>Table of Contents</li> <li>Current Architecture</li> <li>Proposed Architecture</li> <li>Implementation Plan</li> <li>Migration Strategy</li> <li>Testing Strategy</li> <li>References</li> </ol>"},{"location":"TechnicalDesign/EnhancedErrorHandling/#4-current-architecture","title":"4. Current Architecture","text":"<p>The current error handling architecture in UmbraCore has evolved organically and presents several challenges:</p>"},{"location":"TechnicalDesign/EnhancedErrorHandling/#41-dual-module-structure","title":"4.1 Dual Module Structure","text":"<p>UmbraCore currently handles errors through two separate modules:</p> <ul> <li>CoreErrors (<code>/Sources/CoreErrors/</code>): Contains basic error type definitions</li> <li>UmbraCoreTypes/CoreErrors (<code>/Sources/UmbraCoreTypes/CoreErrors/</code>): Provides error mapping functionality</li> </ul> <p>This dual structure creates potential namespace conflicts and makes it difficult to maintain a coherent error handling strategy.</p>"},{"location":"TechnicalDesign/EnhancedErrorHandling/#42-inconsistent-error-implementations","title":"4.2 Inconsistent Error Implementations","text":"<p>Error types across the codebase exhibit inconsistent implementation patterns:</p> <ul> <li>Simple Enumerations: Some errors like <code>CoreErrors.RepositoryError</code> are implemented as basic enumerations without associated values or additional conformances.</li> <li>Rich Implementations: Others like <code>Repositories.RepositoryError</code> provide comprehensive implementations with associated values, localization support, and <code>Codable</code> conformance.</li> </ul> <p>This inconsistency makes error handling unpredictable and requires developers to understand multiple patterns.</p>"},{"location":"TechnicalDesign/EnhancedErrorHandling/#43-string-based-error-mapping","title":"4.3 String-Based Error Mapping","text":"<p>The current error mapping system:</p> <ul> <li>Relies on <code>String(describing:)</code> for type identification</li> <li>Uses string parsing to map between error domains</li> <li>Lacks compile-time safety for error mapping operations</li> </ul> <p>This approach is brittle and error-prone, particularly when types are renamed or restructured.</p>"},{"location":"TechnicalDesign/EnhancedErrorHandling/#44-limited-error-context","title":"4.4 Limited Error Context","text":"<p>Errors currently provide limited context:</p> <ul> <li>No standardised source information (file, function, line)</li> <li>No consistent mechanism for preserving error chains</li> <li>Unstructured, text-based debug information</li> </ul> <p>This makes debugging more challenging and limits the utility of error information for diagnosis.</p>"},{"location":"TechnicalDesign/EnhancedErrorHandling/#45-distributed-error-management","title":"4.5 Distributed Error Management","text":"<p>Error management is distributed across the codebase:</p> <ul> <li>No central registry for error types and domains</li> <li>Inconsistent error creation and transformation patterns</li> <li>Duplicated error handling logic in multiple places</li> </ul> <p>This fragmentation makes it difficult to maintain and evolve the error handling system.</p>"},{"location":"TechnicalDesign/EnhancedErrorHandling/#5-proposed-architecture","title":"5. Proposed Architecture","text":"<p>The proposed architecture addresses the limitations of the current system by introducing a unified, type-safe, and context-rich error handling framework.</p>"},{"location":"TechnicalDesign/EnhancedErrorHandling/#51-unified-error-type-hierarchy","title":"5.1 Unified Error Type Hierarchy","text":"<p>We propose a consolidated error type hierarchy with the following structure:</p>"},{"location":"TechnicalDesign/EnhancedErrorHandling/#511-core-protocols","title":"5.1.1 Core Protocols","text":"<pre><code>/// Base protocol for all UmbraCore errors\npublic protocol UmbraError: Error, Sendable, Equatable, CustomStringConvertible {\n    /// A unique identifier for the error type\n    var errorDomain: String { get }\n\n    /// A code identifying the specific error\n    var errorCode: Int { get }\n\n    /// Human-readable description of the error\n    var errorDescription: String { get }\n\n    /// Optional underlying cause of this error\n    var underlyingError: Error? { get }\n\n    /// Source information where the error was created\n    var source: ErrorSource { get }\n}\n\n/// Represents the source of an error\npublic struct ErrorSource: Sendable, Equatable {\n    let file: StaticString\n    let function: StaticString\n    let line: UInt\n    let module: String\n}\n</code></pre>"},{"location":"TechnicalDesign/EnhancedErrorHandling/#512-base-implementations","title":"5.1.2 Base Implementations","text":"<pre><code>/// Common base for all UmbraCore error implementations\npublic struct ErrorContext: Sendable, Equatable {\n    public let source: ErrorSource\n    public let underlyingError: Error?\n    public let additionalInfo: [String: Any]?\n\n    public init(\n        source: ErrorSource,\n        underlyingError: Error? = nil,\n        additionalInfo: [String: Any]? = nil\n    ) {\n        self.source = source\n        self.underlyingError = underlyingError\n        self.additionalInfo = additionalInfo\n    }\n}\n\n/// Base implementation for domain-specific error enums\npublic protocol DomainError: UmbraError {\n    var context: ErrorContext { get }\n}\n\n/// Default implementation for domain errors\nextension DomainError {\n    public var underlyingError: Error? { context.underlyingError }\n    public var source: ErrorSource { context.source }\n}\n</code></pre>"},{"location":"TechnicalDesign/EnhancedErrorHandling/#52-type-safe-error-mapping","title":"5.2 Type-Safe Error Mapping","text":"<p>The new error mapping system will use generics and explicit type conversions:</p> <pre><code>public protocol ErrorMapper {\n    associatedtype SourceError: UmbraError\n    associatedtype TargetError: UmbraError\n\n    func map(_ error: SourceError) -&gt; TargetError\n}\n\npublic struct AnyErrorMapper&lt;Source: UmbraError, Target: UmbraError&gt;: ErrorMapper {\n    private let _map: (Source) -&gt; Target\n\n    public init(_ mapper: (Source) -&gt; Target) {\n        self._map = mapper\n    }\n\n    public func map(_ error: Source) -&gt; Target {\n        _map(error)\n    }\n}\n</code></pre>"},{"location":"TechnicalDesign/EnhancedErrorHandling/#53-error-context-enhancement","title":"5.3 Error Context Enhancement","text":"<p>Errors will carry rich contextual information:</p> <pre><code>/// Creates an error with source information automatically included\npublic func makeError&lt;T: DomainError&gt;(\n    _ error: T,\n    file: StaticString = #file,\n    function: StaticString = #function,\n    line: UInt = #line,\n    cause: Error? = nil,\n    info: [String: Any]? = nil\n) -&gt; T {\n    // Create error with embedded source information\n    // ...\n}\n</code></pre>"},{"location":"TechnicalDesign/EnhancedErrorHandling/#54-centralised-error-management","title":"5.4 Centralised Error Management","text":"<p>A central error registry will manage error types and transformations:</p> <p>```swift /// Central registry for error domains and mappers public final class ErrorRegistry {     public static let shared = ErrorRegistry()</p> <pre><code>private var mappers: [String: Any] = [:]\n\n/// Register a mapper between error domains\npublic func register&lt;S, T&gt;(\n    mapper: AnyErrorMapper&lt;S, T&gt;\n) where S: UmbraError, T: UmbraError {\n    let key = \"\\(S.self)-&gt;\\(T.self)\"\n    mappers[key] = mapper\n}\n\n/// Transform an error to a different domain\npublic func transform&lt;S, T&gt;(_ error: S) -&gt; T? where S: UmbraError, T: UmbraError {\n    let key = \"\\(S.self)-&gt;\\(T.self)\"\n    guard let mapper = mappers[key] as? AnyErrorMapper&lt;S, T&gt; else {\n        return nil\n    }\n    return mapper.map(error)\n}\n</code></pre> <p>}</p>"},{"location":"TechnicalDesign/EnhancedErrorHandling/#6-implementation-plan","title":"6. Implementation Plan","text":"<p>The implementation of the enhanced error handling system will be carried out in several phases to ensure a smooth transition and maintain code stability.</p>"},{"location":"TechnicalDesign/EnhancedErrorHandling/#61-core-framework-implementation","title":"6.1 Core Framework Implementation","text":""},{"location":"TechnicalDesign/EnhancedErrorHandling/#611-create-base-module-structure","title":"6.1.1 Create Base Module Structure","text":"<ol> <li>Create a new Swift package <code>UmbraErrors</code> to contain the core error handling framework</li> <li>Implement the base protocols (<code>UmbraError</code>, <code>DomainError</code>)</li> <li>Implement supporting types (<code>ErrorSource</code>, <code>ErrorContext</code>)</li> <li>Implement error factory functions (<code>makeError</code>)</li> </ol>"},{"location":"TechnicalDesign/EnhancedErrorHandling/#612-implement-error-mapping-system","title":"6.1.2 Implement Error Mapping System","text":"<ol> <li>Implement the <code>ErrorMapper</code> protocol</li> <li>Create the type-erased <code>AnyErrorMapper</code> implementation</li> <li>Implement the <code>ErrorRegistry</code> for centralised mapping</li> <li>Add convenience extensions for error transformation</li> </ol>"},{"location":"TechnicalDesign/EnhancedErrorHandling/#613-implement-error-logging-and-reporting","title":"6.1.3 Implement Error Logging and Reporting","text":"<ol> <li>Create an <code>ErrorReporter</code> protocol for logging errors</li> <li>Implement a default reporter that integrates with the UmbraCore logging system</li> <li>Add convenience methods for error reporting with contextual information</li> </ol>"},{"location":"TechnicalDesign/EnhancedErrorHandling/#62-securityerror-refactoring-proof-of-concept","title":"6.2 SecurityError Refactoring (Proof of Concept)","text":"<p>As a proof of concept, we will refactor the <code>SecurityError</code> type to use the new architecture:</p> <ol> <li>Create a new <code>SecurityErrorDomain</code> that conforms to <code>DomainError</code></li> <li>Implement all existing error cases with enhanced context</li> <li>Create bidirectional mappers with existing <code>SecurityError</code> types</li> <li>Update client code to use the new error types</li> <li>Implement comprehensive tests to verify correctness</li> </ol>"},{"location":"TechnicalDesign/EnhancedErrorHandling/#63-error-reporting-integration","title":"6.3 Error Reporting Integration","text":"<ol> <li>Integrate with the existing logging system</li> <li>Add diagnostic reporting capabilities</li> <li>Implement error chain visualisation for debugging</li> <li>Create developer tools for error inspection</li> </ol>"},{"location":"TechnicalDesign/EnhancedErrorHandling/#64-documentation-and-examples","title":"6.4 Documentation and Examples","text":"<ol> <li>Create comprehensive API documentation</li> <li>Implement example code for common error handling patterns</li> <li>Create a migration guide for existing error types</li> <li>Document best practices for error handling</li> </ol>"},{"location":"TechnicalDesign/EnhancedErrorHandling/#7-migration-strategy","title":"7. Migration Strategy","text":"<p>The migration to the new error handling system will be phased to minimise disruption while ensuring a smooth transition. This section outlines the systematic approach to migrating existing error types.</p>"},{"location":"TechnicalDesign/EnhancedErrorHandling/#71-existing-error-type-inventory","title":"7.1 Existing Error Type Inventory","text":"<p>First, we'll conduct a comprehensive inventory of all existing error types in the codebase:</p> <ol> <li>Identify all error types across all modules</li> <li>Catalogue their current implementation patterns</li> <li>Map relationships and dependencies between error types</li> <li>Identify usage patterns and integration points</li> </ol> <p>This inventory will help prioritise migration efforts and identify potential challenges.</p>"},{"location":"TechnicalDesign/EnhancedErrorHandling/#72-module-consolidation","title":"7.2 Module Consolidation","text":"<p>A key part of the migration strategy is consolidating error handling into a more cohesive structure:</p> <ol> <li>Merge the duplicate CoreErrors implementations</li> <li>Centralise error mapping functionality in the new UmbraErrors module</li> <li>Resolve namespace conflicts between security modules with explicit type resolution</li> <li>Eliminate redundant error type definitions</li> </ol> <p>This consolidation will address the current namespace ambiguity issues that exist between SecurityProtocolsCore and XPCProtocolsCore modules.</p>"},{"location":"TechnicalDesign/EnhancedErrorHandling/#73-phased-migration-approach","title":"7.3 Phased Migration Approach","text":"<p>The migration will occur in the following phases:</p>"},{"location":"TechnicalDesign/EnhancedErrorHandling/#phase-1-foundation-layer","title":"Phase 1: Foundation Layer","text":"<ol> <li>Implement the core UmbraErrors module</li> <li>Create adapter layer for existing errors</li> <li>Add logging and diagnostic capabilities</li> <li>Deploy comprehensive tests</li> </ol>"},{"location":"TechnicalDesign/EnhancedErrorHandling/#phase-2-core-domain-errors","title":"Phase 2: Core Domain Errors","text":"<ol> <li>Migrate primary domain errors (SecurityError, ResourceError)</li> <li>Update their implementations to use the new architecture</li> <li>Create bidirectional mappers with existing types</li> <li>Verify full compatibility with existing code</li> </ol>"},{"location":"TechnicalDesign/EnhancedErrorHandling/#phase-3-secondary-domain-errors","title":"Phase 3: Secondary Domain Errors","text":"<ol> <li>Migrate remaining domain-specific errors</li> <li>Implement domain-specific error reporting</li> <li>Update all client code to use new APIs</li> <li>Validate with comprehensive tests</li> </ol>"},{"location":"TechnicalDesign/EnhancedErrorHandling/#phase-4-legacy-support-removal","title":"Phase 4: Legacy Support Removal","text":"<p>Once all code has been migrated to the new system:</p> <ol> <li>Deprecate old error types and mapping functions</li> <li>Create documentation for any remaining legacy code</li> <li>Remove obsolete components after an appropriate transition period</li> </ol>"},{"location":"TechnicalDesign/EnhancedErrorHandling/#74-addressing-namespace-resolution","title":"7.4 Addressing Namespace Resolution","text":"<p>Special attention will be paid to addressing the namespace resolution issues with SecurityError types:</p> <ol> <li>Ensure clear type resolution paths for all error types</li> <li>Avoid creating enums with the same name as their modules</li> <li>Use proper type aliasing to avoid ambiguity</li> <li>Create explicit import patterns for modules with similar type names</li> </ol>"},{"location":"TechnicalDesign/EnhancedErrorHandling/#75-risk-mitigation","title":"7.5 Risk Mitigation","text":"<p>Potential migration risks and their mitigations:</p> Risk Mitigation Breaking existing error handling Implement bidirectional mappers before migration Performance degradation Benchmark new implementation against existing system Development delays Implement in phases with interim deliverables Partial adoption Create comprehensive documentation and examples Security impacts Validate error handling in security-critical paths"},{"location":"TechnicalDesign/EnhancedErrorHandling/#8-testing-strategy","title":"8. Testing Strategy","text":"<p>A comprehensive testing strategy is critical to ensure the new error handling system is robust, reliable, and performs as expected. This section outlines the testing approach.</p>"},{"location":"TechnicalDesign/EnhancedErrorHandling/#81-unit-testing","title":"8.1 Unit Testing","text":"<p>Comprehensive unit tests will be implemented at multiple levels:</p> <ol> <li>Core Protocol Tests</li> <li>Test conformance to UmbraError protocol</li> <li>Verify ErrorContext functionality</li> <li> <p>Test error source tracking and reporting</p> </li> <li> <p>Mapping Tests</p> </li> <li>Test bidirectional mapping between error domains</li> <li>Verify error context preservation during mapping</li> <li> <p>Test edge cases and error transformation chains</p> </li> <li> <p>Factory Function Tests</p> </li> <li>Test error creation with source attribution</li> <li>Verify error cause chains are correctly established</li> <li> <p>Test additional context information preservation</p> </li> <li> <p>Registry Tests</p> </li> <li>Test error mapper registration</li> <li>Verify correct mapper lookup and execution</li> <li>Test error transformation between domains</li> </ol>"},{"location":"TechnicalDesign/EnhancedErrorHandling/#82-integration-testing","title":"8.2 Integration Testing","text":"<p>Integration tests will verify how error handling works across module boundaries:</p> <ol> <li>Cross-Module Error Propagation</li> <li>Test error transformation across multiple modules</li> <li>Verify error context is preserved end-to-end</li> <li> <p>Test error reporting and logging integration</p> </li> <li> <p>API Boundary Tests</p> </li> <li>Test error handling at public API boundaries</li> <li>Verify error translation for external consumers</li> <li> <p>Test error serialisation and deserialisation</p> </li> <li> <p>Security Module Tests</p> </li> <li>Test SecurityError mapping in security-critical paths</li> <li>Verify error handling in encryption/decryption operations</li> <li>Test error propagation in XPC service communications</li> </ol>"},{"location":"TechnicalDesign/EnhancedErrorHandling/#83-performance-testing","title":"8.3 Performance Testing","text":"<p>Performance testing will ensure the new system doesn't introduce unacceptable overhead:</p> <ol> <li>Benchmarks</li> <li>Measure error creation performance</li> <li>Benchmark error mapping operations</li> <li> <p>Compare memory usage to existing implementation</p> </li> <li> <p>Overhead Analysis</p> </li> <li>Analyse impact of added context on error objects</li> <li>Measure error chain traversal performance</li> <li>Test error reporting performance under load</li> </ol>"},{"location":"TechnicalDesign/EnhancedErrorHandling/#84-namespace-resolution-testing","title":"8.4 Namespace Resolution Testing","text":"<p>Specific tests will target the namespace resolution issues identified in previous work:</p> <ol> <li>Type Resolution Tests</li> <li>Test explicit module qualification for error types</li> <li>Verify correct resolution of similarly named types</li> <li> <p>Test import patterns for modules with name conflicts</p> </li> <li> <p>Ambiguity Tests</p> </li> <li>Create test cases with potential namespace ambiguity</li> <li>Verify compiler errors are correctly addressed</li> <li>Test migration patterns for ambiguous code</li> </ol>"},{"location":"TechnicalDesign/EnhancedErrorHandling/#85-test-coverage-goals","title":"8.5 Test Coverage Goals","text":"<p>The testing plan establishes the following coverage targets:</p> Component Line Coverage Branch Coverage Mutation Score Core Protocols 100% 95% 90% Error Mapping 100% 95% 90% Factory Functions 100% 90% 85% Error Registry 95% 90% 85% SecurityError Implementation 100% 95% 90%"},{"location":"TechnicalDesign/EnhancedErrorHandling/#86-continuous-integration","title":"8.6 Continuous Integration","text":"<p>Tests will be integrated into the UmbraCore CI/CD pipeline:</p> <ol> <li>Run all tests on every pull request</li> <li>Enforce coverage requirements for new code</li> <li>Add performance regression testing to prevent slowdowns</li> <li>Implement static analysis to catch error handling anti-patterns</li> </ol>"},{"location":"TechnicalDesign/EnhancedErrorHandling/#9-references","title":"9. References","text":""},{"location":"TechnicalDesign/EnhancedErrorHandling/#91-internal-references","title":"9.1 Internal References","text":"<ol> <li>UmbraCore_Refactoring_Plan.md - Contains overall architectural guidance for UmbraCore modules</li> <li>UmbraCore Security Module Type References - Analyses namespace conflicts in security modules</li> <li>XPC_PROTOCOLS_MIGRATION_GUIDE.md - Provides context for XPC protocol migration work</li> <li>SecurityInterfaces documentation - Defines interface contracts and error handling requirements</li> <li>UmbraCore Build Documentation - Contains build system and module organisation guidelines</li> </ol>"},{"location":"TechnicalDesign/EnhancedErrorHandling/#92-swift-language-references","title":"9.2 Swift Language References","text":"<ol> <li>Swift Error Handling Documentation</li> <li>Swift Evolution - Result Type</li> <li>Swift Evolution - Throwing Properties </li> <li>Swift Evolution - Structured Concurrency</li> </ol>"},{"location":"TechnicalDesign/EnhancedErrorHandling/#93-best-practices-references","title":"9.3 Best Practices References","text":"<ol> <li>Swift Style Guide - Error handling conventions</li> <li>Swift API Design Guidelines - For designing error APIs</li> <li>Swift Error Handling Best Practices - External article on error handling patterns</li> <li>Result Builders in Swift - For advanced error composition</li> </ol>"},{"location":"TechnicalDesign/EnhancedErrorHandling/#94-related-work","title":"9.4 Related Work","text":"<ol> <li>Swift Error Handling Evolution - Ongoing discussions about error handling</li> <li>Swift Result Builders for Errors - For potential future work</li> <li>Swift Logging System - For error reporting integration</li> <li>Swift Type-Safe Path - For referencing source locations</li> </ol>"},{"location":"api/","title":"API Documentation","text":""},{"location":"api/#core-services","title":"Core Services","text":""},{"location":"api/#umbrakeychainservice","title":"UmbraKeychainService","text":"<p>Secure credential storage service. - API Reference - Usage Guide</p>"},{"location":"api/#umbracryptoservice","title":"UmbraCryptoService","text":"<p>Cryptographic operations service. - API Reference - Usage Guide</p>"},{"location":"api/#umbrabookmarkservice","title":"UmbraBookmarkService","text":"<p>File system bookmark management. - API Reference - Usage Guide</p>"},{"location":"api/#security-types","title":"Security Types","text":""},{"location":"api/#securitytypes","title":"SecurityTypes","text":"<p>Base security primitives. - API Reference - Usage Guide</p>"},{"location":"api/#cryptotypes","title":"CryptoTypes","text":"<p>Cryptographic types and operations. - API Reference - Usage Guide</p>"},{"location":"api/#utilities","title":"Utilities","text":""},{"location":"api/#umbralogging","title":"UmbraLogging","text":"<p>Logging infrastructure. - API Reference - Usage Guide</p>"},{"location":"api/#umbraxpc","title":"UmbraXPC","text":"<p>XPC communication layer. - API Reference - Usage Guide</p>"},{"location":"api/#error-types","title":"Error Types","text":""},{"location":"api/#commonerror","title":"CommonError","text":"<p>Shared error types. - API Reference - Usage Guide</p>"},{"location":"api/#best-practices","title":"Best Practices","text":"<ul> <li>Thread Safety</li> <li>Error Handling</li> <li>Performance</li> <li>Security</li> </ul>"},{"location":"api/backup-management/","title":"Backup Management","text":"<p>The backup management system in UmbraCore provides comprehensive functionality for managing backup operations.</p>"},{"location":"api/backup-management/#features","title":"Features","text":"<ul> <li>Repository initialization and management</li> <li>Backup creation and verification</li> <li>Snapshot management</li> <li>Tag handling</li> <li>Progress monitoring</li> <li>Error recovery</li> </ul>"},{"location":"api/backup-management/#core-types","title":"Core Types","text":""},{"location":"api/backup-management/#repository-management","title":"Repository Management","text":"<pre><code>protocol RepositoryManager {\n    func initialize(path: URL, password: String) async throws\n    func verify(path: URL) async throws -&gt; VerificationResult\n    func unlock(path: URL) async throws\n    func lock(path: URL) async throws\n}\n</code></pre>"},{"location":"api/backup-management/#backup-operations","title":"Backup Operations","text":"<pre><code>protocol BackupManager {\n    func createBackup(source: URL, tags: [String]) async throws -&gt; BackupResult\n    func verifyBackup(id: String) async throws -&gt; VerificationResult\n    func listSnapshots() async throws -&gt; [Snapshot]\n    func restoreSnapshot(_ snapshot: Snapshot, to: URL) async throws\n}\n</code></pre>"},{"location":"api/backup-management/#usage-examples","title":"Usage Examples","text":""},{"location":"api/backup-management/#creating-a-new-repository","title":"Creating a New Repository","text":"<pre><code>let manager = RepositoryManager()\ntry await manager.initialize(\n    path: repositoryURL,\n    password: \"secure-password\"\n)\n</code></pre>"},{"location":"api/backup-management/#running-a-backup","title":"Running a Backup","text":"<pre><code>let backup = BackupManager()\nlet result = try await backup.createBackup(\n    source: sourceURL,\n    tags: [\"daily\", \"documents\"]\n)\n</code></pre>"},{"location":"api/backup-management/#managing-snapshots","title":"Managing Snapshots","text":"<pre><code>let snapshots = try await backup.listSnapshots()\nfor snapshot in snapshots {\n    print(\"Snapshot \\(snapshot.id) from \\(snapshot.date)\")\n}\n</code></pre>"},{"location":"api/backup-management/#error-handling","title":"Error Handling","text":"<p>Common backup-related errors:</p> <ul> <li><code>RepositoryError</code>: Repository access issues</li> <li><code>BackupError</code>: Backup operation failures</li> <li><code>SnapshotError</code>: Snapshot management issues</li> <li><code>VerificationError</code>: Verification failures</li> </ul>"},{"location":"api/backup-management/#best-practices","title":"Best Practices","text":"<ol> <li>Regular repository verification</li> <li>Proper error handling</li> <li>Progress monitoring</li> <li>Resource cleanup</li> <li>Security considerations</li> </ol>"},{"location":"api/configuration/","title":"Configuration","text":"<p>The configuration system in UmbraCore provides a flexible way to manage backup settings and policies.</p>"},{"location":"api/configuration/#features","title":"Features","text":"<ul> <li>Backup source paths</li> <li>Exclude patterns</li> <li>Retention policies</li> <li>Schedule definitions</li> <li>Performance settings</li> <li>Security configuration</li> </ul>"},{"location":"api/configuration/#core-types","title":"Core Types","text":""},{"location":"api/configuration/#backup-configuration","title":"Backup Configuration","text":"<pre><code>struct BackupConfiguration {\n    let sources: [URL]\n    let excludes: [String]\n    let retention: RetentionPolicy\n    let schedule: Schedule\n    let compression: CompressionSettings\n    let verification: VerificationSettings\n}\n</code></pre>"},{"location":"api/configuration/#retention-policy","title":"Retention Policy","text":"<pre><code>struct RetentionPolicy {\n    let keepLast: Int\n    let keepHourly: Int\n    let keepDaily: Int\n    let keepWeekly: Int\n    let keepMonthly: Int\n    let keepYearly: Int\n    let keepTags: [String]\n}\n</code></pre>"},{"location":"api/configuration/#usage-examples","title":"Usage Examples","text":""},{"location":"api/configuration/#creating-a-configuration","title":"Creating a Configuration","text":"<pre><code>let config = BackupConfiguration(\n    sources: [documentsURL, picturesURL],\n    excludes: [\"*.tmp\", \"*.cache\"],\n    retention: RetentionPolicy(\n        keepLast: 3,\n        keepDaily: 7,\n        keepWeekly: 4,\n        keepMonthly: 6\n    ),\n    schedule: Schedule.daily(at: \"01:00\")\n)\n</code></pre>"},{"location":"api/configuration/#applying-configuration","title":"Applying Configuration","text":"<pre><code>let manager = ConfigurationManager()\ntry await manager.apply(config)\ntry await manager.validate()\n</code></pre>"},{"location":"api/configuration/#error-handling","title":"Error Handling","text":"<p>Common configuration-related errors:</p> <ul> <li><code>ConfigurationError</code>: Invalid settings</li> <li><code>ValidationError</code>: Validation failures</li> <li><code>ApplicationError</code>: Apply failures</li> <li><code>ParseError</code>: Parse issues</li> </ul>"},{"location":"api/configuration/#best-practices","title":"Best Practices","text":"<ol> <li>Validate configurations</li> <li>Use sensible defaults</li> <li>Document changes</li> <li>Version control</li> <li>Security review</li> </ol>"},{"location":"api/reference/","title":"API Reference","text":""},{"location":"api/reference/#core-services","title":"Core Services","text":""},{"location":"api/reference/#umbrakeychainservice","title":"UmbraKeychainService","text":"<p>Secure credential storage service for managing sensitive data:</p> <pre><code>// Initialize the service\nlet keychain = try UmbraKeychainService()\n\n// Store credentials\ntry await keychain.store(\n    password: \"secret\",\n    forKey: \"backup-repository\"\n)\n\n// Retrieve credentials\nlet password = try await keychain.retrieve(\n    forKey: \"backup-repository\"\n)\n</code></pre>"},{"location":"api/reference/#umbracryptoservice","title":"UmbraCryptoService","text":"<p>Cryptographic operations service for data security:</p> <pre><code>// Initialize the service\nlet crypto = try UmbraCryptoService()\n\n// Encrypt data\nlet encrypted = try await crypto.encrypt(\n    sensitiveData,\n    using: .aes256GCM\n)\n\n// Decrypt data\nlet decrypted = try await crypto.decrypt(\n    encrypted\n)\n</code></pre>"},{"location":"api/reference/#umbrabookmarkservice","title":"UmbraBookmarkService","text":"<p>File system bookmark management for persistent file access:</p> <pre><code>// Initialize the service\nlet bookmarks = try UmbraBookmarkService()\n\n// Create bookmark\nlet bookmark = try await bookmarks.create(\n    for: fileURL,\n    type: .securityScoped\n)\n\n// Resolve bookmark\nlet url = try await bookmarks.resolve(\n    bookmark: bookmark\n)\n</code></pre>"},{"location":"api/reference/#security-types","title":"Security Types","text":""},{"location":"api/reference/#securitytypes","title":"SecurityTypes","text":"<p>Base security primitives and protocols:</p> <pre><code>// Secure data container\nstruct SecureData: SecureContainer {\n    let data: Data\n    let metadata: SecurityMetadata\n}\n\n// Security context\nstruct SecurityContext {\n    let accessLevel: AccessLevel\n    let permissions: Permissions\n    let origin: SecurityOrigin\n}\n</code></pre>"},{"location":"api/reference/#cryptotypes","title":"CryptoTypes","text":"<p>Cryptographic types and operations:</p> <pre><code>// Encryption parameters\nstruct EncryptionParameters {\n    let algorithm: EncryptionAlgorithm\n    let keySize: KeySize\n    let iterations: Int\n}\n\n// Key types\nenum KeyType {\n    case aes256\n    case rsa2048\n    case rsa4096\n}\n</code></pre>"},{"location":"api/reference/#utilities","title":"Utilities","text":""},{"location":"api/reference/#umbralogging","title":"UmbraLogging","text":"<p>Centralised logging infrastructure:</p> <pre><code>// Initialize logger\nlet logger = UmbraLogger(\n    subsystem: \"com.example.app\",\n    category: \"backup\"\n)\n\n// Log events\nlogger.info(\"Starting backup\", metadata: [\n    \"repository\": \"main\",\n    \"files\": 100\n])\n\nlogger.error(\"Backup failed\", metadata: [\n    \"error\": error,\n    \"repository\": \"main\"\n])\n</code></pre>"},{"location":"api/reference/#umbraxpc","title":"UmbraXPC","text":"<p>XPC communication infrastructure:</p> <pre><code>// Define service protocol\nprotocol BackupService: XPCService {\n    func backup(source: URL) async throws\n    func restore(to: URL) async throws\n}\n\n// Create service connection\nlet service = try XPCConnection&lt;BackupService&gt;()\n\n// Call service\ntry await service.backup(source: sourceURL)\n</code></pre>"},{"location":"api/reference/#error-types","title":"Error Types","text":""},{"location":"api/reference/#commonerror","title":"CommonError","text":"<p>Shared error types across the framework:</p> <pre><code>enum CommonError: Error {\n    case invalidArgument(String)\n    case resourceNotFound(String)\n    case permissionDenied(String)\n    case operationFailed(String)\n}\n\nenum KeychainError: Error {\n    case itemNotFound(String)\n    case duplicateItem(String)\n    case accessDenied(String)\n}\n\nenum CryptoError: Error {\n    case encryptionFailed(String)\n    case decryptionFailed(String)\n    case invalidKey(String)\n}\n</code></pre>"},{"location":"api/reference/#best-practices","title":"Best Practices","text":""},{"location":"api/reference/#thread-safety","title":"Thread Safety","text":"<p>All services are designed to be thread-safe:</p> <pre><code>// Safe concurrent access\nlet service = try UmbraKeychainService()\nasync let task1 = service.store(password: \"secret1\", forKey: \"key1\")\nasync let task2 = service.store(password: \"secret2\", forKey: \"key2\")\ntry await [task1, task2]\n</code></pre>"},{"location":"api/reference/#error-handling","title":"Error Handling","text":"<p>Implement comprehensive error handling:</p> <pre><code>do {\n    try await service.backup(source: url)\n} catch CommonError.invalidArgument(let reason) {\n    logger.error(\"Invalid argument: \\(reason)\")\n} catch CommonError.permissionDenied(let operation) {\n    logger.error(\"Permission denied: \\(operation)\")\n} catch {\n    logger.error(\"Unknown error: \\(error)\")\n}\n</code></pre>"},{"location":"api/reference/#performance","title":"Performance","text":"<p>Follow performance best practices:</p> <pre><code>// Use batch operations\ntry await service.storeBatch([\n    (\"key1\", \"value1\"),\n    (\"key2\", \"value2\"),\n    (\"key3\", \"value3\")\n])\n\n// Implement cancellation\nlet task = Task {\n    try await service.longOperation()\n}\n// Later...\ntask.cancel()\n</code></pre>"},{"location":"api/reference/#related-documentation","title":"Related Documentation","text":"<ul> <li>Security Guide - Security implementation details</li> <li>Configuration Guide - Configuration options</li> <li>Advanced Features - Advanced usage</li> <li>Troubleshooting Guide - Common issues and solutions</li> </ul>"},{"location":"api/repository-handling/","title":"Repository Handling","text":"<p>The repository handling system in UmbraCore manages repository health, space usage, and maintenance.</p>"},{"location":"api/repository-handling/#features","title":"Features","text":"<ul> <li>Repository health checks</li> <li>Space usage monitoring</li> <li>Cache management</li> <li>Deduplication statistics</li> <li>Repository maintenance</li> <li>Performance optimization</li> </ul>"},{"location":"api/repository-handling/#core-types","title":"Core Types","text":""},{"location":"api/repository-handling/#health-monitoring","title":"Health Monitoring","text":"<pre><code>protocol RepositoryHealth {\n    func checkHealth() async throws -&gt; HealthStatus\n    func runMaintenance() async throws\n    func repairIndex() async throws\n    func validateData() async throws -&gt; ValidationResult\n}\n</code></pre>"},{"location":"api/repository-handling/#space-management","title":"Space Management","text":"<pre><code>protocol SpaceManager {\n    func getUsage() async throws -&gt; SpaceUsage\n    func forecast(days: Int) async throws -&gt; SpaceForecast\n    func cleanup(policy: RetentionPolicy) async throws -&gt; CleanupResult\n}\n</code></pre>"},{"location":"api/repository-handling/#usage-examples","title":"Usage Examples","text":""},{"location":"api/repository-handling/#health-check","title":"Health Check","text":"<pre><code>let health = RepositoryHealth()\nlet status = try await health.checkHealth()\nif status.needsMaintenance {\n    try await health.runMaintenance()\n}\n</code></pre>"},{"location":"api/repository-handling/#space-management_1","title":"Space Management","text":"<pre><code>let space = SpaceManager()\nlet usage = try await space.getUsage()\nprint(\"Used: \\(usage.used), Available: \\(usage.available)\")\n</code></pre>"},{"location":"api/repository-handling/#cache-management","title":"Cache Management","text":"<pre><code>let cache = CacheManager()\ntry await cache.optimize()\ntry await cache.prune(olderThan: .days(7))\n</code></pre>"},{"location":"api/repository-handling/#error-handling","title":"Error Handling","text":"<p>Common repository-related errors:</p> <ul> <li><code>HealthCheckError</code>: Health check failures</li> <li><code>MaintenanceError</code>: Maintenance issues</li> <li><code>SpaceError</code>: Space management problems</li> <li><code>CacheError</code>: Cache operation failures</li> </ul>"},{"location":"api/repository-handling/#best-practices","title":"Best Practices","text":"<ol> <li>Regular health checks</li> <li>Proactive maintenance</li> <li>Space monitoring</li> <li>Cache optimization</li> <li>Error recovery</li> </ol>"},{"location":"api/keychain/overview/","title":"UmbraKeychainService Overview","text":"<p>The UmbraKeychainService module provides secure credential management and storage capabilities for UmbraCore. It handles all sensitive data operations through a secure XPC service.</p>"},{"location":"api/keychain/overview/#features","title":"Features","text":"<ul> <li>Secure password management with validation</li> <li>Keychain integration for credential storage</li> <li>Biometric authentication support</li> <li>XPC service for isolated credential handling</li> <li>Automatic password rotation and expiry</li> <li>Secure backup and restore capabilities</li> </ul>"},{"location":"api/keychain/overview/#architecture","title":"Architecture","text":"<p>The service is built on three main components:</p> <ol> <li>XPC Service: Isolated process for handling sensitive operations</li> <li>Keychain Integration: Direct interface with the system keychain</li> <li>Client Library: Swift API for application integration</li> </ol>"},{"location":"api/keychain/overview/#getting-started","title":"Getting Started","text":"<p>See the following guides for detailed information:</p> <ul> <li>Password Management</li> <li>Secure Storage</li> <li>XPC Integration</li> </ul>"},{"location":"api/keychain/overview/#security-considerations","title":"Security Considerations","text":"<p>The service follows strict security practices:</p> <ul> <li>All operations run in an isolated XPC service</li> <li>Credentials never leave the secure enclave</li> <li>Biometric authentication for sensitive operations</li> <li>Automatic credential rotation</li> <li>Secure error handling to prevent information leaks</li> </ul>"},{"location":"api/keychain/password-management/","title":"Password Management","text":"<p>The password management system in UmbraKeychainService provides comprehensive functionality for handling secure credentials.</p>"},{"location":"api/keychain/password-management/#password-requirements","title":"Password Requirements","text":"<pre><code>struct PasswordRequirements {\n    let minLength: Int\n    let requiresUppercase: Bool\n    let requiresLowercase: Bool\n    let requiresNumbers: Bool\n    let requiresSpecialChars: Bool\n    let maxConsecutiveChars: Int\n    let bannedPasswords: Set&lt;String&gt;\n}\n</code></pre>"},{"location":"api/keychain/password-management/#default-requirements","title":"Default Requirements","text":"<ul> <li>Minimum length: 12 characters</li> <li>Must include uppercase and lowercase letters</li> <li>Must include at least one number</li> <li>Must include at least one special character</li> <li>No more than 3 consecutive identical characters</li> <li>Cannot be in the banned passwords list</li> </ul>"},{"location":"api/keychain/password-management/#password-validation","title":"Password Validation","text":"<p>The <code>PasswordValidator</code> protocol defines the interface for password validation:</p> <pre><code>protocol PasswordValidator {\n    func validateStrength(_ password: String) -&gt; PasswordStrength\n    func validateRequirements(_ password: String) -&gt; [PasswordRequirement]\n}\n</code></pre>"},{"location":"api/keychain/password-management/#strength-levels","title":"Strength Levels","text":"<ul> <li>Weak: Fails to meet minimum requirements</li> <li>Moderate: Meets minimum requirements</li> <li>Strong: Exceeds minimum requirements</li> <li>Very Strong: Significantly exceeds requirements</li> </ul>"},{"location":"api/keychain/password-management/#password-rotation","title":"Password Rotation","text":"<p>Passwords can be configured with expiration policies:</p> <pre><code>struct PasswordMetadata {\n    let creationDate: Date\n    let expirationDate: Date?\n    let lastRotated: Date?\n    let strengthScore: Int\n}\n</code></pre>"},{"location":"api/keychain/password-management/#rotation-policies","title":"Rotation Policies","text":"<ul> <li>Time-based: Rotate after a specified duration</li> <li>Access-based: Rotate after number of uses</li> <li>Strength-based: Rotate when strength requirements change</li> </ul>"},{"location":"api/keychain/password-management/#error-handling","title":"Error Handling","text":"<p>Common password-related errors:</p> <ul> <li><code>WeakPasswordError</code>: Password doesn't meet requirements</li> <li><code>ExpiredPasswordError</code>: Password needs rotation</li> <li><code>ValidationError</code>: General validation failures</li> <li><code>RotationError</code>: Issues during password rotation</li> </ul>"},{"location":"api/keychain/password-management/#best-practices","title":"Best Practices","text":"<ol> <li>Always use the validation system</li> <li>Implement automatic rotation</li> <li>Handle errors appropriately</li> <li>Use secure password generation</li> <li>Maintain audit logs</li> </ol>"},{"location":"api/keychain/password-management/#examples","title":"Examples","text":""},{"location":"api/keychain/password-management/#validating-a-password","title":"Validating a Password","text":"<pre><code>let validator = DefaultPasswordValidator()\nlet strength = validator.validateStrength(\"MySecurePass123!\")\nlet requirements = validator.validateRequirements(\"MySecurePass123!\")\n</code></pre>"},{"location":"api/keychain/password-management/#rotating-a-password","title":"Rotating a Password","text":"<pre><code>let rotator = PasswordRotator()\ntry await rotator.rotatePassword(\n    identifier: \"main-backup-repo\",\n    newPassword: generateSecurePassword()\n)\n</code></pre>"},{"location":"api/keychain/secure-storage/","title":"Secure Storage","text":"<p>The secure storage system in UmbraKeychainService provides a robust interface for storing sensitive data in the system keychain.</p>"},{"location":"api/keychain/secure-storage/#features","title":"Features","text":"<ul> <li>Secure credential storage</li> <li>Biometric authentication</li> <li>Access control management</li> <li>Automatic encryption</li> <li>Secure backup/restore</li> </ul>"},{"location":"api/keychain/secure-storage/#access-control","title":"Access Control","text":"<pre><code>struct KeychainAccessControl {\n    let requiresBiometrics: Bool\n    let accessibleMode: AccessibleMode\n    let sharingMode: SharingMode\n    let timeout: TimeInterval?\n}\n</code></pre>"},{"location":"api/keychain/secure-storage/#access-modes","title":"Access Modes","text":"<ul> <li><code>whenUnlocked</code>: Only when device is unlocked</li> <li><code>afterFirstUnlock</code>: After first unlock until restart</li> <li><code>always</code>: Always accessible (use with caution)</li> </ul>"},{"location":"api/keychain/secure-storage/#sharing-options","title":"Sharing Options","text":"<ul> <li><code>none</code>: No sharing</li> <li><code>sameUserOnly</code>: Share with same user</li> <li><code>anyUser</code>: Share with any user (admin only)</li> </ul>"},{"location":"api/keychain/secure-storage/#encryption","title":"Encryption","text":"<p>All data is encrypted before storage:</p> <ul> <li>AES-256 encryption</li> <li>Secure key generation</li> <li>Key rotation support</li> <li>Forward secrecy</li> </ul>"},{"location":"api/keychain/secure-storage/#backup-and-restore","title":"Backup and Restore","text":"<pre><code>protocol SecureBackupProvider {\n    func createBackup() async throws -&gt; BackupMetadata\n    func restoreFromBackup(_ backup: BackupData) async throws\n    func validateBackup(_ backup: BackupData) async throws -&gt; Bool\n}\n</code></pre>"},{"location":"api/keychain/secure-storage/#backup-features","title":"Backup Features","text":"<ul> <li>Encrypted backups</li> <li>Version control</li> <li>Integrity verification</li> <li>Secure transport</li> </ul>"},{"location":"api/keychain/secure-storage/#error-handling","title":"Error Handling","text":"<p>Common storage errors:</p> <ul> <li><code>AccessDeniedError</code>: Permission issues</li> <li><code>EncryptionError</code>: Encryption failures</li> <li><code>BackupError</code>: Backup/restore issues</li> <li><code>AuthenticationError</code>: Auth failures</li> </ul>"},{"location":"api/keychain/secure-storage/#best-practices","title":"Best Practices","text":"<ol> <li>Use appropriate access controls</li> <li>Implement regular backups</li> <li>Rotate encryption keys</li> <li>Monitor access patterns</li> <li>Handle errors securely</li> </ol>"},{"location":"api/keychain/secure-storage/#examples","title":"Examples","text":""},{"location":"api/keychain/secure-storage/#storing-a-password","title":"Storing a Password","text":"<pre><code>let storage = SecureStorage()\ntry await storage.store(\n    password: \"MySecurePass123!\",\n    identifier: \"backup-repo\",\n    accessControl: .init(\n        requiresBiometrics: true,\n        accessibleMode: .whenUnlocked\n    )\n)\n</code></pre>"},{"location":"api/keychain/secure-storage/#creating-a-backup","title":"Creating a Backup","text":"<pre><code>let backupProvider = SecureBackupProvider()\nlet backup = try await backupProvider.createBackup()\ntry await backupProvider.validateBackup(backup)\n</code></pre>"},{"location":"api/keychain/xpc-integration/","title":"XPC Integration","text":"<p>The XPC integration in UmbraKeychainService provides secure inter-process communication for credential management.</p>"},{"location":"api/keychain/xpc-integration/#architecture","title":"Architecture","text":""},{"location":"api/keychain/xpc-integration/#service-definition","title":"Service Definition","text":"<pre><code>protocol KeychainXPCServiceProtocol {\n    func storePassword(_ password: String, \n                      identifier: String, \n                      accessControl: KeychainAccessControl) async throws\n    func retrievePassword(identifier: String) async throws -&gt; String\n    func deletePassword(identifier: String) async throws\n    func validatePassword(_ password: String) async throws -&gt; ValidationResult\n}\n</code></pre>"},{"location":"api/keychain/xpc-integration/#security-boundaries","title":"Security Boundaries","text":"<p>The XPC service: - Runs in an isolated process - Has minimal privileges - Handles all keychain operations - Manages secure storage</p>"},{"location":"api/keychain/xpc-integration/#implementation","title":"Implementation","text":""},{"location":"api/keychain/xpc-integration/#service-setup","title":"Service Setup","text":"<pre><code>class KeychainXPCService: NSObject, KeychainXPCServiceProtocol {\n    private let storage: SecureStorage\n    private let validator: PasswordValidator\n\n    override init() {\n        self.storage = SecureStorage()\n        self.validator = DefaultPasswordValidator()\n        super.init()\n    }\n}\n</code></pre>"},{"location":"api/keychain/xpc-integration/#client-integration","title":"Client Integration","text":"<pre><code>class KeychainClient {\n    private let connection: NSXPCConnection\n\n    init() {\n        connection = NSXPCConnection(serviceName: \"dev.umbracore.keychain\")\n        connection.remoteObjectInterface = NSXPCInterface(with: KeychainXPCServiceProtocol.self)\n        connection.resume()\n    }\n}\n</code></pre>"},{"location":"api/keychain/xpc-integration/#error-handling","title":"Error Handling","text":"<p>XPC-specific errors:</p> <ul> <li><code>ConnectionError</code>: XPC connection issues</li> <li><code>TimeoutError</code>: Operation timeouts</li> <li><code>SecurityError</code>: Security violations</li> <li><code>ServiceError</code>: Service-specific errors</li> </ul>"},{"location":"api/keychain/xpc-integration/#best-practices","title":"Best Practices","text":"<ol> <li>Validate all inputs</li> <li>Handle connection failures</li> <li>Implement timeouts</li> <li>Monitor service health</li> <li>Log security events</li> </ol>"},{"location":"api/keychain/xpc-integration/#examples","title":"Examples","text":""},{"location":"api/keychain/xpc-integration/#using-the-service","title":"Using the Service","text":"<pre><code>let client = KeychainClient()\ntry await client.storePassword(\n    \"MySecurePass123!\",\n    identifier: \"backup-repo\",\n    accessControl: .init(requiresBiometrics: true)\n)\n</code></pre>"},{"location":"api/keychain/xpc-integration/#error-handling_1","title":"Error Handling","text":"<pre><code>do {\n    let password = try await client.retrievePassword(\"backup-repo\")\n} catch KeychainError.connectionFailed {\n    // Handle connection failure\n} catch KeychainError.accessDenied {\n    // Handle access denied\n} catch {\n    // Handle other errors\n}\n</code></pre>"},{"location":"contributing/CONTRIBUTING/","title":"Contributing to UmbraCore","text":""},{"location":"contributing/CONTRIBUTING/#getting-started","title":"Getting Started","text":""},{"location":"contributing/CONTRIBUTING/#1-development-environment","title":"1. Development Environment","text":"<ul> <li>macOS 14.0+</li> <li>Xcode 15.2+</li> <li>Swift 6.0.3+</li> <li>SwiftLint</li> <li>Restic</li> </ul>"},{"location":"contributing/CONTRIBUTING/#2-setup","title":"2. Setup","text":"<ol> <li>Fork the repository</li> <li>Clone your fork</li> <li>Install dependencies</li> <li>Run tests</li> </ol>"},{"location":"contributing/CONTRIBUTING/#development-process","title":"Development Process","text":""},{"location":"contributing/CONTRIBUTING/#1-branching","title":"1. Branching","text":"<ul> <li><code>main</code>: Production-ready code</li> <li><code>develop</code>: Integration branch</li> <li>Feature branches: <code>feature/description</code></li> <li>Bug fixes: <code>fix/description</code></li> </ul>"},{"location":"contributing/CONTRIBUTING/#2-commit-messages","title":"2. Commit Messages","text":"<p>Follow conventional commits: <pre><code>type(scope): description\n\n[optional body]\n\n[optional footer]\n</code></pre></p> <p>Types: - feat: New feature - fix: Bug fix - docs: Documentation - style: Formatting - refactor: Code restructuring - test: Adding tests - chore: Maintenance</p>"},{"location":"contributing/CONTRIBUTING/#3-code-style","title":"3. Code Style","text":"<ul> <li>Follow Swift API Design Guidelines</li> <li>Use SwiftLint rules</li> <li>Document public APIs</li> <li>Write meaningful comments</li> </ul>"},{"location":"contributing/CONTRIBUTING/#4-testing","title":"4. Testing","text":"<ul> <li>Write unit tests</li> <li>Include integration tests</li> <li>Maintain test coverage</li> <li>Test error conditions</li> </ul>"},{"location":"contributing/CONTRIBUTING/#5-documentation","title":"5. Documentation","text":"<ul> <li>Update API documentation</li> <li>Include code examples</li> <li>Document breaking changes</li> <li>Update guides if needed</li> </ul>"},{"location":"contributing/CONTRIBUTING/#pull-requests","title":"Pull Requests","text":""},{"location":"contributing/CONTRIBUTING/#1-preparation","title":"1. Preparation","text":"<ul> <li>Update from upstream</li> <li>Run all tests</li> <li>Check code coverage</li> <li>Run SwiftLint</li> </ul>"},{"location":"contributing/CONTRIBUTING/#2-submission","title":"2. Submission","text":"<ul> <li>Clear description</li> <li>Link related issues</li> <li>Include test cases</li> <li>Update documentation</li> </ul>"},{"location":"contributing/CONTRIBUTING/#3-review-process","title":"3. Review Process","text":"<ul> <li>Address feedback</li> <li>Keep changes focused</li> <li>Maintain clean history</li> <li>Update as needed</li> </ul>"},{"location":"contributing/CONTRIBUTING/#release-process","title":"Release Process","text":""},{"location":"contributing/CONTRIBUTING/#1-versioning","title":"1. Versioning","text":"<p>Follow semantic versioning: - MAJOR: Breaking changes - MINOR: New features - PATCH: Bug fixes</p>"},{"location":"contributing/CONTRIBUTING/#2-release-checklist","title":"2. Release Checklist","text":"<ul> <li>Update changelog</li> <li>Update version</li> <li>Run full test suite</li> <li>Update documentation</li> <li>Create release notes</li> </ul>"},{"location":"contributing/CONTRIBUTING/#additional-resources","title":"Additional Resources","text":"<ul> <li>Swift API Design Guidelines</li> <li>SwiftLint Rules</li> <li>Conventional Commits</li> </ul>"},{"location":"development/","title":"Development Guide","text":"<p>This section contains technical documentation for developers working with UmbraCore.</p>"},{"location":"development/#development-topics","title":"Development Topics","text":"<ul> <li>Architecture overview</li> <li>Integration guides</li> <li>Contributing guidelines</li> <li>API documentation</li> </ul>"},{"location":"development/#available-guides","title":"Available Guides","text":"<ul> <li>Bazel &amp; SPM Integration: Build system integration guide</li> <li>Architecture: System architecture and design</li> <li>Contributing: Guidelines for contributors</li> </ul>"},{"location":"development/architecture/","title":"UmbraCore Architecture","text":""},{"location":"development/architecture/#overview","title":"Overview","text":"<p>UmbraCore follows a modular architecture with a strong focus on security, type safety, and maintainability. The system is designed around the principle of separation of concerns, with distinct modules handling specific aspects of the backup management process.</p>"},{"location":"development/architecture/#core-architecture-principles","title":"Core Architecture Principles","text":""},{"location":"development/architecture/#security-first-design","title":"Security-First Design","text":"<ul> <li>Foundation-free core modules for critical security operations</li> <li>XPC services for privileged operations</li> <li>Secure keychain integration with sandboxing support</li> </ul>"},{"location":"development/architecture/#module-organisation","title":"Module Organisation","text":"<p>UmbraCore is organised into several logical layers:</p> <ol> <li>Core Foundation-Free Layer</li> <li>SecurityProtocolsCore</li> <li>XPCProtocolsCore</li> <li> <p>UmbraCoreTypes</p> </li> <li> <p>Foundation Bridge Layer</p> </li> <li>SecurityBridge</li> <li> <p>XPCBridge</p> </li> <li> <p>Implementation Layer</p> </li> <li>SecurityImplementation</li> <li> <p>UmbraSecurity</p> </li> <li> <p>Application Services</p> </li> <li>UmbraKeychainService</li> <li>ResticCLIHelper</li> <li>RepositoryManager</li> <li>BackupCoordinator</li> </ol>"},{"location":"development/architecture/#error-handling-architecture","title":"Error Handling Architecture","text":"<p>UmbraCore implements a comprehensive error handling system with:</p> <ul> <li>Domain-specific error types</li> <li>Consistent error mapping between modules</li> <li>Rich error context for debugging</li> </ul>"},{"location":"development/architecture/#concurrency-model","title":"Concurrency Model","text":"<p>The project uses Swift's structured concurrency model with:</p> <ul> <li>Async/await for asynchronous operations</li> <li>Actor-based isolation for thread safety</li> <li>Task management for cancellation support</li> </ul>"},{"location":"development/architecture/#xpc-integration","title":"XPC Integration","text":"<p>UmbraCore uses XPC extensively for privilege separation:</p> <ul> <li>Main app remains sandboxed</li> <li>XPC services handle privileged operations</li> <li>Well-defined protocol interfaces using Swift's protocol system</li> </ul>"},{"location":"development/bazel_spm/","title":"UmbraCore: Bazel and SPM Integration Brief","text":""},{"location":"development/bazel_spm/#overview","title":"Overview","text":"<p>This document outlines our strategy for integrating Bazel build system while maintaining Swift Package Manager (SPM) compatibility in the UmbraCore project.</p>"},{"location":"development/bazel_spm/#1-integration-goals","title":"1. Integration Goals","text":"<ul> <li>Maintain existing SPM dependencies</li> <li>Leverage Bazel's build caching</li> <li>Optimise CI/CD performance</li> <li>Support future scalability</li> </ul>"},{"location":"development/bazel_spm/#2-technical-architecture","title":"2. Technical Architecture","text":""},{"location":"development/bazel_spm/#21-build-system-components","title":"2.1 Build System Components","text":"<pre><code>UmbraCore/\n\u251c\u2500\u2500 WORKSPACE\n\u251c\u2500\u2500 MODULE.bazel          # Bazel module configuration\n\u251c\u2500\u2500 Package.swift         # SPM dependencies\n\u251c\u2500\u2500 Package.resolved      # SPM version lock\n\u251c\u2500\u2500 .bazelrc             # Bazel settings\n\u251c\u2500\u2500 BUILD.bazel          # Root build file\n\u251c\u2500\u2500 Sources/             # Source files\n\u2502   \u2514\u2500\u2500 */\n\u2502       \u251c\u2500\u2500 BUILD       # Generated by Gazelle\n\u2502       \u2514\u2500\u2500 *.swift\n\u2514\u2500\u2500 Tests/              # Test files\n    \u2514\u2500\u2500 */\n        \u251c\u2500\u2500 BUILD       # Generated by Gazelle\n        \u2514\u2500\u2500 *.swift\n</code></pre>"},{"location":"development/bazel_spm/#22-key-configuration-files","title":"2.2 Key Configuration Files","text":""},{"location":"development/bazel_spm/#modulebazel","title":"MODULE.bazel","text":"<pre><code>bazel_dep(name = \"rules_swift_package_manager\", version = \"0.46.0\")\n\nswift_deps = use_extension(\n    \"@rules_swift_package_manager//:extensions.bzl\",\n    \"swift_deps\",\n)\n\nswift_deps.configure_swift_package(\n    build_path = \"spm-build\",\n    cache_path = \"spm-cache\",\n    dependency_caching = \"true\",\n    manifest_cache = \"local\",\n    manifest_caching = \"true\",\n)\n\nswift_deps.from_package(\n    declare_swift_deps_info = True,\n    declare_swift_package = True,\n    resolved = \"//:Package.resolved\",\n    swift = \"//:Package.swift\",\n)\n</code></pre>"},{"location":"development/bazel_spm/#bazelrc","title":".bazelrc","text":"<pre><code># Enable bzlmod\nbuild --enable_bzlmod\n\n# SPM integration\nbuild --experimental_enable_swift_package_manager\n\n# Caching configuration\nbuild --remote_cache=grpcs://cache.buildbuddy.io\nbuild --remote_timeout=3600\n</code></pre>"},{"location":"development/bazel_spm/#3-dependency-management","title":"3. Dependency Management","text":""},{"location":"development/bazel_spm/#31-spm-dependencies","title":"3.1 SPM Dependencies","text":"<ul> <li>CryptoSwift (v1.8.0+)</li> <li>SwiftyBeaver (v2.0.0+)</li> </ul>"},{"location":"development/bazel_spm/#32-bazel-dependencies","title":"3.2 Bazel Dependencies","text":"<ul> <li>rules_swift_package_manager</li> <li>rules_swift</li> <li>rules_apple (optional)</li> <li>Gazelle</li> </ul>"},{"location":"development/bazel_spm/#4-caching-strategy","title":"4. Caching Strategy","text":""},{"location":"development/bazel_spm/#41-cache-locations","title":"4.1 Cache Locations","text":"<ul> <li><code>spm-cache/</code>: SPM dependency cache</li> <li><code>spm-build/</code>: SPM build artifacts</li> <li><code>bazel-*/</code>: Bazel build outputs</li> <li><code>~/.cache/bazel</code>: Bazel system cache</li> </ul>"},{"location":"development/bazel_spm/#42-cicd-caching","title":"4.2 CI/CD Caching","text":"<pre><code>cache:\n  paths:\n    - ~/.cache/bazel\n    - spm-cache\n    - spm-build\n  key: ${CI_COMMIT_REF_SLUG}\n</code></pre>"},{"location":"development/bazel_spm/#5-common-operations","title":"5. Common Operations","text":""},{"location":"development/bazel_spm/#51-dependency-management","title":"5.1 Dependency Management","text":"<pre><code># Update all dependencies\nbazel run @swift_package//:update\n\n# Update specific package\nbazel run @swift_package//:update -- SwiftyBeaver\n\n# Resolve dependencies\nbazel run @swift_package//:resolve\n</code></pre>"},{"location":"development/bazel_spm/#52-build-operations","title":"5.2 Build Operations","text":"<pre><code># Build entire project\nbazel build //...\n\n# Run tests\nbazel test //...\n\n# Generate BUILD files\nbazel run //:update_build_files\n</code></pre>"},{"location":"development/bazel_spm/#6-best-practices","title":"6. Best Practices","text":""},{"location":"development/bazel_spm/#61-development-workflow","title":"6.1 Development Workflow","text":"<ol> <li>Use Bazel commands for all build operations</li> <li>Keep Package.swift minimal and focused</li> <li>Regularly update cached dependencies</li> <li>Monitor cache size and performance</li> </ol>"},{"location":"development/bazel_spm/#62-code-organisation","title":"6.2 Code Organisation","text":"<ol> <li>Follow module structure in Sources/</li> <li>Maintain clear dependency boundaries</li> <li>Use proper visibility declarations</li> <li>Keep BUILD files organised</li> </ol>"},{"location":"development/bazel_spm/#63-language-standards","title":"6.3 Language Standards","text":"<ol> <li>Use British English in:</li> <li>Documentation</li> <li>Comments</li> <li>User-facing text</li> <li>Use American English in:</li> <li>Code</li> <li>Build files</li> <li>Configuration</li> </ol>"},{"location":"development/bazel_spm/#7-performance-considerations","title":"7. Performance Considerations","text":""},{"location":"development/bazel_spm/#71-local-development","title":"7.1 Local Development","text":"<ul> <li>Use local caching</li> <li>Enable parallel builds</li> <li>Monitor resource usage</li> <li>Regular cache cleanup</li> </ul>"},{"location":"development/bazel_spm/#72-cicd-pipeline","title":"7.2 CI/CD Pipeline","text":"<ul> <li>Optimise cache sharing</li> <li>Use remote caching</li> <li>Enable parallel testing</li> <li>Monitor build times</li> </ul>"},{"location":"development/bazel_spm/#8-migration-timeline","title":"8. Migration Timeline","text":""},{"location":"development/bazel_spm/#phase-1-initial-setup-1-week","title":"Phase 1: Initial Setup (1 week)","text":"<ul> <li>[ ] Configure Bazel</li> <li>[ ] Set up SPM integration</li> <li>[ ] Configure caching</li> <li>[ ] Update documentation</li> </ul>"},{"location":"development/bazel_spm/#phase-2-build-migration-2-weeks","title":"Phase 2: Build Migration (2 weeks)","text":"<ul> <li>[ ] Generate BUILD files</li> <li>[ ] Test build system</li> <li>[ ] Validate dependencies</li> <li>[ ] Performance testing</li> </ul>"},{"location":"development/bazel_spm/#phase-3-cicd-integration-1-week","title":"Phase 3: CI/CD Integration (1 week)","text":"<ul> <li>[ ] Configure GitHub Actions</li> <li>[ ] Set up caching</li> <li>[ ] Test workflows</li> <li>[ ] Monitor performance</li> </ul>"},{"location":"development/bazel_spm/#9-support-and-maintenance","title":"9. Support and Maintenance","text":""},{"location":"development/bazel_spm/#91-regular-tasks","title":"9.1 Regular Tasks","text":"<ul> <li>Weekly dependency updates</li> <li>Monthly cache cleanup</li> <li>Quarterly performance review</li> <li>Regular documentation updates</li> </ul>"},{"location":"development/bazel_spm/#92-monitoring","title":"9.2 Monitoring","text":"<ul> <li>Build times</li> <li>Cache hit rates</li> <li>Dependency updates</li> <li>Resource usage</li> </ul>"},{"location":"development/bazel_spm/#10-references","title":"10. References","text":"<ol> <li>Bazel Documentation</li> <li>rules_swift_package_manager</li> <li>Swift Package Manager</li> <li>GitHub Actions Documentation</li> </ol>"},{"location":"development/contributing/","title":"Contributing to UmbraCore","text":"<p>This page will contain information about contributing to UmbraCore. Check back soon for updates.</p>"},{"location":"development/contributing/#coming-soon","title":"Coming Soon","text":"<ul> <li>Development setup</li> <li>Coding standards</li> <li>Testing guidelines</li> <li>Pull request process</li> <li>Documentation guidelines</li> </ul>"},{"location":"development/project_structure/","title":"Project Structure","text":"<p>/Users/mpy/CascadeProjects/UmbraCore |-- Sources |   |-- API |   |   <code>-- UmbraAPI.swift |   |-- Autocomplete |   |   |-- Errors |   |   |-- Extensions |   |   |-- Models |   |   |-- Protocols |   |   |</code>-- AutocompleteProtocol.swift |   |   |-- Services |   |   <code>-- README.md |   |-- Config |   |   |-- Errors |   |   |-- Extensions |   |   |-- Models |   |   |-- Protocols |   |   |</code>-- ConfigurationProtocol.swift |   |   |-- Services |   |   <code>-- README.md |   |-- Core |   |   |-- CryptoTypes |   |   |-- Protocols |   |   |-- SecurityTypes |   |   |-- Services |   |   |</code>-- CoreService.swift |   |   |-- Types |   |   <code>-- UmbraCore |   |       |-- Security |   |</code>-- UmbraCore.swift |   |-- CryptoTypes |   |   |-- Models |   |   |   <code>-- SecureStorageData.swift |   |   |-- Protocols |   |   |</code>-- CryptoServiceProtocol.swift |   |   |-- Services |   |   |   |-- CredentialManager.swift |   |   |   <code>-- CryptoService.swift |   |</code>-- Types |   |       |-- CryptoConfiguration.swift |   |       <code>-- CryptoError.swift |   |-- ErrorHandling |   |   |-- Errors |   |   |-- Extensions |   |   |</code>-- Error+Context.swift |   |   |-- Models |   |   |   |-- CommonError.swift |   |   |   |-- CoreError.swift |   |   |   |-- ErrorContext.swift |   |   |   <code>-- ServiceErrorTypes.swift |   |   |-- Protocols |   |   |   |-- ErrorHandlingProtocol.swift |   |   |   |-- ErrorReporting.swift |   |   |</code>-- ServiceErrorProtocol.swift |   |   |-- Services |   |   <code>-- README.md |   |-- Features |   |   |-- Crypto |   |   |   |-- Errors |   |   |   |-- Models |   |   |   |</code>-- SecureStorageData.swift |   |   |   |-- Protocols |   |   |   |   <code>-- SecureStorageProvider.swift |   |   |</code>-- Services |   |   <code>-- Logging |   |       |-- Errors |   |       |</code>-- LoggingError.swift |   |       |-- Extensions |   |       |-- Models |   |       |   <code>-- LogEntry.swift |   |       |-- Protocols |   |       |</code>-- LoggingProtocol.swift |   |       |-- Services |   |       |   |-- LoggingService.swift |   |       |   <code>-- SwiftyBeaverLoggingService.swift |   |</code>-- README.md |   |-- Mocks |   |   |-- MockKeychain.swift |   |   |-- MockSecurityProvider.swift |   |   <code>-- MockURLProvider.swift |   |-- Repositories |   |   |-- Errors |   |   |-- Extensions |   |   |-- Models |   |   |-- Protocols |   |   |</code>-- RepositoryProtocol.swift |   |   |-- Services |   |   <code>-- README.md |   |-- ResticCLIHelper |   |   |-- Errors |   |   |-- Extensions |   |   |-- Models |   |   |-- Protocols |   |   |</code>-- ResticCLIHelperProtocol.swift |   |   |-- Services |   |   <code>-- README.md |   |-- SecurityTypes |   |   |-- Models |   |   |   |-- FilePermission.swift |   |   |</code>-- SecurityError.swift |   |   |-- Protocols |   |   |   |-- SecureStorageProvider.swift |   |   |   <code>-- SecurityProvider.swift |   |   |-- Testing |   |</code>-- Types |   |       <code>-- SecurityErrorHandler.swift |   |-- Services |   |</code>-- SecurityUtils |   |       |-- Extensions |   |       |-- Protocols |   |       |   <code>-- URLProvider.swift |   |       |-- Services |   |       |   |-- EncryptedBookmarkService.swift |   |       |</code>-- SecurityBookmarkService.swift |   |       |-- Testing |   |       <code>-- Types |   |-- Snapshots |   |   |-- Errors |   |   |-- Extensions |   |   |-- Models |   |   |-- Protocols |   |   |</code>-- SnapshotProtocol.swift |   |   |-- Services |   |   <code>-- README.md |   |-- UmbraCore |   |</code>-- UmbraCore.swift |   |-- UmbraMocks |   |   |-- MockCryptoService.swift |   |   |-- MockKeychain.swift |   |   <code>-- MockSecurityProvider.swift |   |-- UmbraSecurity |   |   |-- Extensions |   |   |</code>-- URL+SecurityScoped.swift |   |   <code>-- Services |   |</code>-- SecurityService.swift |   <code>-- XPC |       |-- Core |       |   |-- XPCConnectionManager.swift |       |   |-- XPCError.swift |       |</code>-- XPCServiceProtocols.swift |       |-- CryptoService |       <code>-- SecurityService |-- Tests |   |-- AutocompleteTests |   |   |-- Errors |   |   |-- Extensions |   |   |-- Models |   |   |-- Protocols |   |</code>-- Services |   |-- ConfigTests |   |   |-- Errors |   |   |-- Extensions |   |   |-- Models |   |   |-- Protocols |   |   <code>-- Services |   |-- CoreTests |   |   |-- CoreServiceTests.swift |   |</code>-- URLSecurityTests.swift |   |-- CryptoTests |   |   |-- Mocks |   |   |-- CredentialManagerTests.swift |   |   <code>-- CryptoServiceTests.swift |   |-- ErrorHandlingTests |   |   |-- Errors |   |   |-- Extensions |   |   |-- Models |   |   |-- Protocols |   |   |-- Services |   |   |-- CommonErrorTests.swift |   |</code>-- CoreErrorTests.swift |   |-- LoggingTests |   |   |-- Errors |   |   |-- Extensions |   |   |-- Models |   |   |-- Protocols |   |   |-- Services |   |   <code>-- LoggingServiceTests.swift |   |-- RepositoriesTests |   |   |-- Errors |   |   |-- Extensions |   |   |-- Models |   |   |-- Protocols |   |</code>-- Services |   |-- ResticCLIHelperTests |   |   |-- Errors |   |   |-- Extensions |   |   |-- Models |   |   |-- Protocols |   |   <code>-- Services |   |-- SecurityTypesTests |   |   |-- MockSecurityProviderTests.swift |   |</code>-- SecurityErrorTests.swift |   |-- SecurityUtilsTests |   |   |-- EncryptedBookmarkServiceTests.swift |   |   <code>-- SecurityBookmarkServiceTests.swift |   |-- SnapshotsTests |   |   |-- Errors |   |   |-- Extensions |   |   |-- Models |   |   |-- Protocols |   |</code>-- Services |   |-- UmbraCoreTests |   |   <code>-- UmbraCoreTests.swift |</code>-- UmbraSecurityTests |       <code>-- SecurityServiceTests.swift |-- .gitignore |-- LICENSE |-- Package.resolved |-- Package.swift |-- README.md |-- STRUCTURE.md |-- UmbraCore.md</code>-- project_structure.md</p> <p>136 directories, 77 files</p>"},{"location":"development/project_structure/#umbracore-project-structure-documentation","title":"UmbraCore Project Structure Documentation","text":""},{"location":"development/project_structure/#project-overview","title":"Project Overview","text":"<ul> <li>Name: UmbraCore</li> <li>Version: 1.0.0</li> <li>Swift Version: 5.9.2/6.0.3</li> <li>Platform: macOS 14+</li> <li>Package Manager: Swift Package Manager (SPM)</li> </ul>"},{"location":"development/project_structure/#key-dependencies","title":"Key Dependencies","text":"<ul> <li>SwiftyBeaver: v2.1.1 (logging)</li> <li>CryptoSwift: v1.8.4 (crypto operations)</li> </ul>"},{"location":"development/project_structure/#core-components","title":"Core Components","text":""},{"location":"development/project_structure/#security-infrastructure","title":"Security Infrastructure","text":"<ul> <li>SecurityTypes Module: Core security types and protocols</li> <li>CryptoTypes Module: Cryptographic operations and types</li> <li>UmbraMocks Module: Mock implementations for testing</li> </ul>"},{"location":"development/project_structure/#implementation-details","title":"Implementation Details","text":"<ul> <li>Encryption: AES-256-GCM with combined auth mode</li> <li>Key Derivation: PBKDF2 with SHA-256 (10,000 iterations)</li> <li>IV Length: 12 bytes (GCM requirement)</li> <li>Salt Length: 32 bytes</li> <li>HMAC: SHA-256 based</li> </ul>"},{"location":"development/project_structure/#xpc-integration-in-progress","title":"XPC Integration (In Progress)","text":"<ul> <li>Core XPC infrastructure</li> <li>CryptoService XPC implementation</li> <li>SecurityService XPC implementation</li> </ul>"},{"location":"development/project_structure/#build-instructions","title":"Build Instructions","text":"<pre><code>swift build\nswift test\n</code></pre>"},{"location":"development/project_structure/#note","title":"Note","text":"<p>This structure snapshot was created on 2025-02-17 before implementing XPC services. Keep this file for reference in case rollback is needed.</p>"},{"location":"development/xpc_implementation_plan/","title":"UmbraCore XPC Implementation Plan","text":""},{"location":"development/xpc_implementation_plan/#overview","title":"Overview","text":"<p>Document Version: 1.0.0 Date: 2025-02-17 Status: In Progress</p>"},{"location":"development/xpc_implementation_plan/#1-architecture-changes","title":"1. Architecture Changes","text":""},{"location":"development/xpc_implementation_plan/#current-architecture","title":"Current Architecture","text":"<pre><code>UmbraCore/\n\u251c\u2500\u2500 CryptoTypes/\n\u2502   \u2514\u2500\u2500 Services/\n\u2502       \u251c\u2500\u2500 CryptoService.swift       # Direct crypto operations\n\u2502       \u2514\u2500\u2500 CredentialManager.swift    # Direct credential management\n\u2514\u2500\u2500 SecurityTypes/\n    \u2514\u2500\u2500 Protocols/\n        \u2514\u2500\u2500 SecurityProvider.swift     # Direct security operations\n</code></pre>"},{"location":"development/xpc_implementation_plan/#target-architecture","title":"Target Architecture","text":"<pre><code>UmbraCore/\n\u251c\u2500\u2500 XPC/\n\u2502   \u251c\u2500\u2500 Core/                         # XPC infrastructure\n\u2502   \u2502   \u251c\u2500\u2500 XPCError.swift\n\u2502   \u2502   \u251c\u2500\u2500 XPCServiceProtocols.swift\n\u2502   \u2502   \u2514\u2500\u2500 XPCConnectionManager.swift\n\u2502   \u251c\u2500\u2500 CryptoService/               # Crypto XPC service\n\u2502   \u2502   \u251c\u2500\u2500 CryptoXPCService.swift\n\u2502   \u2502   \u2514\u2500\u2500 Info.plist\n\u2502   \u2514\u2500\u2500 SecurityService/             # Security XPC service\n\u2502       \u251c\u2500\u2500 SecurityXPCService.swift\n\u2502       \u2514\u2500\u2500 Info.plist\n\u2514\u2500\u2500 [existing modules remain]\n</code></pre>"},{"location":"development/xpc_implementation_plan/#2-migration-strategy","title":"2. Migration Strategy","text":""},{"location":"development/xpc_implementation_plan/#phase-1-infrastructure-current","title":"Phase 1: Infrastructure (Current)","text":"<ul> <li>[x] Create XPC Core module</li> <li>[x] Define XPC protocols</li> <li>[x] Implement connection management</li> <li>[x] Add error handling</li> </ul>"},{"location":"development/xpc_implementation_plan/#phase-2-service-implementation","title":"Phase 2: Service Implementation","text":"<ul> <li>[ ] Create CryptoXPCService</li> <li>[ ] Implement service bundle</li> <li>[ ] Add privilege separation</li> <li>[ ] Set up entitlements</li> <li> <p>[ ] Configure sandbox</p> </li> <li> <p>[ ] Create SecurityXPCService</p> </li> <li>[ ] Implement service bundle</li> <li>[ ] Add privilege separation</li> <li>[ ] Set up entitlements</li> <li>[ ] Configure sandbox</li> </ul>"},{"location":"development/xpc_implementation_plan/#phase-3-client-updates","title":"Phase 3: Client Updates","text":"<ul> <li>[ ] Update CredentialManager</li> <li>[ ] Add XPC client implementation</li> <li>[ ] Implement fallback mechanism</li> <li> <p>[ ] Add connection recovery</p> </li> <li> <p>[ ] Update SecurityProvider clients</p> </li> <li>[ ] Add XPC client implementation</li> <li>[ ] Implement fallback mechanism</li> <li>[ ] Add connection recovery</li> </ul>"},{"location":"development/xpc_implementation_plan/#phase-4-testing-validation","title":"Phase 4: Testing &amp; Validation","text":"<ul> <li>[ ] Create XPCTests target</li> <li>[ ] Implement service tests</li> <li>[ ] Add connection tests</li> <li>[ ] Test error scenarios</li> <li>[ ] Validate security boundaries</li> </ul>"},{"location":"development/xpc_implementation_plan/#3-security-considerations","title":"3. Security Considerations","text":""},{"location":"development/xpc_implementation_plan/#privilege-separation","title":"Privilege Separation","text":"<pre><code>// Example service configuration\nlet connection = NSXPCConnection(serviceName: \"com.umbracore.cryptoservice\")\nconnection.remoteObjectInterface = NSXPCInterface(with: CryptoXPCServiceProtocol.self)\nconnection.auditSessionIdentifier = au_session_self()\n</code></pre>"},{"location":"development/xpc_implementation_plan/#entitlements","title":"Entitlements","text":"<pre><code>&lt;!-- Required entitlements --&gt;\n&lt;key&gt;com.apple.security.app-sandbox&lt;/key&gt;\n&lt;true/&gt;\n&lt;key&gt;com.apple.security.temporary-exception.files.home-relative-path.read-write&lt;/key&gt;\n&lt;string&gt;Library/Application Support/UmbraCore/&lt;/string&gt;\n</code></pre>"},{"location":"development/xpc_implementation_plan/#4-error-handling-strategy","title":"4. Error Handling Strategy","text":""},{"location":"development/xpc_implementation_plan/#error-categories","title":"Error Categories","text":"<ol> <li>Connection Errors</li> <li>Service Errors</li> <li>Security Validation Errors</li> <li>Resource Errors</li> </ol>"},{"location":"development/xpc_implementation_plan/#recovery-strategy","title":"Recovery Strategy","text":"<pre><code>public protocol XPCErrorRecoverable {\n    var isRecoverable: Bool { get }\n    var retryCount: Int { get }\n    var retryDelay: TimeInterval { get }\n}\n</code></pre>"},{"location":"development/xpc_implementation_plan/#5-performance-considerations","title":"5. Performance Considerations","text":""},{"location":"development/xpc_implementation_plan/#connection-management","title":"Connection Management","text":"<ul> <li>Connection pooling</li> <li>Request batching</li> <li>Async operations</li> <li>Resource cleanup</li> </ul>"},{"location":"development/xpc_implementation_plan/#monitoring","title":"Monitoring","text":"<ul> <li>Connection status</li> <li>Operation latency</li> <li>Error rates</li> <li>Resource usage</li> </ul>"},{"location":"development/xpc_implementation_plan/#6-testing-strategy","title":"6. Testing Strategy","text":""},{"location":"development/xpc_implementation_plan/#unit-tests","title":"Unit Tests","text":"<pre><code>func testCryptoXPCService() async throws {\n    let service = CryptoXPCService()\n    let data = Data([1, 2, 3])\n    let key = try await service.generateSecureRandomKey(length: 32)\n    let encrypted = try await service.encrypt(data, using: key)\n    XCTAssertNotEqual(data, encrypted)\n}\n</code></pre>"},{"location":"development/xpc_implementation_plan/#integration-tests","title":"Integration Tests","text":"<ul> <li>Service lifecycle</li> <li>Error propagation</li> <li>Recovery mechanisms</li> <li>Security boundaries</li> </ul>"},{"location":"development/xpc_implementation_plan/#7-rollback-plan","title":"7. Rollback Plan","text":""},{"location":"development/xpc_implementation_plan/#trigger-conditions","title":"Trigger Conditions","text":"<ol> <li>Critical security issues</li> <li>Performance degradation</li> <li>Stability problems</li> <li>Data integrity issues</li> </ol>"},{"location":"development/xpc_implementation_plan/#rollback-steps","title":"Rollback Steps","text":"<ol> <li>Revert to pre-XPC commits</li> <li>Restore original service implementations</li> <li>Update client code</li> <li>Run validation tests</li> </ol>"},{"location":"development/xpc_implementation_plan/#8-success-criteria","title":"8. Success Criteria","text":""},{"location":"development/xpc_implementation_plan/#functional","title":"Functional","text":"<ul> <li>All operations work through XPC</li> <li>Error handling works correctly</li> <li>Recovery mechanisms function</li> <li>Performance meets targets</li> </ul>"},{"location":"development/xpc_implementation_plan/#security","title":"Security","text":"<ul> <li>Process isolation verified</li> <li>Privilege separation effective</li> <li>Sandbox rules working</li> <li>Entitlements correct</li> </ul>"},{"location":"development/xpc_implementation_plan/#performance","title":"Performance","text":"<ul> <li>Latency within bounds</li> <li>Resource usage acceptable</li> <li>Connection management efficient</li> <li>Error recovery timely</li> </ul>"},{"location":"development/xpc_implementation_plan/#9-documentation-requirements","title":"9. Documentation Requirements","text":""},{"location":"development/xpc_implementation_plan/#api-documentation","title":"API Documentation","text":"<ul> <li>XPC protocol documentation</li> <li>Error handling guidance</li> <li>Security considerations</li> <li>Best practices</li> </ul>"},{"location":"development/xpc_implementation_plan/#operational-documentation","title":"Operational Documentation","text":"<ul> <li>Deployment guide</li> <li>Monitoring guide</li> <li>Troubleshooting guide</li> <li>Recovery procedures</li> </ul>"},{"location":"development/xpc_implementation_plan/#10-future-enhancements","title":"10. Future Enhancements","text":""},{"location":"development/xpc_implementation_plan/#planned-features","title":"Planned Features","text":"<ul> <li>[ ] Enhanced monitoring</li> <li>[ ] Performance metrics</li> <li>[ ] Automatic recovery</li> <li>[ ] Load balancing</li> </ul>"},{"location":"development/xpc_implementation_plan/#security-improvements","title":"Security Improvements","text":"<ul> <li>[ ] Additional sandbox rules</li> <li>[ ] Enhanced audit logging</li> <li>[ ] Security event monitoring</li> <li>[ ] Threat detection</li> </ul> <p>unction - Performance meets targets</p>"},{"location":"development/xpc_implementation_plan/#security_1","title":"Security","text":"<ul> <li>Process isolation verified</li> <li>Privilege separation effective</li> <li>Sandbox rules working</li> <li>Entitlements correct</li> </ul>"},{"location":"development/xpc_implementation_plan/#performance_1","title":"Performance","text":"<ul> <li>Latency within bounds</li> <li>Resource usage acceptable</li> <li>Connection management efficient</li> <li>Error recovery timely</li> </ul>"},{"location":"development/xpc_implementation_plan/#9-documentation-requirements_1","title":"9. Documentation Requirements","text":""},{"location":"development/xpc_implementation_plan/#api-documentation_1","title":"API Documentation","text":"<ul> <li>XPC protocol documentation</li> <li>Error handling guidance</li> <li>Security considerations</li> <li>Best practices</li> </ul>"},{"location":"development/xpc_implementation_plan/#operational-documentation_1","title":"Operational Documentation","text":"<ul> <li>Deployment guide</li> <li>Monitoring guide</li> <li>Troubleshooting guide</li> <li>Recovery procedures</li> </ul>"},{"location":"development/xpc_implementation_plan/#10-future-enhancements_1","title":"10. Future Enhancements","text":""},{"location":"development/xpc_implementation_plan/#planned-features_1","title":"Planned Features","text":"<ul> <li>[ ] Enhanced monitoring</li> <li>[ ] Performance metrics</li> <li>[ ] Automatic recovery</li> <li>[ ] Load balancing</li> </ul>"},{"location":"development/xpc_implementation_plan/#security-improvements_1","title":"Security Improvements","text":"<ul> <li>[ ] Additional sandbox rules</li> <li>[ ] Enhanced audit logging</li> <li>[ ] Security event monitoring</li> <li>[ ] Threat detection</li> </ul>"},{"location":"development/xpc_implementation_plan/#version-history","title":"Version History","text":"Version Date Changes 1.0.0 2025-02-17 Initial XPC implementation plan document"},{"location":"getting-started/","title":"Getting Started with UmbraCore","text":"<p>Welcome to UmbraCore! This guide will help you get up and running quickly with our secure backup solution for macOS developers.</p>"},{"location":"getting-started/#what-is-umbracore","title":"What is UmbraCore?","text":"<p>UmbraCore is a Swift-native interface to Restic, providing secure, efficient, and reliable backups specifically designed for macOS application developers. It offers:</p> <ul> <li>Type-safe Swift API</li> <li>Secure keychain integration</li> <li>Native macOS experience</li> <li>Complete Restic compatibility</li> </ul>"},{"location":"getting-started/#quick-navigation","title":"Quick Navigation","text":"<ul> <li>Installation: Set up UmbraCore in your project</li> <li>Quick Start: Create your first backup</li> <li>Configuration: Configure UmbraCore for your needs</li> </ul>"},{"location":"getting-started/installation/","title":"Getting Started with UmbraCore","text":""},{"location":"getting-started/installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>macOS 14.0 or later</li> <li>Xcode 15.2 or later</li> <li>Swift 6.0.3 or later</li> <li>Restic installed</li> </ul>"},{"location":"getting-started/installation/#installation","title":"Installation","text":""},{"location":"getting-started/installation/#swift-package-manager","title":"Swift Package Manager","text":"<p>Add UmbraCore as a dependency in your <code>Package.swift</code>:</p> <pre><code>dependencies: [\n    .package(url: \"https://github.com/mpy-dev-ml/UmbraCore.git\", from: \"1.0.0\")\n]\n</code></pre>"},{"location":"getting-started/installation/#manual-installation","title":"Manual Installation","text":"<ol> <li>Clone the repository</li> <li>Build the package</li> <li>Link the framework</li> </ol>"},{"location":"getting-started/installation/#quick-start-guide","title":"Quick Start Guide","text":""},{"location":"getting-started/installation/#1-basic-setup","title":"1. Basic Setup","text":"<pre><code>import UmbraCore\n\n// Initialize the core services\nlet keychainService = try UmbraKeychainService()\nlet cryptoService = try UmbraCryptoService()\n</code></pre>"},{"location":"getting-started/installation/#2-configure-logging","title":"2. Configure Logging","text":"<pre><code>import UmbraLogging\n\nUmbraLogger.configure(level: .info)\n</code></pre>"},{"location":"getting-started/installation/#3-basic-operations","title":"3. Basic Operations","text":"<pre><code>// Example: Store credentials\ntry await keychainService.store(\n    password: \"repository-password\",\n    forKey: \"backup-repo\"\n)\n\n// Example: Create a bookmark\ntry await bookmarkService.create(\n    for: URL(fileURLWithPath: \"/path/to/backup\"),\n    withName: \"documents\"\n)\n</code></pre>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<p>After installation, you might want to:</p> <ul> <li>Read the Architecture Guide</li> <li>Check out Security Best Practices</li> <li>View API Documentation</li> </ul>"},{"location":"getting-started/quick-start/","title":"Getting Started with UmbraCore","text":""},{"location":"getting-started/quick-start/#prerequisites","title":"Prerequisites","text":"<p>Before you begin working with UmbraCore, ensure you have the following installed:</p> <ul> <li>Xcode 15.0 or later</li> <li>Swift 5.9 or later</li> <li>Restic 0.16.0 or later</li> <li>macOS 13.0 (Ventura) or later</li> </ul>"},{"location":"getting-started/quick-start/#installation","title":"Installation","text":""},{"location":"getting-started/quick-start/#via-swift-package-manager","title":"Via Swift Package Manager","text":"<p>Add UmbraCore as a dependency to your <code>Package.swift</code>:</p> <pre><code>dependencies: [\n    .package(url: \"https://github.com/mpy-dev-ml/UmbraCore.git\", from: \"0.1.0\")\n]\n</code></pre>"},{"location":"getting-started/quick-start/#manual-build","title":"Manual Build","text":"<ol> <li> <p>Clone the repository:    <pre><code>git clone https://github.com/mpy-dev-ml/UmbraCore.git\ncd UmbraCore\n</code></pre></p> </li> <li> <p>Build the project:    <pre><code>swift build\n</code></pre></p> </li> <li> <p>Run the tests:    <pre><code>swift test\n</code></pre></p> </li> </ol>"},{"location":"getting-started/quick-start/#basic-usage","title":"Basic Usage","text":"<p>Here's a simple example of initialising UmbraCore and creating a backup:</p> <pre><code>import UmbraCore\n\n// Initialize the backup service\nlet service = try UmbraBackupService()\n\n// Create a backup\ntry await service.backup(\n    source: \"/path/to/source\",\n    repository: \"rest:https://backup.example.com/repo\",\n    password: \"your-secure-password\"\n)\n</code></pre>"},{"location":"getting-started/quick-start/#security-considerations","title":"Security Considerations","text":"<p>UmbraCore prioritises security in several ways:</p> <ol> <li>Keychain Integration: All sensitive data is stored in the macOS Keychain</li> <li>XPC Services: Security-critical operations run in isolated processes</li> <li>Secure Defaults: Conservative security defaults that follow best practices</li> </ol>"},{"location":"getting-started/quick-start/#next-steps","title":"Next Steps","text":"<p>Now that you have UmbraCore up and running, you might want to:</p> <ul> <li>Learn about Configuration Options</li> <li>Explore Advanced Features</li> <li>Read our Security Guide</li> <li>Check out the API Reference</li> </ul>"},{"location":"getting-started/quick-start/#getting-help","title":"Getting Help","text":"<p>If you encounter any issues or have questions:</p> <ol> <li>Check our Troubleshooting Guide</li> <li>Search existing GitHub Issues</li> <li>Create a new issue if your problem hasn't been reported</li> </ol>"},{"location":"getting-started/quick-start/#contributing","title":"Contributing","text":"<p>We welcome contributions! Please read our Contributing Guide to get started.</p>"},{"location":"guides/ARCHITECTURE/","title":"UmbraCore Architecture Guide","text":""},{"location":"guides/ARCHITECTURE/#overview","title":"Overview","text":"<p>UmbraCore is designed as a modular Swift library that provides a type-safe interface to Restic backup functionality. The architecture follows a service-oriented approach with clear separation of concerns.</p>"},{"location":"guides/ARCHITECTURE/#core-components","title":"Core Components","text":""},{"location":"guides/ARCHITECTURE/#1-security-layer","title":"1. Security Layer","text":"<ul> <li><code>SecurityTypes</code>: Base security primitives</li> <li><code>CryptoTypes</code>: Cryptographic operations</li> <li>Uses Apple's CryptoKit for hardware-backed security</li> <li>Provides core cryptographic primitives</li> <li>Handles secure key generation and management</li> <li><code>UmbraKeychainService</code>: Secure credential storage</li> </ul>"},{"location":"guides/ARCHITECTURE/#2-service-layer","title":"2. Service Layer","text":"<ul> <li><code>UmbraCryptoService</code>: Encryption/decryption operations</li> <li>Uses CryptoSwift for XPC service operations</li> <li>Platform-independent implementation</li> <li>Handles cross-process cryptographic operations</li> <li><code>UmbraBookmarkService</code>: File system bookmark management</li> <li><code>UmbraXPC</code>: Inter-process communication</li> </ul>"},{"location":"guides/ARCHITECTURE/#3-logging-infrastructure","title":"3. Logging Infrastructure","text":"<ul> <li><code>UmbraLogging</code>: Centralised logging system</li> <li>Structured logging with context</li> <li>Log level management</li> </ul>"},{"location":"guides/ARCHITECTURE/#design-patterns","title":"Design Patterns","text":""},{"location":"guides/ARCHITECTURE/#1-xpc-service-pattern","title":"1. XPC Service Pattern","text":"<p>Used for secure inter-process communication: <pre><code>protocol KeychainXPCProtocol {\n    func store(password: String, forKey: String) async throws\n    func retrieve(forKey: String) async throws -&gt; String\n}\n</code></pre></p>"},{"location":"guides/ARCHITECTURE/#2-protocol-oriented-design","title":"2. Protocol-Oriented Design","text":"<p>Services are defined by protocols for better testability: <pre><code>protocol CryptoServiceProtocol {\n    func encrypt(_ data: Data) async throws -&gt; Data\n    func decrypt(_ data: Data) async throws -&gt; Data\n}\n</code></pre></p>"},{"location":"guides/ARCHITECTURE/#3-error-handling-pattern","title":"3. Error Handling Pattern","text":"<p>Structured error types with context: <pre><code>enum KeychainError: Error {\n    case itemNotFound(String)\n    case duplicateItem(String)\n    case accessDenied(String)\n}\n</code></pre></p>"},{"location":"guides/ARCHITECTURE/#cryptographic-architecture","title":"Cryptographic Architecture","text":"<p>The framework employs a dual-library approach for cryptographic operations:</p> <ol> <li>CryptoKit (Main App Context)</li> <li>Hardware-backed security on Apple platforms</li> <li>Used in <code>DefaultCryptoService</code></li> <li>Handles core cryptographic operations</li> <li> <p>Optimal security for main app operations</p> </li> <li> <p>CryptoSwift (XPC Service Context)</p> </li> <li>Platform-independent implementation</li> <li>Used in <code>CryptoXPCService</code></li> <li>Enables reliable cross-process encryption</li> <li>Provides necessary flexibility for XPC operations</li> </ol> <p>This split architecture ensures: - Maximum security through hardware backing where available - Reliable cross-process cryptographic operations - Clear separation of concerns between contexts - Consistent cryptographic operations in each context</p>"},{"location":"guides/ARCHITECTURE/#threading-model","title":"Threading Model","text":"<ul> <li>All services are thread-safe</li> <li>Async/await for asynchronous operations</li> <li>XPC for background processing</li> </ul>"},{"location":"guides/ARCHITECTURE/#security-considerations","title":"Security Considerations","text":"<ul> <li>Keychain integration for secure storage</li> <li>XPC for privilege separation</li> <li>Audit logging</li> <li>Secure defaults</li> </ul>"},{"location":"guides/ARCHITECTURE/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Efficient memory usage</li> <li>Background processing</li> <li>Cache management</li> <li>Resource cleanup</li> </ul>"},{"location":"guides/ARCHITECTURE/#testing-strategy","title":"Testing Strategy","text":"<ul> <li>Unit tests for all components</li> <li>Integration tests for workflows</li> <li>Mock services for testing</li> <li>Performance benchmarks</li> </ul>"},{"location":"guides/ARCHITECTURE/#dependency-management","title":"Dependency Management","text":"<ul> <li>Minimal external dependencies</li> <li>Version pinning</li> <li>Security scanning</li> <li>Regular updates</li> </ul>"},{"location":"guides/ARCHITECTURE/#implementation-plan","title":"Implementation Plan","text":""},{"location":"guides/ARCHITECTURE/#phase-1-core-foundation","title":"Phase 1: Core Foundation","text":"<p>Currently in progress (Q1 2025):</p> <ul> <li>Command execution system</li> <li>Keychain integration</li> <li>XPC service implementation</li> <li>SSH key management</li> <li>Cloud provider integration</li> </ul>"},{"location":"guides/ARCHITECTURE/#phase-2-advanced-features","title":"Phase 2: Advanced Features","text":"<p>Planned for Q2 2025:</p> <ul> <li>Repository management</li> <li>Scheduling system</li> <li>Network operations</li> <li>State persistence</li> </ul>"},{"location":"guides/ARCHITECTURE/#phase-3-optimisation","title":"Phase 3: Optimisation","text":"<p>Scheduled for Q3 2025:</p> <ul> <li>Statistics &amp; analytics</li> <li>Health monitoring</li> <li>Event system</li> <li>Cache optimisation</li> </ul>"},{"location":"guides/ARCHITECTURE/#design-principles","title":"Design Principles","text":""},{"location":"guides/ARCHITECTURE/#1-security-first","title":"1. Security First","text":"<ul> <li>Secure by default</li> <li>Least privilege principle</li> <li>Comprehensive audit logging</li> <li>Regular security reviews</li> </ul>"},{"location":"guides/ARCHITECTURE/#2-reliability","title":"2. Reliability","text":"<ul> <li>Comprehensive error handling</li> <li>Automatic retry mechanisms</li> <li>Circuit breakers</li> <li>Fallback strategies</li> </ul>"},{"location":"guides/ARCHITECTURE/#3-performance","title":"3. Performance","text":"<ul> <li>Efficient resource usage</li> <li>Optimised I/O operations</li> <li>Memory management</li> <li>Cache strategies</li> </ul>"},{"location":"guides/ARCHITECTURE/#4-maintainability","title":"4. Maintainability","text":"<ul> <li>Protocol-oriented design</li> <li>Clear documentation</li> <li>Comprehensive testing</li> <li>Code review process</li> </ul>"},{"location":"guides/ARCHITECTURE/#integration-points","title":"Integration Points","text":"<p>UmbraCore serves as the foundation for:</p> <ul> <li>Rbum: Command-line interface</li> <li>Rbx: GUI application</li> <li>ResticBar: Menu bar application</li> </ul> <p>Each application utilises UmbraCore's components through well-defined protocols and interfaces.</p>"},{"location":"guides/ARCHITECTURE/#testing-strategy_1","title":"Testing Strategy","text":"<p>Comprehensive testing approach:</p> <ol> <li>Unit Tests</li> <li>Component isolation</li> <li>Edge case coverage</li> <li> <p>Mock implementations</p> </li> <li> <p>Integration Tests</p> </li> <li>Component interaction</li> <li>System workflows</li> <li> <p>Error scenarios</p> </li> <li> <p>Performance Tests</p> </li> <li>Resource usage</li> <li>Throughput metrics</li> <li> <p>Scalability checks</p> </li> <li> <p>Security Tests</p> </li> <li>Vulnerability scanning</li> <li>Penetration testing</li> <li>Compliance verification</li> </ol>"},{"location":"guides/bookmarks/","title":"UmbraBookmarkService Guide","text":""},{"location":"guides/bookmarks/#overview","title":"Overview","text":"<p><code>UmbraBookmarkService</code> manages persistent file system access through security-scoped bookmarks. It provides safe and reliable access to files and directories across app launches.</p>"},{"location":"guides/bookmarks/#features","title":"Features","text":"<ul> <li>Security-scoped bookmarks</li> <li>Persistent file access</li> <li>Thread-safe operations</li> <li>Automatic bookmark resolution</li> </ul>"},{"location":"guides/bookmarks/#basic-usage","title":"Basic Usage","text":""},{"location":"guides/bookmarks/#creating-bookmarks","title":"Creating Bookmarks","text":"<pre><code>let service = try UmbraBookmarkService()\n\n// Create bookmark for file\nlet fileURL = URL(fileURLWithPath: \"/path/to/file\")\ntry await service.create(\n    for: fileURL,\n    withName: \"important-file\"\n)\n\n// Create bookmark for directory\nlet dirURL = URL(fileURLWithPath: \"/path/to/directory\")\ntry await service.create(\n    for: dirURL,\n    withName: \"backup-directory\"\n)\n</code></pre>"},{"location":"guides/bookmarks/#resolving-bookmarks","title":"Resolving Bookmarks","text":"<pre><code>// Get URL from bookmark\nlet fileURL = try await service.resolve(name: \"important-file\")\n\n// Access with scope\ntry await service.access(name: \"backup-directory\") { url in\n    // Work with URL within security scope\n    let contents = try FileManager.default.contentsOfDirectory(at: url)\n}\n</code></pre>"},{"location":"guides/bookmarks/#removing-bookmarks","title":"Removing Bookmarks","text":"<pre><code>try await service.remove(name: \"important-file\")\n</code></pre>"},{"location":"guides/bookmarks/#error-handling","title":"Error Handling","text":"<pre><code>do {\n    try await service.create(for: url, withName: name)\n} catch BookmarkError.invalidURL(let url) {\n    // Handle invalid URL\n} catch BookmarkError.accessDenied(let reason) {\n    // Handle access denied\n} catch {\n    // Handle other errors\n}\n</code></pre>"},{"location":"guides/bookmarks/#best-practices","title":"Best Practices","text":""},{"location":"guides/bookmarks/#1-bookmark-naming","title":"1. Bookmark Naming","text":"<ul> <li>Use descriptive names</li> <li>Include context</li> <li>Follow naming conventions</li> </ul> <pre><code>// Good\n\"main-backup-directory\"\n\"config-file-production\"\n\n// Bad\n\"bookmark1\"\n\"file\"\n</code></pre>"},{"location":"guides/bookmarks/#2-access-scoping","title":"2. Access Scoping","text":"<ul> <li>Use scoped access</li> <li>Clean up resources</li> <li>Handle access errors</li> </ul>"},{"location":"guides/bookmarks/#3-error-recovery","title":"3. Error Recovery","text":"<ul> <li>Implement retry logic</li> <li>Provide user feedback</li> <li>Log access failures</li> </ul>"},{"location":"guides/bookmarks/#advanced-usage","title":"Advanced Usage","text":""},{"location":"guides/bookmarks/#1-custom-bookmark-options","title":"1. Custom Bookmark Options","text":"<pre><code>let options = BookmarkOptions(\n    securityScope: .workingDirectory,\n    persistence: .permanent\n)\n\ntry await service.create(\n    for: url,\n    withName: name,\n    options: options\n)\n</code></pre>"},{"location":"guides/bookmarks/#2-batch-operations","title":"2. Batch Operations","text":"<pre><code>let bookmarks = [\n    \"dir1\": url1,\n    \"dir2\": url2\n]\n\ntry await service.createBatch(bookmarks)\n</code></pre>"},{"location":"guides/bookmarks/#3-access-control","title":"3. Access Control","text":"<pre><code>let access = BookmarkAccess(\n    scope: .minimal,\n    duration: .temporary\n)\n\ntry await service.access(\n    name: \"secure-directory\",\n    access: access\n) { url in\n    // Limited scope access\n}\n</code></pre>"},{"location":"guides/bookmarks/#integration-examples","title":"Integration Examples","text":""},{"location":"guides/bookmarks/#1-backup-directory-management","title":"1. Backup Directory Management","text":"<pre><code>class BackupManager {\n    private let bookmarks: UmbraBookmarkService\n\n    init() throws {\n        bookmarks = try UmbraBookmarkService()\n    }\n\n    func configureBackupDirectory(_ url: URL) async throws {\n        // Create persistent bookmark\n        try await bookmarks.create(\n            for: url,\n            withName: \"backup-root\"\n        )\n    }\n\n    func performBackup() async throws {\n        try await bookmarks.access(\"backup-root\") { url in\n            // Perform backup operations\n            try await backupContents(of: url)\n        }\n    }\n}\n</code></pre>"},{"location":"guides/bookmarks/#2-configuration-file-access","title":"2. Configuration File Access","text":"<pre><code>class ConfigManager {\n    private let bookmarks: UmbraBookmarkService\n\n    func saveConfig(_ config: Config) async throws {\n        try await bookmarks.access(\"config-file\") { url in\n            let data = try JSONEncoder().encode(config)\n            try data.write(to: url)\n        }\n    }\n}\n</code></pre>"},{"location":"guides/bookmarks/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guides/bookmarks/#common-issues","title":"Common Issues","text":"<ol> <li> <p>Stale Bookmarks <pre><code>// Refresh bookmark if stale\nif await service.isStale(name: \"backup-dir\") {\n    try await service.refresh(name: \"backup-dir\")\n}\n</code></pre></p> </li> <li> <p>Access Denied <pre><code>// Request user permission if needed\nfunc ensureAccess(to name: String) async throws {\n    do {\n        try await service.verifyAccess(name: name)\n    } catch BookmarkError.accessDenied {\n        try await requestUserPermission(for: name)\n    }\n}\n</code></pre></p> </li> <li> <p>Resource Management <pre><code>// Proper resource cleanup\nfunc processDirectory() async throws {\n    try await service.access(\"work-dir\") { url in\n        defer {\n            // Cleanup code\n        }\n\n        // Process directory\n    }\n}\n</code></pre></p> </li> </ol>"},{"location":"guides/crypto-types/","title":"Cryptographic Types","text":"<p>This guide covers the cryptographic types used in UmbraCore for secure data handling.</p>"},{"location":"guides/crypto-types/#overview","title":"Overview","text":"<p>UmbraCore provides several cryptographic types to ensure secure handling of sensitive data:</p> <ul> <li><code>SecureString</code>: For handling passwords and other sensitive strings</li> <li><code>EncryptedData</code>: For encrypted binary data</li> <li><code>KeyMaterial</code>: For cryptographic key material</li> </ul>"},{"location":"guides/crypto-types/#securestring","title":"SecureString","text":"<p><code>SecureString</code> provides secure storage for sensitive string data:</p> <pre><code>let password = SecureString(\"sensitive-data\")\n// Memory is automatically zeroed when deallocated\n</code></pre>"},{"location":"guides/crypto-types/#encrypteddata","title":"EncryptedData","text":"<p><code>EncryptedData</code> handles encrypted binary data:</p> <pre><code>let encrypted = EncryptedData(data: someData, key: keyMaterial)\nlet decrypted = try encrypted.decrypt(using: keyMaterial)\n</code></pre>"},{"location":"guides/crypto-types/#keymaterial","title":"KeyMaterial","text":"<p><code>KeyMaterial</code> manages cryptographic keys:</p> <pre><code>let key = try KeyMaterial.generate()\nlet derived = try key.deriveKey(salt: salt, rounds: 100_000)\n</code></pre>"},{"location":"guides/crypto-types/#best-practices","title":"Best Practices","text":"<ol> <li>Always use <code>SecureString</code> for passwords and sensitive data</li> <li>Zero memory after use</li> <li>Use appropriate key derivation functions</li> <li>Implement proper key rotation</li> <li>Follow cryptographic hygiene</li> </ol>"},{"location":"guides/crypto/","title":"UmbraCryptoService Guide","text":""},{"location":"guides/crypto/#overview","title":"Overview","text":"<p><code>UmbraCryptoService</code> provides cryptographic operations for securing sensitive data. It supports encryption, decryption, and key management.</p>"},{"location":"guides/crypto/#features","title":"Features","text":"<ul> <li>Secure encryption/decryption</li> <li>Key management</li> <li>Thread-safe operations</li> <li>XPC-based processing</li> </ul>"},{"location":"guides/crypto/#basic-usage","title":"Basic Usage","text":""},{"location":"guides/crypto/#encryption","title":"Encryption","text":"<pre><code>let service = try UmbraCryptoService()\n\n// Encrypt data\nlet data = \"sensitive data\".data(using: .utf8)!\nlet encrypted = try await service.encrypt(data)\n\n// Encrypt with custom key\nlet key = try service.generateKey()\nlet customEncrypted = try await service.encrypt(data, using: key)\n</code></pre>"},{"location":"guides/crypto/#decryption","title":"Decryption","text":"<pre><code>// Decrypt data\nlet decrypted = try await service.decrypt(encrypted)\n\n// Decrypt with custom key\nlet customDecrypted = try await service.decrypt(customEncrypted, using: key)\n</code></pre>"},{"location":"guides/crypto/#key-management","title":"Key Management","text":"<pre><code>// Generate new key\nlet key = try service.generateKey()\n\n// Export key (protected)\nlet exportedKey = try service.exportKey(key)\n\n// Import key\nlet importedKey = try service.importKey(exportedKey)\n</code></pre>"},{"location":"guides/crypto/#error-handling","title":"Error Handling","text":"<pre><code>do {\n    let encrypted = try await service.encrypt(data)\n} catch CryptoError.invalidKey {\n    // Handle invalid key\n} catch CryptoError.encryptionFailed(let reason) {\n    // Handle encryption failure\n} catch {\n    // Handle other errors\n}\n</code></pre>"},{"location":"guides/crypto/#best-practices","title":"Best Practices","text":""},{"location":"guides/crypto/#1-key-management","title":"1. Key Management","text":"<ul> <li>Rotate keys regularly</li> <li>Secure key storage</li> <li>Use key derivation when appropriate</li> </ul>"},{"location":"guides/crypto/#2-data-protection","title":"2. Data Protection","text":"<ul> <li>Encrypt sensitive data immediately</li> <li>Clear sensitive data from memory</li> <li>Use secure random generation</li> </ul>"},{"location":"guides/crypto/#3-error-recovery","title":"3. Error Recovery","text":"<ul> <li>Implement retry logic</li> <li>Log cryptographic failures</li> <li>Provide appropriate user feedback</li> </ul>"},{"location":"guides/crypto/#advanced-usage","title":"Advanced Usage","text":""},{"location":"guides/crypto/#1-custom-encryption-parameters","title":"1. Custom Encryption Parameters","text":"<pre><code>let params = EncryptionParameters(\n    algorithm: .aes256GCM,\n    keySize: .bits256,\n    iterations: 10000\n)\n\nlet encrypted = try await service.encrypt(\n    data,\n    parameters: params\n)\n</code></pre>"},{"location":"guides/crypto/#2-key-derivation","title":"2. Key Derivation","text":"<pre><code>let derivedKey = try service.deriveKey(\n    fromPassword: \"user-password\",\n    salt: salt,\n    iterations: 10000\n)\n</code></pre>"},{"location":"guides/crypto/#3-batch-operations","title":"3. Batch Operations","text":"<pre><code>let dataItems = [\n    \"item1\": data1,\n    \"item2\": data2\n]\n\nlet encrypted = try await service.encryptBatch(dataItems)\n</code></pre>"},{"location":"guides/crypto/#integration-examples","title":"Integration Examples","text":""},{"location":"guides/crypto/#1-secure-configuration","title":"1. Secure Configuration","text":"<pre><code>class SecureConfig {\n    private let crypto: UmbraCryptoService\n\n    init() throws {\n        crypto = try UmbraCryptoService()\n    }\n\n    func saveConfig(_ config: Config) async throws {\n        let data = try JSONEncoder().encode(config)\n        let encrypted = try await crypto.encrypt(data)\n\n        try await FileManager.default.createFile(\n            at: configURL,\n            contents: encrypted\n        )\n    }\n}\n</code></pre>"},{"location":"guides/crypto/#2-secure-data-transfer","title":"2. Secure Data Transfer","text":"<pre><code>class SecureTransfer {\n    private let crypto: UmbraCryptoService\n\n    func secureUpload(_ data: Data) async throws {\n        // Encrypt before upload\n        let encrypted = try await crypto.encrypt(data)\n\n        // Upload encrypted data\n        try await uploadToServer(encrypted)\n    }\n}\n</code></pre>"},{"location":"guides/crypto/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guides/crypto/#common-issues","title":"Common Issues","text":"<ol> <li> <p>Key Validation <pre><code>// Validate key before use\nguard try service.validateKey(key) else {\n    throw CryptoError.invalidKey\n}\n</code></pre></p> </li> <li> <p>Memory Management <pre><code>// Clear sensitive data\ndefer {\n    key.zero()\n    plaintext.zero()\n}\n</code></pre></p> </li> <li> <p>Performance Optimization <pre><code>// Use batch operations for multiple items\nlet results = try await withThrowingTaskGroup(of: (String, Data).self) { group in\n    for (id, data) in items {\n        group.addTask {\n            let encrypted = try await service.encrypt(data)\n            return (id, encrypted)\n        }\n    }\n    return try await group.reduce(into: [:]) { $0[$1.0] = $1.1 }\n}\n</code></pre></p> </li> </ol>"},{"location":"guides/error-handling/","title":"Error Handling in UmbraCore","text":""},{"location":"guides/error-handling/#overview","title":"Overview","text":"<p>UmbraCore uses a structured error handling system that provides detailed error context, supports error recovery, and integrates with the logging system. This guide explains our error handling patterns and best practices.</p>"},{"location":"guides/error-handling/#error-types","title":"Error Types","text":""},{"location":"guides/error-handling/#1-common-errors","title":"1. Common Errors","text":"<p>Base error types shared across the library:</p> <pre><code>enum CommonError: Error {\n    case invalidArgument(String)\n    case resourceNotFound(String)\n    case permissionDenied(String)\n    case operationFailed(String)\n\n    var localizedDescription: String {\n        switch self {\n        case .invalidArgument(let details):\n            return \"Invalid argument: \\(details)\"\n        case .resourceNotFound(let resource):\n            return \"Resource not found: \\(resource)\"\n        case .permissionDenied(let operation):\n            return \"Permission denied for operation: \\(operation)\"\n        case .operationFailed(let reason):\n            return \"Operation failed: \\(reason)\"\n        }\n    }\n}\n</code></pre>"},{"location":"guides/error-handling/#2-service-specific-errors","title":"2. Service-Specific Errors","text":"<p>Each service defines its domain-specific errors:</p> <pre><code>enum KeychainError: Error {\n    case itemNotFound(String)\n    case duplicateItem(String)\n    case accessDenied(String)\n    case invalidData(String)\n}\n\nenum CryptoError: Error {\n    case encryptionFailed(String)\n    case decryptionFailed(String)\n    case invalidKey(String)\n    case algorithmNotSupported(String)\n}\n</code></pre>"},{"location":"guides/error-handling/#3-error-context","title":"3. Error Context","text":"<p>Additional context for debugging and recovery:</p> <pre><code>struct ErrorContext {\n    let file: String\n    let function: String\n    let line: Int\n    let timestamp: Date\n    let operationId: UUID\n    var userInfo: [String: Any]\n\n    var description: String {\n        \"\"\"\n        Error occurred in \\(function)\n        File: \\(file):\\(line)\n        Time: \\(timestamp)\n        Operation: \\(operationId)\n        Additional Info: \\(userInfo)\n        \"\"\"\n    }\n}\n</code></pre>"},{"location":"guides/error-handling/#best-practices","title":"Best Practices","text":""},{"location":"guides/error-handling/#1-error-creation","title":"1. Error Creation","text":"<p>Create informative errors with context:</p> <pre><code>func processFile(_ url: URL) async throws {\n    guard FileManager.default.fileExists(atPath: url.path) else {\n        throw CommonError.resourceNotFound(\n            \"\"\"\n            File not found at \\(url.path)\n            Check if the file exists and you have read permissions.\n            \"\"\"\n        )\n    }\n}\n</code></pre>"},{"location":"guides/error-handling/#2-error-handling","title":"2. Error Handling","text":"<p>Handle errors at appropriate levels:</p> <pre><code>func backupFiles() async throws {\n    do {\n        try await validatePermissions()\n        try await performBackup()\n        try await verifyBackup()\n    } catch KeychainError.accessDenied(let details) {\n        logger.error(\"Keychain access denied\", metadata: [\n            \"details\": details,\n            \"operation\": \"backup\"\n        ])\n        throw CommonError.permissionDenied(\"Keychain access required for backup\")\n    } catch CryptoError.encryptionFailed(let reason) {\n        logger.error(\"Encryption failed\", metadata: [\n            \"reason\": reason,\n            \"operation\": \"backup\"\n        ])\n        throw CommonError.operationFailed(\"Backup encryption failed\")\n    }\n}\n</code></pre>"},{"location":"guides/error-handling/#3-error-recovery","title":"3. Error Recovery","text":"<p>Implement recovery strategies:</p> <pre><code>actor RetryableOperation {\n    func execute() async throws -&gt; Result {\n        var attempts = 0\n        while attempts &lt; maxRetries {\n            do {\n                return try await performOperation()\n            } catch let error as RecoverableError {\n                attempts += 1\n                try await handleError(error, attempt: attempts)\n            } catch {\n                throw error // Non-recoverable error\n            }\n        }\n        throw CommonError.operationFailed(\"Max retry attempts exceeded\")\n    }\n}\n</code></pre>"},{"location":"guides/error-handling/#error-patterns","title":"Error Patterns","text":""},{"location":"guides/error-handling/#1-result-type-usage","title":"1. Result Type Usage","text":"<p>For operations that might fail:</p> <pre><code>enum OperationResult&lt;T&gt; {\n    case success(T)\n    case failure(Error)\n    case partial(T, [Error])\n\n    var value: T? {\n        switch self {\n        case .success(let value), .partial(let value, _):\n            return value\n        case .failure:\n            return nil\n        }\n    }\n}\n\nfunc processItems(_ items: [Item]) async -&gt; OperationResult&lt;[ProcessedItem]&gt; {\n    var processed: [ProcessedItem] = []\n    var errors: [Error] = []\n\n    for item in items {\n        do {\n            let result = try await process(item)\n            processed.append(result)\n        } catch {\n            errors.append(error)\n        }\n    }\n\n    if errors.isEmpty {\n        return .success(processed)\n    } else if processed.isEmpty {\n        return .failure(CommonError.operationFailed(\"All items failed\"))\n    } else {\n        return .partial(processed, errors)\n    }\n}\n</code></pre>"},{"location":"guides/error-handling/#2-error-transformation","title":"2. Error Transformation","text":"<p>Convert between error types while preserving context:</p> <pre><code>extension Error {\n    func asCommonError() -&gt; CommonError {\n        switch self {\n        case let error as KeychainError:\n            return error.toCommonError()\n        case let error as CryptoError:\n            return error.toCommonError()\n        default:\n            return .operationFailed(localizedDescription)\n        }\n    }\n}\n\nextension KeychainError {\n    func toCommonError() -&gt; CommonError {\n        switch self {\n        case .accessDenied(let details):\n            return .permissionDenied(\"Keychain: \\(details)\")\n        case .itemNotFound(let key):\n            return .resourceNotFound(\"Keychain item: \\(key)\")\n        // ... other cases\n        }\n    }\n}\n</code></pre>"},{"location":"guides/error-handling/#3-async-error-handling","title":"3. Async Error Handling","text":"<p>Handle errors in async contexts:</p> <pre><code>actor ErrorHandler {\n    func handle&lt;T&gt;(_ operation: @escaping () async throws -&gt; T) async throws -&gt; T {\n        do {\n            return try await operation()\n        } catch {\n            try await logError(error)\n            try await notifyObservers(of: error)\n            throw error\n        }\n    }\n}\n</code></pre>"},{"location":"guides/error-handling/#integration-with-logging","title":"Integration with Logging","text":""},{"location":"guides/error-handling/#1-error-logging","title":"1. Error Logging","text":"<p>Log errors with context:</p> <pre><code>extension Logger {\n    func logError(\n        _ error: Error,\n        context: ErrorContext,\n        file: String = #file,\n        function: String = #function,\n        line: Int = #line\n    ) {\n        error(\n            \"Error occurred\",\n            metadata: [\n                \"error\": \"\\(error)\",\n                \"context\": \"\\(context)\",\n                \"file\": \"\\(file)\",\n                \"function\": \"\\(function)\",\n                \"line\": \"\\(line)\"\n            ]\n        )\n    }\n}\n</code></pre>"},{"location":"guides/error-handling/#2-error-monitoring","title":"2. Error Monitoring","text":"<p>Track error patterns:</p> <pre><code>actor ErrorMonitor {\n    private var errorCounts: [String: Int] = [:]\n\n    func record(_ error: Error) async {\n        let key = String(describing: type(of: error))\n        errorCounts[key, default: 0] += 1\n\n        if errorCounts[key] ?? 0 &gt; threshold {\n            await notifyHighErrorRate(type: key)\n        }\n    }\n}\n</code></pre>"},{"location":"guides/error-handling/#testing","title":"Testing","text":""},{"location":"guides/error-handling/#1-error-scenarios","title":"1. Error Scenarios","text":"<p>Test error handling paths:</p> <pre><code>func testErrorHandling() async throws {\n    let service = TestService()\n\n    do {\n        try await service.operationThatFails()\n        XCTFail(\"Expected error not thrown\")\n    } catch let error as CommonError {\n        XCTAssertEqual(\n            error.localizedDescription,\n            \"Expected error message\"\n        )\n    }\n}\n</code></pre>"},{"location":"guides/error-handling/#2-recovery-testing","title":"2. Recovery Testing","text":"<p>Test error recovery mechanisms:</p> <pre><code>func testErrorRecovery() async throws {\n    let operation = RetryableOperation()\n\n    // Inject failures\n    operation.injectFailures(count: 2)\n\n    // Should succeed after retries\n    let result = try await operation.execute()\n    XCTAssertNotNil(result)\n}\n</code></pre>"},{"location":"guides/error-handling/#3-error-context-testing","title":"3. Error Context Testing","text":"<p>Verify error context information:</p> <p>```swift func testErrorContext() async throws {     let operation = ContextualOperation()</p> <pre><code>do {\n    try await operation.execute()\n    XCTFail(\"Expected error not thrown\")\n} catch {\n    let context = try XCTUnwrap(error.errorContext)\n    XCTAssertEqual(context.function, \"execute\")\n    XCTAssertNotNil(context.operationId)\n}\n</code></pre> <p>}</p>"},{"location":"guides/keychain/","title":"UmbraKeychainService Guide","text":""},{"location":"guides/keychain/#overview","title":"Overview","text":"<p><code>UmbraKeychainService</code> provides secure credential storage using macOS Keychain. It handles repository passwords, API keys, and other sensitive data.</p>"},{"location":"guides/keychain/#features","title":"Features","text":"<ul> <li>Secure credential storage</li> <li>XPC-based access</li> <li>Thread-safe operations</li> <li>Automatic error handling</li> </ul>"},{"location":"guides/keychain/#basic-usage","title":"Basic Usage","text":""},{"location":"guides/keychain/#storing-credentials","title":"Storing Credentials","text":"<pre><code>let service = try UmbraKeychainService()\n\n// Store a repository password\ntry await service.store(\n    password: \"secret-password\",\n    forKey: \"backup-repository\"\n)\n\n// Store an API key\ntry await service.store(\n    password: \"api-key-12345\",\n    forKey: \"cloud-provider\"\n)\n</code></pre>"},{"location":"guides/keychain/#retrieving-credentials","title":"Retrieving Credentials","text":"<pre><code>// Get repository password\nlet password = try await service.retrieve(forKey: \"backup-repository\")\n\n// Get API key\nlet apiKey = try await service.retrieve(forKey: \"cloud-provider\")\n</code></pre>"},{"location":"guides/keychain/#updating-credentials","title":"Updating Credentials","text":"<pre><code>try await service.update(\n    password: \"new-password\",\n    forKey: \"backup-repository\"\n)\n</code></pre>"},{"location":"guides/keychain/#removing-credentials","title":"Removing Credentials","text":"<pre><code>try await service.remove(forKey: \"backup-repository\")\n</code></pre>"},{"location":"guides/keychain/#error-handling","title":"Error Handling","text":"<pre><code>do {\n    try await service.store(password: \"secret\", forKey: \"key\")\n} catch KeychainError.duplicateItem(let key) {\n    // Handle duplicate item\n} catch KeychainError.accessDenied(let reason) {\n    // Handle access denied\n} catch {\n    // Handle other errors\n}\n</code></pre>"},{"location":"guides/keychain/#best-practices","title":"Best Practices","text":""},{"location":"guides/keychain/#1-key-naming","title":"1. Key Naming","text":"<ul> <li>Use descriptive, consistent keys</li> <li>Include context in key names</li> <li>Follow naming conventions</li> </ul> <pre><code>// Good\n\"backup-repo-main-password\"\n\"aws-access-key-prod\"\n\n// Bad\n\"pwd1\"\n\"key\"\n</code></pre>"},{"location":"guides/keychain/#2-error-recovery","title":"2. Error Recovery","text":"<ul> <li>Implement retry logic</li> <li>Provide user feedback</li> <li>Log failures appropriately</li> </ul>"},{"location":"guides/keychain/#3-security","title":"3. Security","text":"<ul> <li>Never store keys in code</li> <li>Use appropriate access control</li> <li>Clean up unused credentials</li> </ul>"},{"location":"guides/keychain/#advanced-usage","title":"Advanced Usage","text":""},{"location":"guides/keychain/#1-custom-item-attributes","title":"1. Custom Item Attributes","text":"<pre><code>let attributes = KeychainItemAttributes(\n    label: \"Main Backup Repository\",\n    comment: \"Production backup credentials\"\n)\n\ntry await service.store(\n    password: \"secret\",\n    forKey: \"backup-repo\",\n    attributes: attributes\n)\n</code></pre>"},{"location":"guides/keychain/#2-batch-operations","title":"2. Batch Operations","text":"<pre><code>let credentials = [\n    \"repo1\": \"password1\",\n    \"repo2\": \"password2\"\n]\n\ntry await service.storeBatch(credentials)\n</code></pre>"},{"location":"guides/keychain/#3-access-control","title":"3. Access Control","text":"<pre><code>let access = KeychainAccess(\n    accessibility: .whenUnlocked,\n    authentication: .biometric\n)\n\ntry await service.store(\n    password: \"secret\",\n    forKey: \"secure-key\",\n    access: access\n)\n</code></pre>"},{"location":"guides/keychain/#integration-examples","title":"Integration Examples","text":""},{"location":"guides/keychain/#1-repository-setup","title":"1. Repository Setup","text":"<pre><code>func setupRepository() async throws {\n    let service = try UmbraKeychainService()\n\n    // Store repository password\n    try await service.store(\n        password: repositoryPassword,\n        forKey: \"repo-\\(repoId)\"\n    )\n\n    // Store cloud credentials if needed\n    if let cloudKey = cloudCredentials {\n        try await service.store(\n            password: cloudKey,\n            forKey: \"cloud-\\(repoId)\"\n        )\n    }\n}\n</code></pre>"},{"location":"guides/keychain/#2-credential-management","title":"2. Credential Management","text":"<pre><code>class CredentialManager {\n    private let keychain: UmbraKeychainService\n\n    init() throws {\n        keychain = try UmbraKeychainService()\n    }\n\n    func rotateCredentials() async throws {\n        let newPassword = generateSecurePassword()\n\n        try await keychain.update(\n            password: newPassword,\n            forKey: \"repo-main\"\n        )\n\n        try await updateRemoteRepository(password: newPassword)\n    }\n}\n</code></pre>"},{"location":"guides/keychain/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guides/keychain/#common-issues","title":"Common Issues","text":"<ol> <li> <p>Access Denied <pre><code>// Check keychain access\ntry await service.checkAccess()\n\n// Request user permission if needed\ntry await service.requestAccess()\n</code></pre></p> </li> <li> <p>Duplicate Items <pre><code>// Update instead of store for existing items\nif await service.exists(forKey: key) {\n    try await service.update(password: newPassword, forKey: key)\n} else {\n    try await service.store(password: newPassword, forKey: key)\n}\n</code></pre></p> </li> <li> <p>Item Not Found <pre><code>// Implement fallback logic\nfunc getCredential(forKey key: String) async throws -&gt; String {\n    do {\n        return try await service.retrieve(forKey: key)\n    } catch KeychainError.itemNotFound {\n        // Implement recovery logic\n        return try await recoverCredential(forKey: key)\n    }\n}\n</code></pre></p> </li> </ol>"},{"location":"guides/logging/","title":"UmbraLogging Guide","text":""},{"location":"guides/logging/#overview","title":"Overview","text":"<p><code>UmbraLogging</code> provides a centralised, structured logging system built on SwiftyBeaver. It supports multiple destinations, log levels, and contextual metadata.</p>"},{"location":"guides/logging/#features","title":"Features","text":"<ul> <li>Structured logging</li> <li>Multiple log levels</li> <li>Context metadata</li> <li>File output</li> <li>Console output</li> <li>Custom formatters</li> </ul>"},{"location":"guides/logging/#basic-usage","title":"Basic Usage","text":""},{"location":"guides/logging/#configuration","title":"Configuration","text":"<pre><code>import UmbraLogging\n\n// Basic setup\nUmbraLogger.configure(level: .info)\n\n// Custom configuration\nlet config = LoggerConfiguration(\n    level: .debug,\n    destinations: [.console, .file],\n    metadata: [\"app\": \"UmbraCore\"]\n)\nUmbraLogger.configure(config)\n</code></pre>"},{"location":"guides/logging/#logging-messages","title":"Logging Messages","text":"<pre><code>// Basic logging\nlogger.info(\"Backup started\")\nlogger.error(\"Failed to access repository\")\n\n// With metadata\nlogger.info(\"File processed\", metadata: [\n    \"size\": fileSize,\n    \"path\": filePath\n])\n\n// With error context\nlogger.error(\"Backup failed\", error: error, metadata: [\n    \"repository\": repoId,\n    \"files\": fileCount\n])\n</code></pre>"},{"location":"guides/logging/#log-levels","title":"Log Levels","text":""},{"location":"guides/logging/#available-levels","title":"Available Levels","text":"<pre><code>// Verbose - detailed information\nlogger.verbose(\"Entering backup loop\")\n\n// Debug - debugging information\nlogger.debug(\"Processing file: \\(filename)\")\n\n// Info - general information\nlogger.info(\"Backup completed successfully\")\n\n// Warning - potential issues\nlogger.warning(\"Repository space low\")\n\n// Error - operation failures\nlogger.error(\"Failed to store credential\")\n\n// Critical - system-wide issues\nlogger.critical(\"Database corruption detected\")\n</code></pre>"},{"location":"guides/logging/#best-practices","title":"Best Practices","text":""},{"location":"guides/logging/#1-log-level-selection","title":"1. Log Level Selection","text":"<pre><code>// Development\n#if DEBUG\n    UmbraLogger.configure(level: .debug)\n#else\n    UmbraLogger.configure(level: .info)\n#endif\n\n// Production with environment override\nif let levelString = Environment.logLevel {\n    UmbraLogger.configure(level: LogLevel(string: levelString))\n}\n</code></pre>"},{"location":"guides/logging/#2-contextual-information","title":"2. Contextual Information","text":"<pre><code>// Add operation context\nlogger.info(\"Starting backup\", metadata: [\n    \"operation\": \"backup\",\n    \"type\": \"incremental\",\n    \"source\": sourcePath,\n    \"destination\": destPath\n])\n\n// Add error context\nlogger.error(\"Operation failed\", metadata: [\n    \"operation\": operation.name,\n    \"duration\": duration,\n    \"retries\": retryCount,\n    \"error\": error.localizedDescription\n])\n</code></pre>"},{"location":"guides/logging/#3-sensitive-data","title":"3. Sensitive Data","text":"<pre><code>// Never log credentials\nlogger.info(\"Connecting to repository\", metadata: [\n    \"url\": repository.url,\n    \"type\": repository.type\n    // DON'T include passwords or keys\n])\n\n// Mask sensitive data\nlogger.info(\"User authenticated\", metadata: [\n    \"user\": user.id,\n    \"token\": \"****\" // Masked token\n])\n</code></pre>"},{"location":"guides/logging/#advanced-usage","title":"Advanced Usage","text":""},{"location":"guides/logging/#1-custom-destinations","title":"1. Custom Destinations","text":"<pre><code>let customDestination = LogDestination(\n    identifier: \"analytics\",\n    minimumLevel: .info,\n    formatter: AnalyticsFormatter()\n)\n\nUmbraLogger.addDestination(customDestination)\n</code></pre>"},{"location":"guides/logging/#2-custom-formatters","title":"2. Custom Formatters","text":"<pre><code>class JSONFormatter: LogFormatter {\n    func format(_ entry: LogEntry) -&gt; String {\n        let json: [String: Any] = [\n            \"timestamp\": entry.timestamp,\n            \"level\": entry.level.rawValue,\n            \"message\": entry.message,\n            \"metadata\": entry.metadata\n        ]\n        return try! JSONSerialization.data(withJSONObject: json)\n    }\n}\n</code></pre>"},{"location":"guides/logging/#3-context-managers","title":"3. Context Managers","text":"<pre><code>class OperationContext {\n    private var metadata: [String: Any]\n\n    func execute(_ operation: String) async throws {\n        logger.withMetadata(metadata) {\n            logger.info(\"Starting operation\")\n            // Execute operation\n            logger.info(\"Operation completed\")\n        }\n    }\n}\n</code></pre>"},{"location":"guides/logging/#integration-examples","title":"Integration Examples","text":""},{"location":"guides/logging/#1-service-integration","title":"1. Service Integration","text":"<pre><code>class BackupService {\n    private let logger = UmbraLogger.forModule(\"BackupService\")\n\n    func performBackup() async throws {\n        logger.info(\"Starting backup\", metadata: [\n            \"type\": backupType,\n            \"files\": fileCount\n        ])\n\n        do {\n            try await runBackup()\n            logger.info(\"Backup completed\")\n        } catch {\n            logger.error(\"Backup failed\", error: error)\n            throw error\n        }\n    }\n}\n</code></pre>"},{"location":"guides/logging/#2-error-tracking","title":"2. Error Tracking","text":"<pre><code>class ErrorTracker {\n    private let logger = UmbraLogger.forModule(\"ErrorTracker\")\n\n    func track(_ error: Error, context: [String: Any]) {\n        logger.error(\"Error occurred\", metadata: [\n            \"error\": error.localizedDescription,\n            \"type\": String(describing: type(of: error)),\n            \"context\": context\n        ])\n    }\n}\n</code></pre>"},{"location":"guides/logging/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guides/logging/#common-issues","title":"Common Issues","text":"<ol> <li> <p>Log File Management <pre><code>// Rotate log files\nUmbraLogger.configure(\n    fileConfig: FileConfiguration(\n        directory: logDirectory,\n        maxFileSize: 10_000_000,  // 10MB\n        maxFileCount: 5\n    )\n)\n</code></pre></p> </li> <li> <p>Performance Optimization <pre><code>// Avoid expensive logging in production\nif logger.isEnabled(for: .debug) {\n    let expensive = calculateExpensiveMetadata()\n    logger.debug(\"Details\", metadata: expensive)\n}\n</code></pre></p> </li> <li> <p>Error Investigation <pre><code>// Enable full debug logging temporarily\nUmbraLogger.configure(\n    level: .verbose,\n    destinations: [.console, .file],\n    metadata: [\"debug\": true]\n)\n</code></pre></p> </li> </ol>"},{"location":"guides/performance/","title":"Performance Optimisation in UmbraCore","text":""},{"location":"guides/performance/#overview","title":"Overview","text":"<p>Performance is crucial for backup operations. This guide covers performance optimisation techniques used in UmbraCore and best practices for maintaining high performance.</p>"},{"location":"guides/performance/#core-principles","title":"Core Principles","text":""},{"location":"guides/performance/#1-asynchronous-operations","title":"1. Asynchronous Operations","text":"<p>Leverage Swift's async/await for non-blocking operations:</p> <pre><code>actor BackupCoordinator {\n    func backupMultipleDirectories(_ paths: [String]) async throws {\n        try await withThrowingTaskGroup(of: Void.self) { group in\n            for path in paths {\n                group.addTask {\n                    try await backupDirectory(path)\n                }\n            }\n            try await group.waitForAll()\n        }\n    }\n}\n</code></pre>"},{"location":"guides/performance/#2-memory-management","title":"2. Memory Management","text":"<p>Efficient memory usage patterns:</p> <pre><code>actor StreamProcessor {\n    // Use streams for large data\n    func processLargeFile(_ url: URL) async throws {\n        for try await line in url.lines {\n            try await processLine(line)\n        }\n    }\n\n    // Batch small operations\n    func processBatch(_ items: [Item]) async throws {\n        let batchSize = 100\n        for batch in items.chunked(into: batchSize) {\n            try await processBatchItems(batch)\n        }\n    }\n}\n</code></pre>"},{"location":"guides/performance/#3-resource-pooling","title":"3. Resource Pooling","text":"<p>Pool and reuse expensive resources:</p> <pre><code>actor ConnectionPool {\n    private var connections: [Connection] = []\n    private let maxConnections = 10\n\n    func acquire() async throws -&gt; Connection {\n        if let connection = connections.popLast() {\n            return connection\n        }\n\n        guard connections.count &lt; maxConnections else {\n            throw PoolError.maxConnectionsReached\n        }\n\n        return try await createConnection()\n    }\n\n    func release(_ connection: Connection) async {\n        if connections.count &lt; maxConnections {\n            connections.append(connection)\n        } else {\n            await connection.close()\n        }\n    }\n}\n</code></pre>"},{"location":"guides/performance/#optimisation-techniques","title":"Optimisation Techniques","text":""},{"location":"guides/performance/#1-caching","title":"1. Caching","text":"<p>Implement efficient caching strategies:</p> <pre><code>actor CacheManager {\n    private var cache = NSCache&lt;NSString, AnyObject&gt;()\n    private let fileManager = FileManager.default\n\n    func cachedValue(\n        forKey key: String,\n        generator: () async throws -&gt; Any\n    ) async throws -&gt; Any {\n        // Check memory cache\n        if let cached = cache.object(forKey: key as NSString) {\n            return cached\n        }\n\n        // Generate new value\n        let value = try await generator()\n        cache.setObject(value as AnyObject, forKey: key as NSString)\n        return value\n    }\n\n    func clearStaleEntries() async {\n        // Implement cache eviction policy\n    }\n}\n</code></pre>"},{"location":"guides/performance/#2-data-structures","title":"2. Data Structures","text":"<p>Choose appropriate data structures:</p> <pre><code>struct PerformanceOptimised {\n    // Use Set for fast lookups\n    private var processedItems: Set&lt;String&gt; = []\n\n    // Use Dictionary for O(1) access\n    private var itemCache: [String: Item] = [:]\n\n    // Use Array for ordered data\n    private var processingQueue: [Item] = []\n\n    // Use ContiguousArray for better performance with value types\n    private var metrics: ContiguousArray&lt;Double&gt; = []\n}\n</code></pre>"},{"location":"guides/performance/#3-lazy-loading","title":"3. Lazy Loading","text":"<p>Defer expensive operations:</p> <pre><code>class LazyResource {\n    private lazy var expensiveResource: Resource = {\n        createExpensiveResource()\n    }()\n\n    private func createExpensiveResource() -&gt; Resource {\n        // Only created when first accessed\n        Resource(configuration: loadConfiguration())\n    }\n}\n</code></pre>"},{"location":"guides/performance/#performance-monitoring","title":"Performance Monitoring","text":""},{"location":"guides/performance/#1-metrics-collection","title":"1. Metrics Collection","text":"<p>Track performance metrics:</p> <pre><code>actor PerformanceMonitor {\n    private var metrics: [String: [TimeInterval]] = [:]\n\n    func measure&lt;T&gt;(\n        operation: String,\n        block: () async throws -&gt; T\n    ) async throws -&gt; T {\n        let start = ProcessInfo.processInfo.systemUptime\n        let result = try await block()\n        let duration = ProcessInfo.processInfo.systemUptime - start\n\n        await record(operation: operation, duration: duration)\n        return result\n    }\n\n    private func record(operation: String, duration: TimeInterval) {\n        metrics[operation, default: []].append(duration)\n\n        if metrics[operation]?.count ?? 0 &gt; 1000 {\n            metrics[operation]?.removeFirst(500)\n        }\n    }\n\n    func getMetrics(for operation: String) -&gt; PerformanceMetrics {\n        guard let measurements = metrics[operation] else {\n            return PerformanceMetrics.empty\n        }\n\n        return PerformanceMetrics(\n            average: measurements.average,\n            median: measurements.median,\n            percentile95: measurements.percentile(95),\n            count: measurements.count\n        )\n    }\n}\n</code></pre>"},{"location":"guides/performance/#2-performance-logging","title":"2. Performance Logging","text":"<p>Log performance data:</p> <pre><code>extension Logger {\n    func logPerformance(\n        _ metrics: PerformanceMetrics,\n        operation: String,\n        file: String = #file,\n        function: String = #function\n    ) {\n        info(\n            \"Performance metrics\",\n            metadata: [\n                \"operation\": \"\\(operation)\",\n                \"average\": \"\\(metrics.average)\",\n                \"median\": \"\\(metrics.median)\",\n                \"p95\": \"\\(metrics.percentile95)\",\n                \"count\": \"\\(metrics.count)\",\n                \"file\": \"\\(file)\",\n                \"function\": \"\\(function)\"\n            ]\n        )\n    }\n}\n</code></pre>"},{"location":"guides/performance/#3-alerts-and-thresholds","title":"3. Alerts and Thresholds","text":"<p>Monitor performance thresholds:</p> <pre><code>actor PerformanceAlert {\n    private let thresholds: [String: TimeInterval]\n    private let notifier: AlertNotifier\n\n    func checkThresholds(_ metrics: PerformanceMetrics, operation: String) async {\n        guard let threshold = thresholds[operation] else { return }\n\n        if metrics.percentile95 &gt; threshold {\n            await notifier.alert(\n                \"\"\"\n                Performance degradation detected:\n                Operation: \\(operation)\n                P95: \\(metrics.percentile95)\n                Threshold: \\(threshold)\n                \"\"\"\n            )\n        }\n    }\n}\n</code></pre>"},{"location":"guides/performance/#best-practices","title":"Best Practices","text":""},{"location":"guides/performance/#1-batch-processing","title":"1. Batch Processing","text":"<p>Batch operations for efficiency:</p> <pre><code>actor BatchProcessor {\n    private let batchSize = 100\n\n    func process(_ items: [Item]) async throws {\n        let batches = items.chunked(into: batchSize)\n\n        try await withThrowingTaskGroup(of: Void.self) { group in\n            for batch in batches {\n                group.addTask {\n                    try await processBatch(batch)\n                }\n            }\n            try await group.waitForAll()\n        }\n    }\n}\n</code></pre>"},{"location":"guides/performance/#2-resource-management","title":"2. Resource Management","text":"<p>Proper resource cleanup:</p> <pre><code>class ManagedResource {\n    private var resources: [Resource] = []\n\n    func use&lt;T&gt;(_ resource: Resource, operation: (Resource) throws -&gt; T) throws -&gt; T {\n        resources.append(resource)\n        defer {\n            resource.cleanup()\n            resources.removeAll { $0 === resource }\n        }\n        return try operation(resource)\n    }\n}\n</code></pre>"},{"location":"guides/performance/#3-background-processing","title":"3. Background Processing","text":"<p>Offload heavy work:</p> <pre><code>actor BackgroundProcessor {\n    private let queue = DispatchQueue(\n        label: \"com.umbracore.background\",\n        qos: .background\n    )\n\n    func processInBackground(_ work: @escaping () -&gt; Void) {\n        queue.async {\n            work()\n        }\n    }\n}\n</code></pre>"},{"location":"guides/performance/#testing","title":"Testing","text":""},{"location":"guides/performance/#1-performance-tests","title":"1. Performance Tests","text":"<p>Test performance metrics:</p> <pre><code>class PerformanceTests: XCTestCase {\n    func testOperationPerformance() throws {\n        measure {\n            // Performance-critical code\n        }\n    }\n\n    func testAsyncPerformance() async throws {\n        let metrics = try await measureAsync {\n            try await performOperation()\n        }\n\n        XCTAssertLessThan(metrics.average, 0.1)\n        XCTAssertLessThan(metrics.percentile95, 0.2)\n    }\n}\n</code></pre>"},{"location":"guides/performance/#2-memory-tests","title":"2. Memory Tests","text":"<p>Test memory usage:</p> <pre><code>class MemoryTests: XCTestCase {\n    func testMemoryUsage() throws {\n        let tracker = MemoryTracker()\n\n        autoreleasepool {\n            // Memory-intensive operation\n        }\n\n        XCTAssertLessThan(\n            tracker.peakMemoryUsage,\n            50 * 1024 * 1024 // 50MB\n        )\n    }\n}\n</code></pre>"},{"location":"guides/performance/#3-load-tests","title":"3. Load Tests","text":"<p>Test under load:</p> <p>```swift class LoadTests: XCTestCase {     func testConcurrentOperations() async throws {         let operations = 1000         let service = TestService()</p> <pre><code>    try await withThrowingTaskGroup(of: Void.self) { group in\n        for _ in 0..&lt;operations {\n            group.addTask {\n                try await service.operation()\n            }\n        }\n        try await group.waitForAll()\n    }\n}\n</code></pre> <p>}</p>"},{"location":"guides/security/","title":"Security Guidelines","text":"<p>This guide outlines security best practices for using UmbraCore.</p>"},{"location":"guides/security/#core-principles","title":"Core Principles","text":"<ol> <li>Least Privilege: Only request necessary permissions</li> <li>Data Protection: Secure all sensitive data</li> <li>Secure Communication: Use encrypted channels</li> <li>Audit Logging: Track security-relevant events</li> </ol>"},{"location":"guides/security/#secure-storage","title":"Secure Storage","text":""},{"location":"guides/security/#password-storage","title":"Password Storage","text":"<ul> <li>Use <code>SecureString</code> for passwords</li> <li>Implement proper password policies</li> <li>Use secure key derivation</li> </ul>"},{"location":"guides/security/#repository-encryption","title":"Repository Encryption","text":"<ul> <li>Use strong encryption keys</li> <li>Implement key rotation</li> <li>Secure key storage</li> </ul>"},{"location":"guides/security/#network-security","title":"Network Security","text":""},{"location":"guides/security/#remote-repositories","title":"Remote Repositories","text":"<ul> <li>Use SSH or HTTPS</li> <li>Validate certificates</li> <li>Implement rate limiting</li> <li>Handle network errors securely</li> </ul>"},{"location":"guides/security/#api-security","title":"API Security","text":"<ul> <li>Use API tokens securely</li> <li>Implement request signing</li> <li>Validate all inputs</li> </ul>"},{"location":"guides/security/#error-handling","title":"Error Handling","text":""},{"location":"guides/security/#security-errors","title":"Security Errors","text":"<ul> <li>Log security events</li> <li>Don't expose sensitive data</li> <li>Implement proper error recovery</li> </ul>"},{"location":"guides/security/#access-control","title":"Access Control","text":"<ul> <li>Validate permissions</li> <li>Check file access rights</li> <li>Handle access denied errors</li> </ul>"},{"location":"guides/security/#best-practices","title":"Best Practices","text":"<ol> <li>Keep dependencies updated</li> <li>Regular security audits</li> <li>Follow cryptographic best practices</li> <li>Implement proper logging</li> <li>Regular penetration testing</li> </ol>"},{"location":"guides/thread-safety/","title":"Thread Safety in UmbraCore","text":""},{"location":"guides/thread-safety/#overview","title":"Overview","text":"<p>UmbraCore is designed to be thread-safe by default. All public APIs can be safely called from multiple threads concurrently. This guide explains our thread safety guarantees and best practices.</p>"},{"location":"guides/thread-safety/#core-principles","title":"Core Principles","text":""},{"location":"guides/thread-safety/#1-actor-based-services","title":"1. Actor-Based Services","text":"<p>All core services in UmbraCore use Swift's actor system to ensure thread safety:</p> <pre><code>actor KeychainService {\n    private var cache: [String: Data] = [:]\n\n    func store(_ data: Data, forKey key: String) async throws {\n        // Thread-safe access to cache\n        cache[key] = data\n        try await persistToKeychain(data, key)\n    }\n}\n</code></pre>"},{"location":"guides/thread-safety/#2-immutable-state","title":"2. Immutable State","text":"<p>We prefer immutable state to minimize synchronization needs:</p> <pre><code>struct BackupConfig {\n    // Immutable properties\n    let sourcePath: String\n    let destinationPath: String\n    let excludePatterns: [String]\n\n    // Instead of mutating, create new instance\n    func withExcludePattern(_ pattern: String) -&gt; BackupConfig {\n        var patterns = excludePatterns\n        patterns.append(pattern)\n        return BackupConfig(\n            sourcePath: sourcePath,\n            destinationPath: destinationPath,\n            excludePatterns: patterns\n        )\n    }\n}\n</code></pre>"},{"location":"guides/thread-safety/#3-synchronized-collections","title":"3. Synchronized Collections","text":"<p>When mutable state is necessary, we use synchronized collections:</p> <pre><code>actor CacheManager {\n    private var cache = [String: Any]()\n    private let queue = DispatchQueue(label: \"com.umbracore.cache\")\n\n    func set(_ value: Any, forKey key: String) {\n        queue.sync { cache[key] = value }\n    }\n\n    func get(_ key: String) -&gt; Any? {\n        queue.sync { cache[key] }\n    }\n}\n</code></pre>"},{"location":"guides/thread-safety/#best-practices","title":"Best Practices","text":""},{"location":"guides/thread-safety/#1-asyncawait-usage","title":"1. Async/Await Usage","text":"<p>Always use async/await for asynchronous operations:</p> <pre><code>// Good\nfunc backupFiles() async throws {\n    try await prepareBackup()\n    try await performBackup()\n    try await cleanup()\n}\n\n// Avoid\nfunc backupFiles(completion: @escaping (Error?) -&gt; Void) {\n    prepareBackup { error in\n        guard error == nil else {\n            completion(error)\n            return\n        }\n        // Callback hell continues...\n    }\n}\n</code></pre>"},{"location":"guides/thread-safety/#2-resource-access","title":"2. Resource Access","text":"<p>Use proper resource access patterns:</p> <pre><code>actor ResourceManager {\n    private var isLocked = false\n\n    func acquireResource() async throws {\n        guard !isLocked else {\n            throw ResourceError.alreadyLocked\n        }\n        isLocked = true\n    }\n\n    func releaseResource() {\n        isLocked = false\n    }\n}\n</code></pre>"},{"location":"guides/thread-safety/#3-shared-state","title":"3. Shared State","text":"<p>Minimize shared state, use message passing:</p> <pre><code>actor BackupCoordinator {\n    private var activeBackups: Set&lt;UUID&gt; = []\n\n    func startBackup() async throws -&gt; UUID {\n        let id = UUID()\n        activeBackups.insert(id)\n        return id\n    }\n\n    func completeBackup(_ id: UUID) {\n        activeBackups.remove(id)\n    }\n}\n</code></pre>"},{"location":"guides/thread-safety/#common-patterns","title":"Common Patterns","text":""},{"location":"guides/thread-safety/#1-double-checked-locking","title":"1. Double-Checked Locking","text":"<p>For expensive initialization:</p> <pre><code>actor ConfigurationManager {\n    private var config: Configuration?\n\n    func getConfiguration() async throws -&gt; Configuration {\n        if let existing = config {\n            return existing\n        }\n\n        let loaded = try await loadConfiguration()\n        config = loaded\n        return loaded\n    }\n}\n</code></pre>"},{"location":"guides/thread-safety/#2-reader-writer-pattern","title":"2. Reader-Writer Pattern","text":"<p>For concurrent read access:</p> <pre><code>actor DatabaseManager {\n    private var isWriting = false\n    private var activeReaders = 0\n\n    func read() async throws -&gt; Data {\n        while isWriting {\n            try await Task.sleep(nanoseconds: 100_000)\n        }\n        activeReaders += 1\n        defer { activeReaders -= 1 }\n        return try getData()\n    }\n\n    func write(_ data: Data) async throws {\n        while activeReaders &gt; 0 {\n            try await Task.sleep(nanoseconds: 100_000)\n        }\n        isWriting = true\n        defer { isWriting = false }\n        try await writeData(data)\n    }\n}\n</code></pre>"},{"location":"guides/thread-safety/#3-task-management","title":"3. Task Management","text":"<p>For concurrent operations:</p> <pre><code>class BackupTask {\n    func executeParallel(_ operations: [Operation]) async throws {\n        try await withThrowingTaskGroup(of: Void.self) { group in\n            for operation in operations {\n                group.addTask {\n                    try await operation.execute()\n                }\n            }\n            try await group.waitForAll()\n        }\n    }\n}\n</code></pre>"},{"location":"guides/thread-safety/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guides/thread-safety/#1-deadlock-prevention","title":"1. Deadlock Prevention","text":"<pre><code>actor Service {\n    // Avoid nested actor calls\n    func operation1() async {\n        await operation2() // Could deadlock if not careful\n    }\n\n    func operation2() async {\n        // Implementation\n    }\n}\n\n// Better approach\nactor Service {\n    func operation1() async {\n        // Execute independently\n        try await Task.sleep(nanoseconds: 100_000)\n        await operation2()\n    }\n}\n</code></pre>"},{"location":"guides/thread-safety/#2-race-condition-detection","title":"2. Race Condition Detection","text":"<pre><code>actor StateManager {\n    private var state: State\n    private var version: UInt64 = 0\n\n    func modify(_ change: (State) -&gt; State) async {\n        let currentVersion = version\n        state = change(state)\n\n        // Detect concurrent modifications\n        guard version == currentVersion else {\n            throw ConcurrencyError.stateModified\n        }\n        version += 1\n    }\n}\n</code></pre>"},{"location":"guides/thread-safety/#3-performance-issues","title":"3. Performance Issues","text":"<pre><code>actor PerformanceOptimized {\n    // Batch operations to reduce actor hops\n    func batchOperation(_ items: [Item]) async {\n        // Single actor hop for batch\n        items.forEach { process($0) }\n    }\n\n    // Avoid frequent actor hops\n    private func process(_ item: Item) {\n        // Local processing\n    }\n}\n</code></pre>"},{"location":"guides/thread-safety/#testing","title":"Testing","text":""},{"location":"guides/thread-safety/#1-concurrency-testing","title":"1. Concurrency Testing","text":"<pre><code>func testConcurrentAccess() async throws {\n    let service = SharedService()\n\n    try await withThrowingTaskGroup(of: Void.self) { group in\n        for _ in 0..&lt;100 {\n            group.addTask {\n                try await service.operation()\n            }\n        }\n        try await group.waitForAll()\n    }\n}\n</code></pre>"},{"location":"guides/thread-safety/#2-race-condition-testing","title":"2. Race Condition Testing","text":"<p>```swift func testRaceConditions() async throws {     let service = SharedService()</p> <pre><code>async let operation1 = service.modify()\nasync let operation2 = service.modify()\n\n// This should handle concurrent modifications gracefully\ntry await [operation1, operation2]\n</code></pre> <p>}</p>"},{"location":"guides/xpc/","title":"UmbraXPC Guide","text":""},{"location":"guides/xpc/#overview","title":"Overview","text":"<p><code>UmbraXPC</code> provides a secure inter-process communication layer for UmbraCore services. It enables privilege separation and sandboxing while maintaining type safety and async/await support.</p>"},{"location":"guides/xpc/#features","title":"Features","text":"<ul> <li>Secure IPC communication</li> <li>Type-safe protocols</li> <li>Async/await support</li> <li>Error handling</li> <li>Privilege separation</li> </ul>"},{"location":"guides/xpc/#basic-usage","title":"Basic Usage","text":""},{"location":"guides/xpc/#service-definition","title":"Service Definition","text":"<pre><code>// Define XPC protocol\n@objc protocol KeychainXPCProtocol {\n    func store(password: String, forKey: String) async throws\n    func retrieve(forKey: String) async throws -&gt; String\n    func remove(forKey: String) async throws\n}\n\n// Implement service\nclass KeychainXPCService: NSObject, KeychainXPCProtocol {\n    func store(password: String, forKey: String) async throws {\n        // Implementation\n    }\n\n    // Other implementations...\n}\n</code></pre>"},{"location":"guides/xpc/#service-registration","title":"Service Registration","text":"<pre><code>// Register service\nlet service = XPCService(\n    service: KeychainXPCService(),\n    protocol: KeychainXPCProtocol.self\n)\n\ntry await service.register()\n</code></pre>"},{"location":"guides/xpc/#client-usage","title":"Client Usage","text":"<pre><code>// Connect to service\nlet client = try XPCClient&lt;KeychainXPCProtocol&gt;()\n\n// Use service\ntry await client.store(password: \"secret\", forKey: \"key\")\nlet value = try await client.retrieve(forKey: \"key\")\n</code></pre>"},{"location":"guides/xpc/#error-handling","title":"Error Handling","text":"<pre><code>do {\n    try await client.store(password: \"secret\", forKey: \"key\")\n} catch XPCError.connectionFailed {\n    // Handle connection failure\n} catch XPCError.serviceStopped {\n    // Handle service stop\n} catch {\n    // Handle other errors\n}\n</code></pre>"},{"location":"guides/xpc/#best-practices","title":"Best Practices","text":""},{"location":"guides/xpc/#1-protocol-design","title":"1. Protocol Design","text":"<pre><code>// Good protocol design\n@objc protocol BackupXPCProtocol {\n    // Clear operation names\n    func startBackup(source: URL, destination: URL) async throws\n\n    // Specific error types\n    func checkAccess(path: String) async throws -&gt; Bool\n\n    // Progress reporting\n    func getProgress() async throws -&gt; Double\n}\n</code></pre>"},{"location":"guides/xpc/#2-error-handling","title":"2. Error Handling","text":"<pre><code>// Define specific errors\nenum BackupXPCError: Error {\n    case accessDenied(String)\n    case insufficientSpace(needed: UInt64, available: UInt64)\n    case connectionLost\n}\n\n// Handle errors appropriately\ndo {\n    try await service.startBackup(source: src, destination: dest)\n} catch BackupXPCError.accessDenied(let path) {\n    // Handle access denied\n} catch BackupXPCError.insufficientSpace(let needed, let available) {\n    // Handle space issues\n}\n</code></pre>"},{"location":"guides/xpc/#3-resource-management","title":"3. Resource Management","text":"<pre><code>// Proper cleanup\nclass XPCManager {\n    private var client: XPCClient&lt;BackupXPCProtocol&gt;?\n\n    func shutdown() async {\n        await client?.disconnect()\n        client = nil\n    }\n}\n</code></pre>"},{"location":"guides/xpc/#advanced-usage","title":"Advanced Usage","text":""},{"location":"guides/xpc/#1-custom-message-handling","title":"1. Custom Message Handling","text":"<pre><code>class CustomXPCService: XPCServiceDelegate {\n    func handleCustomMessage(_ message: [String: Any]) async throws -&gt; Any {\n        // Custom message handling\n        switch message[\"type\"] as? String {\n        case \"status\":\n            return await getStatus()\n        case \"control\":\n            return try await handleControl(message)\n        default:\n            throw XPCError.invalidMessage\n        }\n    }\n}\n</code></pre>"},{"location":"guides/xpc/#2-progress-reporting","title":"2. Progress Reporting","text":"<pre><code>protocol ProgressReporting {\n    func reportProgress(_ progress: Double) async\n}\n\nclass BackupXPCService: ProgressReporting {\n    private var progress: Double = 0\n\n    func reportProgress(_ progress: Double) async {\n        self.progress = progress\n        await notifyObservers()\n    }\n}\n</code></pre>"},{"location":"guides/xpc/#3-connection-management","title":"3. Connection Management","text":"<pre><code>class XPCConnectionManager {\n    private var connections: [String: XPCClient&lt;Any&gt;] = [:]\n\n    func getConnection&lt;T&gt;(_ type: T.Type) async throws -&gt; XPCClient&lt;T&gt; {\n        let id = String(describing: type)\n\n        if let existing = connections[id] as? XPCClient&lt;T&gt; {\n            return existing\n        }\n\n        let new = try XPCClient&lt;T&gt;()\n        connections[id] = new\n        return new\n    }\n}\n</code></pre>"},{"location":"guides/xpc/#integration-examples","title":"Integration Examples","text":""},{"location":"guides/xpc/#1-backup-service","title":"1. Backup Service","text":"<pre><code>class BackupManager {\n    private let xpc: XPCClient&lt;BackupXPCProtocol&gt;\n\n    func startBackup() async throws {\n        // Connect to XPC service\n        try await xpc.connect()\n\n        // Start backup operation\n        try await xpc.startBackup(\n            source: sourceURL,\n            destination: destURL\n        )\n\n        // Monitor progress\n        for await progress in xpc.progressUpdates() {\n            updateUI(progress)\n        }\n    }\n}\n</code></pre>"},{"location":"guides/xpc/#2-security-service","title":"2. Security Service","text":"<pre><code>class SecurityManager {\n    private let xpc: XPCClient&lt;SecurityXPCProtocol&gt;\n\n    func validateAccess() async throws -&gt; Bool {\n        try await xpc.withConnection { service in\n            try await service.checkSecurity([\n                \"operation\": \"backup\",\n                \"level\": \"system\"\n            ])\n        }\n    }\n}\n</code></pre>"},{"location":"guides/xpc/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guides/xpc/#common-issues","title":"Common Issues","text":"<ol> <li> <p>Connection Issues <pre><code>// Implement retry logic\nfunc connectWithRetry() async throws -&gt; XPCClient&lt;T&gt; {\n    var attempts = 0\n    while attempts &lt; 3 {\n        do {\n            return try await XPCClient&lt;T&gt;().connect()\n        } catch {\n            attempts += 1\n            try await Task.sleep(nanoseconds: 1_000_000_000)\n        }\n    }\n    throw XPCError.connectionFailed\n}\n</code></pre></p> </li> <li> <p>Service Recovery <pre><code>// Handle service interruption\nfunc handleServiceFailure() async throws {\n    try await xpc.disconnect()\n    try await Task.sleep(nanoseconds: 1_000_000_000)\n    try await xpc.connect()\n}\n</code></pre></p> </li> <li> <p>Resource Cleanup <pre><code>// Proper resource management\nclass XPCResource {\n    private var resources: Set&lt;XPCClient&lt;Any&gt;&gt; = []\n\n    func cleanup() async {\n        for resource in resources {\n            await resource.disconnect()\n        }\n        resources.removeAll()\n    }\n}\n</code></pre></p> </li> </ol>"},{"location":"linting/swiftlint-analysis/","title":"SwiftLint Analysis Report","text":"<p>Generated: 24 February 2025 Last Updated: 24 February 2025</p>"},{"location":"linting/swiftlint-analysis/#overview","title":"Overview","text":"<p>This document tracks SwiftLint violations in the UmbraCore project. Each section lists violations by category and file, making it easier to track progress as we address them.</p>"},{"location":"linting/swiftlint-analysis/#current-status","title":"Current Status","text":"<ul> <li>Initial Violations: 264</li> <li>Current Violations: 237</li> <li>Reduction: 27 violations (10.2% improvement)</li> </ul>"},{"location":"linting/swiftlint-analysis/#violation-categories","title":"Violation Categories","text":""},{"location":"linting/swiftlint-analysis/#1-vertical-parameter-alignment","title":"1. Vertical Parameter Alignment","text":"<p>Files with parameter alignment issues: - [x] <code>Sources/UmbraKeychainService/KeychainXPCImplementation.swift</code> (Fixed) - [ ] <code>Sources/UmbraKeychainService/KeychainXPCConnection.swift</code>   - Multiple instances of misaligned parameters in function declarations</p>"},{"location":"linting/swiftlint-analysis/#2-identifier-naming","title":"2. Identifier Naming","text":"<p>Files with naming issues: - [x] <code>Tests/CryptoTests/CryptoServiceTests.swift</code> (Fixed) - [x] <code>Tests/CryptoTypesTests/DefaultCryptoServiceTests.swift</code> (Fixed) - [ ] <code>Tests/XPCTests/CryptoXPCServiceTests.swift</code>   - Variable 'iv' too short - [ ] <code>Tests/UmbraTestKit/Sources/UmbraTestKit/TestUtilities.swift</code>   - Variable 'fm' and 'i' too short</p>"},{"location":"linting/swiftlint-analysis/#3-string-to-data-conversion","title":"3. String to Data Conversion","text":"<p>Files with non-optimal conversions: - [x] <code>Tests/CryptoTests/CryptoServiceTests.swift</code> (Fixed) - [x] <code>Tests/CryptoTypesTests/DefaultCryptoServiceTests.swift</code> (Fixed) - [ ] <code>Tests/SecurityTypesTests/MockSecurityProviderTests.swift</code> - [ ] <code>Tests/CoreTests/CryptoTests.swift</code> - [ ] <code>Tests/KeychainTests/KeychainServiceTests.swift</code></p>"},{"location":"linting/swiftlint-analysis/#4-line-length","title":"4. Line Length","text":"<p>Files exceeding line length limits: - [ ] <code>Sources/Core/Services/ServiceContainer.swift</code>   - Line 170: 132 characters (limit: 120) - [ ] <code>Tests/ResticCLIHelperTests/Support/TestUtilities.swift</code>   - Line 39: 124 characters - [ ] <code>Tests/CryptoTests/CryptoServiceTests.swift</code>   - Line 35: 124 characters</p>"},{"location":"linting/swiftlint-analysis/#5-attributes","title":"5. Attributes","text":"<p>Files with attribute placement issues: - [x] <code>Sources/Core/Services/CoreService.swift</code> (Fixed) - [ ] <code>Sources/Core/Services/UmbraService.swift</code></p>"},{"location":"linting/swiftlint-analysis/#6-todos","title":"6. TODOs","text":"<p>Files with TODO comments to resolve: - [ ] <code>Sources/Core/Core.swift</code> - [ ] <code>Sources/Core/Services/KeyManager.swift</code> (multiple TODOs)</p>"},{"location":"linting/swiftlint-analysis/#7-other-issues","title":"7. Other Issues","text":"<ul> <li>[ ] Unused enumerated in <code>Tests/ResticCLIHelperTests/Support/TestUtilities.swift</code></li> </ul>"},{"location":"linting/swiftlint-analysis/#progress-tracking","title":"Progress Tracking","text":""},{"location":"linting/swiftlint-analysis/#completion-status","title":"Completion Status","text":"<ul> <li>[x] Initial vertical parameter alignment in KeychainXPCImplementation.swift</li> <li>[x] Initial identifier naming issues in crypto test files</li> <li>[x] Initial String to Data conversion issues in main crypto test files</li> <li>[x] Attribute placement in CoreService.swift</li> <li>[ ] Remaining vertical parameter alignment issues</li> <li>[ ] Remaining identifier naming issues</li> <li>[ ] Remaining String to Data conversion issues</li> <li>[ ] Line length issues</li> <li>[ ] Remaining attribute placement issues</li> <li>[ ] TODO comments</li> <li>[ ] Other minor issues</li> </ul>"},{"location":"linting/swiftlint-analysis/#next-steps","title":"Next Steps","text":"<ol> <li>Address vertical parameter alignment in KeychainXPCConnection.swift</li> <li>Fix remaining short variable names in test files</li> <li>Update remaining String to Data conversions</li> <li>Fix line length violations</li> <li>Correct remaining attribute placements</li> <li>Review and address TODO comments</li> <li>Fix miscellaneous issues</li> </ol>"},{"location":"linting/swiftlint-analysis/#notes","title":"Notes","text":"<ul> <li>All fixes should maintain existing functionality</li> <li>Test coverage should be maintained or improved</li> <li>Document any architectural decisions made during refactoring</li> <li>Consider creating tickets for addressing TODO comments separately</li> </ul>"},{"location":"modules/","title":"UmbraCore Modules","text":"<p>UmbraCore is organised into a set of specialised modules that work together to provide a comprehensive backup solution for macOS applications. Each module has a specific responsibility within the framework.</p>"},{"location":"modules/#core-modules","title":"Core Modules","text":"Module Description UmbraCore The main integration module providing core functionality XPCProtocolsCore Foundation-free XPC protocol definitions SecurityProtocolsCore Foundation-free security interfaces"},{"location":"modules/#security-modules","title":"Security Modules","text":"Module Description SecurityTypes Core security primitives and types UmbraCryptoService Cryptographic operations implementation UmbraKeychainService Secure credential storage"},{"location":"modules/#infrastructure-modules","title":"Infrastructure Modules","text":"Module Description UmbraXPC Cross-process communication infrastructure ErrorTypes Error handling architecture Configuration Settings and preferences management"},{"location":"modules/#repository-and-backup-modules","title":"Repository and Backup Modules","text":"Module Description RepositoryManager Repository lifecycle management BackupCoordinator Backup orchestration ResticCLIHelper Type-safe Restic command execution"},{"location":"modules/#module-integration","title":"Module Integration","text":"<p>These modules are designed to work together seamlessly whilst maintaining clear boundaries and separation of concerns. The modular architecture allows for flexible integration into different types of applications.</p>"},{"location":"modules/backupcoordinator/","title":"BackupCoordinator Module","text":"<p>The BackupCoordinator module orchestrates backup operations across the UmbraCore framework, providing a streamlined approach to managing backup processes.</p>"},{"location":"modules/backupcoordinator/#overview","title":"Overview","text":"<p>BackupCoordinator handles the orchestration of backup operations, managing the creation, scheduling, execution, and monitoring of backups. It coordinates between different modules to provide a cohesive backup experience.</p>"},{"location":"modules/backupcoordinator/#features","title":"Features","text":"<ul> <li>Backup task orchestration</li> <li>Backup scheduling and timing</li> <li>Progress monitoring and reporting</li> <li>Error handling and recovery</li> <li>Backup verification and validation</li> </ul>"},{"location":"modules/backupcoordinator/#usage","title":"Usage","text":"<pre><code>import BackupCoordinator\n\n// Create a backup coordinator\nlet coordinator = BackupCoordinator()\n\n// Configure a backup job\nlet backupJob = BackupJob(\n    sources: [\"/Users/username/Documents\", \"/Users/username/Pictures\"],\n    excludes: [\"**/.DS_Store\", \"**/node_modules\"],\n    repository: mainRepository,\n    schedule: BackupSchedule(\n        frequency: .daily,\n        preferredTime: \"02:00\",\n        retryStrategy: .exponentialBackoff(maxAttempts: 3)\n    ),\n    tags: [\"documents\", \"pictures\", \"important\"]\n)\n\n// Register the backup job\ntry coordinator.registerBackupJob(backupJob)\n\n// Run a backup immediately\ntry await coordinator.runBackupJob(\n    id: backupJob.id,\n    options: BackupOptions(\n        compressionLevel: 6,\n        verifyAfterCompletion: true\n    )\n)\n\n// Monitor progress\ncoordinator.progressHandler = { progress in\n    print(\"Backup progress: \\(progress.percentage)%\")\n    print(\"Files processed: \\(progress.filesProcessed)\")\n    print(\"Bytes processed: \\(progress.bytesProcessed)\")\n}\n\n// Get backup history\nlet history = try await coordinator.getBackupHistory(\n    forRepository: mainRepository,\n    limit: 10\n)\n</code></pre>"},{"location":"modules/backupcoordinator/#integration","title":"Integration","text":"<p>BackupCoordinator integrates with:</p> <ul> <li>RepositoryManager for repository access and management</li> <li>ResticCLIHelper for executing backup commands</li> <li>UmbraXPC for privileged operations</li> <li>Configuration for backup settings</li> </ul>"},{"location":"modules/backupcoordinator/#advanced-features","title":"Advanced Features","text":"<ul> <li>Incremental backups</li> <li>Snapshot management</li> <li>Differential backup strategies</li> <li>Backup chains and dependencies</li> <li>Resource-aware backup throttling</li> </ul>"},{"location":"modules/backupcoordinator/#source-code","title":"Source Code","text":"<p>The source code for this module is located in the <code>Sources/BackupCoordinator</code> directory of the UmbraCore repository.</p>"},{"location":"modules/configuration/","title":"Configuration Module","text":"<p>The Configuration module provides settings and preferences management capabilities for the UmbraCore framework.</p>"},{"location":"modules/configuration/#overview","title":"Overview","text":"<p>The Configuration module handles application settings, user preferences, and framework configuration, offering a consistent and type-safe approach to managing configuration across the UmbraCore framework.</p>"},{"location":"modules/configuration/#features","title":"Features","text":"<ul> <li>Type-safe configuration management</li> <li>Default value handling</li> <li>Configuration validation</li> <li>Secure storage for sensitive settings</li> <li>Configuration migration support</li> </ul>"},{"location":"modules/configuration/#usage","title":"Usage","text":"<pre><code>import Configuration\n\n// Access application configuration\nlet config = Configuration.shared\n\n// Read configuration values\nlet backupInterval = config.get(\\.backupSchedule.intervalHours)\nlet compressionLevel = config.get(\\.backup.compressionLevel)\nlet isEncryptionEnabled = config.get(\\.security.encryptBackups)\n\n// Update configuration values\ntry config.set(\\.backup.compressionLevel, to: 6)\ntry config.set(\\.security.encryptBackups, to: true)\n\n// Use strongly-typed configuration\nstruct BackupSettings: ConfigurationProvider {\n    @ConfigurationProperty(\\.backup.excludedPaths)\n    var excludedPaths: [String]\n\n    @ConfigurationProperty(\\.backup.maxParallelOperations)\n    var maxParallelOperations: Int\n}\n\nlet backupSettings = BackupSettings()\nprint(\"Excluded paths: \\(backupSettings.excludedPaths)\")\nprint(\"Max parallel operations: \\(backupSettings.maxParallelOperations)\")\n</code></pre>"},{"location":"modules/configuration/#integration","title":"Integration","text":"<p>The Configuration module integrates with:</p> <ul> <li>UmbraCore for framework-level settings</li> <li>UmbraKeychainService for secure settings storage</li> <li>RepositoryManager for repository configuration</li> <li>BackupCoordinator for backup settings</li> </ul>"},{"location":"modules/configuration/#security-considerations","title":"Security Considerations","text":"<ul> <li>Sensitive configuration values are stored securely</li> <li>Configuration validation prevents insecure settings</li> <li>Configuration access is controlled through appropriate access levels</li> <li>Configuration migration handles changes safely</li> </ul>"},{"location":"modules/configuration/#source-code","title":"Source Code","text":"<p>The source code for this module is located in the <code>Sources/Configuration</code> directory of the UmbraCore repository.</p>"},{"location":"modules/errortypes/","title":"ErrorTypes Module","text":"<p>The ErrorTypes module provides a comprehensive error handling architecture for the UmbraCore framework.</p>"},{"location":"modules/errortypes/#overview","title":"Overview","text":"<p>ErrorTypes defines a structured approach to error handling across the UmbraCore framework, ensuring consistency, proper error propagation, and meaningful error reporting. This module establishes error domains, error types, and conventions for error handling throughout the codebase.</p>"},{"location":"modules/errortypes/#features","title":"Features","text":"<ul> <li>Comprehensive error type definitions</li> <li>Domain-specific error categorisation</li> <li>Structured error propagation</li> <li>Localised error descriptions</li> <li>Error recovery strategies</li> </ul>"},{"location":"modules/errortypes/#usage","title":"Usage","text":"<pre><code>import ErrorTypes\n\n// Define a function that can throw specific errors\nfunc performOperation() throws {\n    guard isAvailable else {\n        throw CoreError.serviceUnavailable(\n            reason: \"The service is currently offline\", \n            suggestion: \"Try again later\"\n        )\n    }\n\n    guard hasPermission else {\n        throw SecurityError.insufficientPermissions(\n            resource: \"backup-repository\",\n            requiredPermission: \"write\"\n        )\n    }\n\n    // Perform operation\n}\n\n// Handle errors with structured catching\ndo {\n    try performOperation()\n} catch let error as CoreError {\n    // Handle core framework errors\n    switch error {\n    case .serviceUnavailable(let reason, let suggestion):\n        log(\"Service unavailable: \\(reason). \\(suggestion)\")\n    // Handle other core errors\n    }\n} catch let error as SecurityError {\n    // Handle security-specific errors\n} catch {\n    // Handle unexpected errors\n}\n</code></pre>"},{"location":"modules/errortypes/#integration","title":"Integration","text":"<p>ErrorTypes integrates with all UmbraCore modules to provide consistent error handling throughout the framework:</p> <ul> <li>UmbraCore for framework-level errors</li> <li>UmbraXPC for cross-process error propagation</li> <li>SecurityTypes for security-specific errors</li> <li>ResticCLIHelper for command execution errors</li> </ul>"},{"location":"modules/errortypes/#design-philosophy","title":"Design Philosophy","text":"<p>The ErrorTypes module follows these key principles:</p> <ul> <li>Errors should be specific and meaningful</li> <li>Error types should include helpful context</li> <li>Errors should suggest recovery actions when possible</li> <li>Error handling should be consistent across the framework</li> </ul>"},{"location":"modules/errortypes/#source-code","title":"Source Code","text":"<p>The source code for this module is located in the <code>Sources/ErrorTypes</code> directory of the UmbraCore repository.</p>"},{"location":"modules/repositorymanager/","title":"RepositoryManager Module","text":"<p>The RepositoryManager module provides repository lifecycle management capabilities for the UmbraCore framework.</p>"},{"location":"modules/repositorymanager/#overview","title":"Overview","text":"<p>RepositoryManager handles all aspects of repository management, including creation, initialisation, validation, and maintenance of Restic repositories. It ensures repositories are properly configured, accessible, and maintained throughout their lifecycle.</p>"},{"location":"modules/repositorymanager/#features","title":"Features","text":"<ul> <li>Repository initialisation and setup</li> <li>Repository validation and health checks</li> <li>Repository configuration management</li> <li>Repository maintenance operations</li> <li>Multi-repository support</li> </ul>"},{"location":"modules/repositorymanager/#usage","title":"Usage","text":"<pre><code>import RepositoryManager\n\n// Create a repository manager\nlet repoManager = RepositoryManager()\n\n// Initialise a new repository\nlet repository = try await repoManager.initialise(\n    at: \"/Volumes/Backup/my-repository\",\n    withPassword: securePasswordReference,\n    options: RepositoryOptions(\n        compressionLevel: 6,\n        encryptionAlgorithm: .aes256\n    )\n)\n\n// Check repository health\nlet healthStatus = try await repoManager.checkHealth(repository)\nif healthStatus.needsMaintenance {\n    try await repoManager.performMaintenance(\n        on: repository,\n        operations: [.prune, .check, .rebuild]\n    )\n}\n\n// List repositories\nlet allRepositories = try await repoManager.listRepositories()\nfor repo in allRepositories {\n    print(\"Repository: \\(repo.name), Status: \\(repo.status)\")\n}\n</code></pre>"},{"location":"modules/repositorymanager/#integration","title":"Integration","text":"<p>RepositoryManager integrates with:</p> <ul> <li>ResticCLIHelper for Restic command execution</li> <li>UmbraKeychainService for secure password management</li> <li>UmbraXPC for privileged operations</li> <li>BackupCoordinator for coordinating backup operations</li> </ul>"},{"location":"modules/repositorymanager/#security-considerations","title":"Security Considerations","text":"<ul> <li>Repository passwords are managed securely</li> <li>Repository access control is enforced</li> <li>Repository integrity is validated</li> <li>Secure storage locations are recommended</li> </ul>"},{"location":"modules/repositorymanager/#source-code","title":"Source Code","text":"<p>The source code for this module is located in the <code>Sources/RepositoryManager</code> directory of the UmbraCore repository.</p>"},{"location":"modules/resticlihelper/","title":"ResticCLIHelper Module","text":"<p>The ResticCLIHelper module provides type-safe Restic command execution capabilities for the UmbraCore framework.</p>"},{"location":"modules/resticlihelper/#overview","title":"Overview","text":"<p>ResticCLIHelper encapsulates the interaction with the Restic command-line tool, providing a type-safe and structured API for executing Restic commands. This module handles command building, parameter validation, and execution in a secure environment.</p>"},{"location":"modules/resticlihelper/#features","title":"Features","text":"<ul> <li>Type-safe Restic command building</li> <li>Secure parameter validation</li> <li>Structured output parsing</li> <li>Error handling and logging</li> <li>Sandboxed execution support</li> </ul>"},{"location":"modules/resticlihelper/#usage","title":"Usage","text":"<pre><code>import ResticCLIHelper\n\n// Create a helper instance\nlet resticHelper = ResticCLIHelper()\n\n// Configure a repository\nlet repoConfig = ResticRepositoryConfiguration(\n    path: \"/Volumes/Backup/main-repository\",\n    password: securePasswordReference,\n    extraEnvironment: [\"RESTIC_CACHE_DIR\": \"/tmp/restic-cache\"]\n)\n\n// Initialise a repository\ntry await resticHelper.initialise(repository: repoConfig)\n\n// Create a backup\ntry await resticHelper.backup(\n    repository: repoConfig,\n    sourcePaths: [\"/Users/username/Documents\"],\n    excludePaths: [\"/Users/username/Documents/temp\"],\n    tags: [\"documents\", \"important\"]\n)\n\n// List snapshots\nlet snapshots = try await resticHelper.listSnapshots(\n    repository: repoConfig,\n    tag: \"documents\"\n)\n</code></pre>"},{"location":"modules/resticlihelper/#integration","title":"Integration","text":"<p>ResticCLIHelper integrates with:</p> <ul> <li>UmbraXPC for executing commands in a privileged context</li> <li>SecurityTypes for secure credential handling</li> <li>RepositoryManager for repository lifecycle operations</li> <li>BackupCoordinator for orchestrating backup operations</li> </ul>"},{"location":"modules/resticlihelper/#security-considerations","title":"Security Considerations","text":"<ul> <li>Never exposes raw passwords in command-line arguments</li> <li>Validates all parameters before execution</li> <li>Uses secure environment variables for credentials</li> <li>Sanitises command output for logging</li> </ul>"},{"location":"modules/resticlihelper/#source-code","title":"Source Code","text":"<p>The source code for this module is located in the <code>Sources/ResticCLIHelper</code> directory of the UmbraCore repository.</p>"},{"location":"modules/securityprotocolscore/","title":"SecurityProtocolsCore Module","text":"<p>The SecurityProtocolsCore module provides foundation-free security protocol definitions for the UmbraCore framework.</p>"},{"location":"modules/securityprotocolscore/#overview","title":"Overview","text":"<p>SecurityProtocolsCore defines the core security interfaces used throughout the UmbraCore framework, allowing for consistent and reliable security operations across different modules. This module is designed to be foundation-free, enabling it to be used in contexts where Foundation dependencies would be problematic.</p>"},{"location":"modules/securityprotocolscore/#features","title":"Features","text":"<ul> <li>Foundation-free security protocol definitions</li> <li>Secure credential management interfaces</li> <li>Cryptographic operation protocols</li> <li>Authentication validation interfaces</li> </ul>"},{"location":"modules/securityprotocolscore/#usage","title":"Usage","text":"<pre><code>import SecurityProtocolsCore\n\n// Create a type that implements a security protocol\nclass MySecurityProvider: CryptoServiceProvider {\n    func generateKey(strength: KeyStrength) throws -&gt; SecureKey {\n        // Implementation\n    }\n\n    func encryptData(_ data: Data, withKey key: SecureKey) throws -&gt; EncryptedData {\n        // Implementation\n    }\n}\n</code></pre>"},{"location":"modules/securityprotocolscore/#integration","title":"Integration","text":"<p>SecurityProtocolsCore integrates with:</p> <ul> <li>SecurityTypes for core security type definitions</li> <li>UmbraCryptoService for cryptographic operations</li> <li>UmbraKeychainService for secure storage</li> <li>UmbraXPC for secure cross-process operations</li> </ul>"},{"location":"modules/securityprotocolscore/#source-code","title":"Source Code","text":"<p>The source code for this module is located in the <code>Sources/SecurityProtocolsCore</code> directory of the UmbraCore repository.</p>"},{"location":"modules/securitytypes/","title":"SecurityTypes Module","text":"<p>The SecurityTypes module provides the core security primitives and types used throughout the UmbraCore framework.</p>"},{"location":"modules/securitytypes/#overview","title":"Overview","text":"<p>SecurityTypes defines foundational security-related types, enumerations, and structures that are shared across different modules of the UmbraCore framework. It serves as a central library of security primitives designed to be used consistently throughout the system.</p>"},{"location":"modules/securitytypes/#features","title":"Features","text":"<ul> <li>Core security primitive types</li> <li>Cryptographic key representations</li> <li>Secure credential containers</li> <li>Error types for security operations</li> <li>Serialisation protocols for secure types</li> </ul>"},{"location":"modules/securitytypes/#usage","title":"Usage","text":"<pre><code>import SecurityTypes\n\n// Create a secure credential\nlet credential = SecureCredential(\n    username: \"repouser\",\n    passwordData: encryptedPasswordData,\n    metadata: [\n        \"repository\": \"backup-main\",\n        \"created\": ISO8601DateFormatter().string(from: Date())\n    ]\n)\n\n// Use a security error\nfunc handleError(_ error: SecurityError) {\n    switch error {\n    case .authenticationFailed:\n        // Handle authentication failure\n    case .keyGenerationFailed(let reason):\n        // Handle key generation failure\n    case .encryptionFailed(let underlyingError):\n        // Handle encryption failure\n    // ...other cases\n    }\n}\n</code></pre>"},{"location":"modules/securitytypes/#integration","title":"Integration","text":"<p>SecurityTypes is a foundational module that integrates with:</p> <ul> <li>SecurityProtocolsCore for protocol definitions</li> <li>UmbraCryptoService for cryptographic operations</li> <li>UmbraKeychainService for secure storage</li> <li>UmbraXPC for secure cross-process operations</li> </ul>"},{"location":"modules/securitytypes/#source-code","title":"Source Code","text":"<p>The source code for this module is located in the <code>Sources/SecurityTypes</code> directory of the UmbraCore repository.</p>"},{"location":"modules/umbracore/","title":"UmbraCore Module","text":"<p>The UmbraCore module is the main integration point of the framework, providing the core functionality for integrating with Restic backup on macOS systems.</p>"},{"location":"modules/umbracore/#overview","title":"Overview","text":"<p>The UmbraCore module brings together all the components of the framework to provide a cohesive and unified API for macOS applications to interact with Restic backup functionality. It serves as the main entry point for applications using the framework.</p>"},{"location":"modules/umbracore/#features","title":"Features","text":"<ul> <li>Unified API for Restic operations</li> <li>Integration with macOS security features</li> <li>Complete backup and restore functionality</li> <li>Cross-process security operations</li> </ul>"},{"location":"modules/umbracore/#usage","title":"Usage","text":"<pre><code>import UmbraCore\n\n// Initialize the core framework\nlet core = UmbraCore()\n\n// Access various subsystems\nlet repositories = core.repositories\nlet snapshots = core.snapshots\nlet securityService = core.securityService\n</code></pre>"},{"location":"modules/umbracore/#integration","title":"Integration","text":"<p>This module integrates with all other UmbraCore modules to provide a seamless experience for developers building backup solutions on macOS.</p>"},{"location":"modules/umbracore/#source-code","title":"Source Code","text":"<p>The source code for this module is located in the <code>Sources/UmbraCore</code> directory of the UmbraCore repository.</p>"},{"location":"modules/umbracryptoservice/","title":"UmbraCryptoService Module","text":"<p>The UmbraCryptoService module provides cryptographic operations and services for the UmbraCore framework.</p>"},{"location":"modules/umbracryptoservice/#overview","title":"Overview","text":"<p>UmbraCryptoService implements secure cryptographic functions required for encrypting and decrypting data, generating secure keys, and providing other essential cryptographic operations needed by the UmbraCore framework.</p>"},{"location":"modules/umbracryptoservice/#features","title":"Features","text":"<ul> <li>Secure encryption and decryption operations</li> <li>Cryptographic key generation and management</li> <li>Password hashing with modern algorithms</li> <li>Secure random data generation</li> <li>Digital signature verification</li> </ul>"},{"location":"modules/umbracryptoservice/#usage","title":"Usage","text":"<pre><code>import UmbraCryptoService\n\n// Create a crypto service instance\nlet cryptoService = UmbraCryptoService()\n\n// Generate a secure key\nlet key = try cryptoService.generateKey(\n    strength: .high,\n    purpose: .encryption\n)\n\n// Encrypt sensitive data\nlet encryptedData = try cryptoService.encrypt(\n    data: sensitiveData,\n    using: key,\n    algorithm: .aes256GCM\n)\n\n// Decrypt the encrypted data\nlet decryptedData = try cryptoService.decrypt(\n    data: encryptedData,\n    using: key,\n    algorithm: .aes256GCM\n)\n</code></pre>"},{"location":"modules/umbracryptoservice/#integration","title":"Integration","text":"<p>UmbraCryptoService integrates with:</p> <ul> <li>SecurityTypes for core security primitives</li> <li>SecurityProtocolsCore for protocol conformance</li> <li>UmbraKeychainService for secure key storage</li> <li>UmbraCore for high-level security operations</li> </ul>"},{"location":"modules/umbracryptoservice/#security-considerations","title":"Security Considerations","text":"<ul> <li>Implements industry-standard cryptographic algorithms</li> <li>Uses secure key management practices</li> <li>Implements key rotation capabilities</li> <li>Provides secure memory handling for sensitive data</li> </ul>"},{"location":"modules/umbracryptoservice/#source-code","title":"Source Code","text":"<p>The source code for this module is located in the <code>Sources/UmbraCryptoService</code> directory of the UmbraCore repository.</p>"},{"location":"modules/umbrakeychainservice/","title":"UmbraKeychainService Module","text":"<p>The UmbraKeychainService module provides secure credential storage and management using macOS Keychain for the UmbraCore framework.</p>"},{"location":"modules/umbrakeychainservice/#overview","title":"Overview","text":"<p>UmbraKeychainService encapsulates secure credential management functionality, allowing the application to store and retrieve sensitive information such as repository passwords and encryption keys securely using the macOS Keychain.</p>"},{"location":"modules/umbrakeychainservice/#features","title":"Features","text":"<ul> <li>Secure password storage and retrieval</li> <li>Encryption key management</li> <li>Access control for credential access</li> <li>Secure credential sharing with XPC service</li> <li>Automatic credential lifecycle management</li> </ul>"},{"location":"modules/umbrakeychainservice/#usage","title":"Usage","text":"<pre><code>import UmbraKeychainService\n\n// Store a repository password\nlet keychainService = UmbraKeychainService()\ntry await keychainService.storePassword(\n    \"my-secure-password\",\n    forRepository: repositoryID,\n    accessGroup: \"com.example.myapp.shared\"\n)\n\n// Retrieve a repository password\nlet password = try await keychainService.retrievePassword(\n    forRepository: repositoryID,\n    accessGroup: \"com.example.myapp.shared\"\n)\n</code></pre>"},{"location":"modules/umbrakeychainservice/#integration","title":"Integration","text":"<p>UmbraKeychainService integrates with:</p> <ul> <li>SecurityTypes for secure credential types</li> <li>SecurityProtocolsCore for security interfaces</li> <li>UmbraCore for application integration</li> <li>UmbraXPC for secure credential passing to XPC service</li> </ul>"},{"location":"modules/umbrakeychainservice/#security-considerations","title":"Security Considerations","text":"<ul> <li>Passwords are never stored in plain text</li> <li>Credentials are accessible only to authorised processes</li> <li>Access control lists limit which processes can access credentials</li> <li>Automatic cleanup of orphaned credentials</li> </ul>"},{"location":"modules/umbrakeychainservice/#source-code","title":"Source Code","text":"<p>The source code for this module is located in the <code>Sources/UmbraKeychainService</code> directory of the UmbraCore repository.</p>"},{"location":"modules/umbraxpc/","title":"UmbraXPC Module","text":"<p>The UmbraXPC module provides the cross-process communication infrastructure for the UmbraCore framework, enabling secure operations between the sandboxed application and privileged XPC service.</p>"},{"location":"modules/umbraxpc/#overview","title":"Overview","text":"<p>UmbraXPC implements the infrastructure required for secure and reliable communication between the main application and the XPC service. It handles process lifecycle management, error handling, and secure message passing to maintain the security boundaries required by macOS.</p>"},{"location":"modules/umbraxpc/#features","title":"Features","text":"<ul> <li>Secure XPC service implementation</li> <li>Process lifecycle management</li> <li>Robust error handling</li> <li>Secure credential passing</li> <li>Permission validation</li> </ul>"},{"location":"modules/umbraxpc/#usage","title":"Usage","text":"<pre><code>import UmbraXPC\n\n// Set up the XPC service connection\nlet xpcService = UmbraXPCServiceConnector.shared\n\n// Execute a command via XPC\ntry await xpcService.executeCommand(\n    command: \"backup\",\n    arguments: [\"--source\", sourcePath, \"--target\", targetPath],\n    environment: [\"RESTIC_PASSWORD\": passwordReference]\n)\n</code></pre>"},{"location":"modules/umbraxpc/#integration","title":"Integration","text":"<p>UmbraXPC integrates with:</p> <ul> <li>XPCProtocolsCore for protocol definitions</li> <li>SecurityTypes for secure type passing</li> <li>ResticCLIHelper for command execution</li> <li>UmbraCore for main application integration</li> </ul>"},{"location":"modules/umbraxpc/#security-model","title":"Security Model","text":"<p>UmbraXPC follows a strict security model:</p> <ul> <li>Main app requests permissions</li> <li>XPC service executes commands</li> <li>Secure data passing between components</li> <li>Resource cleanup on both sides</li> </ul>"},{"location":"modules/umbraxpc/#source-code","title":"Source Code","text":"<p>The source code for this module is located in the <code>Sources/UmbraXPC</code> directory of the UmbraCore repository.</p>"},{"location":"modules/xpcprotocolscore/","title":"XPCProtocolsCore Module","text":"<p>The XPCProtocolsCore module defines the foundation-free protocols used for XPC communication between the sandboxed application and XPC service.</p>"},{"location":"modules/xpcprotocolscore/#overview","title":"Overview","text":"<p>XPCProtocolsCore provides a consistent set of protocols and interfaces for secure cross-process communication, enabling sandboxed applications to perform privileged operations without compromising security. This module is designed to work without Foundation dependencies, making it lightweight and suitable for use in security-critical contexts.</p>"},{"location":"modules/xpcprotocolscore/#features","title":"Features","text":"<ul> <li>Foundation-free protocol definitions</li> <li>Standardised error handling</li> <li>Type-safe message passing</li> <li>Secure parameter validation</li> </ul>"},{"location":"modules/xpcprotocolscore/#usage","title":"Usage","text":"<pre><code>import XPCProtocolsCore\n\n// Define a service conforming to XPC protocols\nclass MyXPCService: XPCServiceProtocol {\n    func performOperation(\n        parameters: OperationParameters, \n        withReply reply: @escaping (Result&lt;OperationResult, XPCSecurityError&gt;) -&gt; Void\n    ) {\n        // Implementation\n    }\n}\n</code></pre>"},{"location":"modules/xpcprotocolscore/#integration","title":"Integration","text":"<p>XPCProtocolsCore is primarily integrated with:</p> <ul> <li>UmbraXPC for XPC service implementation</li> <li>SecurityProtocolsCore for security protocols</li> <li>UmbraCore for main application integration</li> </ul>"},{"location":"modules/xpcprotocolscore/#source-code","title":"Source Code","text":"<p>The source code for this module is located in the <code>Sources/XPCProtocolsCore</code> directory of the UmbraCore repository.</p>"},{"location":"security/SECURITY_GUIDELINES/","title":"Security Guidelines","text":""},{"location":"security/SECURITY_GUIDELINES/#overview","title":"Overview","text":"<p>UmbraCore handles sensitive data and requires careful attention to security. This guide outlines our security practices and requirements.</p>"},{"location":"security/SECURITY_GUIDELINES/#secure-storage","title":"Secure Storage","text":""},{"location":"security/SECURITY_GUIDELINES/#1-credentials","title":"1. Credentials","text":"<ul> <li>Always use <code>UmbraKeychainService</code> for storing:</li> <li>Repository passwords</li> <li>API keys</li> <li>Access tokens</li> <li>SSH keys</li> </ul> <pre><code>// DO THIS:\ntry await keychainService.store(password: \"secret\", forKey: \"repo-key\")\n\n// DON'T DO THIS:\nUserDefaults.standard.set(\"secret\", forKey: \"repo-key\") // UNSAFE!\n</code></pre>"},{"location":"security/SECURITY_GUIDELINES/#2-file-system-access","title":"2. File System Access","text":"<ul> <li>Use <code>UmbraBookmarkService</code> for persistent file access</li> <li>Never store raw file paths</li> <li>Always use security-scoped bookmarks</li> </ul>"},{"location":"security/SECURITY_GUIDELINES/#encryption","title":"Encryption","text":""},{"location":"security/SECURITY_GUIDELINES/#1-data-at-rest","title":"1. Data at Rest","text":"<ul> <li>All sensitive data must be encrypted</li> <li>Use <code>UmbraCryptoService</code> for encryption/decryption</li> <li>Never store encryption keys in code</li> </ul>"},{"location":"security/SECURITY_GUIDELINES/#2-data-in-transit","title":"2. Data in Transit","text":"<ul> <li>Use secure transport (HTTPS, SSH)</li> <li>Validate certificates</li> <li>Implement proper error handling</li> </ul>"},{"location":"security/SECURITY_GUIDELINES/#access-control","title":"Access Control","text":""},{"location":"security/SECURITY_GUIDELINES/#1-xpc-services","title":"1. XPC Services","text":"<ul> <li>Principle of least privilege</li> <li>Separate process for sensitive operations</li> <li>Validate all inputs</li> </ul>"},{"location":"security/SECURITY_GUIDELINES/#2-file-permissions","title":"2. File Permissions","text":"<ul> <li>Respect system permissions</li> <li>Use security-scoped resources</li> <li>Clean up temporary files</li> </ul>"},{"location":"security/SECURITY_GUIDELINES/#logging","title":"Logging","text":""},{"location":"security/SECURITY_GUIDELINES/#1-sensitive-data","title":"1. Sensitive Data","text":"<ul> <li>Never log credentials</li> <li>Mask sensitive information</li> <li>Use appropriate log levels</li> </ul>"},{"location":"security/SECURITY_GUIDELINES/#2-audit-trail","title":"2. Audit Trail","text":"<ul> <li>Log security-relevant events</li> <li>Include necessary context</li> <li>Maintain audit logs</li> </ul>"},{"location":"security/SECURITY_GUIDELINES/#error-handling","title":"Error Handling","text":""},{"location":"security/SECURITY_GUIDELINES/#1-security-errors","title":"1. Security Errors","text":"<ul> <li>Don't expose internal details</li> <li>Provide appropriate user feedback</li> <li>Log security failures</li> </ul>"},{"location":"security/SECURITY_GUIDELINES/#2-recovery","title":"2. Recovery","text":"<ul> <li>Implement secure fallbacks</li> <li>Clean up on failure</li> <li>Maintain system integrity</li> </ul>"},{"location":"security/SECURITY_GUIDELINES/#best-practices","title":"Best Practices","text":""},{"location":"security/SECURITY_GUIDELINES/#1-code","title":"1. Code","text":"<ul> <li>Use Swift's type safety</li> <li>Implement input validation</li> <li>Follow OWASP guidelines</li> </ul>"},{"location":"security/SECURITY_GUIDELINES/#2-testing","title":"2. Testing","text":"<ul> <li>Include security test cases</li> <li>Test error conditions</li> <li>Verify security boundaries</li> </ul>"},{"location":"security/SECURITY_GUIDELINES/#3-dependencies","title":"3. Dependencies","text":"<ul> <li>Regular security updates</li> <li>Vulnerability scanning</li> <li>Dependency pinning</li> </ul>"},{"location":"support/troubleshooting/","title":"Troubleshooting","text":"<p>This page will contain troubleshooting information for common UmbraCore issues. Check back soon for updates.</p>"},{"location":"support/troubleshooting/#coming-soon","title":"Coming Soon","text":"<ul> <li>Common issues</li> <li>Error messages</li> <li>Debug procedures</li> <li>Performance problems</li> <li>Known limitations</li> </ul>"},{"location":"user-guide/","title":"UmbraCore User Guide","text":"<p>This comprehensive guide covers everything you need to know about using UmbraCore effectively in your macOS applications.</p>"},{"location":"user-guide/#core-concepts","title":"Core Concepts","text":"<ul> <li>Configuration and setup</li> <li>Backup strategies</li> <li>Security best practices</li> <li>Advanced features</li> </ul>"},{"location":"user-guide/#available-guides","title":"Available Guides","text":"<ul> <li>Configuration: Detailed configuration options</li> <li>Advanced Features: Advanced usage and features</li> <li>Security: Security guidelines and best practices</li> </ul>"},{"location":"user-guide/advanced-features/","title":"Advanced Features","text":"<p>UmbraCore provides several advanced features for secure backup management. This guide covers cryptographic operations, keychain integration, and other advanced capabilities.</p>"},{"location":"user-guide/advanced-features/#cryptographic-operations","title":"Cryptographic Operations","text":""},{"location":"user-guide/advanced-features/#overview","title":"Overview","text":"<p>The <code>UmbraCryptoService</code> provides comprehensive cryptographic operations:</p> <pre><code>let service = try UmbraCryptoService()\n\n// Basic encryption\nlet data = \"sensitive data\".data(using: .utf8)!\nlet encrypted = try await service.encrypt(data)\n\n// Custom key encryption\nlet key = try service.generateKey()\nlet customEncrypted = try await service.encrypt(data, using: key)\n\n// Decryption\nlet decrypted = try await service.decrypt(encrypted)\n</code></pre>"},{"location":"user-guide/advanced-features/#advanced-encryption","title":"Advanced Encryption","text":"<p>Configure custom encryption parameters:</p> <pre><code>let params = EncryptionParameters(\n    algorithm: .aes256GCM,\n    keySize: .bits256,\n    iterations: 10000\n)\n\nlet encrypted = try await service.encrypt(\n    data,\n    parameters: params\n)\n</code></pre>"},{"location":"user-guide/advanced-features/#key-management","title":"Key Management","text":"<p>Secure key handling:</p> <pre><code>// Generate new key\nlet key = try service.generateKey()\n\n// Export key (protected)\nlet exportedKey = try service.exportKey(key)\n\n// Import key\nlet importedKey = try service.importKey(exportedKey)\n\n// Key derivation\nlet derivedKey = try service.deriveKey(\n    fromPassword: \"user-password\",\n    salt: salt,\n    iterations: 10000\n)\n</code></pre>"},{"location":"user-guide/advanced-features/#keychain-integration","title":"Keychain Integration","text":""},{"location":"user-guide/advanced-features/#overview_1","title":"Overview","text":"<p>The <code>UmbraKeychainService</code> provides secure credential storage:</p> <pre><code>let service = try UmbraKeychainService()\n\n// Store credentials\ntry await service.store(\n    password: \"secret-password\",\n    forKey: \"backup-repository\"\n)\n\n// Retrieve credentials\nlet password = try await service.retrieve(forKey: \"backup-repository\")\n\n// Update credentials\ntry await service.update(\n    password: \"new-password\",\n    forKey: \"backup-repository\"\n)\n\n// Remove credentials\ntry await service.remove(forKey: \"backup-repository\")\n</code></pre>"},{"location":"user-guide/advanced-features/#advanced-keychain-usage","title":"Advanced Keychain Usage","text":"<p>Custom item attributes:</p> <pre><code>let attributes = KeychainItemAttributes(\n    label: \"Main Backup Repository\",\n    comment: \"Production backup credentials\"\n)\n\ntry await service.store(\n    password: \"secret\",\n    forKey: \"main-repo\",\n    attributes: attributes\n)\n</code></pre>"},{"location":"user-guide/advanced-features/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/advanced-features/#cryptographic-security","title":"Cryptographic Security","text":"<ol> <li>Key Management</li> <li>Rotate keys regularly</li> <li>Secure key storage</li> <li> <p>Use key derivation when appropriate</p> </li> <li> <p>Data Protection</p> </li> <li>Encrypt sensitive data immediately</li> <li>Clear sensitive data from memory</li> <li> <p>Use secure random generation</p> </li> <li> <p>Error Recovery</p> </li> <li>Implement retry logic</li> <li>Log cryptographic failures</li> <li>Provide appropriate user feedback</li> </ol>"},{"location":"user-guide/advanced-features/#keychain-security","title":"Keychain Security","text":"<ol> <li> <p>Key Naming    <pre><code>// Good\n\"backup-repo-main-password\"\n\"aws-access-key-prod\"\n\n// Bad\n\"pwd1\"\n\"key\"\n</code></pre></p> </li> <li> <p>Error Recovery</p> </li> <li>Implement retry logic</li> <li>Provide user feedback</li> <li> <p>Log failures appropriately</p> </li> <li> <p>Security Practices</p> </li> <li>Never store keys in code</li> <li>Use appropriate access control</li> <li>Clean up unused credentials</li> </ol>"},{"location":"user-guide/advanced-features/#error-handling","title":"Error Handling","text":""},{"location":"user-guide/advanced-features/#cryptographic-errors","title":"Cryptographic Errors","text":"<pre><code>do {\n    let encrypted = try await cryptoService.encrypt(data)\n} catch CryptoError.invalidKey {\n    // Handle invalid key\n} catch CryptoError.encryptionFailed(let reason) {\n    // Handle encryption failure\n} catch {\n    // Handle other errors\n}\n</code></pre>"},{"location":"user-guide/advanced-features/#keychain-errors","title":"Keychain Errors","text":"<pre><code>do {\n    try await keychainService.store(password: \"secret\", forKey: \"key\")\n} catch KeychainError.duplicateItem(let key) {\n    // Handle duplicate item\n} catch KeychainError.accessDenied(let reason) {\n    // Handle access denied\n} catch {\n    // Handle other errors\n}\n</code></pre>"},{"location":"user-guide/advanced-features/#related-documentation","title":"Related Documentation","text":"<ul> <li>Security Guide - Comprehensive security information</li> <li>Configuration Guide - Configuration options</li> <li>API Reference - Complete API documentation</li> <li>Troubleshooting Guide - Common issues and solutions</li> </ul>"},{"location":"user-guide/configuration/","title":"Configuration Guide","text":""},{"location":"user-guide/configuration/#overview","title":"Overview","text":"<p>UmbraCore provides a robust configuration system with built-in error handling and validation. This guide covers configuration options and error handling patterns.</p>"},{"location":"user-guide/configuration/#error-handling","title":"Error Handling","text":""},{"location":"user-guide/configuration/#error-types","title":"Error Types","text":"<p>UmbraCore uses a structured error handling system:</p> <pre><code>// Common base errors\nenum CommonError: Error {\n    case invalidArgument(String)\n    case resourceNotFound(String)\n    case permissionDenied(String)\n    case operationFailed(String)\n}\n\n// Service-specific errors\nenum KeychainError: Error {\n    case itemNotFound(String)\n    case duplicateItem(String)\n    case accessDenied(String)\n    case invalidData(String)\n}\n</code></pre>"},{"location":"user-guide/configuration/#error-context","title":"Error Context","text":"<p>Errors include detailed context for debugging:</p> <pre><code>struct ErrorContext {\n    let file: String\n    let function: String\n    let line: Int\n    let timestamp: Date\n    let operationId: UUID\n    var userInfo: [String: Any]\n}\n</code></pre>"},{"location":"user-guide/configuration/#error-handling-patterns","title":"Error Handling Patterns","text":"<p>Handle errors appropriately in your code:</p> <pre><code>func backupFiles() async throws {\n    do {\n        try await validatePermissions()\n        try await performBackup()\n        try await verifyBackup()\n    } catch KeychainError.accessDenied(let details) {\n        logger.error(\"Keychain access denied\", metadata: [\n            \"details\": details,\n            \"operation\": \"backup\"\n        ])\n        throw CommonError.permissionDenied(\"Keychain access required for backup\")\n    }\n}\n</code></pre>"},{"location":"user-guide/configuration/#configuration-options","title":"Configuration Options","text":""},{"location":"user-guide/configuration/#backup-settings","title":"Backup Settings","text":"<p>Configure backup behaviour:</p> <pre><code>struct BackupConfiguration {\n    let compressionLevel: CompressionLevel\n    let excludePatterns: [String]\n    let retentionPolicy: RetentionPolicy\n    let verifyAfterBackup: Bool\n\n    static let `default` = BackupConfiguration(\n        compressionLevel: .balanced,\n        excludePatterns: [\".DS_Store\", \"*.tmp\"],\n        retentionPolicy: .standard,\n        verifyAfterBackup: true\n    )\n}\n</code></pre>"},{"location":"user-guide/configuration/#network-settings","title":"Network Settings","text":"<p>Control network behaviour:</p> <pre><code>struct NetworkConfiguration {\n    let timeoutSeconds: Double\n    let maxRetries: Int\n    let retryDelay: TimeInterval\n    let rateLimit: RateLimit?\n\n    static let `default` = NetworkConfiguration(\n        timeoutSeconds: 30,\n        maxRetries: 3,\n        retryDelay: 1.0,\n        rateLimit: .init(requestsPerMinute: 60)\n    )\n}\n</code></pre>"},{"location":"user-guide/configuration/#logging-configuration","title":"Logging Configuration","text":"<p>Configure logging behaviour:</p> <pre><code>struct LogConfiguration {\n    let level: LogLevel\n    let destination: LogDestination\n    let includeMetadata: Bool\n    let retentionDays: Int\n\n    static let `default` = LogConfiguration(\n        level: .info,\n        destination: .file,\n        includeMetadata: true,\n        retentionDays: 30\n    )\n}\n</code></pre>"},{"location":"user-guide/configuration/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/configuration/#configuration-validation","title":"Configuration Validation","text":"<p>Always validate configuration:</p> <pre><code>func validateConfiguration(_ config: BackupConfiguration) throws {\n    guard config.compressionLevel.isSupported else {\n        throw CommonError.invalidArgument(\n            \"Unsupported compression level: \\(config.compressionLevel)\"\n        )\n    }\n\n    for pattern in config.excludePatterns {\n        guard pattern.isValidGlobPattern else {\n            throw CommonError.invalidArgument(\n                \"Invalid exclude pattern: \\(pattern)\"\n            )\n        }\n    }\n}\n</code></pre>"},{"location":"user-guide/configuration/#error-recovery","title":"Error Recovery","text":"<p>Implement retry logic for recoverable errors:</p> <pre><code>actor RetryableOperation {\n    func execute() async throws -&gt; Result {\n        var attempts = 0\n        while attempts &lt; maxRetries {\n            do {\n                return try await performOperation()\n            } catch let error as RecoverableError {\n                attempts += 1\n                try await handleError(error, attempt: attempts)\n            } catch {\n                throw error // Non-recoverable error\n            }\n        }\n        throw CommonError.operationFailed(\"Max retry attempts exceeded\")\n    }\n}\n</code></pre>"},{"location":"user-guide/configuration/#related-documentation","title":"Related Documentation","text":"<ul> <li>Security Guide - Security configuration</li> <li>Advanced Features - Advanced configuration options</li> <li>API Reference - Complete API documentation</li> <li>Troubleshooting Guide - Common issues and solutions</li> </ul>"},{"location":"user-guide/security/","title":"Security Guidelines","text":""},{"location":"user-guide/security/#overview","title":"Overview","text":"<p>UmbraCore handles sensitive data and requires careful attention to security. This guide outlines our security practices and requirements for developers integrating UmbraCore into their applications.</p>"},{"location":"user-guide/security/#secure-storage","title":"Secure Storage","text":""},{"location":"user-guide/security/#credentials-management","title":"Credentials Management","text":"<p>UmbraCore provides secure storage mechanisms for sensitive data:</p> <pre><code>// Recommended: Use UmbraKeychainService\ntry await keychainService.store(password: \"secret\", forKey: \"repo-key\")\n\n// Never do this:\nUserDefaults.standard.set(\"secret\", forKey: \"repo-key\") // UNSAFE!\n</code></pre> <p>Always use <code>UmbraKeychainService</code> for storing: - Repository passwords - API keys - Access tokens - SSH keys</p>"},{"location":"user-guide/security/#file-system-access","title":"File System Access","text":"<p>UmbraCore implements secure file system access through: - <code>UmbraBookmarkService</code> for persistent file access - Security-scoped bookmarks - Proper permission handling</p> <p>Never store raw file paths - always use security-scoped bookmarks for persistent access.</p>"},{"location":"user-guide/security/#encryption","title":"Encryption","text":""},{"location":"user-guide/security/#data-at-rest","title":"Data at Rest","text":"<p>UmbraCore ensures data security through: - Mandatory encryption of all sensitive data - <code>UmbraCryptoService</code> for encryption/decryption operations - Secure key management (never stored in code)</p>"},{"location":"user-guide/security/#data-in-transit","title":"Data in Transit","text":"<p>Network security is maintained by: - Enforcing secure transport (HTTPS, SSH) - Certificate validation - Comprehensive error handling - Rate limiting and timeout management</p>"},{"location":"user-guide/security/#access-control","title":"Access Control","text":""},{"location":"user-guide/security/#xpc-services","title":"XPC Services","text":"<p>UmbraCore uses XPC services to: - Implement the principle of least privilege - Isolate sensitive operations in separate processes - Validate all inputs and outputs - Maintain process boundaries</p>"},{"location":"user-guide/security/#file-permissions","title":"File Permissions","text":"<p>The framework respects system security by: - Honouring system permissions - Using security-scoped resources - Implementing proper cleanup of temporary files - Validating access rights</p>"},{"location":"user-guide/security/#logging-and-auditing","title":"Logging and Auditing","text":""},{"location":"user-guide/security/#sensitive-data-handling","title":"Sensitive Data Handling","text":"<p>UmbraCore implements secure logging practices: - No credentials in logs - Automatic masking of sensitive information - Appropriate log levels for different contexts - Privacy-aware debug information</p>"},{"location":"user-guide/security/#audit-trail","title":"Audit Trail","text":"<p>Security events are tracked through: - Comprehensive event logging - Contextual information capture - Secure audit log maintenance - Structured log formats</p>"},{"location":"user-guide/security/#error-handling","title":"Error Handling","text":""},{"location":"user-guide/security/#security-errors","title":"Security Errors","text":"<p>The framework handles security errors by: - Abstracting internal details - Providing appropriate user feedback - Logging security failures securely - Implementing secure fallbacks</p>"},{"location":"user-guide/security/#recovery-procedures","title":"Recovery Procedures","text":"<p>Error recovery includes: - Clean state maintenance - Secure cleanup procedures - System integrity verification - Graceful degradation</p>"},{"location":"user-guide/security/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/security/#code-security","title":"Code Security","text":"<p>Developers should follow these practices: - Leverage Swift's type safety - Implement thorough input validation - Follow OWASP guidelines - Use strong types for sensitive data</p>"},{"location":"user-guide/security/#security-testing","title":"Security Testing","text":"<p>UmbraCore requires: - Comprehensive security test cases - Error condition testing - Security boundary verification - Regular security audits</p>"},{"location":"user-guide/security/#dependency-management","title":"Dependency Management","text":"<p>Maintain security through: - Regular security updates - Vulnerability scanning - Strict dependency pinning - Supply chain security</p>"},{"location":"user-guide/security/#getting-help","title":"Getting Help","text":"<p>If you discover a security vulnerability:</p> <ol> <li>DO NOT create a public issue</li> <li>Email security@mpy-dev.ml with details</li> <li>Expect a response within 24 hours</li> <li>Follow responsible disclosure practices</li> </ol>"},{"location":"user-guide/security/#related-documentation","title":"Related Documentation","text":"<ul> <li>Configuration Guide</li> <li>API Reference</li> <li>Troubleshooting Guide</li> </ul>"}]}