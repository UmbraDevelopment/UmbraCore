{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#umbracore-documentation","title":"UmbraCore Documentation","text":"<p>UmbraCore is built upon the foundation of Restic, a remarkable open-source backup programme that has set the standard for secure, efficient, and reliable backups. We are deeply grateful to the Restic team for their years of dedication in creating and maintaining such an exceptional tool.</p> <p>Our mission with UmbraCore is to extend Restic's capabilities specifically for macOS application developers, providing a type-safe, Swift-native interface while maintaining complete compatibility with Restic's core functionality. UmbraCore is not an alternative to Restic, but rather a complementary tool that makes Restic's powerful features more accessible in the macOS development ecosystem.</p>"},{"location":"#core-applications","title":"Core Applications","text":"<p>UmbraCore powers several macOS backup management tools: - ResticBar: macOS menu bar app for developers - Rbx: VS Code extension - Rbum: User-friendly GUI</p>"},{"location":"#features","title":"Features","text":""},{"location":"#implemented","title":"Implemented","text":"<ul> <li>Secure keychain operations with XPC service</li> <li>Comprehensive error handling and logging</li> <li>Thread-safe operations</li> <li>SwiftyBeaver logging integration</li> <li>Modular architecture</li> <li>Extensive test coverage</li> </ul>"},{"location":"#in-development","title":"In Development","text":"<ul> <li>SSH key management</li> <li>Cloud provider credentials</li> <li>Repository password handling</li> </ul>"},{"location":"#architecture","title":"Architecture","text":""},{"location":"#core-libraries","title":"Core Libraries","text":"<ul> <li>SecurityTypes: Base security primitives and protocols</li> <li>CryptoTypes: Cryptographic operations and types</li> <li>UmbraLogging: Centralised logging infrastructure</li> </ul>"},{"location":"#service-layer","title":"Service Layer","text":"<ul> <li>UmbraKeychainService: Secure keychain operations</li> <li>UmbraCryptoService: Cryptographic operations service</li> <li>UmbraBookmarkService: File system bookmark management</li> <li>UmbraXPC: XPC communication infrastructure</li> </ul>"},{"location":"#features_1","title":"Features","text":"<ul> <li>ResticCLIHelper: Command-line interface integration</li> <li>Repositories: Repository management and operations</li> <li>Snapshots: Snapshot creation and management</li> <li>Config: Configuration and settings management</li> <li>Logging: Privacy-aware structured logging</li> <li>ErrorHandling: Comprehensive error management</li> <li>Autocomplete: Context-aware command completion</li> </ul>"},{"location":"#project-status","title":"Project Status","text":"<p>UmbraCore is currently in active development with the following milestones:</p>"},{"location":"#q1-2025-current","title":"Q1 2025 (Current)","text":"<ul> <li>\u2713 Repository Management</li> <li>Secure repository initialisation</li> <li>Repository health monitoring</li> <li>Multi-repository support</li> <li>\u2713 Core Restic Integration</li> <li>Command execution system</li> <li>Output parsing</li> <li>Error handling</li> <li>Process management</li> <li>\u2713 Testing Infrastructure</li> <li>Unit testing framework</li> <li>Integration test suite</li> <li>Performance benchmarks</li> <li>Mock services</li> </ul>"},{"location":"#q2-2025-planned","title":"Q2 2025 (Planned)","text":"<ul> <li>Security Layer</li> <li>SSH key management</li> <li>Cloud provider credentials</li> <li>Repository password handling</li> <li>Configuration System</li> <li>Configuration file format</li> <li>Validation system</li> <li>Migration support</li> <li>Progress Monitoring</li> <li>Progress reporting protocol</li> <li>Status updates system</li> <li>Metrics collection</li> </ul>"},{"location":"#q3-2025-planned","title":"Q3 2025 (Planned)","text":"<ul> <li>Statistics &amp; Analytics</li> <li>Performance metrics</li> <li>Usage statistics</li> <li>Trend analysis</li> <li>Health Monitoring</li> <li>System diagnostics</li> <li>Performance monitoring</li> <li>Resource tracking</li> <li>Event System</li> <li>Event dispatching</li> <li>Notification management</li> <li>Webhook support</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Please refer to our Quick Start Guide for installation and basic usage instructions.</p>"},{"location":"#security","title":"Security","text":"<p>UmbraCore prioritises security in all aspects of its implementation. For details, see our Security Guide.</p>"},{"location":"#documentation","title":"Documentation","text":"<p>Key documentation sections:</p> <ul> <li>Configuration: Configuration Guide</li> <li>Features: Advanced Features</li> <li>Development: API Reference</li> <li>Support: Troubleshooting Guide</li> </ul>"},{"location":"#support","title":"Support","text":"<p>If you find UmbraCore useful, please consider:</p> <ol> <li>Contributing to the project</li> <li>Supporting Restic</li> <li>Starring us on GitHub</li> <li>Sharing your experience with others</li> </ol>"},{"location":"#license","title":"License","text":"<p>UmbraCore is available under the MIT license. See the LICENSE file for more info.</p>"},{"location":"ACKNOWLEDGMENTS/","title":"Acknowledgments","text":"<p>UmbraCore stands on the shoulders of open-source giants. We're deeply grateful to the following open-source projects and their maintainers:</p>"},{"location":"ACKNOWLEDGMENTS/#core-dependencies","title":"Core Dependencies","text":""},{"location":"ACKNOWLEDGMENTS/#restic","title":"Restic","text":"<p>Restic is the backbone of UmbraCore's backup capabilities. It's a modern backup program written in Go which provides: - Fast, secure, and efficient backups - Deduplication - Encryption - Multiple backend support - Outstanding performance</p> <p>We highly recommend supporting the Restic project: - GitHub Repository - Documentation - Contributing Guide - Donate</p>"},{"location":"ACKNOWLEDGMENTS/#swiftybeaver","title":"SwiftyBeaver","text":"<p>SwiftyBeaver powers UmbraCore's logging infrastructure. It's a sophisticated logging system that offers: - Colourised console output - File logging - Cloud logging - Custom formats - Filters and threading support</p> <p>Support SwiftyBeaver: - GitHub Repository - Documentation - Pro Features</p>"},{"location":"ACKNOWLEDGMENTS/#cryptoswift","title":"CryptoSwift","text":"<p>CryptoSwift provides UmbraCore's cryptographic operations. It's a comprehensive cryptography framework offering: - AES encryption - Hash functions - HMAC - PBKDF - Extensible architecture</p> <p>Support CryptoSwift: - GitHub Repository - Documentation - Sponsor</p>"},{"location":"ACKNOWLEDGMENTS/#development-tools","title":"Development Tools","text":""},{"location":"ACKNOWLEDGMENTS/#just-the-docs","title":"Just the Docs","text":"<p>The beautiful documentation theme you're currently viewing. Features: - Clean, responsive design - Full-text search - Dark/light mode - Navigation structure - Customisation options</p> <p>Support Just the Docs: - GitHub Repository - Documentation - Contributing Guide</p>"},{"location":"ACKNOWLEDGMENTS/#jazzy","title":"Jazzy","text":"<p>Jazzy generates our API documentation. It provides: - Clean documentation generation - Markdown support - Search functionality - Cross-references</p> <p>Support Jazzy: - GitHub Repository - Documentation - Contributing Guide</p>"},{"location":"ACKNOWLEDGMENTS/#swiftlint","title":"SwiftLint","text":"<p>SwiftLint helps maintain our code quality. It offers: - Style and convention checking - Customisable rules - Automatic fixing - Xcode integration</p> <p>Support SwiftLint: - GitHub Repository - Documentation - Contributing Guide</p>"},{"location":"ACKNOWLEDGMENTS/#security-tools","title":"Security Tools","text":""},{"location":"ACKNOWLEDGMENTS/#snyk","title":"Snyk","text":"<p>Snyk helps keep UmbraCore secure by providing: - Vulnerability scanning - Dependency monitoring - Security updates - License compliance</p> <p>Support Snyk: - Website - Documentation - Blog</p>"},{"location":"ACKNOWLEDGMENTS/#codecov","title":"Codecov","text":"<p>Codecov helps maintain our test coverage by offering: - Coverage reporting - PR checks - Trending analysis - Quality gates</p> <p>Support Codecov: - Website - Documentation - GitHub Repository</p>"},{"location":"ACKNOWLEDGMENTS/#contributing","title":"Contributing","text":"<p>If you'd like to contribute to UmbraCore, please see our Contributing Guidelines. We welcome all contributions, from code to documentation improvements.</p>"},{"location":"ACKNOWLEDGMENTS/#supporting-open-source","title":"Supporting Open Source","text":"<p>We encourage users of UmbraCore to consider supporting these projects through: - Code contributions - Documentation improvements - Bug reports - Financial support where available - Spreading the word about their excellent work</p> <p>The strength of UmbraCore comes from these outstanding open-source projects. Supporting them helps ensure a vibrant and sustainable open-source ecosystem.</p>"},{"location":"DEPENDENCIES/","title":"UmbraCore Dependencies Documentation","text":""},{"location":"DEPENDENCIES/#core-module-structure","title":"Core Module Structure","text":""},{"location":"DEPENDENCIES/#main-components","title":"Main Components","text":"<ol> <li>API Layer</li> <li><code>//Sources/API:Sources_API</code></li> <li> <p>Dependencies:</p> <ul> <li>Core/UmbraCore</li> </ul> </li> <li> <p>Core Services</p> </li> <li><code>//Sources/Core:Sources_Core</code></li> <li><code>//Sources/Core/Services:CoreServices</code></li> <li> <p><code>//Sources/Core/UmbraCore:Sources_Core_UmbraCore</code></p> </li> <li> <p>Security Components</p> </li> <li><code>//Sources/UmbraSecurity:Sources_UmbraSecurity</code></li> <li><code>//Sources/SecurityUtils:Sources_SecurityUtils</code></li> <li><code>//Sources/UmbraCrypto:UmbraCrypto</code></li> <li><code>//Sources/UmbraCryptoService:Sources_UmbraCryptoService</code></li> <li> <p><code>//Sources/CryptoTypes:CryptoTypes</code></p> </li> <li> <p>Restic Integration</p> </li> <li><code>//Sources/ResticCLIHelper:Sources_ResticCLIHelper</code></li> <li><code>//Sources/ResticCLIHelper/Protocols:Sources_ResticCLIHelper_Protocols</code></li> <li> <p><code>//Sources/ResticCLIHelper/Types:Sources_ResticCLIHelper_Types</code></p> </li> <li> <p>Storage &amp; Persistence</p> </li> <li><code>//Sources/UmbraBookmarkService:Sources_UmbraBookmarkService</code></li> <li><code>//Sources/UmbraKeychainService:UmbraKeychainService</code></li> <li><code>//Sources/Repositories:Sources_Repositories</code></li> <li> <p><code>//Sources/Snapshots:Sources_Snapshots</code></p> </li> <li> <p>Error Handling</p> </li> <li><code>//Sources/ErrorHandling:ErrorHandling</code></li> <li><code>//Sources/ErrorHandling/Common:Sources_ErrorHandling_Common</code></li> <li><code>//Sources/ErrorHandling/Models:Sources_ErrorHandling_Models</code></li> <li> <p><code>//Sources/ErrorHandling/Protocols:Sources_ErrorHandling_Protocols</code></p> </li> <li> <p>Features</p> </li> <li><code>//Sources/Features:Sources_Features</code></li> <li>Crypto Features:<ul> <li><code>//Sources/Features/Crypto/Models:Sources_Features_Crypto_Models</code></li> <li><code>//Sources/Features/Crypto/Protocols:Sources_Features_Crypto_Protocols</code></li> </ul> </li> <li> <p>Logging Features:</p> <ul> <li><code>//Sources/Features/Logging/Errors:Sources_Features_Logging_Errors</code></li> <li><code>//Sources/Features/Logging/Models:Models</code></li> <li><code>//Sources/Features/Logging/Protocols:Protocols</code></li> <li><code>//Sources/Features/Logging/Services:LoggingServices</code></li> </ul> </li> <li> <p>Testing Support</p> </li> <li><code>//Sources/UmbraTestKit:UmbraTestKit</code></li> <li><code>//Sources/UmbraMocks:UmbraMocks</code></li> </ol>"},{"location":"DEPENDENCIES/#dependency-graph","title":"Dependency Graph","text":""},{"location":"DEPENDENCIES/#key-dependencies","title":"Key Dependencies","text":"<ol> <li> <p>API Layer <pre><code>API\n\u2514\u2500\u2500 Core/UmbraCore\n</code></pre></p> </li> <li> <p>Security Stack <pre><code>UmbraSecurity\n\u251c\u2500\u2500 SecurityUtils\n\u2502   \u2514\u2500\u2500 Services/SecurityUtils/Services\n\u2514\u2500\u2500 CryptoTypes\n    \u251c\u2500\u2500 Protocols\n    \u251c\u2500\u2500 Services\n    \u2514\u2500\u2500 Types\n</code></pre></p> </li> <li> <p>Restic Integration <pre><code>ResticCLIHelper\n\u251c\u2500\u2500 Protocols\n\u2514\u2500\u2500 Types\n</code></pre></p> </li> <li> <p>Storage Stack <pre><code>UmbraBookmarkService\n\u251c\u2500\u2500 XPC/Core\n\u2514\u2500\u2500 SecurityUtils\n\nUmbraKeychainService\n\u2514\u2500\u2500 XPC/Core\n\nRepositories\n\u2514\u2500\u2500 Protocols\n\nSnapshots\n\u2514\u2500\u2500 Protocols\n</code></pre></p> </li> </ol>"},{"location":"DEPENDENCIES/#external-dependencies","title":"External Dependencies","text":"<ol> <li>Swift Package Manager Dependencies</li> <li><code>@swiftpkg_cryptoswift//:CryptoSwift</code></li> <li> <p><code>@swiftpkg_swiftybeaver//:SwiftyBeaver</code></p> </li> <li> <p>Build System</p> </li> <li><code>@build_bazel_rules_swift//swift:swift.bzl</code></li> <li><code>@bazel_gazelle//label:label.go</code></li> </ol>"},{"location":"DEPENDENCIES/#module-responsibilities","title":"Module Responsibilities","text":""},{"location":"DEPENDENCIES/#core-modules","title":"Core Modules","text":"<ol> <li>API (<code>//Sources/API</code>)</li> <li>Public interface for the UmbraCore framework</li> <li> <p>Entry point for external applications</p> </li> <li> <p>Core (<code>//Sources/Core</code>)</p> </li> <li>Core functionality and business logic</li> <li>Service coordination</li> <li> <p>Application state management</p> </li> <li> <p>Security (<code>//Sources/UmbraSecurity</code>, <code>//Sources/SecurityUtils</code>)</p> </li> <li>Encryption and decryption operations</li> <li>Key management</li> <li> <p>Security protocol implementations</p> </li> <li> <p>ResticCLIHelper (<code>//Sources/ResticCLIHelper</code>)</p> </li> <li>Restic command-line interface integration</li> <li>Backup and restore operations</li> <li>Repository management</li> </ol>"},{"location":"DEPENDENCIES/#support-modules","title":"Support Modules","text":"<ol> <li>Error Handling (<code>//Sources/ErrorHandling</code>)</li> <li>Error type definitions</li> <li>Error handling protocols</li> <li> <p>Error reporting and logging</p> </li> <li> <p>Features (<code>//Sources/Features</code>)</p> </li> <li>Feature-specific implementations</li> <li>Modular functionality</li> <li> <p>Feature configuration</p> </li> <li> <p>Testing (<code>//Sources/UmbraTestKit</code>, <code>//Sources/UmbraMocks</code>)</p> </li> <li>Test utilities</li> <li>Mock implementations</li> <li>Testing protocols</li> </ol>"},{"location":"DEPENDENCIES/#build-configuration","title":"Build Configuration","text":""},{"location":"DEPENDENCIES/#compiler-options","title":"Compiler Options","text":"<p>All Swift libraries are built with: <pre><code>copts = [\n    \"-target\",\n    \"arm64-apple-macos14.0\",\n    \"-strict-concurrency=complete\",\n    \"-warn-concurrency\",\n    \"-enable-actor-data-race-checks\",\n]\n</code></pre></p>"},{"location":"DEPENDENCIES/#visibility","title":"Visibility","text":"<p>Most modules have <code>visibility = [\"//visibility:public\"]</code> to allow for internal dependencies.</p>"},{"location":"DEPENDENCIES/#notes","title":"Notes","text":"<ol> <li>Concurrency Safety</li> <li>All modules are built with strict concurrency checking</li> <li>Actor data race checks are enabled</li> <li> <p>Concurrency warnings are treated as errors</p> </li> <li> <p>Module Independence</p> </li> <li>Each module has its own protocols package</li> <li>Clear separation between interfaces and implementations</li> <li> <p>Minimal cross-module dependencies</p> </li> <li> <p>Testing Support</p> </li> <li>Comprehensive mock implementations</li> <li>Dedicated test utilities</li> <li> <p>Protocol-based design for testability</p> </li> <li> <p>Security Considerations</p> </li> <li>XPC for secure inter-process communication</li> <li>Encrypted storage for sensitive data</li> <li>Secure bookmark management</li> </ol> <p>Last Updated: 2025-02-24</p>"},{"location":"LICENSE/","title":"MIT License","text":"<p>Copyright (c) 2025 MPY Development</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"PROJECT_STATUS/","title":"UmbraCore Project Status and Roadmap","text":""},{"location":"PROJECT_STATUS/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Current Status</li> <li>Style Guide Compliance Plan</li> <li>Functional Refactoring Plan</li> <li>Implementation Timeline</li> </ul>"},{"location":"PROJECT_STATUS/#current-status","title":"Current Status","text":""},{"location":"PROJECT_STATUS/#core-components","title":"Core Components","text":""},{"location":"PROJECT_STATUS/#1-resticclihelper-integration","title":"1. ResticCLIHelper Integration","text":"<ul> <li>Status: Partially Implemented</li> <li>Features:</li> <li>Core command support (backup, restore, init)</li> <li>Repository management commands</li> <li>Well-typed command results</li> <li>Needs Improvement:</li> <li>Error handling mechanisms</li> <li>Retry logic</li> <li>Progress reporting</li> <li>Cancellation support</li> </ul>"},{"location":"PROJECT_STATUS/#2-security-encryption","title":"2. Security &amp; Encryption","text":"<ul> <li>Status: Well Implemented</li> <li>Components:</li> <li><code>UmbraCrypto</code> for core cryptographic operations</li> <li><code>CryptoTypes</code> for type-safe crypto operations</li> <li><code>UmbraKeychainService</code> for secure storage</li> <li>XPC support for secure IPC</li> <li>Strengths:</li> <li>Strong encryption implementation</li> <li>Secure key management</li> <li>Protected data storage</li> </ul>"},{"location":"PROJECT_STATUS/#3-core-architecture","title":"3. Core Architecture","text":"<ul> <li>Status: Solid Foundation</li> <li>Features:</li> <li>Modular design</li> <li>Protocol-oriented architecture</li> <li>Comprehensive error handling</li> <li>Robust logging system</li> </ul>"},{"location":"PROJECT_STATUS/#areas-of-concern","title":"Areas of Concern","text":""},{"location":"PROJECT_STATUS/#1-integration-points","title":"1. Integration Points","text":"<ul> <li>Rbum Integration</li> <li>Current Status: Incomplete</li> <li>Missing core functionality</li> <li> <p>Integration points undefined</p> </li> <li> <p>Rbx Support</p> </li> <li>Current Status: Missing</li> <li>Implementation needed</li> <li> <p>Requirements to be defined</p> </li> <li> <p>ResticBar Integration</p> </li> <li>Current Status: Partial</li> <li>Needs better documentation</li> <li>Error handling improvements required</li> </ul>"},{"location":"PROJECT_STATUS/#2-code-quality-issues","title":"2. Code Quality Issues","text":"<ul> <li>Inconsistent concurrency patterns</li> <li>Documentation gaps</li> <li>Test coverage needs improvement</li> <li>Some tight coupling between components</li> </ul>"},{"location":"PROJECT_STATUS/#style-guide-compliance-plan","title":"Style Guide Compliance Plan","text":""},{"location":"PROJECT_STATUS/#phase-1-documentation-naming-2-weeks","title":"Phase 1: Documentation &amp; Naming (2 weeks)","text":"<ul> <li>Documentation Updates</li> <li>Add proper documentation for all public APIs</li> <li>Include usage examples</li> <li>Document error conditions</li> <li> <p>Add inline comments for complex logic</p> </li> <li> <p>Naming Standardization</p> </li> <li>Function names: Use verb phrases</li> <li>Consistent acronym capitalization</li> <li>Clear, self-documenting names</li> <li>Follow Swift API guidelines</li> </ul>"},{"location":"PROJECT_STATUS/#phase-2-code-structure-2-weeks","title":"Phase 2: Code Structure (2 weeks)","text":"<ul> <li>Formatting</li> <li>Implement 2-space indentation</li> <li>Standardize brace placement</li> <li> <p>Fix line wrapping issues</p> </li> <li> <p>File Organization</p> </li> <li>Properties</li> <li>Initializers</li> <li>Methods</li> <li>Protocol conformances in extensions</li> </ul>"},{"location":"PROJECT_STATUS/#phase-3-language-features-2-weeks","title":"Phase 3: Language Features (2 weeks)","text":"<ul> <li>Swift Best Practices</li> <li>Audit access control</li> <li>Convert <code>var</code> to <code>let</code> where possible</li> <li>Implement type inference</li> <li>Add early returns</li> <li>Use proper optionals handling</li> </ul>"},{"location":"PROJECT_STATUS/#functional-refactoring-plan","title":"Functional Refactoring Plan","text":""},{"location":"PROJECT_STATUS/#a-architecture-improvements","title":"A. Architecture Improvements","text":""},{"location":"PROJECT_STATUS/#1-service-layer-abstraction","title":"1. Service Layer Abstraction","text":"<pre><code>public protocol UmbraService {\n    var serviceIdentifier: String { get }\n    func initialize() async throws\n    func shutdown() async\n}\n</code></pre>"},{"location":"PROJECT_STATUS/#2-dependency-injection","title":"2. Dependency Injection","text":"<pre><code>public final class ServiceContainer {\n    private var services: [String: any UmbraService]\n\n    public func register&lt;T: UmbraService&gt;(_ service: T)\n    public func resolve&lt;T: UmbraService&gt;(_ type: T.Type) -&gt; T?\n}\n</code></pre>"},{"location":"PROJECT_STATUS/#3-module-boundaries","title":"3. Module Boundaries","text":"<ul> <li>Split large modules</li> <li>Define clear interfaces</li> <li>Implement proper dependency management</li> </ul>"},{"location":"PROJECT_STATUS/#b-specific-improvements","title":"B. Specific Improvements","text":""},{"location":"PROJECT_STATUS/#1-resticclihelper-enhancement","title":"1. ResticCLIHelper Enhancement","text":"<ul> <li>Add retry mechanisms</li> <li>Implement cancellation</li> <li>Add progress reporting</li> <li>Improve error handling</li> </ul>"},{"location":"PROJECT_STATUS/#2-security-layer","title":"2. Security Layer","text":"<ul> <li>Centralize encryption</li> <li>Improve key management</li> <li>Add audit logging</li> <li>Enhance error reporting</li> </ul>"},{"location":"PROJECT_STATUS/#3-performance-optimization","title":"3. Performance Optimization","text":"<ul> <li>Implement caching</li> <li>Add async/await support</li> <li>Optimize resource usage</li> <li>Add performance metrics</li> </ul>"},{"location":"PROJECT_STATUS/#c-testing-infrastructure","title":"C. Testing Infrastructure","text":""},{"location":"PROJECT_STATUS/#1-test-coverage","title":"1. Test Coverage","text":"<ul> <li>Unit tests for public APIs</li> <li>Integration tests</li> <li>Performance tests</li> <li>Mock objects improvement</li> </ul>"},{"location":"PROJECT_STATUS/#2-cicd-improvements","title":"2. CI/CD Improvements","text":"<ul> <li>Style checking automation</li> <li>Performance regression tests</li> <li>Security scanning</li> <li>Build process optimization</li> </ul>"},{"location":"PROJECT_STATUS/#implementation-timeline","title":"Implementation Timeline","text":""},{"location":"PROJECT_STATUS/#high-priority-1-2-months","title":"High Priority (1-2 months)","text":"<ul> <li>[ ] Service layer abstraction</li> <li>[ ] Security improvements</li> <li>[ ] Critical bug fixes</li> <li>[ ] Basic test coverage</li> </ul>"},{"location":"PROJECT_STATUS/#medium-priority-2-3-months","title":"Medium Priority (2-3 months)","text":"<ul> <li>[ ] Dependency injection</li> <li>[ ] Module boundary cleanup</li> <li>[ ] Performance optimization</li> <li>[ ] Integration tests</li> </ul>"},{"location":"PROJECT_STATUS/#lower-priority-3-4-months","title":"Lower Priority (3-4 months)","text":"<ul> <li>[ ] Additional test coverage</li> <li>[ ] Documentation improvements</li> <li>[ ] Nice-to-have features</li> <li>[ ] Performance tuning</li> </ul>"},{"location":"PROJECT_STATUS/#contributing","title":"Contributing","text":"<p>When contributing to this project:</p> <ol> <li>Follow the Google Swift Style Guide</li> <li>Ensure all new code has tests</li> <li>Update documentation</li> <li>Add inline comments for complex logic</li> <li>Follow the existing architectural patterns</li> </ol>"},{"location":"PROJECT_STATUS/#notes","title":"Notes","text":"<ul> <li>British English should be used in comments and documentation</li> <li>American English is acceptable in code</li> <li>All new features must include proper error handling</li> <li>Security-related changes require review</li> <li>Performance-critical code must include benchmarks</li> </ul> <p>Last Updated: 2025-02-24</p>"},{"location":"REFACTORING_PLAN/","title":"UmbraCore Refactoring Plan","text":""},{"location":"REFACTORING_PLAN/#overview","title":"Overview","text":"<p>This document outlines our approach to refactoring UmbraCore, using the Security and Crypto modules as templates. The plan combines functional improvements with progressive style guide compliance.</p>"},{"location":"REFACTORING_PLAN/#phase-1-service-architecture-4-weeks","title":"Phase 1: Service Architecture (4 weeks)","text":""},{"location":"REFACTORING_PLAN/#week-1-2-core-service-infrastructure","title":"Week 1-2: Core Service Infrastructure","text":""},{"location":"REFACTORING_PLAN/#1-service-protocol-definition","title":"1. Service Protocol Definition","text":"<pre><code>/// Protocol defining the base requirements for all UmbraCore services\npublic protocol UmbraService: Actor {\n    /// Unique identifier for the service type\n    static var serviceIdentifier: String { get }\n\n    /// Current state of the service\n    var state: ServiceState { get }\n\n    /// Initialize the service\n    /// - Throws: ServiceError if initialization fails\n    func initialize() async throws\n\n    /// Gracefully shut down the service\n    func shutdown() async\n}\n\n/// Represents the current state of a service\npublic enum ServiceState: String {\n    case uninitialized\n    case initializing\n    case ready\n    case error\n    case shuttingDown\n    case shutdown\n}\n</code></pre>"},{"location":"REFACTORING_PLAN/#2-service-container-implementation","title":"2. Service Container Implementation","text":"<pre><code>/// Thread-safe container for managing service instances\npublic actor ServiceContainer {\n    /// Registered services\n    private var services: [String: any UmbraService]\n\n    /// Service initialization queue\n    private let initializationQueue: TaskGroup\n\n    /// Register a service with the container\n    /// - Parameter service: The service to register\n    /// - Throws: ServiceError if registration fails\n    public func register&lt;T: UmbraService&gt;(_ service: T) async throws\n\n    /// Resolve a service of the specified type\n    /// - Returns: The requested service instance\n    /// - Throws: ServiceError if service not found\n    public func resolve&lt;T: UmbraService&gt;(_ type: T.Type) async throws -&gt; T\n}\n</code></pre>"},{"location":"REFACTORING_PLAN/#week-3-4-security-service-refactoring","title":"Week 3-4: Security Service Refactoring","text":""},{"location":"REFACTORING_PLAN/#1-crypto-service-implementation","title":"1. Crypto Service Implementation","text":"<pre><code>/// Handles cryptographic operations\npublic actor CryptoService: UmbraService {\n    public static let serviceIdentifier = \"com.umbracore.crypto\"\n    public private(set) var state: ServiceState\n\n    private let keyManager: KeyManager\n    private let config: CryptoConfig\n\n    /// Initialize with the specified configuration\n    /// - Parameter config: Cryptographic configuration\n    public init(config: CryptoConfig) async throws\n\n    /// Encrypt data using the specified key\n    /// - Parameters:\n    ///   - data: Data to encrypt\n    ///   - key: Encryption key\n    /// - Returns: Encrypted data\n    /// - Throws: CryptoError on failure\n    public func encrypt(_ data: Data, using key: SymmetricKey) async throws -&gt; EncryptedData\n}\n</code></pre>"},{"location":"REFACTORING_PLAN/#2-security-service-implementation","title":"2. Security Service Implementation","text":"<pre><code>/// Manages security operations and access control\npublic actor SecurityService: UmbraService {\n    public static let serviceIdentifier = \"com.umbracore.security\"\n    public private(set) var state: ServiceState\n\n    private let cryptoService: CryptoService\n    private let accessController: AccessController\n\n    /// Initialize security service\n    /// - Parameter container: Service container for dependencies\n    public init(container: ServiceContainer) async throws\n\n    /// Secure a resource with the specified protection level\n    /// - Parameters:\n    ///   - resource: Resource to protect\n    ///   - level: Protection level\n    /// - Returns: Protected resource handle\n    /// - Throws: SecurityError on failure\n    public func secure&lt;T&gt;(_ resource: T, level: ProtectionLevel) async throws -&gt; SecureHandle&lt;T&gt;\n}\n</code></pre>"},{"location":"REFACTORING_PLAN/#phase-2-resource-management-4-weeks","title":"Phase 2: Resource Management (4 weeks)","text":""},{"location":"REFACTORING_PLAN/#week-1-2-resource-handling","title":"Week 1-2: Resource Handling","text":""},{"location":"REFACTORING_PLAN/#1-resource-protocol","title":"1. Resource Protocol","text":"<pre><code>/// Protocol for managed resources\npublic protocol ManagedResource: Actor {\n    /// Resource type identifier\n    static var resourceType: String { get }\n\n    /// Current state of the resource\n    var state: ResourceState { get }\n\n    /// Acquire the resource\n    func acquire() async throws\n\n    /// Release the resource\n    func release() async\n\n    /// Clean up any allocated resources\n    func cleanup() async\n}\n</code></pre>"},{"location":"REFACTORING_PLAN/#2-resource-pool-implementation","title":"2. Resource Pool Implementation","text":"<pre><code>/// Manages a pool of reusable resources\npublic actor ResourcePool&lt;T: ManagedResource&gt; {\n    /// Available resources\n    private var available: [T]\n\n    /// Resources currently in use\n    private var inUse: [T]\n\n    /// Resource creation factory\n    private let factory: () async throws -&gt; T\n\n    /// Acquire a resource from the pool\n    /// - Returns: An available resource\n    /// - Throws: ResourceError if no resources available\n    public func acquire() async throws -&gt; T\n\n    /// Release a resource back to the pool\n    /// - Parameter resource: Resource to release\n    public func release(_ resource: T) async\n}\n</code></pre>"},{"location":"REFACTORING_PLAN/#week-3-4-security-resource-implementation","title":"Week 3-4: Security Resource Implementation","text":""},{"location":"REFACTORING_PLAN/#1-secure-storage-resource","title":"1. Secure Storage Resource","text":"<pre><code>/// Manages secure storage operations\npublic actor SecureStorageResource: ManagedResource {\n    public static let resourceType = \"com.umbracore.secure-storage\"\n    public private(set) var state: ResourceState\n\n    private let storage: SecureStorage\n    private let cryptoService: CryptoService\n\n    /// Store data securely\n    /// - Parameters:\n    ///   - data: Data to store\n    ///   - key: Storage key\n    /// - Throws: StorageError on failure\n    public func store(_ data: Data, forKey key: String) async throws\n}\n</code></pre>"},{"location":"REFACTORING_PLAN/#2-keychain-resource","title":"2. Keychain Resource","text":"<pre><code>/// Manages keychain operations\npublic actor KeychainResource: ManagedResource {\n    public static let resourceType = \"com.umbracore.keychain\"\n    public private(set) var state: ResourceState\n\n    private let accessGroup: String\n    private let accessibility: KeychainAccessibility\n\n    /// Store an item in the keychain\n    /// - Parameters:\n    ///   - item: Item to store\n    ///   - identifier: Item identifier\n    /// - Throws: KeychainError on failure\n    public func store(_ item: KeychainItem, identifier: String) async throws\n}\n</code></pre>"},{"location":"REFACTORING_PLAN/#phase-3-error-handling-4-weeks","title":"Phase 3: Error Handling (4 weeks)","text":""},{"location":"REFACTORING_PLAN/#week-1-2-error-infrastructure","title":"Week 1-2: Error Infrastructure","text":""},{"location":"REFACTORING_PLAN/#1-error-context","title":"1. Error Context","text":"<pre><code>/// Provides context for error handling\npublic struct ErrorContext {\n    /// Source file where error occurred\n    public let file: String\n\n    /// Function where error occurred\n    public let function: String\n\n    /// Line number where error occurred\n    public let line: Int\n\n    /// Time when error occurred\n    public let timestamp: Date\n\n    /// Additional context information\n    public var userInfo: [String: Any]\n}\n</code></pre>"},{"location":"REFACTORING_PLAN/#2-error-protocol","title":"2. Error Protocol","text":"<pre><code>/// Protocol for contextual errors\npublic protocol ContextualError: Error {\n    /// Error context\n    var context: ErrorContext { get }\n\n    /// Available recovery options\n    var recoveryOptions: [RecoveryOption] { get }\n\n    /// Attempt to recover from the error\n    /// - Parameter option: Recovery option to attempt\n    /// - Returns: Whether recovery was successful\n    func attemptRecovery(_ option: RecoveryOption) async -&gt; Bool\n}\n</code></pre>"},{"location":"REFACTORING_PLAN/#week-3-4-security-error-implementation","title":"Week 3-4: Security Error Implementation","text":""},{"location":"REFACTORING_PLAN/#1-crypto-errors","title":"1. Crypto Errors","text":"<pre><code>/// Represents cryptographic operation errors\npublic enum CryptoError: ContextualError {\n    case invalidKey(reason: String)\n    case encryptionFailed(reason: String)\n    case decryptionFailed(reason: String)\n    case invalidData(reason: String)\n\n    public var context: ErrorContext\n    public var recoveryOptions: [RecoveryOption]\n\n    public func attemptRecovery(_ option: RecoveryOption) async -&gt; Bool\n}\n</code></pre>"},{"location":"REFACTORING_PLAN/#2-security-errors","title":"2. Security Errors","text":"<pre><code>/// Represents security operation errors\npublic enum SecurityError: ContextualError {\n    case accessDenied(resource: String)\n    case invalidCredentials(reason: String)\n    case resourceUnavailable(identifier: String)\n    case secureStorageFailed(reason: String)\n\n    public var context: ErrorContext\n    public var recoveryOptions: [RecoveryOption]\n\n    public func attemptRecovery(_ option: RecoveryOption) async -&gt; Bool\n}\n</code></pre>"},{"location":"REFACTORING_PLAN/#style-guide-compliance","title":"Style Guide Compliance","text":""},{"location":"REFACTORING_PLAN/#documentation-standards","title":"Documentation Standards","text":"<ul> <li>Use /// for documentation comments</li> <li>Document all public APIs</li> <li>Include parameter descriptions</li> <li>Document error conditions</li> <li>Add usage examples</li> </ul>"},{"location":"REFACTORING_PLAN/#code-organization","title":"Code Organization","text":"<ul> <li>Properties first</li> <li>Then initializers</li> <li>Then methods</li> <li>Protocol conformance in extensions</li> </ul>"},{"location":"REFACTORING_PLAN/#naming-conventions","title":"Naming Conventions","text":"<ul> <li>Use verb phrases for functions</li> <li>Clear, self-documenting names</li> <li>Consistent capitalization</li> <li>Follow Swift API guidelines</li> </ul>"},{"location":"REFACTORING_PLAN/#swift-best-practices","title":"Swift Best Practices","text":"<ul> <li>Use let over var</li> <li>Early returns with guard</li> <li>Proper access control</li> <li>Type inference where clear</li> </ul>"},{"location":"REFACTORING_PLAN/#implementation-strategy","title":"Implementation Strategy","text":""},{"location":"REFACTORING_PLAN/#1-service-layer-weeks-1-4","title":"1. Service Layer (Weeks 1-4)","text":"<ul> <li>[ ] Define base protocols</li> <li>[ ] Implement service container</li> <li>[ ] Refactor crypto service</li> <li>[ ] Refactor security service</li> </ul>"},{"location":"REFACTORING_PLAN/#2-resource-management-weeks-5-8","title":"2. Resource Management (Weeks 5-8)","text":"<ul> <li>[ ] Define resource protocols</li> <li>[ ] Implement resource pool</li> <li>[ ] Refactor secure storage</li> <li>[ ] Refactor keychain access</li> </ul>"},{"location":"REFACTORING_PLAN/#3-error-handling-weeks-9-12","title":"3. Error Handling (Weeks 9-12)","text":"<ul> <li>[ ] Define error protocols</li> <li>[ ] Implement error context</li> <li>[ ] Refactor crypto errors</li> <li>[ ] Refactor security errors</li> </ul>"},{"location":"REFACTORING_PLAN/#testing-strategy","title":"Testing Strategy","text":""},{"location":"REFACTORING_PLAN/#1-unit-tests","title":"1. Unit Tests","text":"<ul> <li>Test each component in isolation</li> <li>Mock dependencies</li> <li>Test error conditions</li> <li>Verify resource cleanup</li> </ul>"},{"location":"REFACTORING_PLAN/#2-integration-tests","title":"2. Integration Tests","text":"<ul> <li>Test service interactions</li> <li>Verify resource management</li> <li>Test error recovery</li> <li>Check memory handling</li> </ul>"},{"location":"REFACTORING_PLAN/#3-performance-tests","title":"3. Performance Tests","text":"<ul> <li>Measure operation timing</li> <li>Check resource usage</li> <li>Test under load</li> <li>Verify cleanup efficiency</li> </ul>"},{"location":"REFACTORING_PLAN/#success-metrics","title":"Success Metrics","text":""},{"location":"REFACTORING_PLAN/#1-code-quality","title":"1. Code Quality","text":"<ul> <li>Reduced coupling</li> <li>Improved cohesion</li> <li>Better error handling</li> <li>Cleaner interfaces</li> </ul>"},{"location":"REFACTORING_PLAN/#2-performance","title":"2. Performance","text":"<ul> <li>Faster operations</li> <li>Lower memory usage</li> <li>Better resource utilization</li> <li>Quicker error recovery</li> </ul>"},{"location":"REFACTORING_PLAN/#3-maintainability","title":"3. Maintainability","text":"<ul> <li>Easier to test</li> <li>Simpler to debug</li> <li>Clearer documentation</li> <li>More consistent style</li> </ul> <p>Last Updated: 2025-02-24</p>"},{"location":"SECURITY_ARCHITECTURE/","title":"UmbraCore Security Architecture","text":""},{"location":"SECURITY_ARCHITECTURE/#overview","title":"Overview","text":"<p>The UmbraCore security architecture is built on multiple layers to provide secure data handling, encryption, and access control. This document details the security components and their interactions.</p>"},{"location":"SECURITY_ARCHITECTURE/#component-architecture","title":"Component Architecture","text":""},{"location":"SECURITY_ARCHITECTURE/#1-cryptographic-stack","title":"1. Cryptographic Stack","text":""},{"location":"SECURITY_ARCHITECTURE/#cryptotypes-module","title":"CryptoTypes Module","text":"<ul> <li>Purpose: Core cryptographic type definitions and protocols</li> <li>Location: <code>//Sources/CryptoTypes</code></li> <li>Key Components:   <pre><code>CryptoTypes\n\u251c\u2500\u2500 Protocols\n\u2502   \u2514\u2500\u2500 CryptoService.swift\n\u251c\u2500\u2500 Services\n\u2502   \u2514\u2500\u2500 DefaultCryptoService.swift\n\u2514\u2500\u2500 Types\n    \u251c\u2500\u2500 CryptoConfig.swift\n    \u251c\u2500\u2500 CryptoConfiguration.swift\n    \u2514\u2500\u2500 CredentialManager.swift\n</code></pre></li> <li>External Dependencies:</li> <li><code>CryptoSwift</code> for cryptographic operations</li> </ul>"},{"location":"SECURITY_ARCHITECTURE/#umbracrypto-module","title":"UmbraCrypto Module","text":"<ul> <li>Purpose: Implementation of cryptographic operations</li> <li>Location: <code>//Sources/UmbraCrypto</code></li> <li>Dependencies:</li> <li><code>CryptoTypes</code></li> <li><code>CryptoSwift</code></li> <li>Testing Status: Test-only module</li> </ul>"},{"location":"SECURITY_ARCHITECTURE/#2-security-services","title":"2. Security Services","text":""},{"location":"SECURITY_ARCHITECTURE/#umbracryptoservice","title":"UmbraCryptoService","text":"<ul> <li>Purpose: XPC-based secure crypto service</li> <li>Location: <code>//Sources/UmbraCryptoService</code></li> <li>Key Components:   <pre><code>UmbraCryptoService\n\u251c\u2500\u2500 CryptoServiceListener.swift\n\u251c\u2500\u2500 CryptoXPCService.swift\n\u2514\u2500\u2500 UmbraCryptoService.swift\n</code></pre></li> <li>Entitlements:</li> <li>App sandbox enabled</li> <li>Keychain access groups</li> <li>Application group access</li> <li>Network client capabilities</li> </ul>"},{"location":"SECURITY_ARCHITECTURE/#umbrasecurity","title":"UmbraSecurity","text":"<ul> <li>Purpose: High-level security interface</li> <li>Location: <code>//Sources/UmbraSecurity</code></li> <li>Components:</li> <li>Security service implementation</li> <li>Security-scoped bookmark handling</li> <li>URL security extensions</li> </ul>"},{"location":"SECURITY_ARCHITECTURE/#3-security-utils","title":"3. Security Utils","text":""},{"location":"SECURITY_ARCHITECTURE/#securityutils-module","title":"SecurityUtils Module","text":"<ul> <li>Purpose: Common security utilities</li> <li>Location: <code>//Sources/SecurityUtils</code></li> <li>Features:</li> <li>Encrypted bookmark service</li> <li>Security bookmark service</li> <li>Security protocols</li> </ul>"},{"location":"SECURITY_ARCHITECTURE/#security-features","title":"Security Features","text":""},{"location":"SECURITY_ARCHITECTURE/#1-encryption","title":"1. Encryption","text":"<ul> <li>AES-256 encryption (via CryptoSwift)</li> <li>Secure key generation and management</li> <li>IV (Initialization Vector) handling</li> <li>Secure memory handling</li> </ul>"},{"location":"SECURITY_ARCHITECTURE/#2-access-control","title":"2. Access Control","text":"<ul> <li>Security-scoped bookmarks</li> <li>Keychain integration</li> <li>Sandboxed operations</li> <li>XPC service isolation</li> </ul>"},{"location":"SECURITY_ARCHITECTURE/#3-credential-management","title":"3. Credential Management","text":"<pre><code>public struct CredentialManager {\n    public let keyLength: Int\n    public let ivLength: Int\n\n    // Secure credential storage\n    private let secureStorage: SecureStorageProvider\n\n    // Credential lifecycle management\n    public func store(_ credentials: Credentials) async throws\n    public func retrieve() async throws -&gt; Credentials\n    public func clear() async throws\n}\n</code></pre>"},{"location":"SECURITY_ARCHITECTURE/#external-dependencies","title":"External Dependencies","text":""},{"location":"SECURITY_ARCHITECTURE/#1-cryptoswift","title":"1. CryptoSwift","text":"<ul> <li>Version: Latest stable</li> <li>Usage: Core cryptographic operations</li> <li>Features Used:</li> <li>AES encryption</li> <li>Key generation</li> <li>Secure random number generation</li> <li>Hash functions</li> </ul>"},{"location":"SECURITY_ARCHITECTURE/#2-apple-security-framework","title":"2. Apple Security Framework","text":"<ul> <li>Features Used:</li> <li>Keychain Services</li> <li>Security-scoped bookmarks</li> <li>Certificate handling</li> <li>Secure enclave operations</li> </ul>"},{"location":"SECURITY_ARCHITECTURE/#security-protocols","title":"Security Protocols","text":""},{"location":"SECURITY_ARCHITECTURE/#1-cryptoservice-protocol","title":"1. CryptoService Protocol","text":"<pre><code>public protocol CryptoService {\n    func encrypt(_ data: Data, using key: SymmetricKey) async throws -&gt; EncryptedData\n    func decrypt(_ data: EncryptedData, using key: SymmetricKey) async throws -&gt; Data\n    func generateKey(length: Int) async throws -&gt; SymmetricKey\n    func generateIV(length: Int) async throws -&gt; Data\n}\n</code></pre>"},{"location":"SECURITY_ARCHITECTURE/#2-securestorageprovider-protocol","title":"2. SecureStorageProvider Protocol","text":"<pre><code>public protocol SecureStorageProvider {\n    func store(_ data: Data, for identifier: String) async throws\n    func retrieve(for identifier: String) async throws -&gt; Data\n    func remove(for identifier: String) async throws\n}\n</code></pre>"},{"location":"SECURITY_ARCHITECTURE/#security-configuration","title":"Security Configuration","text":""},{"location":"SECURITY_ARCHITECTURE/#1-default-configuration","title":"1. Default Configuration","text":"<pre><code>public struct CryptoConfig {\n    public static let `default` = CryptoConfig(\n        keyLength: 256,  // AES-256\n        ivLength: 16     // 128 bits\n    )\n}\n</code></pre>"},{"location":"SECURITY_ARCHITECTURE/#2-xpc-service-configuration","title":"2. XPC Service Configuration","text":"<ul> <li>Sandboxed environment</li> <li>Limited file system access</li> <li>Specific keychain access groups</li> <li>Application group sharing</li> </ul>"},{"location":"SECURITY_ARCHITECTURE/#known-issues-and-mitigations","title":"Known Issues and Mitigations","text":""},{"location":"SECURITY_ARCHITECTURE/#1-memory-management","title":"1. Memory Management","text":"<ul> <li>Issue: Sensitive data in memory</li> <li>Mitigation: Secure memory wiping after use</li> </ul>"},{"location":"SECURITY_ARCHITECTURE/#2-key-storage","title":"2. Key Storage","text":"<ul> <li>Issue: Secure key storage</li> <li>Mitigation: Keychain with access control</li> </ul>"},{"location":"SECURITY_ARCHITECTURE/#3-ipc-security","title":"3. IPC Security","text":"<ul> <li>Issue: Inter-process communication security</li> <li>Mitigation: XPC with entitlement checking</li> </ul>"},{"location":"SECURITY_ARCHITECTURE/#testing","title":"Testing","text":""},{"location":"SECURITY_ARCHITECTURE/#1-security-testing","title":"1. Security Testing","text":"<ul> <li>Unit tests for all crypto operations</li> <li>Integration tests for service communication</li> <li>Fuzzing tests for input validation</li> <li>Memory leak detection</li> </ul>"},{"location":"SECURITY_ARCHITECTURE/#2-mock-implementations","title":"2. Mock Implementations","text":"<pre><code>public final class MockCryptoService: CryptoService {\n    public var encryptionBehavior: EncryptionBehavior\n    public var decryptionBehavior: DecryptionBehavior\n    // Implementation for testing\n}\n</code></pre>"},{"location":"SECURITY_ARCHITECTURE/#future-improvements","title":"Future Improvements","text":"<ol> <li>Hardware Security</li> <li>Secure Enclave integration</li> <li>Touch ID/Apple Watch authentication</li> <li> <p>Smart card support</p> </li> <li> <p>Key Management</p> </li> <li>Key rotation policies</li> <li>Multi-factor key derivation</li> <li> <p>Quantum-resistant algorithms</p> </li> <li> <p>Audit Logging</p> </li> <li>Comprehensive security event logging</li> <li>Real-time alerts</li> <li>Compliance reporting</li> </ol>"},{"location":"SECURITY_ARCHITECTURE/#security-guidelines","title":"Security Guidelines","text":"<ol> <li>Development</li> <li>Always use secure random number generation</li> <li>Implement proper error handling</li> <li> <p>Clear sensitive data from memory</p> </li> <li> <p>Testing</p> </li> <li>Test with different key sizes</li> <li>Validate all error paths</li> <li> <p>Check memory handling</p> </li> <li> <p>Deployment</p> </li> <li>Review entitlements</li> <li>Validate sandbox configuration</li> <li>Check keychain access groups</li> </ol> <p>Last Updated: 2025-02-24</p>"},{"location":"crypto-strategy/","title":"UmbraCore Cryptographic Strategy","text":""},{"location":"crypto-strategy/#overview","title":"Overview","text":"<p>UmbraCore implements a sophisticated dual-library cryptographic strategy to support both native macOS security features and cross-process operations. This document outlines the technical details of this implementation.</p>"},{"location":"crypto-strategy/#architecture","title":"Architecture","text":""},{"location":"crypto-strategy/#dual-library-implementation","title":"Dual-Library Implementation","text":""},{"location":"crypto-strategy/#1-cryptokit-apples-framework","title":"1. CryptoKit (Apple's Framework)","text":"<ul> <li>Primary Use: ResticBar and native macOS operations</li> <li>Key Features:</li> <li>Hardware-backed security through Secure Enclave</li> <li>Native integration with macOS security features</li> <li>Optimised for sandboxed environments</li> <li>Secure key storage with Keychain integration</li> </ul>"},{"location":"crypto-strategy/#2-cryptoswift-third-party-library","title":"2. CryptoSwift (Third-party Library)","text":"<ul> <li>Primary Use: Rbum and Rbx cross-process operations</li> <li>Key Features:</li> <li>Platform-independent implementation</li> <li>XPC service compatibility</li> <li>Flexible deployment options</li> <li>Cross-process encryption support</li> </ul>"},{"location":"crypto-strategy/#keymanager","title":"KeyManager","text":"<p>The KeyManager serves as the orchestration layer between these implementations:</p>"},{"location":"crypto-strategy/#core-responsibilities","title":"Core Responsibilities","text":"<ol> <li>Implementation Selection</li> <li>Context-aware routing between CryptoKit and CryptoSwift</li> <li>Security boundary enforcement</li> <li> <p>Operation validation</p> </li> <li> <p>Key Lifecycle Management</p> </li> <li>Key generation and storage</li> <li>Rotation policies and execution</li> <li>Validation and verification</li> <li> <p>Cross-process synchronisation</p> </li> <li> <p>Security Context Management</p> </li> <li>Sandbox compliance</li> <li>XPC service coordination</li> <li>Permission management</li> <li>Resource access control</li> </ol>"},{"location":"crypto-strategy/#implementation-details","title":"Implementation Details","text":"<pre><code>actor KeyManager {\n    // Context-aware implementation selection\n    func selectImplementation(for operation: CryptoOperation) -&gt; CryptoImplementation\n\n    // Key lifecycle operations\n    func generateKey(for context: SecurityContext) async throws -&gt; Key\n    func rotateKey(id: KeyIdentifier) async throws\n    func validateKey(id: KeyIdentifier) async throws -&gt; ValidationResult\n\n    // Cross-process coordination\n    func synchroniseKeys() async throws\n    func validateSecurityBoundaries() async throws\n}\n</code></pre>"},{"location":"crypto-strategy/#security-considerations","title":"Security Considerations","text":""},{"location":"crypto-strategy/#1-sandbox-compliance","title":"1. Sandbox Compliance","text":"<ul> <li>Proper security-scoped bookmark usage</li> <li>Explicit permission management</li> <li>Resource access tracking</li> <li>Clean-up and resource release</li> </ul>"},{"location":"crypto-strategy/#2-cross-process-security","title":"2. Cross-Process Security","text":"<ul> <li>XPC service isolation</li> <li>Secure message passing</li> <li>State synchronisation</li> <li>Error handling and recovery</li> </ul>"},{"location":"crypto-strategy/#3-key-management","title":"3. Key Management","text":"<ul> <li>Secure storage strategies</li> <li>Rotation policies</li> <li>Access control</li> <li>Audit logging</li> </ul>"},{"location":"crypto-strategy/#implementation-strategy","title":"Implementation Strategy","text":""},{"location":"crypto-strategy/#phase-1-foundation","title":"Phase 1: Foundation","text":"<ol> <li>Core KeyManager implementation</li> <li>Basic routing logic</li> <li>Key lifecycle management</li> <li>Error handling framework</li> </ol>"},{"location":"crypto-strategy/#phase-2-security-integration","title":"Phase 2: Security Integration","text":"<ol> <li>CryptoKit integration</li> <li>Sandbox compliance</li> <li>Keychain integration</li> <li>Security boundary enforcement</li> </ol>"},{"location":"crypto-strategy/#phase-3-cross-process-support","title":"Phase 3: Cross-Process Support","text":"<ol> <li>CryptoSwift integration</li> <li>XPC service implementation</li> <li>Cross-process synchronisation</li> <li>Error recovery</li> </ol>"},{"location":"crypto-strategy/#phase-4-advanced-features","title":"Phase 4: Advanced Features","text":"<ol> <li>Key rotation policies</li> <li>Audit logging</li> <li>Performance optimisation</li> <li>Advanced security features</li> </ol>"},{"location":"crypto-strategy/#testing-strategy","title":"Testing Strategy","text":""},{"location":"crypto-strategy/#unit-tests","title":"Unit Tests","text":"<ol> <li>Implementation routing</li> <li>Key lifecycle operations</li> <li>Error conditions</li> <li>Security boundaries</li> </ol>"},{"location":"crypto-strategy/#integration-tests","title":"Integration Tests","text":"<ol> <li>Cross-process operations</li> <li>Sandbox compliance</li> <li>Security features</li> <li>Performance metrics</li> </ol>"},{"location":"crypto-strategy/#security-tests","title":"Security Tests","text":"<ol> <li>Boundary violations</li> <li>Error handling</li> <li>Resource cleanup</li> <li>State consistency</li> </ol>"},{"location":"crypto-strategy/#performance-considerations","title":"Performance Considerations","text":""},{"location":"crypto-strategy/#1-operation-routing","title":"1. Operation Routing","text":"<ul> <li>Minimal overhead for implementation selection</li> <li>Efficient context switching</li> <li>Optimised security checks</li> </ul>"},{"location":"crypto-strategy/#2-key-management","title":"2. Key Management","text":"<ul> <li>Efficient key storage</li> <li>Quick key rotation</li> <li>Fast validation</li> </ul>"},{"location":"crypto-strategy/#3-cross-process-operations","title":"3. Cross-Process Operations","text":"<ul> <li>Minimal latency</li> <li>Efficient synchronisation</li> <li>Resource usage optimisation</li> </ul>"},{"location":"crypto-strategy/#error-handling","title":"Error Handling","text":""},{"location":"crypto-strategy/#1-error-categories","title":"1. Error Categories","text":"<ul> <li>Implementation selection errors</li> <li>Key lifecycle errors</li> <li>Security boundary violations</li> <li>Cross-process errors</li> </ul>"},{"location":"crypto-strategy/#2-recovery-strategies","title":"2. Recovery Strategies","text":"<ul> <li>Automatic retry policies</li> <li>Fallback implementations</li> <li>State recovery</li> <li>Resource cleanup</li> </ul>"},{"location":"crypto-strategy/#documentation-requirements","title":"Documentation Requirements","text":""},{"location":"crypto-strategy/#1-api-documentation","title":"1. API Documentation","text":"<ul> <li>Clear interface descriptions</li> <li>Usage examples</li> <li>Security considerations</li> <li>Best practices</li> </ul>"},{"location":"crypto-strategy/#2-security-documentation","title":"2. Security Documentation","text":"<ul> <li>Security model overview</li> <li>Threat model</li> <li>Mitigation strategies</li> <li>Audit requirements</li> </ul>"},{"location":"crypto-strategy/#success-criteria","title":"Success Criteria","text":""},{"location":"crypto-strategy/#1-functionality","title":"1. Functionality","text":"<ul> <li>Successful implementation routing</li> <li>Proper key lifecycle management</li> <li>Effective cross-process operations</li> <li>Reliable error handling</li> </ul>"},{"location":"crypto-strategy/#2-security","title":"2. Security","text":"<ul> <li>Sandbox compliance</li> <li>Secure key management</li> <li>Proper boundary enforcement</li> <li>Audit trail availability</li> </ul>"},{"location":"crypto-strategy/#3-performance","title":"3. Performance","text":"<ul> <li>Minimal routing overhead</li> <li>Fast key operations</li> <li>Efficient cross-process communication</li> <li>Resource usage within bounds</li> </ul>"},{"location":"crypto-strategy/#future-considerations","title":"Future Considerations","text":""},{"location":"crypto-strategy/#1-extensibility","title":"1. Extensibility","text":"<ul> <li>New implementation support</li> <li>Additional security features</li> <li>Enhanced monitoring</li> <li>Advanced audit capabilities</li> </ul>"},{"location":"crypto-strategy/#2-integration","title":"2. Integration","text":"<ul> <li>Additional application support</li> <li>Cloud service integration</li> <li>Enhanced security features</li> <li>Performance optimisations</li> </ul>"},{"location":"api/","title":"API Documentation","text":""},{"location":"api/#core-services","title":"Core Services","text":""},{"location":"api/#umbrakeychainservice","title":"UmbraKeychainService","text":"<p>Secure credential storage service. - API Reference - Usage Guide</p>"},{"location":"api/#umbracryptoservice","title":"UmbraCryptoService","text":"<p>Cryptographic operations service. - API Reference - Usage Guide</p>"},{"location":"api/#umbrabookmarkservice","title":"UmbraBookmarkService","text":"<p>File system bookmark management. - API Reference - Usage Guide</p>"},{"location":"api/#security-types","title":"Security Types","text":""},{"location":"api/#securitytypes","title":"SecurityTypes","text":"<p>Base security primitives. - API Reference - Usage Guide</p>"},{"location":"api/#cryptotypes","title":"CryptoTypes","text":"<p>Cryptographic types and operations. - API Reference - Usage Guide</p>"},{"location":"api/#utilities","title":"Utilities","text":""},{"location":"api/#umbralogging","title":"UmbraLogging","text":"<p>Logging infrastructure. - API Reference - Usage Guide</p>"},{"location":"api/#umbraxpc","title":"UmbraXPC","text":"<p>XPC communication layer. - API Reference - Usage Guide</p>"},{"location":"api/#error-types","title":"Error Types","text":""},{"location":"api/#commonerror","title":"CommonError","text":"<p>Shared error types. - API Reference - Usage Guide</p>"},{"location":"api/#best-practices","title":"Best Practices","text":"<ul> <li>Thread Safety</li> <li>Error Handling</li> <li>Performance</li> <li>Security</li> </ul>"},{"location":"api/backup-management/","title":"Backup Management","text":"<p>The backup management system in UmbraCore provides comprehensive functionality for managing backup operations.</p>"},{"location":"api/backup-management/#features","title":"Features","text":"<ul> <li>Repository initialization and management</li> <li>Backup creation and verification</li> <li>Snapshot management</li> <li>Tag handling</li> <li>Progress monitoring</li> <li>Error recovery</li> </ul>"},{"location":"api/backup-management/#core-types","title":"Core Types","text":""},{"location":"api/backup-management/#repository-management","title":"Repository Management","text":"<pre><code>protocol RepositoryManager {\n    func initialize(path: URL, password: String) async throws\n    func verify(path: URL) async throws -&gt; VerificationResult\n    func unlock(path: URL) async throws\n    func lock(path: URL) async throws\n}\n</code></pre>"},{"location":"api/backup-management/#backup-operations","title":"Backup Operations","text":"<pre><code>protocol BackupManager {\n    func createBackup(source: URL, tags: [String]) async throws -&gt; BackupResult\n    func verifyBackup(id: String) async throws -&gt; VerificationResult\n    func listSnapshots() async throws -&gt; [Snapshot]\n    func restoreSnapshot(_ snapshot: Snapshot, to: URL) async throws\n}\n</code></pre>"},{"location":"api/backup-management/#usage-examples","title":"Usage Examples","text":""},{"location":"api/backup-management/#creating-a-new-repository","title":"Creating a New Repository","text":"<pre><code>let manager = RepositoryManager()\ntry await manager.initialize(\n    path: repositoryURL,\n    password: \"secure-password\"\n)\n</code></pre>"},{"location":"api/backup-management/#running-a-backup","title":"Running a Backup","text":"<pre><code>let backup = BackupManager()\nlet result = try await backup.createBackup(\n    source: sourceURL,\n    tags: [\"daily\", \"documents\"]\n)\n</code></pre>"},{"location":"api/backup-management/#managing-snapshots","title":"Managing Snapshots","text":"<pre><code>let snapshots = try await backup.listSnapshots()\nfor snapshot in snapshots {\n    print(\"Snapshot \\(snapshot.id) from \\(snapshot.date)\")\n}\n</code></pre>"},{"location":"api/backup-management/#error-handling","title":"Error Handling","text":"<p>Common backup-related errors:</p> <ul> <li><code>RepositoryError</code>: Repository access issues</li> <li><code>BackupError</code>: Backup operation failures</li> <li><code>SnapshotError</code>: Snapshot management issues</li> <li><code>VerificationError</code>: Verification failures</li> </ul>"},{"location":"api/backup-management/#best-practices","title":"Best Practices","text":"<ol> <li>Regular repository verification</li> <li>Proper error handling</li> <li>Progress monitoring</li> <li>Resource cleanup</li> <li>Security considerations</li> </ol>"},{"location":"api/configuration/","title":"Configuration","text":"<p>The configuration system in UmbraCore provides a flexible way to manage backup settings and policies.</p>"},{"location":"api/configuration/#features","title":"Features","text":"<ul> <li>Backup source paths</li> <li>Exclude patterns</li> <li>Retention policies</li> <li>Schedule definitions</li> <li>Performance settings</li> <li>Security configuration</li> </ul>"},{"location":"api/configuration/#core-types","title":"Core Types","text":""},{"location":"api/configuration/#backup-configuration","title":"Backup Configuration","text":"<pre><code>struct BackupConfiguration {\n    let sources: [URL]\n    let excludes: [String]\n    let retention: RetentionPolicy\n    let schedule: Schedule\n    let compression: CompressionSettings\n    let verification: VerificationSettings\n}\n</code></pre>"},{"location":"api/configuration/#retention-policy","title":"Retention Policy","text":"<pre><code>struct RetentionPolicy {\n    let keepLast: Int\n    let keepHourly: Int\n    let keepDaily: Int\n    let keepWeekly: Int\n    let keepMonthly: Int\n    let keepYearly: Int\n    let keepTags: [String]\n}\n</code></pre>"},{"location":"api/configuration/#usage-examples","title":"Usage Examples","text":""},{"location":"api/configuration/#creating-a-configuration","title":"Creating a Configuration","text":"<pre><code>let config = BackupConfiguration(\n    sources: [documentsURL, picturesURL],\n    excludes: [\"*.tmp\", \"*.cache\"],\n    retention: RetentionPolicy(\n        keepLast: 3,\n        keepDaily: 7,\n        keepWeekly: 4,\n        keepMonthly: 6\n    ),\n    schedule: Schedule.daily(at: \"01:00\")\n)\n</code></pre>"},{"location":"api/configuration/#applying-configuration","title":"Applying Configuration","text":"<pre><code>let manager = ConfigurationManager()\ntry await manager.apply(config)\ntry await manager.validate()\n</code></pre>"},{"location":"api/configuration/#error-handling","title":"Error Handling","text":"<p>Common configuration-related errors:</p> <ul> <li><code>ConfigurationError</code>: Invalid settings</li> <li><code>ValidationError</code>: Validation failures</li> <li><code>ApplicationError</code>: Apply failures</li> <li><code>ParseError</code>: Parse issues</li> </ul>"},{"location":"api/configuration/#best-practices","title":"Best Practices","text":"<ol> <li>Validate configurations</li> <li>Use sensible defaults</li> <li>Document changes</li> <li>Version control</li> <li>Security review</li> </ol>"},{"location":"api/reference/","title":"API Reference","text":""},{"location":"api/reference/#core-services","title":"Core Services","text":""},{"location":"api/reference/#umbrakeychainservice","title":"UmbraKeychainService","text":"<p>Secure credential storage service for managing sensitive data:</p> <pre><code>// Initialize the service\nlet keychain = try UmbraKeychainService()\n\n// Store credentials\ntry await keychain.store(\n    password: \"secret\",\n    forKey: \"backup-repository\"\n)\n\n// Retrieve credentials\nlet password = try await keychain.retrieve(\n    forKey: \"backup-repository\"\n)\n</code></pre>"},{"location":"api/reference/#umbracryptoservice","title":"UmbraCryptoService","text":"<p>Cryptographic operations service for data security:</p> <pre><code>// Initialize the service\nlet crypto = try UmbraCryptoService()\n\n// Encrypt data\nlet encrypted = try await crypto.encrypt(\n    sensitiveData,\n    using: .aes256GCM\n)\n\n// Decrypt data\nlet decrypted = try await crypto.decrypt(\n    encrypted\n)\n</code></pre>"},{"location":"api/reference/#umbrabookmarkservice","title":"UmbraBookmarkService","text":"<p>File system bookmark management for persistent file access:</p> <pre><code>// Initialize the service\nlet bookmarks = try UmbraBookmarkService()\n\n// Create bookmark\nlet bookmark = try await bookmarks.create(\n    for: fileURL,\n    type: .securityScoped\n)\n\n// Resolve bookmark\nlet url = try await bookmarks.resolve(\n    bookmark: bookmark\n)\n</code></pre>"},{"location":"api/reference/#security-types","title":"Security Types","text":""},{"location":"api/reference/#securitytypes","title":"SecurityTypes","text":"<p>Base security primitives and protocols:</p> <pre><code>// Secure data container\nstruct SecureData: SecureContainer {\n    let data: Data\n    let metadata: SecurityMetadata\n}\n\n// Security context\nstruct SecurityContext {\n    let accessLevel: AccessLevel\n    let permissions: Permissions\n    let origin: SecurityOrigin\n}\n</code></pre>"},{"location":"api/reference/#cryptotypes","title":"CryptoTypes","text":"<p>Cryptographic types and operations:</p> <pre><code>// Encryption parameters\nstruct EncryptionParameters {\n    let algorithm: EncryptionAlgorithm\n    let keySize: KeySize\n    let iterations: Int\n}\n\n// Key types\nenum KeyType {\n    case aes256\n    case rsa2048\n    case rsa4096\n}\n</code></pre>"},{"location":"api/reference/#utilities","title":"Utilities","text":""},{"location":"api/reference/#umbralogging","title":"UmbraLogging","text":"<p>Centralised logging infrastructure:</p> <pre><code>// Initialize logger\nlet logger = UmbraLogger(\n    subsystem: \"com.example.app\",\n    category: \"backup\"\n)\n\n// Log events\nlogger.info(\"Starting backup\", metadata: [\n    \"repository\": \"main\",\n    \"files\": 100\n])\n\nlogger.error(\"Backup failed\", metadata: [\n    \"error\": error,\n    \"repository\": \"main\"\n])\n</code></pre>"},{"location":"api/reference/#umbraxpc","title":"UmbraXPC","text":"<p>XPC communication infrastructure:</p> <pre><code>// Define service protocol\nprotocol BackupService: XPCService {\n    func backup(source: URL) async throws\n    func restore(to: URL) async throws\n}\n\n// Create service connection\nlet service = try XPCConnection&lt;BackupService&gt;()\n\n// Call service\ntry await service.backup(source: sourceURL)\n</code></pre>"},{"location":"api/reference/#error-types","title":"Error Types","text":""},{"location":"api/reference/#commonerror","title":"CommonError","text":"<p>Shared error types across the framework:</p> <pre><code>enum CommonError: Error {\n    case invalidArgument(String)\n    case resourceNotFound(String)\n    case permissionDenied(String)\n    case operationFailed(String)\n}\n\nenum KeychainError: Error {\n    case itemNotFound(String)\n    case duplicateItem(String)\n    case accessDenied(String)\n}\n\nenum CryptoError: Error {\n    case encryptionFailed(String)\n    case decryptionFailed(String)\n    case invalidKey(String)\n}\n</code></pre>"},{"location":"api/reference/#best-practices","title":"Best Practices","text":""},{"location":"api/reference/#thread-safety","title":"Thread Safety","text":"<p>All services are designed to be thread-safe:</p> <pre><code>// Safe concurrent access\nlet service = try UmbraKeychainService()\nasync let task1 = service.store(password: \"secret1\", forKey: \"key1\")\nasync let task2 = service.store(password: \"secret2\", forKey: \"key2\")\ntry await [task1, task2]\n</code></pre>"},{"location":"api/reference/#error-handling","title":"Error Handling","text":"<p>Implement comprehensive error handling:</p> <pre><code>do {\n    try await service.backup(source: url)\n} catch CommonError.invalidArgument(let reason) {\n    logger.error(\"Invalid argument: \\(reason)\")\n} catch CommonError.permissionDenied(let operation) {\n    logger.error(\"Permission denied: \\(operation)\")\n} catch {\n    logger.error(\"Unknown error: \\(error)\")\n}\n</code></pre>"},{"location":"api/reference/#performance","title":"Performance","text":"<p>Follow performance best practices:</p> <pre><code>// Use batch operations\ntry await service.storeBatch([\n    (\"key1\", \"value1\"),\n    (\"key2\", \"value2\"),\n    (\"key3\", \"value3\")\n])\n\n// Implement cancellation\nlet task = Task {\n    try await service.longOperation()\n}\n// Later...\ntask.cancel()\n</code></pre>"},{"location":"api/reference/#related-documentation","title":"Related Documentation","text":"<ul> <li>Security Guide - Security implementation details</li> <li>Configuration Guide - Configuration options</li> <li>Advanced Features - Advanced usage</li> <li>Troubleshooting Guide - Common issues and solutions</li> </ul>"},{"location":"api/repository-handling/","title":"Repository Handling","text":"<p>The repository handling system in UmbraCore manages repository health, space usage, and maintenance.</p>"},{"location":"api/repository-handling/#features","title":"Features","text":"<ul> <li>Repository health checks</li> <li>Space usage monitoring</li> <li>Cache management</li> <li>Deduplication statistics</li> <li>Repository maintenance</li> <li>Performance optimization</li> </ul>"},{"location":"api/repository-handling/#core-types","title":"Core Types","text":""},{"location":"api/repository-handling/#health-monitoring","title":"Health Monitoring","text":"<pre><code>protocol RepositoryHealth {\n    func checkHealth() async throws -&gt; HealthStatus\n    func runMaintenance() async throws\n    func repairIndex() async throws\n    func validateData() async throws -&gt; ValidationResult\n}\n</code></pre>"},{"location":"api/repository-handling/#space-management","title":"Space Management","text":"<pre><code>protocol SpaceManager {\n    func getUsage() async throws -&gt; SpaceUsage\n    func forecast(days: Int) async throws -&gt; SpaceForecast\n    func cleanup(policy: RetentionPolicy) async throws -&gt; CleanupResult\n}\n</code></pre>"},{"location":"api/repository-handling/#usage-examples","title":"Usage Examples","text":""},{"location":"api/repository-handling/#health-check","title":"Health Check","text":"<pre><code>let health = RepositoryHealth()\nlet status = try await health.checkHealth()\nif status.needsMaintenance {\n    try await health.runMaintenance()\n}\n</code></pre>"},{"location":"api/repository-handling/#space-management_1","title":"Space Management","text":"<pre><code>let space = SpaceManager()\nlet usage = try await space.getUsage()\nprint(\"Used: \\(usage.used), Available: \\(usage.available)\")\n</code></pre>"},{"location":"api/repository-handling/#cache-management","title":"Cache Management","text":"<pre><code>let cache = CacheManager()\ntry await cache.optimize()\ntry await cache.prune(olderThan: .days(7))\n</code></pre>"},{"location":"api/repository-handling/#error-handling","title":"Error Handling","text":"<p>Common repository-related errors:</p> <ul> <li><code>HealthCheckError</code>: Health check failures</li> <li><code>MaintenanceError</code>: Maintenance issues</li> <li><code>SpaceError</code>: Space management problems</li> <li><code>CacheError</code>: Cache operation failures</li> </ul>"},{"location":"api/repository-handling/#best-practices","title":"Best Practices","text":"<ol> <li>Regular health checks</li> <li>Proactive maintenance</li> <li>Space monitoring</li> <li>Cache optimization</li> <li>Error recovery</li> </ol>"},{"location":"api/keychain/overview/","title":"UmbraKeychainService Overview","text":"<p>The UmbraKeychainService module provides secure credential management and storage capabilities for UmbraCore. It handles all sensitive data operations through a secure XPC service.</p>"},{"location":"api/keychain/overview/#features","title":"Features","text":"<ul> <li>Secure password management with validation</li> <li>Keychain integration for credential storage</li> <li>Biometric authentication support</li> <li>XPC service for isolated credential handling</li> <li>Automatic password rotation and expiry</li> <li>Secure backup and restore capabilities</li> </ul>"},{"location":"api/keychain/overview/#architecture","title":"Architecture","text":"<p>The service is built on three main components:</p> <ol> <li>XPC Service: Isolated process for handling sensitive operations</li> <li>Keychain Integration: Direct interface with the system keychain</li> <li>Client Library: Swift API for application integration</li> </ol>"},{"location":"api/keychain/overview/#getting-started","title":"Getting Started","text":"<p>See the following guides for detailed information:</p> <ul> <li>Password Management</li> <li>Secure Storage</li> <li>XPC Integration</li> </ul>"},{"location":"api/keychain/overview/#security-considerations","title":"Security Considerations","text":"<p>The service follows strict security practices:</p> <ul> <li>All operations run in an isolated XPC service</li> <li>Credentials never leave the secure enclave</li> <li>Biometric authentication for sensitive operations</li> <li>Automatic credential rotation</li> <li>Secure error handling to prevent information leaks</li> </ul>"},{"location":"api/keychain/password-management/","title":"Password Management","text":"<p>The password management system in UmbraKeychainService provides comprehensive functionality for handling secure credentials.</p>"},{"location":"api/keychain/password-management/#password-requirements","title":"Password Requirements","text":"<pre><code>struct PasswordRequirements {\n    let minLength: Int\n    let requiresUppercase: Bool\n    let requiresLowercase: Bool\n    let requiresNumbers: Bool\n    let requiresSpecialChars: Bool\n    let maxConsecutiveChars: Int\n    let bannedPasswords: Set&lt;String&gt;\n}\n</code></pre>"},{"location":"api/keychain/password-management/#default-requirements","title":"Default Requirements","text":"<ul> <li>Minimum length: 12 characters</li> <li>Must include uppercase and lowercase letters</li> <li>Must include at least one number</li> <li>Must include at least one special character</li> <li>No more than 3 consecutive identical characters</li> <li>Cannot be in the banned passwords list</li> </ul>"},{"location":"api/keychain/password-management/#password-validation","title":"Password Validation","text":"<p>The <code>PasswordValidator</code> protocol defines the interface for password validation:</p> <pre><code>protocol PasswordValidator {\n    func validateStrength(_ password: String) -&gt; PasswordStrength\n    func validateRequirements(_ password: String) -&gt; [PasswordRequirement]\n}\n</code></pre>"},{"location":"api/keychain/password-management/#strength-levels","title":"Strength Levels","text":"<ul> <li>Weak: Fails to meet minimum requirements</li> <li>Moderate: Meets minimum requirements</li> <li>Strong: Exceeds minimum requirements</li> <li>Very Strong: Significantly exceeds requirements</li> </ul>"},{"location":"api/keychain/password-management/#password-rotation","title":"Password Rotation","text":"<p>Passwords can be configured with expiration policies:</p> <pre><code>struct PasswordMetadata {\n    let creationDate: Date\n    let expirationDate: Date?\n    let lastRotated: Date?\n    let strengthScore: Int\n}\n</code></pre>"},{"location":"api/keychain/password-management/#rotation-policies","title":"Rotation Policies","text":"<ul> <li>Time-based: Rotate after a specified duration</li> <li>Access-based: Rotate after number of uses</li> <li>Strength-based: Rotate when strength requirements change</li> </ul>"},{"location":"api/keychain/password-management/#error-handling","title":"Error Handling","text":"<p>Common password-related errors:</p> <ul> <li><code>WeakPasswordError</code>: Password doesn't meet requirements</li> <li><code>ExpiredPasswordError</code>: Password needs rotation</li> <li><code>ValidationError</code>: General validation failures</li> <li><code>RotationError</code>: Issues during password rotation</li> </ul>"},{"location":"api/keychain/password-management/#best-practices","title":"Best Practices","text":"<ol> <li>Always use the validation system</li> <li>Implement automatic rotation</li> <li>Handle errors appropriately</li> <li>Use secure password generation</li> <li>Maintain audit logs</li> </ol>"},{"location":"api/keychain/password-management/#examples","title":"Examples","text":""},{"location":"api/keychain/password-management/#validating-a-password","title":"Validating a Password","text":"<pre><code>let validator = DefaultPasswordValidator()\nlet strength = validator.validateStrength(\"MySecurePass123!\")\nlet requirements = validator.validateRequirements(\"MySecurePass123!\")\n</code></pre>"},{"location":"api/keychain/password-management/#rotating-a-password","title":"Rotating a Password","text":"<pre><code>let rotator = PasswordRotator()\ntry await rotator.rotatePassword(\n    identifier: \"main-backup-repo\",\n    newPassword: generateSecurePassword()\n)\n</code></pre>"},{"location":"api/keychain/secure-storage/","title":"Secure Storage","text":"<p>The secure storage system in UmbraKeychainService provides a robust interface for storing sensitive data in the system keychain.</p>"},{"location":"api/keychain/secure-storage/#features","title":"Features","text":"<ul> <li>Secure credential storage</li> <li>Biometric authentication</li> <li>Access control management</li> <li>Automatic encryption</li> <li>Secure backup/restore</li> </ul>"},{"location":"api/keychain/secure-storage/#access-control","title":"Access Control","text":"<pre><code>struct KeychainAccessControl {\n    let requiresBiometrics: Bool\n    let accessibleMode: AccessibleMode\n    let sharingMode: SharingMode\n    let timeout: TimeInterval?\n}\n</code></pre>"},{"location":"api/keychain/secure-storage/#access-modes","title":"Access Modes","text":"<ul> <li><code>whenUnlocked</code>: Only when device is unlocked</li> <li><code>afterFirstUnlock</code>: After first unlock until restart</li> <li><code>always</code>: Always accessible (use with caution)</li> </ul>"},{"location":"api/keychain/secure-storage/#sharing-options","title":"Sharing Options","text":"<ul> <li><code>none</code>: No sharing</li> <li><code>sameUserOnly</code>: Share with same user</li> <li><code>anyUser</code>: Share with any user (admin only)</li> </ul>"},{"location":"api/keychain/secure-storage/#encryption","title":"Encryption","text":"<p>All data is encrypted before storage:</p> <ul> <li>AES-256 encryption</li> <li>Secure key generation</li> <li>Key rotation support</li> <li>Forward secrecy</li> </ul>"},{"location":"api/keychain/secure-storage/#backup-and-restore","title":"Backup and Restore","text":"<pre><code>protocol SecureBackupProvider {\n    func createBackup() async throws -&gt; BackupMetadata\n    func restoreFromBackup(_ backup: BackupData) async throws\n    func validateBackup(_ backup: BackupData) async throws -&gt; Bool\n}\n</code></pre>"},{"location":"api/keychain/secure-storage/#backup-features","title":"Backup Features","text":"<ul> <li>Encrypted backups</li> <li>Version control</li> <li>Integrity verification</li> <li>Secure transport</li> </ul>"},{"location":"api/keychain/secure-storage/#error-handling","title":"Error Handling","text":"<p>Common storage errors:</p> <ul> <li><code>AccessDeniedError</code>: Permission issues</li> <li><code>EncryptionError</code>: Encryption failures</li> <li><code>BackupError</code>: Backup/restore issues</li> <li><code>AuthenticationError</code>: Auth failures</li> </ul>"},{"location":"api/keychain/secure-storage/#best-practices","title":"Best Practices","text":"<ol> <li>Use appropriate access controls</li> <li>Implement regular backups</li> <li>Rotate encryption keys</li> <li>Monitor access patterns</li> <li>Handle errors securely</li> </ol>"},{"location":"api/keychain/secure-storage/#examples","title":"Examples","text":""},{"location":"api/keychain/secure-storage/#storing-a-password","title":"Storing a Password","text":"<pre><code>let storage = SecureStorage()\ntry await storage.store(\n    password: \"MySecurePass123!\",\n    identifier: \"backup-repo\",\n    accessControl: .init(\n        requiresBiometrics: true,\n        accessibleMode: .whenUnlocked\n    )\n)\n</code></pre>"},{"location":"api/keychain/secure-storage/#creating-a-backup","title":"Creating a Backup","text":"<pre><code>let backupProvider = SecureBackupProvider()\nlet backup = try await backupProvider.createBackup()\ntry await backupProvider.validateBackup(backup)\n</code></pre>"},{"location":"api/keychain/xpc-integration/","title":"XPC Integration","text":"<p>The XPC integration in UmbraKeychainService provides secure inter-process communication for credential management.</p>"},{"location":"api/keychain/xpc-integration/#architecture","title":"Architecture","text":""},{"location":"api/keychain/xpc-integration/#service-definition","title":"Service Definition","text":"<pre><code>protocol KeychainXPCServiceProtocol {\n    func storePassword(_ password: String, \n                      identifier: String, \n                      accessControl: KeychainAccessControl) async throws\n    func retrievePassword(identifier: String) async throws -&gt; String\n    func deletePassword(identifier: String) async throws\n    func validatePassword(_ password: String) async throws -&gt; ValidationResult\n}\n</code></pre>"},{"location":"api/keychain/xpc-integration/#security-boundaries","title":"Security Boundaries","text":"<p>The XPC service: - Runs in an isolated process - Has minimal privileges - Handles all keychain operations - Manages secure storage</p>"},{"location":"api/keychain/xpc-integration/#implementation","title":"Implementation","text":""},{"location":"api/keychain/xpc-integration/#service-setup","title":"Service Setup","text":"<pre><code>class KeychainXPCService: NSObject, KeychainXPCServiceProtocol {\n    private let storage: SecureStorage\n    private let validator: PasswordValidator\n\n    override init() {\n        self.storage = SecureStorage()\n        self.validator = DefaultPasswordValidator()\n        super.init()\n    }\n}\n</code></pre>"},{"location":"api/keychain/xpc-integration/#client-integration","title":"Client Integration","text":"<pre><code>class KeychainClient {\n    private let connection: NSXPCConnection\n\n    init() {\n        connection = NSXPCConnection(serviceName: \"dev.umbracore.keychain\")\n        connection.remoteObjectInterface = NSXPCInterface(with: KeychainXPCServiceProtocol.self)\n        connection.resume()\n    }\n}\n</code></pre>"},{"location":"api/keychain/xpc-integration/#error-handling","title":"Error Handling","text":"<p>XPC-specific errors:</p> <ul> <li><code>ConnectionError</code>: XPC connection issues</li> <li><code>TimeoutError</code>: Operation timeouts</li> <li><code>SecurityError</code>: Security violations</li> <li><code>ServiceError</code>: Service-specific errors</li> </ul>"},{"location":"api/keychain/xpc-integration/#best-practices","title":"Best Practices","text":"<ol> <li>Validate all inputs</li> <li>Handle connection failures</li> <li>Implement timeouts</li> <li>Monitor service health</li> <li>Log security events</li> </ol>"},{"location":"api/keychain/xpc-integration/#examples","title":"Examples","text":""},{"location":"api/keychain/xpc-integration/#using-the-service","title":"Using the Service","text":"<pre><code>let client = KeychainClient()\ntry await client.storePassword(\n    \"MySecurePass123!\",\n    identifier: \"backup-repo\",\n    accessControl: .init(requiresBiometrics: true)\n)\n</code></pre>"},{"location":"api/keychain/xpc-integration/#error-handling_1","title":"Error Handling","text":"<pre><code>do {\n    let password = try await client.retrievePassword(\"backup-repo\")\n} catch KeychainError.connectionFailed {\n    // Handle connection failure\n} catch KeychainError.accessDenied {\n    // Handle access denied\n} catch {\n    // Handle other errors\n}\n</code></pre>"},{"location":"archive/ACKNOWLEDGMENTS/","title":"Acknowledgments","text":"<p>UmbraCore stands on the shoulders of open-source giants. We're deeply grateful to the following open-source projects and their maintainers:</p>"},{"location":"archive/ACKNOWLEDGMENTS/#core-dependencies","title":"Core Dependencies","text":""},{"location":"archive/ACKNOWLEDGMENTS/#restic","title":"Restic","text":"<p>Restic is the backbone of UmbraCore's backup capabilities. It's a modern backup program written in Go which provides: - Fast, secure, and efficient backups - Deduplication - Encryption - Multiple backend support - Outstanding performance</p> <p>We highly recommend supporting the Restic project: - GitHub Repository - Documentation - Contributing Guide - Donate</p>"},{"location":"archive/ACKNOWLEDGMENTS/#swiftybeaver","title":"SwiftyBeaver","text":"<p>SwiftyBeaver powers UmbraCore's logging infrastructure. It's a sophisticated logging system that offers: - Colourised console output - File logging - Cloud logging - Custom formats - Filters and threading support</p> <p>Support SwiftyBeaver: - GitHub Repository - Documentation - Pro Features</p>"},{"location":"archive/ACKNOWLEDGMENTS/#cryptoswift","title":"CryptoSwift","text":"<p>CryptoSwift provides UmbraCore's cryptographic operations. It's a comprehensive cryptography framework offering: - AES encryption - Hash functions - HMAC - PBKDF - Extensible architecture</p> <p>Support CryptoSwift: - GitHub Repository - Documentation - Sponsor</p>"},{"location":"archive/ACKNOWLEDGMENTS/#development-tools","title":"Development Tools","text":""},{"location":"archive/ACKNOWLEDGMENTS/#just-the-docs","title":"Just the Docs","text":"<p>The beautiful documentation theme you're currently viewing. Features: - Clean, responsive design - Full-text search - Dark/light mode - Navigation structure - Customisation options</p> <p>Support Just the Docs: - GitHub Repository - Documentation - Contributing Guide</p>"},{"location":"archive/ACKNOWLEDGMENTS/#jazzy","title":"Jazzy","text":"<p>Jazzy generates our API documentation. It provides: - Clean documentation generation - Markdown support - Search functionality - Cross-references</p> <p>Support Jazzy: - GitHub Repository - Documentation - Contributing Guide</p>"},{"location":"archive/ACKNOWLEDGMENTS/#swiftlint","title":"SwiftLint","text":"<p>SwiftLint helps maintain our code quality. It offers: - Style and convention checking - Customisable rules - Automatic fixing - Xcode integration</p> <p>Support SwiftLint: - GitHub Repository - Documentation - Contributing Guide</p>"},{"location":"archive/ACKNOWLEDGMENTS/#security-tools","title":"Security Tools","text":""},{"location":"archive/ACKNOWLEDGMENTS/#snyk","title":"Snyk","text":"<p>Snyk helps keep UmbraCore secure by providing: - Vulnerability scanning - Dependency monitoring - Security updates - License compliance</p> <p>Support Snyk: - Website - Documentation - Blog</p>"},{"location":"archive/ACKNOWLEDGMENTS/#codecov","title":"Codecov","text":"<p>Codecov helps maintain our test coverage by offering: - Coverage reporting - PR checks - Trending analysis - Quality gates</p> <p>Support Codecov: - Website - Documentation - GitHub Repository</p>"},{"location":"archive/ACKNOWLEDGMENTS/#contributing","title":"Contributing","text":"<p>If you'd like to contribute to UmbraCore, please see our Contributing Guidelines. We welcome all contributions, from code to documentation improvements.</p>"},{"location":"archive/ACKNOWLEDGMENTS/#supporting-open-source","title":"Supporting Open Source","text":"<p>We encourage users of UmbraCore to consider supporting these projects through: - Code contributions - Documentation improvements - Bug reports - Financial support where available - Spreading the word about their excellent work</p> <p>The strength of UmbraCore comes from these outstanding open-source projects. Supporting them helps ensure a vibrant and sustainable open-source ecosystem.</p>"},{"location":"archive/GETTING_STARTED/","title":"Getting Started with UmbraCore","text":""},{"location":"archive/GETTING_STARTED/#prerequisites","title":"Prerequisites","text":"<ul> <li>macOS 14.0 or later</li> <li>Xcode 15.2 or later</li> <li>Swift 6.0.3 or later</li> <li>Restic installed</li> </ul>"},{"location":"archive/GETTING_STARTED/#installation","title":"Installation","text":""},{"location":"archive/GETTING_STARTED/#swift-package-manager","title":"Swift Package Manager","text":"<p>Add UmbraCore as a dependency in your <code>Package.swift</code>:</p> <pre><code>dependencies: [\n    .package(url: \"https://github.com/mpy-dev-ml/UmbraCore.git\", from: \"1.0.0\")\n]\n</code></pre>"},{"location":"archive/GETTING_STARTED/#manual-installation","title":"Manual Installation","text":"<ol> <li>Clone the repository</li> <li>Build the package</li> <li>Link the framework</li> </ol>"},{"location":"archive/GETTING_STARTED/#quick-start-guide","title":"Quick Start Guide","text":""},{"location":"archive/GETTING_STARTED/#1-basic-setup","title":"1. Basic Setup","text":"<pre><code>import UmbraCore\n\n// Initialize the core services\nlet keychainService = try UmbraKeychainService()\nlet cryptoService = try UmbraCryptoService()\n</code></pre>"},{"location":"archive/GETTING_STARTED/#2-configure-logging","title":"2. Configure Logging","text":"<pre><code>import UmbraLogging\n\nUmbraLogger.configure(level: .info)\n</code></pre>"},{"location":"archive/GETTING_STARTED/#3-basic-operations","title":"3. Basic Operations","text":"<pre><code>// Example: Store credentials\ntry await keychainService.store(\n    password: \"repository-password\",\n    forKey: \"backup-repo\"\n)\n\n// Example: Create a bookmark\ntry await bookmarkService.create(\n    for: URL(fileURLWithPath: \"/path/to/backup\"),\n    withName: \"documents\"\n)\n</code></pre>"},{"location":"archive/GETTING_STARTED/#next-steps","title":"Next Steps","text":"<ul> <li>Read the Architecture Guide</li> <li>Check out Security Best Practices</li> <li>View API Documentation</li> </ul>"},{"location":"archive/LICENSE/","title":"MIT License","text":"<p>Copyright (c) 2025 MPY Development</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"archive/bazel_spm_integration/","title":"UmbraCore: Bazel and SPM Integration Brief","text":""},{"location":"archive/bazel_spm_integration/#overview","title":"Overview","text":"<p>This document outlines our strategy for integrating Bazel build system while maintaining Swift Package Manager (SPM) compatibility in the UmbraCore project.</p>"},{"location":"archive/bazel_spm_integration/#1-integration-goals","title":"1. Integration Goals","text":"<ul> <li>Maintain existing SPM dependencies</li> <li>Leverage Bazel's build caching</li> <li>Optimise CI/CD performance</li> <li>Support future scalability</li> </ul>"},{"location":"archive/bazel_spm_integration/#2-technical-architecture","title":"2. Technical Architecture","text":""},{"location":"archive/bazel_spm_integration/#21-build-system-components","title":"2.1 Build System Components","text":"<pre><code>UmbraCore/\n\u251c\u2500\u2500 WORKSPACE\n\u251c\u2500\u2500 MODULE.bazel          # Bazel module configuration\n\u251c\u2500\u2500 Package.swift         # SPM dependencies\n\u251c\u2500\u2500 Package.resolved      # SPM version lock\n\u251c\u2500\u2500 .bazelrc             # Bazel settings\n\u251c\u2500\u2500 BUILD.bazel          # Root build file\n\u251c\u2500\u2500 Sources/             # Source files\n\u2502   \u2514\u2500\u2500 */\n\u2502       \u251c\u2500\u2500 BUILD       # Generated by Gazelle\n\u2502       \u2514\u2500\u2500 *.swift\n\u2514\u2500\u2500 Tests/              # Test files\n    \u2514\u2500\u2500 */\n        \u251c\u2500\u2500 BUILD       # Generated by Gazelle\n        \u2514\u2500\u2500 *.swift\n</code></pre>"},{"location":"archive/bazel_spm_integration/#22-key-configuration-files","title":"2.2 Key Configuration Files","text":""},{"location":"archive/bazel_spm_integration/#modulebazel","title":"MODULE.bazel","text":"<pre><code>bazel_dep(name = \"rules_swift_package_manager\", version = \"0.46.0\")\n\nswift_deps = use_extension(\n    \"@rules_swift_package_manager//:extensions.bzl\",\n    \"swift_deps\",\n)\n\nswift_deps.configure_swift_package(\n    build_path = \"spm-build\",\n    cache_path = \"spm-cache\",\n    dependency_caching = \"true\",\n    manifest_cache = \"local\",\n    manifest_caching = \"true\",\n)\n\nswift_deps.from_package(\n    declare_swift_deps_info = True,\n    declare_swift_package = True,\n    resolved = \"//:Package.resolved\",\n    swift = \"//:Package.swift\",\n)\n</code></pre>"},{"location":"archive/bazel_spm_integration/#bazelrc","title":".bazelrc","text":"<pre><code># Enable bzlmod\nbuild --enable_bzlmod\n\n# SPM integration\nbuild --experimental_enable_swift_package_manager\n\n# Caching configuration\nbuild --remote_cache=grpcs://cache.buildbuddy.io\nbuild --remote_timeout=3600\n</code></pre>"},{"location":"archive/bazel_spm_integration/#3-dependency-management","title":"3. Dependency Management","text":""},{"location":"archive/bazel_spm_integration/#31-spm-dependencies","title":"3.1 SPM Dependencies","text":"<ul> <li>CryptoSwift (v1.8.0+)</li> <li>SwiftyBeaver (v2.0.0+)</li> </ul>"},{"location":"archive/bazel_spm_integration/#32-bazel-dependencies","title":"3.2 Bazel Dependencies","text":"<ul> <li>rules_swift_package_manager</li> <li>rules_swift</li> <li>rules_apple (optional)</li> <li>Gazelle</li> </ul>"},{"location":"archive/bazel_spm_integration/#4-caching-strategy","title":"4. Caching Strategy","text":""},{"location":"archive/bazel_spm_integration/#41-cache-locations","title":"4.1 Cache Locations","text":"<ul> <li><code>spm-cache/</code>: SPM dependency cache</li> <li><code>spm-build/</code>: SPM build artifacts</li> <li><code>bazel-*/</code>: Bazel build outputs</li> <li><code>~/.cache/bazel</code>: Bazel system cache</li> </ul>"},{"location":"archive/bazel_spm_integration/#42-cicd-caching","title":"4.2 CI/CD Caching","text":"<pre><code>cache:\n  paths:\n    - ~/.cache/bazel\n    - spm-cache\n    - spm-build\n  key: ${CI_COMMIT_REF_SLUG}\n</code></pre>"},{"location":"archive/bazel_spm_integration/#5-common-operations","title":"5. Common Operations","text":""},{"location":"archive/bazel_spm_integration/#51-dependency-management","title":"5.1 Dependency Management","text":"<pre><code># Update all dependencies\nbazel run @swift_package//:update\n\n# Update specific package\nbazel run @swift_package//:update -- SwiftyBeaver\n\n# Resolve dependencies\nbazel run @swift_package//:resolve\n</code></pre>"},{"location":"archive/bazel_spm_integration/#52-build-operations","title":"5.2 Build Operations","text":"<pre><code># Build entire project\nbazel build //...\n\n# Run tests\nbazel test //...\n\n# Generate BUILD files\nbazel run //:update_build_files\n</code></pre>"},{"location":"archive/bazel_spm_integration/#6-best-practices","title":"6. Best Practices","text":""},{"location":"archive/bazel_spm_integration/#61-development-workflow","title":"6.1 Development Workflow","text":"<ol> <li>Use Bazel commands for all build operations</li> <li>Keep Package.swift minimal and focused</li> <li>Regularly update cached dependencies</li> <li>Monitor cache size and performance</li> </ol>"},{"location":"archive/bazel_spm_integration/#62-code-organisation","title":"6.2 Code Organisation","text":"<ol> <li>Follow module structure in Sources/</li> <li>Maintain clear dependency boundaries</li> <li>Use proper visibility declarations</li> <li>Keep BUILD files organised</li> </ol>"},{"location":"archive/bazel_spm_integration/#63-language-standards","title":"6.3 Language Standards","text":"<ol> <li>Use British English in:</li> <li>Documentation</li> <li>Comments</li> <li>User-facing text</li> <li>Use American English in:</li> <li>Code</li> <li>Build files</li> <li>Configuration</li> </ol>"},{"location":"archive/bazel_spm_integration/#7-performance-considerations","title":"7. Performance Considerations","text":""},{"location":"archive/bazel_spm_integration/#71-local-development","title":"7.1 Local Development","text":"<ul> <li>Use local caching</li> <li>Enable parallel builds</li> <li>Monitor resource usage</li> <li>Regular cache cleanup</li> </ul>"},{"location":"archive/bazel_spm_integration/#72-cicd-pipeline","title":"7.2 CI/CD Pipeline","text":"<ul> <li>Optimise cache sharing</li> <li>Use remote caching</li> <li>Enable parallel testing</li> <li>Monitor build times</li> </ul>"},{"location":"archive/bazel_spm_integration/#8-migration-timeline","title":"8. Migration Timeline","text":""},{"location":"archive/bazel_spm_integration/#phase-1-initial-setup-1-week","title":"Phase 1: Initial Setup (1 week)","text":"<ul> <li>[ ] Configure Bazel</li> <li>[ ] Set up SPM integration</li> <li>[ ] Configure caching</li> <li>[ ] Update documentation</li> </ul>"},{"location":"archive/bazel_spm_integration/#phase-2-build-migration-2-weeks","title":"Phase 2: Build Migration (2 weeks)","text":"<ul> <li>[ ] Generate BUILD files</li> <li>[ ] Test build system</li> <li>[ ] Validate dependencies</li> <li>[ ] Performance testing</li> </ul>"},{"location":"archive/bazel_spm_integration/#phase-3-cicd-integration-1-week","title":"Phase 3: CI/CD Integration (1 week)","text":"<ul> <li>[ ] Configure GitHub Actions</li> <li>[ ] Set up caching</li> <li>[ ] Test workflows</li> <li>[ ] Monitor performance</li> </ul>"},{"location":"archive/bazel_spm_integration/#9-support-and-maintenance","title":"9. Support and Maintenance","text":""},{"location":"archive/bazel_spm_integration/#91-regular-tasks","title":"9.1 Regular Tasks","text":"<ul> <li>Weekly dependency updates</li> <li>Monthly cache cleanup</li> <li>Quarterly performance review</li> <li>Regular documentation updates</li> </ul>"},{"location":"archive/bazel_spm_integration/#92-monitoring","title":"9.2 Monitoring","text":"<ul> <li>Build times</li> <li>Cache hit rates</li> <li>Dependency updates</li> <li>Resource usage</li> </ul>"},{"location":"archive/bazel_spm_integration/#10-references","title":"10. References","text":"<ol> <li>Bazel Documentation</li> <li>rules_swift_package_manager</li> <li>Swift Package Manager</li> <li>GitHub Actions Documentation</li> </ol>"},{"location":"archive/api/","title":"API Documentation","text":""},{"location":"archive/api/#core-services","title":"Core Services","text":""},{"location":"archive/api/#umbrakeychainservice","title":"UmbraKeychainService","text":"<p>Secure credential storage service. - API Reference - Usage Guide</p>"},{"location":"archive/api/#umbracryptoservice","title":"UmbraCryptoService","text":"<p>Cryptographic operations service. - API Reference - Usage Guide</p>"},{"location":"archive/api/#umbrabookmarkservice","title":"UmbraBookmarkService","text":"<p>File system bookmark management. - API Reference - Usage Guide</p>"},{"location":"archive/api/#security-types","title":"Security Types","text":""},{"location":"archive/api/#securitytypes","title":"SecurityTypes","text":"<p>Base security primitives. - API Reference - Usage Guide</p>"},{"location":"archive/api/#cryptotypes","title":"CryptoTypes","text":"<p>Cryptographic types and operations. - API Reference - Usage Guide</p>"},{"location":"archive/api/#utilities","title":"Utilities","text":""},{"location":"archive/api/#umbralogging","title":"UmbraLogging","text":"<p>Logging infrastructure. - API Reference - Usage Guide</p>"},{"location":"archive/api/#umbraxpc","title":"UmbraXPC","text":"<p>XPC communication layer. - API Reference - Usage Guide</p>"},{"location":"archive/api/#error-types","title":"Error Types","text":""},{"location":"archive/api/#commonerror","title":"CommonError","text":"<p>Shared error types. - API Reference - Usage Guide</p>"},{"location":"archive/api/#best-practices","title":"Best Practices","text":"<ul> <li>Thread Safety</li> <li>Error Handling</li> <li>Performance</li> <li>Security</li> </ul>"},{"location":"archive/contributing/CONTRIBUTING/","title":"Contributing to UmbraCore","text":""},{"location":"archive/contributing/CONTRIBUTING/#getting-started","title":"Getting Started","text":""},{"location":"archive/contributing/CONTRIBUTING/#1-development-environment","title":"1. Development Environment","text":"<ul> <li>macOS 14.0+</li> <li>Xcode 15.2+</li> <li>Swift 6.0.3+</li> <li>SwiftLint</li> <li>Restic</li> </ul>"},{"location":"archive/contributing/CONTRIBUTING/#2-setup","title":"2. Setup","text":"<ol> <li>Fork the repository</li> <li>Clone your fork</li> <li>Install dependencies</li> <li>Run tests</li> </ol>"},{"location":"archive/contributing/CONTRIBUTING/#development-process","title":"Development Process","text":""},{"location":"archive/contributing/CONTRIBUTING/#1-branching","title":"1. Branching","text":"<ul> <li><code>main</code>: Production-ready code</li> <li><code>develop</code>: Integration branch</li> <li>Feature branches: <code>feature/description</code></li> <li>Bug fixes: <code>fix/description</code></li> </ul>"},{"location":"archive/contributing/CONTRIBUTING/#2-commit-messages","title":"2. Commit Messages","text":"<p>Follow conventional commits: <pre><code>type(scope): description\n\n[optional body]\n\n[optional footer]\n</code></pre></p> <p>Types: - feat: New feature - fix: Bug fix - docs: Documentation - style: Formatting - refactor: Code restructuring - test: Adding tests - chore: Maintenance</p>"},{"location":"archive/contributing/CONTRIBUTING/#3-code-style","title":"3. Code Style","text":"<ul> <li>Follow Swift API Design Guidelines</li> <li>Use SwiftLint rules</li> <li>Document public APIs</li> <li>Write meaningful comments</li> </ul>"},{"location":"archive/contributing/CONTRIBUTING/#4-testing","title":"4. Testing","text":"<ul> <li>Write unit tests</li> <li>Include integration tests</li> <li>Maintain test coverage</li> <li>Test error conditions</li> </ul>"},{"location":"archive/contributing/CONTRIBUTING/#5-documentation","title":"5. Documentation","text":"<ul> <li>Update API documentation</li> <li>Include code examples</li> <li>Document breaking changes</li> <li>Update guides if needed</li> </ul>"},{"location":"archive/contributing/CONTRIBUTING/#pull-requests","title":"Pull Requests","text":""},{"location":"archive/contributing/CONTRIBUTING/#1-preparation","title":"1. Preparation","text":"<ul> <li>Update from upstream</li> <li>Run all tests</li> <li>Check code coverage</li> <li>Run SwiftLint</li> </ul>"},{"location":"archive/contributing/CONTRIBUTING/#2-submission","title":"2. Submission","text":"<ul> <li>Clear description</li> <li>Link related issues</li> <li>Include test cases</li> <li>Update documentation</li> </ul>"},{"location":"archive/contributing/CONTRIBUTING/#3-review-process","title":"3. Review Process","text":"<ul> <li>Address feedback</li> <li>Keep changes focused</li> <li>Maintain clean history</li> <li>Update as needed</li> </ul>"},{"location":"archive/contributing/CONTRIBUTING/#release-process","title":"Release Process","text":""},{"location":"archive/contributing/CONTRIBUTING/#1-versioning","title":"1. Versioning","text":"<p>Follow semantic versioning: - MAJOR: Breaking changes - MINOR: New features - PATCH: Bug fixes</p>"},{"location":"archive/contributing/CONTRIBUTING/#2-release-checklist","title":"2. Release Checklist","text":"<ul> <li>Update changelog</li> <li>Update version</li> <li>Run full test suite</li> <li>Update documentation</li> <li>Create release notes</li> </ul>"},{"location":"archive/contributing/CONTRIBUTING/#additional-resources","title":"Additional Resources","text":"<ul> <li>Swift API Design Guidelines</li> <li>SwiftLint Rules</li> <li>Conventional Commits</li> </ul>"},{"location":"archive/guides/ARCHITECTURE/","title":"UmbraCore Architecture Guide","text":""},{"location":"archive/guides/ARCHITECTURE/#overview","title":"Overview","text":"<p>UmbraCore is designed as a modular Swift library that provides a type-safe interface to Restic backup functionality. The architecture follows a service-oriented approach with clear separation of concerns.</p>"},{"location":"archive/guides/ARCHITECTURE/#core-components","title":"Core Components","text":""},{"location":"archive/guides/ARCHITECTURE/#1-security-layer","title":"1. Security Layer","text":"<ul> <li><code>SecurityTypes</code>: Base security primitives</li> <li><code>CryptoTypes</code>: Cryptographic operations</li> <li>Uses Apple's CryptoKit for hardware-backed security</li> <li>Provides core cryptographic primitives</li> <li>Handles secure key generation and management</li> <li><code>UmbraKeychainService</code>: Secure credential storage</li> </ul>"},{"location":"archive/guides/ARCHITECTURE/#2-service-layer","title":"2. Service Layer","text":"<ul> <li><code>UmbraCryptoService</code>: Encryption/decryption operations</li> <li>Uses CryptoSwift for XPC service operations</li> <li>Platform-independent implementation</li> <li>Handles cross-process cryptographic operations</li> <li><code>UmbraBookmarkService</code>: File system bookmark management</li> <li><code>UmbraXPC</code>: Inter-process communication</li> </ul>"},{"location":"archive/guides/ARCHITECTURE/#3-logging-infrastructure","title":"3. Logging Infrastructure","text":"<ul> <li><code>UmbraLogging</code>: Centralised logging system</li> <li>Structured logging with context</li> <li>Log level management</li> </ul>"},{"location":"archive/guides/ARCHITECTURE/#design-patterns","title":"Design Patterns","text":""},{"location":"archive/guides/ARCHITECTURE/#1-xpc-service-pattern","title":"1. XPC Service Pattern","text":"<p>Used for secure inter-process communication: <pre><code>protocol KeychainXPCProtocol {\n    func store(password: String, forKey: String) async throws\n    func retrieve(forKey: String) async throws -&gt; String\n}\n</code></pre></p>"},{"location":"archive/guides/ARCHITECTURE/#2-protocol-oriented-design","title":"2. Protocol-Oriented Design","text":"<p>Services are defined by protocols for better testability: <pre><code>protocol CryptoServiceProtocol {\n    func encrypt(_ data: Data) async throws -&gt; Data\n    func decrypt(_ data: Data) async throws -&gt; Data\n}\n</code></pre></p>"},{"location":"archive/guides/ARCHITECTURE/#3-error-handling-pattern","title":"3. Error Handling Pattern","text":"<p>Structured error types with context: <pre><code>enum KeychainError: Error {\n    case itemNotFound(String)\n    case duplicateItem(String)\n    case accessDenied(String)\n}\n</code></pre></p>"},{"location":"archive/guides/ARCHITECTURE/#cryptographic-architecture","title":"Cryptographic Architecture","text":"<p>The framework employs a dual-library approach for cryptographic operations:</p> <ol> <li>CryptoKit (Main App Context)</li> <li>Hardware-backed security on Apple platforms</li> <li>Used in <code>DefaultCryptoService</code></li> <li>Handles core cryptographic operations</li> <li> <p>Optimal security for main app operations</p> </li> <li> <p>CryptoSwift (XPC Service Context)</p> </li> <li>Platform-independent implementation</li> <li>Used in <code>CryptoXPCService</code></li> <li>Enables reliable cross-process encryption</li> <li>Provides necessary flexibility for XPC operations</li> </ol> <p>This split architecture ensures: - Maximum security through hardware backing where available - Reliable cross-process cryptographic operations - Clear separation of concerns between contexts - Consistent cryptographic operations in each context</p>"},{"location":"archive/guides/ARCHITECTURE/#threading-model","title":"Threading Model","text":"<ul> <li>All services are thread-safe</li> <li>Async/await for asynchronous operations</li> <li>XPC for background processing</li> </ul>"},{"location":"archive/guides/ARCHITECTURE/#security-considerations","title":"Security Considerations","text":"<ul> <li>Keychain integration for secure storage</li> <li>XPC for privilege separation</li> <li>Audit logging</li> <li>Secure defaults</li> </ul>"},{"location":"archive/guides/ARCHITECTURE/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Efficient memory usage</li> <li>Background processing</li> <li>Cache management</li> <li>Resource cleanup</li> </ul>"},{"location":"archive/guides/ARCHITECTURE/#testing-strategy","title":"Testing Strategy","text":"<ul> <li>Unit tests for all components</li> <li>Integration tests for workflows</li> <li>Mock services for testing</li> <li>Performance benchmarks</li> </ul>"},{"location":"archive/guides/ARCHITECTURE/#dependency-management","title":"Dependency Management","text":"<ul> <li>Minimal external dependencies</li> <li>Version pinning</li> <li>Security scanning</li> <li>Regular updates</li> </ul>"},{"location":"archive/guides/ARCHITECTURE/#implementation-plan","title":"Implementation Plan","text":""},{"location":"archive/guides/ARCHITECTURE/#phase-1-core-foundation","title":"Phase 1: Core Foundation","text":"<p>Currently in progress (Q1 2025):</p> <ul> <li>Command execution system</li> <li>Keychain integration</li> <li>XPC service implementation</li> <li>SSH key management</li> <li>Cloud provider integration</li> </ul>"},{"location":"archive/guides/ARCHITECTURE/#phase-2-advanced-features","title":"Phase 2: Advanced Features","text":"<p>Planned for Q2 2025:</p> <ul> <li>Repository management</li> <li>Scheduling system</li> <li>Network operations</li> <li>State persistence</li> </ul>"},{"location":"archive/guides/ARCHITECTURE/#phase-3-optimisation","title":"Phase 3: Optimisation","text":"<p>Scheduled for Q3 2025:</p> <ul> <li>Statistics &amp; analytics</li> <li>Health monitoring</li> <li>Event system</li> <li>Cache optimisation</li> </ul>"},{"location":"archive/guides/ARCHITECTURE/#design-principles","title":"Design Principles","text":""},{"location":"archive/guides/ARCHITECTURE/#1-security-first","title":"1. Security First","text":"<ul> <li>Secure by default</li> <li>Least privilege principle</li> <li>Comprehensive audit logging</li> <li>Regular security reviews</li> </ul>"},{"location":"archive/guides/ARCHITECTURE/#2-reliability","title":"2. Reliability","text":"<ul> <li>Comprehensive error handling</li> <li>Automatic retry mechanisms</li> <li>Circuit breakers</li> <li>Fallback strategies</li> </ul>"},{"location":"archive/guides/ARCHITECTURE/#3-performance","title":"3. Performance","text":"<ul> <li>Efficient resource usage</li> <li>Optimised I/O operations</li> <li>Memory management</li> <li>Cache strategies</li> </ul>"},{"location":"archive/guides/ARCHITECTURE/#4-maintainability","title":"4. Maintainability","text":"<ul> <li>Protocol-oriented design</li> <li>Clear documentation</li> <li>Comprehensive testing</li> <li>Code review process</li> </ul>"},{"location":"archive/guides/ARCHITECTURE/#integration-points","title":"Integration Points","text":"<p>UmbraCore serves as the foundation for:</p> <ul> <li>Rbum: Command-line interface</li> <li>Rbx: GUI application</li> <li>ResticBar: Menu bar application</li> </ul> <p>Each application utilises UmbraCore's components through well-defined protocols and interfaces.</p>"},{"location":"archive/guides/ARCHITECTURE/#testing-strategy_1","title":"Testing Strategy","text":"<p>Comprehensive testing approach:</p> <ol> <li>Unit Tests</li> <li>Component isolation</li> <li>Edge case coverage</li> <li> <p>Mock implementations</p> </li> <li> <p>Integration Tests</p> </li> <li>Component interaction</li> <li>System workflows</li> <li> <p>Error scenarios</p> </li> <li> <p>Performance Tests</p> </li> <li>Resource usage</li> <li>Throughput metrics</li> <li> <p>Scalability checks</p> </li> <li> <p>Security Tests</p> </li> <li>Vulnerability scanning</li> <li>Penetration testing</li> <li>Compliance verification</li> </ol>"},{"location":"archive/guides/bookmarks/","title":"UmbraBookmarkService Guide","text":""},{"location":"archive/guides/bookmarks/#overview","title":"Overview","text":"<p><code>UmbraBookmarkService</code> manages persistent file system access through security-scoped bookmarks. It provides safe and reliable access to files and directories across app launches.</p>"},{"location":"archive/guides/bookmarks/#features","title":"Features","text":"<ul> <li>Security-scoped bookmarks</li> <li>Persistent file access</li> <li>Thread-safe operations</li> <li>Automatic bookmark resolution</li> </ul>"},{"location":"archive/guides/bookmarks/#basic-usage","title":"Basic Usage","text":""},{"location":"archive/guides/bookmarks/#creating-bookmarks","title":"Creating Bookmarks","text":"<pre><code>let service = try UmbraBookmarkService()\n\n// Create bookmark for file\nlet fileURL = URL(fileURLWithPath: \"/path/to/file\")\ntry await service.create(\n    for: fileURL,\n    withName: \"important-file\"\n)\n\n// Create bookmark for directory\nlet dirURL = URL(fileURLWithPath: \"/path/to/directory\")\ntry await service.create(\n    for: dirURL,\n    withName: \"backup-directory\"\n)\n</code></pre>"},{"location":"archive/guides/bookmarks/#resolving-bookmarks","title":"Resolving Bookmarks","text":"<pre><code>// Get URL from bookmark\nlet fileURL = try await service.resolve(name: \"important-file\")\n\n// Access with scope\ntry await service.access(name: \"backup-directory\") { url in\n    // Work with URL within security scope\n    let contents = try FileManager.default.contentsOfDirectory(at: url)\n}\n</code></pre>"},{"location":"archive/guides/bookmarks/#removing-bookmarks","title":"Removing Bookmarks","text":"<pre><code>try await service.remove(name: \"important-file\")\n</code></pre>"},{"location":"archive/guides/bookmarks/#error-handling","title":"Error Handling","text":"<pre><code>do {\n    try await service.create(for: url, withName: name)\n} catch BookmarkError.invalidURL(let url) {\n    // Handle invalid URL\n} catch BookmarkError.accessDenied(let reason) {\n    // Handle access denied\n} catch {\n    // Handle other errors\n}\n</code></pre>"},{"location":"archive/guides/bookmarks/#best-practices","title":"Best Practices","text":""},{"location":"archive/guides/bookmarks/#1-bookmark-naming","title":"1. Bookmark Naming","text":"<ul> <li>Use descriptive names</li> <li>Include context</li> <li>Follow naming conventions</li> </ul> <pre><code>// Good\n\"main-backup-directory\"\n\"config-file-production\"\n\n// Bad\n\"bookmark1\"\n\"file\"\n</code></pre>"},{"location":"archive/guides/bookmarks/#2-access-scoping","title":"2. Access Scoping","text":"<ul> <li>Use scoped access</li> <li>Clean up resources</li> <li>Handle access errors</li> </ul>"},{"location":"archive/guides/bookmarks/#3-error-recovery","title":"3. Error Recovery","text":"<ul> <li>Implement retry logic</li> <li>Provide user feedback</li> <li>Log access failures</li> </ul>"},{"location":"archive/guides/bookmarks/#advanced-usage","title":"Advanced Usage","text":""},{"location":"archive/guides/bookmarks/#1-custom-bookmark-options","title":"1. Custom Bookmark Options","text":"<pre><code>let options = BookmarkOptions(\n    securityScope: .workingDirectory,\n    persistence: .permanent\n)\n\ntry await service.create(\n    for: url,\n    withName: name,\n    options: options\n)\n</code></pre>"},{"location":"archive/guides/bookmarks/#2-batch-operations","title":"2. Batch Operations","text":"<pre><code>let bookmarks = [\n    \"dir1\": url1,\n    \"dir2\": url2\n]\n\ntry await service.createBatch(bookmarks)\n</code></pre>"},{"location":"archive/guides/bookmarks/#3-access-control","title":"3. Access Control","text":"<pre><code>let access = BookmarkAccess(\n    scope: .minimal,\n    duration: .temporary\n)\n\ntry await service.access(\n    name: \"secure-directory\",\n    access: access\n) { url in\n    // Limited scope access\n}\n</code></pre>"},{"location":"archive/guides/bookmarks/#integration-examples","title":"Integration Examples","text":""},{"location":"archive/guides/bookmarks/#1-backup-directory-management","title":"1. Backup Directory Management","text":"<pre><code>class BackupManager {\n    private let bookmarks: UmbraBookmarkService\n\n    init() throws {\n        bookmarks = try UmbraBookmarkService()\n    }\n\n    func configureBackupDirectory(_ url: URL) async throws {\n        // Create persistent bookmark\n        try await bookmarks.create(\n            for: url,\n            withName: \"backup-root\"\n        )\n    }\n\n    func performBackup() async throws {\n        try await bookmarks.access(\"backup-root\") { url in\n            // Perform backup operations\n            try await backupContents(of: url)\n        }\n    }\n}\n</code></pre>"},{"location":"archive/guides/bookmarks/#2-configuration-file-access","title":"2. Configuration File Access","text":"<pre><code>class ConfigManager {\n    private let bookmarks: UmbraBookmarkService\n\n    func saveConfig(_ config: Config) async throws {\n        try await bookmarks.access(\"config-file\") { url in\n            let data = try JSONEncoder().encode(config)\n            try data.write(to: url)\n        }\n    }\n}\n</code></pre>"},{"location":"archive/guides/bookmarks/#troubleshooting","title":"Troubleshooting","text":""},{"location":"archive/guides/bookmarks/#common-issues","title":"Common Issues","text":"<ol> <li> <p>Stale Bookmarks <pre><code>// Refresh bookmark if stale\nif await service.isStale(name: \"backup-dir\") {\n    try await service.refresh(name: \"backup-dir\")\n}\n</code></pre></p> </li> <li> <p>Access Denied <pre><code>// Request user permission if needed\nfunc ensureAccess(to name: String) async throws {\n    do {\n        try await service.verifyAccess(name: name)\n    } catch BookmarkError.accessDenied {\n        try await requestUserPermission(for: name)\n    }\n}\n</code></pre></p> </li> <li> <p>Resource Management <pre><code>// Proper resource cleanup\nfunc processDirectory() async throws {\n    try await service.access(\"work-dir\") { url in\n        defer {\n            // Cleanup code\n        }\n\n        // Process directory\n    }\n}\n</code></pre></p> </li> </ol>"},{"location":"archive/guides/crypto-types/","title":"Cryptographic Types","text":"<p>This guide covers the cryptographic types used in UmbraCore for secure data handling.</p>"},{"location":"archive/guides/crypto-types/#overview","title":"Overview","text":"<p>UmbraCore provides several cryptographic types to ensure secure handling of sensitive data:</p> <ul> <li><code>SecureString</code>: For handling passwords and other sensitive strings</li> <li><code>EncryptedData</code>: For encrypted binary data</li> <li><code>KeyMaterial</code>: For cryptographic key material</li> </ul>"},{"location":"archive/guides/crypto-types/#securestring","title":"SecureString","text":"<p><code>SecureString</code> provides secure storage for sensitive string data:</p> <pre><code>let password = SecureString(\"sensitive-data\")\n// Memory is automatically zeroed when deallocated\n</code></pre>"},{"location":"archive/guides/crypto-types/#encrypteddata","title":"EncryptedData","text":"<p><code>EncryptedData</code> handles encrypted binary data:</p> <pre><code>let encrypted = EncryptedData(data: someData, key: keyMaterial)\nlet decrypted = try encrypted.decrypt(using: keyMaterial)\n</code></pre>"},{"location":"archive/guides/crypto-types/#keymaterial","title":"KeyMaterial","text":"<p><code>KeyMaterial</code> manages cryptographic keys:</p> <pre><code>let key = try KeyMaterial.generate()\nlet derived = try key.deriveKey(salt: salt, rounds: 100_000)\n</code></pre>"},{"location":"archive/guides/crypto-types/#best-practices","title":"Best Practices","text":"<ol> <li>Always use <code>SecureString</code> for passwords and sensitive data</li> <li>Zero memory after use</li> <li>Use appropriate key derivation functions</li> <li>Implement proper key rotation</li> <li>Follow cryptographic hygiene</li> </ol>"},{"location":"archive/guides/crypto/","title":"UmbraCryptoService Guide","text":""},{"location":"archive/guides/crypto/#overview","title":"Overview","text":"<p><code>UmbraCryptoService</code> provides cryptographic operations for securing sensitive data. It supports encryption, decryption, and key management.</p>"},{"location":"archive/guides/crypto/#features","title":"Features","text":"<ul> <li>Secure encryption/decryption</li> <li>Key management</li> <li>Thread-safe operations</li> <li>XPC-based processing</li> </ul>"},{"location":"archive/guides/crypto/#basic-usage","title":"Basic Usage","text":""},{"location":"archive/guides/crypto/#encryption","title":"Encryption","text":"<pre><code>let service = try UmbraCryptoService()\n\n// Encrypt data\nlet data = \"sensitive data\".data(using: .utf8)!\nlet encrypted = try await service.encrypt(data)\n\n// Encrypt with custom key\nlet key = try service.generateKey()\nlet customEncrypted = try await service.encrypt(data, using: key)\n</code></pre>"},{"location":"archive/guides/crypto/#decryption","title":"Decryption","text":"<pre><code>// Decrypt data\nlet decrypted = try await service.decrypt(encrypted)\n\n// Decrypt with custom key\nlet customDecrypted = try await service.decrypt(customEncrypted, using: key)\n</code></pre>"},{"location":"archive/guides/crypto/#key-management","title":"Key Management","text":"<pre><code>// Generate new key\nlet key = try service.generateKey()\n\n// Export key (protected)\nlet exportedKey = try service.exportKey(key)\n\n// Import key\nlet importedKey = try service.importKey(exportedKey)\n</code></pre>"},{"location":"archive/guides/crypto/#error-handling","title":"Error Handling","text":"<pre><code>do {\n    let encrypted = try await service.encrypt(data)\n} catch CryptoError.invalidKey {\n    // Handle invalid key\n} catch CryptoError.encryptionFailed(let reason) {\n    // Handle encryption failure\n} catch {\n    // Handle other errors\n}\n</code></pre>"},{"location":"archive/guides/crypto/#best-practices","title":"Best Practices","text":""},{"location":"archive/guides/crypto/#1-key-management","title":"1. Key Management","text":"<ul> <li>Rotate keys regularly</li> <li>Secure key storage</li> <li>Use key derivation when appropriate</li> </ul>"},{"location":"archive/guides/crypto/#2-data-protection","title":"2. Data Protection","text":"<ul> <li>Encrypt sensitive data immediately</li> <li>Clear sensitive data from memory</li> <li>Use secure random generation</li> </ul>"},{"location":"archive/guides/crypto/#3-error-recovery","title":"3. Error Recovery","text":"<ul> <li>Implement retry logic</li> <li>Log cryptographic failures</li> <li>Provide appropriate user feedback</li> </ul>"},{"location":"archive/guides/crypto/#advanced-usage","title":"Advanced Usage","text":""},{"location":"archive/guides/crypto/#1-custom-encryption-parameters","title":"1. Custom Encryption Parameters","text":"<pre><code>let params = EncryptionParameters(\n    algorithm: .aes256GCM,\n    keySize: .bits256,\n    iterations: 10000\n)\n\nlet encrypted = try await service.encrypt(\n    data,\n    parameters: params\n)\n</code></pre>"},{"location":"archive/guides/crypto/#2-key-derivation","title":"2. Key Derivation","text":"<pre><code>let derivedKey = try service.deriveKey(\n    fromPassword: \"user-password\",\n    salt: salt,\n    iterations: 10000\n)\n</code></pre>"},{"location":"archive/guides/crypto/#3-batch-operations","title":"3. Batch Operations","text":"<pre><code>let dataItems = [\n    \"item1\": data1,\n    \"item2\": data2\n]\n\nlet encrypted = try await service.encryptBatch(dataItems)\n</code></pre>"},{"location":"archive/guides/crypto/#integration-examples","title":"Integration Examples","text":""},{"location":"archive/guides/crypto/#1-secure-configuration","title":"1. Secure Configuration","text":"<pre><code>class SecureConfig {\n    private let crypto: UmbraCryptoService\n\n    init() throws {\n        crypto = try UmbraCryptoService()\n    }\n\n    func saveConfig(_ config: Config) async throws {\n        let data = try JSONEncoder().encode(config)\n        let encrypted = try await crypto.encrypt(data)\n\n        try await FileManager.default.createFile(\n            at: configURL,\n            contents: encrypted\n        )\n    }\n}\n</code></pre>"},{"location":"archive/guides/crypto/#2-secure-data-transfer","title":"2. Secure Data Transfer","text":"<pre><code>class SecureTransfer {\n    private let crypto: UmbraCryptoService\n\n    func secureUpload(_ data: Data) async throws {\n        // Encrypt before upload\n        let encrypted = try await crypto.encrypt(data)\n\n        // Upload encrypted data\n        try await uploadToServer(encrypted)\n    }\n}\n</code></pre>"},{"location":"archive/guides/crypto/#troubleshooting","title":"Troubleshooting","text":""},{"location":"archive/guides/crypto/#common-issues","title":"Common Issues","text":"<ol> <li> <p>Key Validation <pre><code>// Validate key before use\nguard try service.validateKey(key) else {\n    throw CryptoError.invalidKey\n}\n</code></pre></p> </li> <li> <p>Memory Management <pre><code>// Clear sensitive data\ndefer {\n    key.zero()\n    plaintext.zero()\n}\n</code></pre></p> </li> <li> <p>Performance Optimization <pre><code>// Use batch operations for multiple items\nlet results = try await withThrowingTaskGroup(of: (String, Data).self) { group in\n    for (id, data) in items {\n        group.addTask {\n            let encrypted = try await service.encrypt(data)\n            return (id, encrypted)\n        }\n    }\n    return try await group.reduce(into: [:]) { $0[$1.0] = $1.1 }\n}\n</code></pre></p> </li> </ol>"},{"location":"archive/guides/error-handling/","title":"Error Handling in UmbraCore","text":""},{"location":"archive/guides/error-handling/#overview","title":"Overview","text":"<p>UmbraCore uses a structured error handling system that provides detailed error context, supports error recovery, and integrates with the logging system. This guide explains our error handling patterns and best practices.</p>"},{"location":"archive/guides/error-handling/#error-types","title":"Error Types","text":""},{"location":"archive/guides/error-handling/#1-common-errors","title":"1. Common Errors","text":"<p>Base error types shared across the library:</p> <pre><code>enum CommonError: Error {\n    case invalidArgument(String)\n    case resourceNotFound(String)\n    case permissionDenied(String)\n    case operationFailed(String)\n\n    var localizedDescription: String {\n        switch self {\n        case .invalidArgument(let details):\n            return \"Invalid argument: \\(details)\"\n        case .resourceNotFound(let resource):\n            return \"Resource not found: \\(resource)\"\n        case .permissionDenied(let operation):\n            return \"Permission denied for operation: \\(operation)\"\n        case .operationFailed(let reason):\n            return \"Operation failed: \\(reason)\"\n        }\n    }\n}\n</code></pre>"},{"location":"archive/guides/error-handling/#2-service-specific-errors","title":"2. Service-Specific Errors","text":"<p>Each service defines its domain-specific errors:</p> <pre><code>enum KeychainError: Error {\n    case itemNotFound(String)\n    case duplicateItem(String)\n    case accessDenied(String)\n    case invalidData(String)\n}\n\nenum CryptoError: Error {\n    case encryptionFailed(String)\n    case decryptionFailed(String)\n    case invalidKey(String)\n    case algorithmNotSupported(String)\n}\n</code></pre>"},{"location":"archive/guides/error-handling/#3-error-context","title":"3. Error Context","text":"<p>Additional context for debugging and recovery:</p> <pre><code>struct ErrorContext {\n    let file: String\n    let function: String\n    let line: Int\n    let timestamp: Date\n    let operationId: UUID\n    var userInfo: [String: Any]\n\n    var description: String {\n        \"\"\"\n        Error occurred in \\(function)\n        File: \\(file):\\(line)\n        Time: \\(timestamp)\n        Operation: \\(operationId)\n        Additional Info: \\(userInfo)\n        \"\"\"\n    }\n}\n</code></pre>"},{"location":"archive/guides/error-handling/#best-practices","title":"Best Practices","text":""},{"location":"archive/guides/error-handling/#1-error-creation","title":"1. Error Creation","text":"<p>Create informative errors with context:</p> <pre><code>func processFile(_ url: URL) async throws {\n    guard FileManager.default.fileExists(atPath: url.path) else {\n        throw CommonError.resourceNotFound(\n            \"\"\"\n            File not found at \\(url.path)\n            Check if the file exists and you have read permissions.\n            \"\"\"\n        )\n    }\n}\n</code></pre>"},{"location":"archive/guides/error-handling/#2-error-handling","title":"2. Error Handling","text":"<p>Handle errors at appropriate levels:</p> <pre><code>func backupFiles() async throws {\n    do {\n        try await validatePermissions()\n        try await performBackup()\n        try await verifyBackup()\n    } catch KeychainError.accessDenied(let details) {\n        logger.error(\"Keychain access denied\", metadata: [\n            \"details\": details,\n            \"operation\": \"backup\"\n        ])\n        throw CommonError.permissionDenied(\"Keychain access required for backup\")\n    } catch CryptoError.encryptionFailed(let reason) {\n        logger.error(\"Encryption failed\", metadata: [\n            \"reason\": reason,\n            \"operation\": \"backup\"\n        ])\n        throw CommonError.operationFailed(\"Backup encryption failed\")\n    }\n}\n</code></pre>"},{"location":"archive/guides/error-handling/#3-error-recovery","title":"3. Error Recovery","text":"<p>Implement recovery strategies:</p> <pre><code>actor RetryableOperation {\n    func execute() async throws -&gt; Result {\n        var attempts = 0\n        while attempts &lt; maxRetries {\n            do {\n                return try await performOperation()\n            } catch let error as RecoverableError {\n                attempts += 1\n                try await handleError(error, attempt: attempts)\n            } catch {\n                throw error // Non-recoverable error\n            }\n        }\n        throw CommonError.operationFailed(\"Max retry attempts exceeded\")\n    }\n}\n</code></pre>"},{"location":"archive/guides/error-handling/#error-patterns","title":"Error Patterns","text":""},{"location":"archive/guides/error-handling/#1-result-type-usage","title":"1. Result Type Usage","text":"<p>For operations that might fail:</p> <pre><code>enum OperationResult&lt;T&gt; {\n    case success(T)\n    case failure(Error)\n    case partial(T, [Error])\n\n    var value: T? {\n        switch self {\n        case .success(let value), .partial(let value, _):\n            return value\n        case .failure:\n            return nil\n        }\n    }\n}\n\nfunc processItems(_ items: [Item]) async -&gt; OperationResult&lt;[ProcessedItem]&gt; {\n    var processed: [ProcessedItem] = []\n    var errors: [Error] = []\n\n    for item in items {\n        do {\n            let result = try await process(item)\n            processed.append(result)\n        } catch {\n            errors.append(error)\n        }\n    }\n\n    if errors.isEmpty {\n        return .success(processed)\n    } else if processed.isEmpty {\n        return .failure(CommonError.operationFailed(\"All items failed\"))\n    } else {\n        return .partial(processed, errors)\n    }\n}\n</code></pre>"},{"location":"archive/guides/error-handling/#2-error-transformation","title":"2. Error Transformation","text":"<p>Convert between error types while preserving context:</p> <pre><code>extension Error {\n    func asCommonError() -&gt; CommonError {\n        switch self {\n        case let error as KeychainError:\n            return error.toCommonError()\n        case let error as CryptoError:\n            return error.toCommonError()\n        default:\n            return .operationFailed(localizedDescription)\n        }\n    }\n}\n\nextension KeychainError {\n    func toCommonError() -&gt; CommonError {\n        switch self {\n        case .accessDenied(let details):\n            return .permissionDenied(\"Keychain: \\(details)\")\n        case .itemNotFound(let key):\n            return .resourceNotFound(\"Keychain item: \\(key)\")\n        // ... other cases\n        }\n    }\n}\n</code></pre>"},{"location":"archive/guides/error-handling/#3-async-error-handling","title":"3. Async Error Handling","text":"<p>Handle errors in async contexts:</p> <pre><code>actor ErrorHandler {\n    func handle&lt;T&gt;(_ operation: @escaping () async throws -&gt; T) async throws -&gt; T {\n        do {\n            return try await operation()\n        } catch {\n            try await logError(error)\n            try await notifyObservers(of: error)\n            throw error\n        }\n    }\n}\n</code></pre>"},{"location":"archive/guides/error-handling/#integration-with-logging","title":"Integration with Logging","text":""},{"location":"archive/guides/error-handling/#1-error-logging","title":"1. Error Logging","text":"<p>Log errors with context:</p> <pre><code>extension Logger {\n    func logError(\n        _ error: Error,\n        context: ErrorContext,\n        file: String = #file,\n        function: String = #function,\n        line: Int = #line\n    ) {\n        error(\n            \"Error occurred\",\n            metadata: [\n                \"error\": \"\\(error)\",\n                \"context\": \"\\(context)\",\n                \"file\": \"\\(file)\",\n                \"function\": \"\\(function)\",\n                \"line\": \"\\(line)\"\n            ]\n        )\n    }\n}\n</code></pre>"},{"location":"archive/guides/error-handling/#2-error-monitoring","title":"2. Error Monitoring","text":"<p>Track error patterns:</p> <pre><code>actor ErrorMonitor {\n    private var errorCounts: [String: Int] = [:]\n\n    func record(_ error: Error) async {\n        let key = String(describing: type(of: error))\n        errorCounts[key, default: 0] += 1\n\n        if errorCounts[key] ?? 0 &gt; threshold {\n            await notifyHighErrorRate(type: key)\n        }\n    }\n}\n</code></pre>"},{"location":"archive/guides/error-handling/#testing","title":"Testing","text":""},{"location":"archive/guides/error-handling/#1-error-scenarios","title":"1. Error Scenarios","text":"<p>Test error handling paths:</p> <pre><code>func testErrorHandling() async throws {\n    let service = TestService()\n\n    do {\n        try await service.operationThatFails()\n        XCTFail(\"Expected error not thrown\")\n    } catch let error as CommonError {\n        XCTAssertEqual(\n            error.localizedDescription,\n            \"Expected error message\"\n        )\n    }\n}\n</code></pre>"},{"location":"archive/guides/error-handling/#2-recovery-testing","title":"2. Recovery Testing","text":"<p>Test error recovery mechanisms:</p> <pre><code>func testErrorRecovery() async throws {\n    let operation = RetryableOperation()\n\n    // Inject failures\n    operation.injectFailures(count: 2)\n\n    // Should succeed after retries\n    let result = try await operation.execute()\n    XCTAssertNotNil(result)\n}\n</code></pre>"},{"location":"archive/guides/error-handling/#3-error-context-testing","title":"3. Error Context Testing","text":"<p>Verify error context information:</p> <p>```swift func testErrorContext() async throws {     let operation = ContextualOperation()</p> <pre><code>do {\n    try await operation.execute()\n    XCTFail(\"Expected error not thrown\")\n} catch {\n    let context = try XCTUnwrap(error.errorContext)\n    XCTAssertEqual(context.function, \"execute\")\n    XCTAssertNotNil(context.operationId)\n}\n</code></pre> <p>}</p>"},{"location":"archive/guides/keychain/","title":"UmbraKeychainService Guide","text":""},{"location":"archive/guides/keychain/#overview","title":"Overview","text":"<p><code>UmbraKeychainService</code> provides secure credential storage using macOS Keychain. It handles repository passwords, API keys, and other sensitive data.</p>"},{"location":"archive/guides/keychain/#features","title":"Features","text":"<ul> <li>Secure credential storage</li> <li>XPC-based access</li> <li>Thread-safe operations</li> <li>Automatic error handling</li> </ul>"},{"location":"archive/guides/keychain/#basic-usage","title":"Basic Usage","text":""},{"location":"archive/guides/keychain/#storing-credentials","title":"Storing Credentials","text":"<pre><code>let service = try UmbraKeychainService()\n\n// Store a repository password\ntry await service.store(\n    password: \"secret-password\",\n    forKey: \"backup-repository\"\n)\n\n// Store an API key\ntry await service.store(\n    password: \"api-key-12345\",\n    forKey: \"cloud-provider\"\n)\n</code></pre>"},{"location":"archive/guides/keychain/#retrieving-credentials","title":"Retrieving Credentials","text":"<pre><code>// Get repository password\nlet password = try await service.retrieve(forKey: \"backup-repository\")\n\n// Get API key\nlet apiKey = try await service.retrieve(forKey: \"cloud-provider\")\n</code></pre>"},{"location":"archive/guides/keychain/#updating-credentials","title":"Updating Credentials","text":"<pre><code>try await service.update(\n    password: \"new-password\",\n    forKey: \"backup-repository\"\n)\n</code></pre>"},{"location":"archive/guides/keychain/#removing-credentials","title":"Removing Credentials","text":"<pre><code>try await service.remove(forKey: \"backup-repository\")\n</code></pre>"},{"location":"archive/guides/keychain/#error-handling","title":"Error Handling","text":"<pre><code>do {\n    try await service.store(password: \"secret\", forKey: \"key\")\n} catch KeychainError.duplicateItem(let key) {\n    // Handle duplicate item\n} catch KeychainError.accessDenied(let reason) {\n    // Handle access denied\n} catch {\n    // Handle other errors\n}\n</code></pre>"},{"location":"archive/guides/keychain/#best-practices","title":"Best Practices","text":""},{"location":"archive/guides/keychain/#1-key-naming","title":"1. Key Naming","text":"<ul> <li>Use descriptive, consistent keys</li> <li>Include context in key names</li> <li>Follow naming conventions</li> </ul> <pre><code>// Good\n\"backup-repo-main-password\"\n\"aws-access-key-prod\"\n\n// Bad\n\"pwd1\"\n\"key\"\n</code></pre>"},{"location":"archive/guides/keychain/#2-error-recovery","title":"2. Error Recovery","text":"<ul> <li>Implement retry logic</li> <li>Provide user feedback</li> <li>Log failures appropriately</li> </ul>"},{"location":"archive/guides/keychain/#3-security","title":"3. Security","text":"<ul> <li>Never store keys in code</li> <li>Use appropriate access control</li> <li>Clean up unused credentials</li> </ul>"},{"location":"archive/guides/keychain/#advanced-usage","title":"Advanced Usage","text":""},{"location":"archive/guides/keychain/#1-custom-item-attributes","title":"1. Custom Item Attributes","text":"<pre><code>let attributes = KeychainItemAttributes(\n    label: \"Main Backup Repository\",\n    comment: \"Production backup credentials\"\n)\n\ntry await service.store(\n    password: \"secret\",\n    forKey: \"backup-repo\",\n    attributes: attributes\n)\n</code></pre>"},{"location":"archive/guides/keychain/#2-batch-operations","title":"2. Batch Operations","text":"<pre><code>let credentials = [\n    \"repo1\": \"password1\",\n    \"repo2\": \"password2\"\n]\n\ntry await service.storeBatch(credentials)\n</code></pre>"},{"location":"archive/guides/keychain/#3-access-control","title":"3. Access Control","text":"<pre><code>let access = KeychainAccess(\n    accessibility: .whenUnlocked,\n    authentication: .biometric\n)\n\ntry await service.store(\n    password: \"secret\",\n    forKey: \"secure-key\",\n    access: access\n)\n</code></pre>"},{"location":"archive/guides/keychain/#integration-examples","title":"Integration Examples","text":""},{"location":"archive/guides/keychain/#1-repository-setup","title":"1. Repository Setup","text":"<pre><code>func setupRepository() async throws {\n    let service = try UmbraKeychainService()\n\n    // Store repository password\n    try await service.store(\n        password: repositoryPassword,\n        forKey: \"repo-\\(repoId)\"\n    )\n\n    // Store cloud credentials if needed\n    if let cloudKey = cloudCredentials {\n        try await service.store(\n            password: cloudKey,\n            forKey: \"cloud-\\(repoId)\"\n        )\n    }\n}\n</code></pre>"},{"location":"archive/guides/keychain/#2-credential-management","title":"2. Credential Management","text":"<pre><code>class CredentialManager {\n    private let keychain: UmbraKeychainService\n\n    init() throws {\n        keychain = try UmbraKeychainService()\n    }\n\n    func rotateCredentials() async throws {\n        let newPassword = generateSecurePassword()\n\n        try await keychain.update(\n            password: newPassword,\n            forKey: \"repo-main\"\n        )\n\n        try await updateRemoteRepository(password: newPassword)\n    }\n}\n</code></pre>"},{"location":"archive/guides/keychain/#troubleshooting","title":"Troubleshooting","text":""},{"location":"archive/guides/keychain/#common-issues","title":"Common Issues","text":"<ol> <li> <p>Access Denied <pre><code>// Check keychain access\ntry await service.checkAccess()\n\n// Request user permission if needed\ntry await service.requestAccess()\n</code></pre></p> </li> <li> <p>Duplicate Items <pre><code>// Update instead of store for existing items\nif await service.exists(forKey: key) {\n    try await service.update(password: newPassword, forKey: key)\n} else {\n    try await service.store(password: newPassword, forKey: key)\n}\n</code></pre></p> </li> <li> <p>Item Not Found <pre><code>// Implement fallback logic\nfunc getCredential(forKey key: String) async throws -&gt; String {\n    do {\n        return try await service.retrieve(forKey: key)\n    } catch KeychainError.itemNotFound {\n        // Implement recovery logic\n        return try await recoverCredential(forKey: key)\n    }\n}\n</code></pre></p> </li> </ol>"},{"location":"archive/guides/logging/","title":"UmbraLogging Guide","text":""},{"location":"archive/guides/logging/#overview","title":"Overview","text":"<p><code>UmbraLogging</code> provides a centralised, structured logging system built on SwiftyBeaver. It supports multiple destinations, log levels, and contextual metadata.</p>"},{"location":"archive/guides/logging/#features","title":"Features","text":"<ul> <li>Structured logging</li> <li>Multiple log levels</li> <li>Context metadata</li> <li>File output</li> <li>Console output</li> <li>Custom formatters</li> </ul>"},{"location":"archive/guides/logging/#basic-usage","title":"Basic Usage","text":""},{"location":"archive/guides/logging/#configuration","title":"Configuration","text":"<pre><code>import UmbraLogging\n\n// Basic setup\nUmbraLogger.configure(level: .info)\n\n// Custom configuration\nlet config = LoggerConfiguration(\n    level: .debug,\n    destinations: [.console, .file],\n    metadata: [\"app\": \"UmbraCore\"]\n)\nUmbraLogger.configure(config)\n</code></pre>"},{"location":"archive/guides/logging/#logging-messages","title":"Logging Messages","text":"<pre><code>// Basic logging\nlogger.info(\"Backup started\")\nlogger.error(\"Failed to access repository\")\n\n// With metadata\nlogger.info(\"File processed\", metadata: [\n    \"size\": fileSize,\n    \"path\": filePath\n])\n\n// With error context\nlogger.error(\"Backup failed\", error: error, metadata: [\n    \"repository\": repoId,\n    \"files\": fileCount\n])\n</code></pre>"},{"location":"archive/guides/logging/#log-levels","title":"Log Levels","text":""},{"location":"archive/guides/logging/#available-levels","title":"Available Levels","text":"<pre><code>// Verbose - detailed information\nlogger.verbose(\"Entering backup loop\")\n\n// Debug - debugging information\nlogger.debug(\"Processing file: \\(filename)\")\n\n// Info - general information\nlogger.info(\"Backup completed successfully\")\n\n// Warning - potential issues\nlogger.warning(\"Repository space low\")\n\n// Error - operation failures\nlogger.error(\"Failed to store credential\")\n\n// Critical - system-wide issues\nlogger.critical(\"Database corruption detected\")\n</code></pre>"},{"location":"archive/guides/logging/#best-practices","title":"Best Practices","text":""},{"location":"archive/guides/logging/#1-log-level-selection","title":"1. Log Level Selection","text":"<pre><code>// Development\n#if DEBUG\n    UmbraLogger.configure(level: .debug)\n#else\n    UmbraLogger.configure(level: .info)\n#endif\n\n// Production with environment override\nif let levelString = Environment.logLevel {\n    UmbraLogger.configure(level: LogLevel(string: levelString))\n}\n</code></pre>"},{"location":"archive/guides/logging/#2-contextual-information","title":"2. Contextual Information","text":"<pre><code>// Add operation context\nlogger.info(\"Starting backup\", metadata: [\n    \"operation\": \"backup\",\n    \"type\": \"incremental\",\n    \"source\": sourcePath,\n    \"destination\": destPath\n])\n\n// Add error context\nlogger.error(\"Operation failed\", metadata: [\n    \"operation\": operation.name,\n    \"duration\": duration,\n    \"retries\": retryCount,\n    \"error\": error.localizedDescription\n])\n</code></pre>"},{"location":"archive/guides/logging/#3-sensitive-data","title":"3. Sensitive Data","text":"<pre><code>// Never log credentials\nlogger.info(\"Connecting to repository\", metadata: [\n    \"url\": repository.url,\n    \"type\": repository.type\n    // DON'T include passwords or keys\n])\n\n// Mask sensitive data\nlogger.info(\"User authenticated\", metadata: [\n    \"user\": user.id,\n    \"token\": \"****\" // Masked token\n])\n</code></pre>"},{"location":"archive/guides/logging/#advanced-usage","title":"Advanced Usage","text":""},{"location":"archive/guides/logging/#1-custom-destinations","title":"1. Custom Destinations","text":"<pre><code>let customDestination = LogDestination(\n    identifier: \"analytics\",\n    minimumLevel: .info,\n    formatter: AnalyticsFormatter()\n)\n\nUmbraLogger.addDestination(customDestination)\n</code></pre>"},{"location":"archive/guides/logging/#2-custom-formatters","title":"2. Custom Formatters","text":"<pre><code>class JSONFormatter: LogFormatter {\n    func format(_ entry: LogEntry) -&gt; String {\n        let json: [String: Any] = [\n            \"timestamp\": entry.timestamp,\n            \"level\": entry.level.rawValue,\n            \"message\": entry.message,\n            \"metadata\": entry.metadata\n        ]\n        return try! JSONSerialization.data(withJSONObject: json)\n    }\n}\n</code></pre>"},{"location":"archive/guides/logging/#3-context-managers","title":"3. Context Managers","text":"<pre><code>class OperationContext {\n    private var metadata: [String: Any]\n\n    func execute(_ operation: String) async throws {\n        logger.withMetadata(metadata) {\n            logger.info(\"Starting operation\")\n            // Execute operation\n            logger.info(\"Operation completed\")\n        }\n    }\n}\n</code></pre>"},{"location":"archive/guides/logging/#integration-examples","title":"Integration Examples","text":""},{"location":"archive/guides/logging/#1-service-integration","title":"1. Service Integration","text":"<pre><code>class BackupService {\n    private let logger = UmbraLogger.forModule(\"BackupService\")\n\n    func performBackup() async throws {\n        logger.info(\"Starting backup\", metadata: [\n            \"type\": backupType,\n            \"files\": fileCount\n        ])\n\n        do {\n            try await runBackup()\n            logger.info(\"Backup completed\")\n        } catch {\n            logger.error(\"Backup failed\", error: error)\n            throw error\n        }\n    }\n}\n</code></pre>"},{"location":"archive/guides/logging/#2-error-tracking","title":"2. Error Tracking","text":"<pre><code>class ErrorTracker {\n    private let logger = UmbraLogger.forModule(\"ErrorTracker\")\n\n    func track(_ error: Error, context: [String: Any]) {\n        logger.error(\"Error occurred\", metadata: [\n            \"error\": error.localizedDescription,\n            \"type\": String(describing: type(of: error)),\n            \"context\": context\n        ])\n    }\n}\n</code></pre>"},{"location":"archive/guides/logging/#troubleshooting","title":"Troubleshooting","text":""},{"location":"archive/guides/logging/#common-issues","title":"Common Issues","text":"<ol> <li> <p>Log File Management <pre><code>// Rotate log files\nUmbraLogger.configure(\n    fileConfig: FileConfiguration(\n        directory: logDirectory,\n        maxFileSize: 10_000_000,  // 10MB\n        maxFileCount: 5\n    )\n)\n</code></pre></p> </li> <li> <p>Performance Optimization <pre><code>// Avoid expensive logging in production\nif logger.isEnabled(for: .debug) {\n    let expensive = calculateExpensiveMetadata()\n    logger.debug(\"Details\", metadata: expensive)\n}\n</code></pre></p> </li> <li> <p>Error Investigation <pre><code>// Enable full debug logging temporarily\nUmbraLogger.configure(\n    level: .verbose,\n    destinations: [.console, .file],\n    metadata: [\"debug\": true]\n)\n</code></pre></p> </li> </ol>"},{"location":"archive/guides/performance/","title":"Performance Optimisation in UmbraCore","text":""},{"location":"archive/guides/performance/#overview","title":"Overview","text":"<p>Performance is crucial for backup operations. This guide covers performance optimisation techniques used in UmbraCore and best practices for maintaining high performance.</p>"},{"location":"archive/guides/performance/#core-principles","title":"Core Principles","text":""},{"location":"archive/guides/performance/#1-asynchronous-operations","title":"1. Asynchronous Operations","text":"<p>Leverage Swift's async/await for non-blocking operations:</p> <pre><code>actor BackupCoordinator {\n    func backupMultipleDirectories(_ paths: [String]) async throws {\n        try await withThrowingTaskGroup(of: Void.self) { group in\n            for path in paths {\n                group.addTask {\n                    try await backupDirectory(path)\n                }\n            }\n            try await group.waitForAll()\n        }\n    }\n}\n</code></pre>"},{"location":"archive/guides/performance/#2-memory-management","title":"2. Memory Management","text":"<p>Efficient memory usage patterns:</p> <pre><code>actor StreamProcessor {\n    // Use streams for large data\n    func processLargeFile(_ url: URL) async throws {\n        for try await line in url.lines {\n            try await processLine(line)\n        }\n    }\n\n    // Batch small operations\n    func processBatch(_ items: [Item]) async throws {\n        let batchSize = 100\n        for batch in items.chunked(into: batchSize) {\n            try await processBatchItems(batch)\n        }\n    }\n}\n</code></pre>"},{"location":"archive/guides/performance/#3-resource-pooling","title":"3. Resource Pooling","text":"<p>Pool and reuse expensive resources:</p> <pre><code>actor ConnectionPool {\n    private var connections: [Connection] = []\n    private let maxConnections = 10\n\n    func acquire() async throws -&gt; Connection {\n        if let connection = connections.popLast() {\n            return connection\n        }\n\n        guard connections.count &lt; maxConnections else {\n            throw PoolError.maxConnectionsReached\n        }\n\n        return try await createConnection()\n    }\n\n    func release(_ connection: Connection) async {\n        if connections.count &lt; maxConnections {\n            connections.append(connection)\n        } else {\n            await connection.close()\n        }\n    }\n}\n</code></pre>"},{"location":"archive/guides/performance/#optimisation-techniques","title":"Optimisation Techniques","text":""},{"location":"archive/guides/performance/#1-caching","title":"1. Caching","text":"<p>Implement efficient caching strategies:</p> <pre><code>actor CacheManager {\n    private var cache = NSCache&lt;NSString, AnyObject&gt;()\n    private let fileManager = FileManager.default\n\n    func cachedValue(\n        forKey key: String,\n        generator: () async throws -&gt; Any\n    ) async throws -&gt; Any {\n        // Check memory cache\n        if let cached = cache.object(forKey: key as NSString) {\n            return cached\n        }\n\n        // Generate new value\n        let value = try await generator()\n        cache.setObject(value as AnyObject, forKey: key as NSString)\n        return value\n    }\n\n    func clearStaleEntries() async {\n        // Implement cache eviction policy\n    }\n}\n</code></pre>"},{"location":"archive/guides/performance/#2-data-structures","title":"2. Data Structures","text":"<p>Choose appropriate data structures:</p> <pre><code>struct PerformanceOptimised {\n    // Use Set for fast lookups\n    private var processedItems: Set&lt;String&gt; = []\n\n    // Use Dictionary for O(1) access\n    private var itemCache: [String: Item] = [:]\n\n    // Use Array for ordered data\n    private var processingQueue: [Item] = []\n\n    // Use ContiguousArray for better performance with value types\n    private var metrics: ContiguousArray&lt;Double&gt; = []\n}\n</code></pre>"},{"location":"archive/guides/performance/#3-lazy-loading","title":"3. Lazy Loading","text":"<p>Defer expensive operations:</p> <pre><code>class LazyResource {\n    private lazy var expensiveResource: Resource = {\n        createExpensiveResource()\n    }()\n\n    private func createExpensiveResource() -&gt; Resource {\n        // Only created when first accessed\n        Resource(configuration: loadConfiguration())\n    }\n}\n</code></pre>"},{"location":"archive/guides/performance/#performance-monitoring","title":"Performance Monitoring","text":""},{"location":"archive/guides/performance/#1-metrics-collection","title":"1. Metrics Collection","text":"<p>Track performance metrics:</p> <pre><code>actor PerformanceMonitor {\n    private var metrics: [String: [TimeInterval]] = [:]\n\n    func measure&lt;T&gt;(\n        operation: String,\n        block: () async throws -&gt; T\n    ) async throws -&gt; T {\n        let start = ProcessInfo.processInfo.systemUptime\n        let result = try await block()\n        let duration = ProcessInfo.processInfo.systemUptime - start\n\n        await record(operation: operation, duration: duration)\n        return result\n    }\n\n    private func record(operation: String, duration: TimeInterval) {\n        metrics[operation, default: []].append(duration)\n\n        if metrics[operation]?.count ?? 0 &gt; 1000 {\n            metrics[operation]?.removeFirst(500)\n        }\n    }\n\n    func getMetrics(for operation: String) -&gt; PerformanceMetrics {\n        guard let measurements = metrics[operation] else {\n            return PerformanceMetrics.empty\n        }\n\n        return PerformanceMetrics(\n            average: measurements.average,\n            median: measurements.median,\n            percentile95: measurements.percentile(95),\n            count: measurements.count\n        )\n    }\n}\n</code></pre>"},{"location":"archive/guides/performance/#2-performance-logging","title":"2. Performance Logging","text":"<p>Log performance data:</p> <pre><code>extension Logger {\n    func logPerformance(\n        _ metrics: PerformanceMetrics,\n        operation: String,\n        file: String = #file,\n        function: String = #function\n    ) {\n        info(\n            \"Performance metrics\",\n            metadata: [\n                \"operation\": \"\\(operation)\",\n                \"average\": \"\\(metrics.average)\",\n                \"median\": \"\\(metrics.median)\",\n                \"p95\": \"\\(metrics.percentile95)\",\n                \"count\": \"\\(metrics.count)\",\n                \"file\": \"\\(file)\",\n                \"function\": \"\\(function)\"\n            ]\n        )\n    }\n}\n</code></pre>"},{"location":"archive/guides/performance/#3-alerts-and-thresholds","title":"3. Alerts and Thresholds","text":"<p>Monitor performance thresholds:</p> <pre><code>actor PerformanceAlert {\n    private let thresholds: [String: TimeInterval]\n    private let notifier: AlertNotifier\n\n    func checkThresholds(_ metrics: PerformanceMetrics, operation: String) async {\n        guard let threshold = thresholds[operation] else { return }\n\n        if metrics.percentile95 &gt; threshold {\n            await notifier.alert(\n                \"\"\"\n                Performance degradation detected:\n                Operation: \\(operation)\n                P95: \\(metrics.percentile95)\n                Threshold: \\(threshold)\n                \"\"\"\n            )\n        }\n    }\n}\n</code></pre>"},{"location":"archive/guides/performance/#best-practices","title":"Best Practices","text":""},{"location":"archive/guides/performance/#1-batch-processing","title":"1. Batch Processing","text":"<p>Batch operations for efficiency:</p> <pre><code>actor BatchProcessor {\n    private let batchSize = 100\n\n    func process(_ items: [Item]) async throws {\n        let batches = items.chunked(into: batchSize)\n\n        try await withThrowingTaskGroup(of: Void.self) { group in\n            for batch in batches {\n                group.addTask {\n                    try await processBatch(batch)\n                }\n            }\n            try await group.waitForAll()\n        }\n    }\n}\n</code></pre>"},{"location":"archive/guides/performance/#2-resource-management","title":"2. Resource Management","text":"<p>Proper resource cleanup:</p> <pre><code>class ManagedResource {\n    private var resources: [Resource] = []\n\n    func use&lt;T&gt;(_ resource: Resource, operation: (Resource) throws -&gt; T) throws -&gt; T {\n        resources.append(resource)\n        defer {\n            resource.cleanup()\n            resources.removeAll { $0 === resource }\n        }\n        return try operation(resource)\n    }\n}\n</code></pre>"},{"location":"archive/guides/performance/#3-background-processing","title":"3. Background Processing","text":"<p>Offload heavy work:</p> <pre><code>actor BackgroundProcessor {\n    private let queue = DispatchQueue(\n        label: \"com.umbracore.background\",\n        qos: .background\n    )\n\n    func processInBackground(_ work: @escaping () -&gt; Void) {\n        queue.async {\n            work()\n        }\n    }\n}\n</code></pre>"},{"location":"archive/guides/performance/#testing","title":"Testing","text":""},{"location":"archive/guides/performance/#1-performance-tests","title":"1. Performance Tests","text":"<p>Test performance metrics:</p> <pre><code>class PerformanceTests: XCTestCase {\n    func testOperationPerformance() throws {\n        measure {\n            // Performance-critical code\n        }\n    }\n\n    func testAsyncPerformance() async throws {\n        let metrics = try await measureAsync {\n            try await performOperation()\n        }\n\n        XCTAssertLessThan(metrics.average, 0.1)\n        XCTAssertLessThan(metrics.percentile95, 0.2)\n    }\n}\n</code></pre>"},{"location":"archive/guides/performance/#2-memory-tests","title":"2. Memory Tests","text":"<p>Test memory usage:</p> <pre><code>class MemoryTests: XCTestCase {\n    func testMemoryUsage() throws {\n        let tracker = MemoryTracker()\n\n        autoreleasepool {\n            // Memory-intensive operation\n        }\n\n        XCTAssertLessThan(\n            tracker.peakMemoryUsage,\n            50 * 1024 * 1024 // 50MB\n        )\n    }\n}\n</code></pre>"},{"location":"archive/guides/performance/#3-load-tests","title":"3. Load Tests","text":"<p>Test under load:</p> <p>```swift class LoadTests: XCTestCase {     func testConcurrentOperations() async throws {         let operations = 1000         let service = TestService()</p> <pre><code>    try await withThrowingTaskGroup(of: Void.self) { group in\n        for _ in 0..&lt;operations {\n            group.addTask {\n                try await service.operation()\n            }\n        }\n        try await group.waitForAll()\n    }\n}\n</code></pre> <p>}</p>"},{"location":"archive/guides/security/","title":"Security Guidelines","text":"<p>This guide outlines security best practices for using UmbraCore.</p>"},{"location":"archive/guides/security/#core-principles","title":"Core Principles","text":"<ol> <li>Least Privilege: Only request necessary permissions</li> <li>Data Protection: Secure all sensitive data</li> <li>Secure Communication: Use encrypted channels</li> <li>Audit Logging: Track security-relevant events</li> </ol>"},{"location":"archive/guides/security/#secure-storage","title":"Secure Storage","text":""},{"location":"archive/guides/security/#password-storage","title":"Password Storage","text":"<ul> <li>Use <code>SecureString</code> for passwords</li> <li>Implement proper password policies</li> <li>Use secure key derivation</li> </ul>"},{"location":"archive/guides/security/#repository-encryption","title":"Repository Encryption","text":"<ul> <li>Use strong encryption keys</li> <li>Implement key rotation</li> <li>Secure key storage</li> </ul>"},{"location":"archive/guides/security/#network-security","title":"Network Security","text":""},{"location":"archive/guides/security/#remote-repositories","title":"Remote Repositories","text":"<ul> <li>Use SSH or HTTPS</li> <li>Validate certificates</li> <li>Implement rate limiting</li> <li>Handle network errors securely</li> </ul>"},{"location":"archive/guides/security/#api-security","title":"API Security","text":"<ul> <li>Use API tokens securely</li> <li>Implement request signing</li> <li>Validate all inputs</li> </ul>"},{"location":"archive/guides/security/#error-handling","title":"Error Handling","text":""},{"location":"archive/guides/security/#security-errors","title":"Security Errors","text":"<ul> <li>Log security events</li> <li>Don't expose sensitive data</li> <li>Implement proper error recovery</li> </ul>"},{"location":"archive/guides/security/#access-control","title":"Access Control","text":"<ul> <li>Validate permissions</li> <li>Check file access rights</li> <li>Handle access denied errors</li> </ul>"},{"location":"archive/guides/security/#best-practices","title":"Best Practices","text":"<ol> <li>Keep dependencies updated</li> <li>Regular security audits</li> <li>Follow cryptographic best practices</li> <li>Implement proper logging</li> <li>Regular penetration testing</li> </ol>"},{"location":"archive/guides/thread-safety/","title":"Thread Safety in UmbraCore","text":""},{"location":"archive/guides/thread-safety/#overview","title":"Overview","text":"<p>UmbraCore is designed to be thread-safe by default. All public APIs can be safely called from multiple threads concurrently. This guide explains our thread safety guarantees and best practices.</p>"},{"location":"archive/guides/thread-safety/#core-principles","title":"Core Principles","text":""},{"location":"archive/guides/thread-safety/#1-actor-based-services","title":"1. Actor-Based Services","text":"<p>All core services in UmbraCore use Swift's actor system to ensure thread safety:</p> <pre><code>actor KeychainService {\n    private var cache: [String: Data] = [:]\n\n    func store(_ data: Data, forKey key: String) async throws {\n        // Thread-safe access to cache\n        cache[key] = data\n        try await persistToKeychain(data, key)\n    }\n}\n</code></pre>"},{"location":"archive/guides/thread-safety/#2-immutable-state","title":"2. Immutable State","text":"<p>We prefer immutable state to minimize synchronization needs:</p> <pre><code>struct BackupConfig {\n    // Immutable properties\n    let sourcePath: String\n    let destinationPath: String\n    let excludePatterns: [String]\n\n    // Instead of mutating, create new instance\n    func withExcludePattern(_ pattern: String) -&gt; BackupConfig {\n        var patterns = excludePatterns\n        patterns.append(pattern)\n        return BackupConfig(\n            sourcePath: sourcePath,\n            destinationPath: destinationPath,\n            excludePatterns: patterns\n        )\n    }\n}\n</code></pre>"},{"location":"archive/guides/thread-safety/#3-synchronized-collections","title":"3. Synchronized Collections","text":"<p>When mutable state is necessary, we use synchronized collections:</p> <pre><code>actor CacheManager {\n    private var cache = [String: Any]()\n    private let queue = DispatchQueue(label: \"com.umbracore.cache\")\n\n    func set(_ value: Any, forKey key: String) {\n        queue.sync { cache[key] = value }\n    }\n\n    func get(_ key: String) -&gt; Any? {\n        queue.sync { cache[key] }\n    }\n}\n</code></pre>"},{"location":"archive/guides/thread-safety/#best-practices","title":"Best Practices","text":""},{"location":"archive/guides/thread-safety/#1-asyncawait-usage","title":"1. Async/Await Usage","text":"<p>Always use async/await for asynchronous operations:</p> <pre><code>// Good\nfunc backupFiles() async throws {\n    try await prepareBackup()\n    try await performBackup()\n    try await cleanup()\n}\n\n// Avoid\nfunc backupFiles(completion: @escaping (Error?) -&gt; Void) {\n    prepareBackup { error in\n        guard error == nil else {\n            completion(error)\n            return\n        }\n        // Callback hell continues...\n    }\n}\n</code></pre>"},{"location":"archive/guides/thread-safety/#2-resource-access","title":"2. Resource Access","text":"<p>Use proper resource access patterns:</p> <pre><code>actor ResourceManager {\n    private var isLocked = false\n\n    func acquireResource() async throws {\n        guard !isLocked else {\n            throw ResourceError.alreadyLocked\n        }\n        isLocked = true\n    }\n\n    func releaseResource() {\n        isLocked = false\n    }\n}\n</code></pre>"},{"location":"archive/guides/thread-safety/#3-shared-state","title":"3. Shared State","text":"<p>Minimize shared state, use message passing:</p> <pre><code>actor BackupCoordinator {\n    private var activeBackups: Set&lt;UUID&gt; = []\n\n    func startBackup() async throws -&gt; UUID {\n        let id = UUID()\n        activeBackups.insert(id)\n        return id\n    }\n\n    func completeBackup(_ id: UUID) {\n        activeBackups.remove(id)\n    }\n}\n</code></pre>"},{"location":"archive/guides/thread-safety/#common-patterns","title":"Common Patterns","text":""},{"location":"archive/guides/thread-safety/#1-double-checked-locking","title":"1. Double-Checked Locking","text":"<p>For expensive initialization:</p> <pre><code>actor ConfigurationManager {\n    private var config: Configuration?\n\n    func getConfiguration() async throws -&gt; Configuration {\n        if let existing = config {\n            return existing\n        }\n\n        let loaded = try await loadConfiguration()\n        config = loaded\n        return loaded\n    }\n}\n</code></pre>"},{"location":"archive/guides/thread-safety/#2-reader-writer-pattern","title":"2. Reader-Writer Pattern","text":"<p>For concurrent read access:</p> <pre><code>actor DatabaseManager {\n    private var isWriting = false\n    private var activeReaders = 0\n\n    func read() async throws -&gt; Data {\n        while isWriting {\n            try await Task.sleep(nanoseconds: 100_000)\n        }\n        activeReaders += 1\n        defer { activeReaders -= 1 }\n        return try getData()\n    }\n\n    func write(_ data: Data) async throws {\n        while activeReaders &gt; 0 {\n            try await Task.sleep(nanoseconds: 100_000)\n        }\n        isWriting = true\n        defer { isWriting = false }\n        try await writeData(data)\n    }\n}\n</code></pre>"},{"location":"archive/guides/thread-safety/#3-task-management","title":"3. Task Management","text":"<p>For concurrent operations:</p> <pre><code>class BackupTask {\n    func executeParallel(_ operations: [Operation]) async throws {\n        try await withThrowingTaskGroup(of: Void.self) { group in\n            for operation in operations {\n                group.addTask {\n                    try await operation.execute()\n                }\n            }\n            try await group.waitForAll()\n        }\n    }\n}\n</code></pre>"},{"location":"archive/guides/thread-safety/#troubleshooting","title":"Troubleshooting","text":""},{"location":"archive/guides/thread-safety/#1-deadlock-prevention","title":"1. Deadlock Prevention","text":"<pre><code>actor Service {\n    // Avoid nested actor calls\n    func operation1() async {\n        await operation2() // Could deadlock if not careful\n    }\n\n    func operation2() async {\n        // Implementation\n    }\n}\n\n// Better approach\nactor Service {\n    func operation1() async {\n        // Execute independently\n        try await Task.sleep(nanoseconds: 100_000)\n        await operation2()\n    }\n}\n</code></pre>"},{"location":"archive/guides/thread-safety/#2-race-condition-detection","title":"2. Race Condition Detection","text":"<pre><code>actor StateManager {\n    private var state: State\n    private var version: UInt64 = 0\n\n    func modify(_ change: (State) -&gt; State) async {\n        let currentVersion = version\n        state = change(state)\n\n        // Detect concurrent modifications\n        guard version == currentVersion else {\n            throw ConcurrencyError.stateModified\n        }\n        version += 1\n    }\n}\n</code></pre>"},{"location":"archive/guides/thread-safety/#3-performance-issues","title":"3. Performance Issues","text":"<pre><code>actor PerformanceOptimized {\n    // Batch operations to reduce actor hops\n    func batchOperation(_ items: [Item]) async {\n        // Single actor hop for batch\n        items.forEach { process($0) }\n    }\n\n    // Avoid frequent actor hops\n    private func process(_ item: Item) {\n        // Local processing\n    }\n}\n</code></pre>"},{"location":"archive/guides/thread-safety/#testing","title":"Testing","text":""},{"location":"archive/guides/thread-safety/#1-concurrency-testing","title":"1. Concurrency Testing","text":"<pre><code>func testConcurrentAccess() async throws {\n    let service = SharedService()\n\n    try await withThrowingTaskGroup(of: Void.self) { group in\n        for _ in 0..&lt;100 {\n            group.addTask {\n                try await service.operation()\n            }\n        }\n        try await group.waitForAll()\n    }\n}\n</code></pre>"},{"location":"archive/guides/thread-safety/#2-race-condition-testing","title":"2. Race Condition Testing","text":"<p>```swift func testRaceConditions() async throws {     let service = SharedService()</p> <pre><code>async let operation1 = service.modify()\nasync let operation2 = service.modify()\n\n// This should handle concurrent modifications gracefully\ntry await [operation1, operation2]\n</code></pre> <p>}</p>"},{"location":"archive/guides/xpc/","title":"UmbraXPC Guide","text":""},{"location":"archive/guides/xpc/#overview","title":"Overview","text":"<p><code>UmbraXPC</code> provides a secure inter-process communication layer for UmbraCore services. It enables privilege separation and sandboxing while maintaining type safety and async/await support.</p>"},{"location":"archive/guides/xpc/#features","title":"Features","text":"<ul> <li>Secure IPC communication</li> <li>Type-safe protocols</li> <li>Async/await support</li> <li>Error handling</li> <li>Privilege separation</li> </ul>"},{"location":"archive/guides/xpc/#basic-usage","title":"Basic Usage","text":""},{"location":"archive/guides/xpc/#service-definition","title":"Service Definition","text":"<pre><code>// Define XPC protocol\n@objc protocol KeychainXPCProtocol {\n    func store(password: String, forKey: String) async throws\n    func retrieve(forKey: String) async throws -&gt; String\n    func remove(forKey: String) async throws\n}\n\n// Implement service\nclass KeychainXPCService: NSObject, KeychainXPCProtocol {\n    func store(password: String, forKey: String) async throws {\n        // Implementation\n    }\n\n    // Other implementations...\n}\n</code></pre>"},{"location":"archive/guides/xpc/#service-registration","title":"Service Registration","text":"<pre><code>// Register service\nlet service = XPCService(\n    service: KeychainXPCService(),\n    protocol: KeychainXPCProtocol.self\n)\n\ntry await service.register()\n</code></pre>"},{"location":"archive/guides/xpc/#client-usage","title":"Client Usage","text":"<pre><code>// Connect to service\nlet client = try XPCClient&lt;KeychainXPCProtocol&gt;()\n\n// Use service\ntry await client.store(password: \"secret\", forKey: \"key\")\nlet value = try await client.retrieve(forKey: \"key\")\n</code></pre>"},{"location":"archive/guides/xpc/#error-handling","title":"Error Handling","text":"<pre><code>do {\n    try await client.store(password: \"secret\", forKey: \"key\")\n} catch XPCError.connectionFailed {\n    // Handle connection failure\n} catch XPCError.serviceStopped {\n    // Handle service stop\n} catch {\n    // Handle other errors\n}\n</code></pre>"},{"location":"archive/guides/xpc/#best-practices","title":"Best Practices","text":""},{"location":"archive/guides/xpc/#1-protocol-design","title":"1. Protocol Design","text":"<pre><code>// Good protocol design\n@objc protocol BackupXPCProtocol {\n    // Clear operation names\n    func startBackup(source: URL, destination: URL) async throws\n\n    // Specific error types\n    func checkAccess(path: String) async throws -&gt; Bool\n\n    // Progress reporting\n    func getProgress() async throws -&gt; Double\n}\n</code></pre>"},{"location":"archive/guides/xpc/#2-error-handling","title":"2. Error Handling","text":"<pre><code>// Define specific errors\nenum BackupXPCError: Error {\n    case accessDenied(String)\n    case insufficientSpace(needed: UInt64, available: UInt64)\n    case connectionLost\n}\n\n// Handle errors appropriately\ndo {\n    try await service.startBackup(source: src, destination: dest)\n} catch BackupXPCError.accessDenied(let path) {\n    // Handle access denied\n} catch BackupXPCError.insufficientSpace(let needed, let available) {\n    // Handle space issues\n}\n</code></pre>"},{"location":"archive/guides/xpc/#3-resource-management","title":"3. Resource Management","text":"<pre><code>// Proper cleanup\nclass XPCManager {\n    private var client: XPCClient&lt;BackupXPCProtocol&gt;?\n\n    func shutdown() async {\n        await client?.disconnect()\n        client = nil\n    }\n}\n</code></pre>"},{"location":"archive/guides/xpc/#advanced-usage","title":"Advanced Usage","text":""},{"location":"archive/guides/xpc/#1-custom-message-handling","title":"1. Custom Message Handling","text":"<pre><code>class CustomXPCService: XPCServiceDelegate {\n    func handleCustomMessage(_ message: [String: Any]) async throws -&gt; Any {\n        // Custom message handling\n        switch message[\"type\"] as? String {\n        case \"status\":\n            return await getStatus()\n        case \"control\":\n            return try await handleControl(message)\n        default:\n            throw XPCError.invalidMessage\n        }\n    }\n}\n</code></pre>"},{"location":"archive/guides/xpc/#2-progress-reporting","title":"2. Progress Reporting","text":"<pre><code>protocol ProgressReporting {\n    func reportProgress(_ progress: Double) async\n}\n\nclass BackupXPCService: ProgressReporting {\n    private var progress: Double = 0\n\n    func reportProgress(_ progress: Double) async {\n        self.progress = progress\n        await notifyObservers()\n    }\n}\n</code></pre>"},{"location":"archive/guides/xpc/#3-connection-management","title":"3. Connection Management","text":"<pre><code>class XPCConnectionManager {\n    private var connections: [String: XPCClient&lt;Any&gt;] = [:]\n\n    func getConnection&lt;T&gt;(_ type: T.Type) async throws -&gt; XPCClient&lt;T&gt; {\n        let id = String(describing: type)\n\n        if let existing = connections[id] as? XPCClient&lt;T&gt; {\n            return existing\n        }\n\n        let new = try XPCClient&lt;T&gt;()\n        connections[id] = new\n        return new\n    }\n}\n</code></pre>"},{"location":"archive/guides/xpc/#integration-examples","title":"Integration Examples","text":""},{"location":"archive/guides/xpc/#1-backup-service","title":"1. Backup Service","text":"<pre><code>class BackupManager {\n    private let xpc: XPCClient&lt;BackupXPCProtocol&gt;\n\n    func startBackup() async throws {\n        // Connect to XPC service\n        try await xpc.connect()\n\n        // Start backup operation\n        try await xpc.startBackup(\n            source: sourceURL,\n            destination: destURL\n        )\n\n        // Monitor progress\n        for await progress in xpc.progressUpdates() {\n            updateUI(progress)\n        }\n    }\n}\n</code></pre>"},{"location":"archive/guides/xpc/#2-security-service","title":"2. Security Service","text":"<pre><code>class SecurityManager {\n    private let xpc: XPCClient&lt;SecurityXPCProtocol&gt;\n\n    func validateAccess() async throws -&gt; Bool {\n        try await xpc.withConnection { service in\n            try await service.checkSecurity([\n                \"operation\": \"backup\",\n                \"level\": \"system\"\n            ])\n        }\n    }\n}\n</code></pre>"},{"location":"archive/guides/xpc/#troubleshooting","title":"Troubleshooting","text":""},{"location":"archive/guides/xpc/#common-issues","title":"Common Issues","text":"<ol> <li> <p>Connection Issues <pre><code>// Implement retry logic\nfunc connectWithRetry() async throws -&gt; XPCClient&lt;T&gt; {\n    var attempts = 0\n    while attempts &lt; 3 {\n        do {\n            return try await XPCClient&lt;T&gt;().connect()\n        } catch {\n            attempts += 1\n            try await Task.sleep(nanoseconds: 1_000_000_000)\n        }\n    }\n    throw XPCError.connectionFailed\n}\n</code></pre></p> </li> <li> <p>Service Recovery <pre><code>// Handle service interruption\nfunc handleServiceFailure() async throws {\n    try await xpc.disconnect()\n    try await Task.sleep(nanoseconds: 1_000_000_000)\n    try await xpc.connect()\n}\n</code></pre></p> </li> <li> <p>Resource Cleanup <pre><code>// Proper resource management\nclass XPCResource {\n    private var resources: Set&lt;XPCClient&lt;Any&gt;&gt; = []\n\n    func cleanup() async {\n        for resource in resources {\n            await resource.disconnect()\n        }\n        resources.removeAll()\n    }\n}\n</code></pre></p> </li> </ol>"},{"location":"archive/security/SECURITY_GUIDELINES/","title":"Security Guidelines","text":""},{"location":"archive/security/SECURITY_GUIDELINES/#overview","title":"Overview","text":"<p>UmbraCore handles sensitive data and requires careful attention to security. This guide outlines our security practices and requirements.</p>"},{"location":"archive/security/SECURITY_GUIDELINES/#secure-storage","title":"Secure Storage","text":""},{"location":"archive/security/SECURITY_GUIDELINES/#1-credentials","title":"1. Credentials","text":"<ul> <li>Always use <code>UmbraKeychainService</code> for storing:</li> <li>Repository passwords</li> <li>API keys</li> <li>Access tokens</li> <li>SSH keys</li> </ul> <pre><code>// DO THIS:\ntry await keychainService.store(password: \"secret\", forKey: \"repo-key\")\n\n// DON'T DO THIS:\nUserDefaults.standard.set(\"secret\", forKey: \"repo-key\") // UNSAFE!\n</code></pre>"},{"location":"archive/security/SECURITY_GUIDELINES/#2-file-system-access","title":"2. File System Access","text":"<ul> <li>Use <code>UmbraBookmarkService</code> for persistent file access</li> <li>Never store raw file paths</li> <li>Always use security-scoped bookmarks</li> </ul>"},{"location":"archive/security/SECURITY_GUIDELINES/#encryption","title":"Encryption","text":""},{"location":"archive/security/SECURITY_GUIDELINES/#1-data-at-rest","title":"1. Data at Rest","text":"<ul> <li>All sensitive data must be encrypted</li> <li>Use <code>UmbraCryptoService</code> for encryption/decryption</li> <li>Never store encryption keys in code</li> </ul>"},{"location":"archive/security/SECURITY_GUIDELINES/#2-data-in-transit","title":"2. Data in Transit","text":"<ul> <li>Use secure transport (HTTPS, SSH)</li> <li>Validate certificates</li> <li>Implement proper error handling</li> </ul>"},{"location":"archive/security/SECURITY_GUIDELINES/#access-control","title":"Access Control","text":""},{"location":"archive/security/SECURITY_GUIDELINES/#1-xpc-services","title":"1. XPC Services","text":"<ul> <li>Principle of least privilege</li> <li>Separate process for sensitive operations</li> <li>Validate all inputs</li> </ul>"},{"location":"archive/security/SECURITY_GUIDELINES/#2-file-permissions","title":"2. File Permissions","text":"<ul> <li>Respect system permissions</li> <li>Use security-scoped resources</li> <li>Clean up temporary files</li> </ul>"},{"location":"archive/security/SECURITY_GUIDELINES/#logging","title":"Logging","text":""},{"location":"archive/security/SECURITY_GUIDELINES/#1-sensitive-data","title":"1. Sensitive Data","text":"<ul> <li>Never log credentials</li> <li>Mask sensitive information</li> <li>Use appropriate log levels</li> </ul>"},{"location":"archive/security/SECURITY_GUIDELINES/#2-audit-trail","title":"2. Audit Trail","text":"<ul> <li>Log security-relevant events</li> <li>Include necessary context</li> <li>Maintain audit logs</li> </ul>"},{"location":"archive/security/SECURITY_GUIDELINES/#error-handling","title":"Error Handling","text":""},{"location":"archive/security/SECURITY_GUIDELINES/#1-security-errors","title":"1. Security Errors","text":"<ul> <li>Don't expose internal details</li> <li>Provide appropriate user feedback</li> <li>Log security failures</li> </ul>"},{"location":"archive/security/SECURITY_GUIDELINES/#2-recovery","title":"2. Recovery","text":"<ul> <li>Implement secure fallbacks</li> <li>Clean up on failure</li> <li>Maintain system integrity</li> </ul>"},{"location":"archive/security/SECURITY_GUIDELINES/#best-practices","title":"Best Practices","text":""},{"location":"archive/security/SECURITY_GUIDELINES/#1-code","title":"1. Code","text":"<ul> <li>Use Swift's type safety</li> <li>Implement input validation</li> <li>Follow OWASP guidelines</li> </ul>"},{"location":"archive/security/SECURITY_GUIDELINES/#2-testing","title":"2. Testing","text":"<ul> <li>Include security test cases</li> <li>Test error conditions</li> <li>Verify security boundaries</li> </ul>"},{"location":"archive/security/SECURITY_GUIDELINES/#3-dependencies","title":"3. Dependencies","text":"<ul> <li>Regular security updates</li> <li>Vulnerability scanning</li> <li>Dependency pinning</li> </ul>"},{"location":"contributing/CONTRIBUTING/","title":"Contributing to UmbraCore","text":""},{"location":"contributing/CONTRIBUTING/#getting-started","title":"Getting Started","text":""},{"location":"contributing/CONTRIBUTING/#1-development-environment","title":"1. Development Environment","text":"<ul> <li>macOS 14.0+</li> <li>Xcode 15.2+</li> <li>Swift 6.0.3+</li> <li>SwiftLint</li> <li>Restic</li> </ul>"},{"location":"contributing/CONTRIBUTING/#2-setup","title":"2. Setup","text":"<ol> <li>Fork the repository</li> <li>Clone your fork</li> <li>Install dependencies</li> <li>Run tests</li> </ol>"},{"location":"contributing/CONTRIBUTING/#development-process","title":"Development Process","text":""},{"location":"contributing/CONTRIBUTING/#1-branching","title":"1. Branching","text":"<ul> <li><code>main</code>: Production-ready code</li> <li><code>develop</code>: Integration branch</li> <li>Feature branches: <code>feature/description</code></li> <li>Bug fixes: <code>fix/description</code></li> </ul>"},{"location":"contributing/CONTRIBUTING/#2-commit-messages","title":"2. Commit Messages","text":"<p>Follow conventional commits: <pre><code>type(scope): description\n\n[optional body]\n\n[optional footer]\n</code></pre></p> <p>Types: - feat: New feature - fix: Bug fix - docs: Documentation - style: Formatting - refactor: Code restructuring - test: Adding tests - chore: Maintenance</p>"},{"location":"contributing/CONTRIBUTING/#3-code-style","title":"3. Code Style","text":"<ul> <li>Follow Swift API Design Guidelines</li> <li>Use SwiftLint rules</li> <li>Document public APIs</li> <li>Write meaningful comments</li> </ul>"},{"location":"contributing/CONTRIBUTING/#4-testing","title":"4. Testing","text":"<ul> <li>Write unit tests</li> <li>Include integration tests</li> <li>Maintain test coverage</li> <li>Test error conditions</li> </ul>"},{"location":"contributing/CONTRIBUTING/#5-documentation","title":"5. Documentation","text":"<ul> <li>Update API documentation</li> <li>Include code examples</li> <li>Document breaking changes</li> <li>Update guides if needed</li> </ul>"},{"location":"contributing/CONTRIBUTING/#pull-requests","title":"Pull Requests","text":""},{"location":"contributing/CONTRIBUTING/#1-preparation","title":"1. Preparation","text":"<ul> <li>Update from upstream</li> <li>Run all tests</li> <li>Check code coverage</li> <li>Run SwiftLint</li> </ul>"},{"location":"contributing/CONTRIBUTING/#2-submission","title":"2. Submission","text":"<ul> <li>Clear description</li> <li>Link related issues</li> <li>Include test cases</li> <li>Update documentation</li> </ul>"},{"location":"contributing/CONTRIBUTING/#3-review-process","title":"3. Review Process","text":"<ul> <li>Address feedback</li> <li>Keep changes focused</li> <li>Maintain clean history</li> <li>Update as needed</li> </ul>"},{"location":"contributing/CONTRIBUTING/#release-process","title":"Release Process","text":""},{"location":"contributing/CONTRIBUTING/#1-versioning","title":"1. Versioning","text":"<p>Follow semantic versioning: - MAJOR: Breaking changes - MINOR: New features - PATCH: Bug fixes</p>"},{"location":"contributing/CONTRIBUTING/#2-release-checklist","title":"2. Release Checklist","text":"<ul> <li>Update changelog</li> <li>Update version</li> <li>Run full test suite</li> <li>Update documentation</li> <li>Create release notes</li> </ul>"},{"location":"contributing/CONTRIBUTING/#additional-resources","title":"Additional Resources","text":"<ul> <li>Swift API Design Guidelines</li> <li>SwiftLint Rules</li> <li>Conventional Commits</li> </ul>"},{"location":"development/","title":"Development Guide","text":"<p>This section contains technical documentation for developers working with UmbraCore.</p>"},{"location":"development/#development-topics","title":"Development Topics","text":"<ul> <li>Architecture overview</li> <li>Integration guides</li> <li>Contributing guidelines</li> <li>API documentation</li> </ul>"},{"location":"development/#available-guides","title":"Available Guides","text":"<ul> <li>Bazel &amp; SPM Integration: Build system integration guide</li> <li>Architecture: System architecture and design</li> <li>Contributing: Guidelines for contributors</li> </ul>"},{"location":"development/bazel_spm/","title":"UmbraCore: Bazel and SPM Integration Brief","text":""},{"location":"development/bazel_spm/#overview","title":"Overview","text":"<p>This document outlines our strategy for integrating Bazel build system while maintaining Swift Package Manager (SPM) compatibility in the UmbraCore project.</p>"},{"location":"development/bazel_spm/#1-integration-goals","title":"1. Integration Goals","text":"<ul> <li>Maintain existing SPM dependencies</li> <li>Leverage Bazel's build caching</li> <li>Optimise CI/CD performance</li> <li>Support future scalability</li> </ul>"},{"location":"development/bazel_spm/#2-technical-architecture","title":"2. Technical Architecture","text":""},{"location":"development/bazel_spm/#21-build-system-components","title":"2.1 Build System Components","text":"<pre><code>UmbraCore/\n\u251c\u2500\u2500 WORKSPACE\n\u251c\u2500\u2500 MODULE.bazel          # Bazel module configuration\n\u251c\u2500\u2500 Package.swift         # SPM dependencies\n\u251c\u2500\u2500 Package.resolved      # SPM version lock\n\u251c\u2500\u2500 .bazelrc             # Bazel settings\n\u251c\u2500\u2500 BUILD.bazel          # Root build file\n\u251c\u2500\u2500 Sources/             # Source files\n\u2502   \u2514\u2500\u2500 */\n\u2502       \u251c\u2500\u2500 BUILD       # Generated by Gazelle\n\u2502       \u2514\u2500\u2500 *.swift\n\u2514\u2500\u2500 Tests/              # Test files\n    \u2514\u2500\u2500 */\n        \u251c\u2500\u2500 BUILD       # Generated by Gazelle\n        \u2514\u2500\u2500 *.swift\n</code></pre>"},{"location":"development/bazel_spm/#22-key-configuration-files","title":"2.2 Key Configuration Files","text":""},{"location":"development/bazel_spm/#modulebazel","title":"MODULE.bazel","text":"<pre><code>bazel_dep(name = \"rules_swift_package_manager\", version = \"0.46.0\")\n\nswift_deps = use_extension(\n    \"@rules_swift_package_manager//:extensions.bzl\",\n    \"swift_deps\",\n)\n\nswift_deps.configure_swift_package(\n    build_path = \"spm-build\",\n    cache_path = \"spm-cache\",\n    dependency_caching = \"true\",\n    manifest_cache = \"local\",\n    manifest_caching = \"true\",\n)\n\nswift_deps.from_package(\n    declare_swift_deps_info = True,\n    declare_swift_package = True,\n    resolved = \"//:Package.resolved\",\n    swift = \"//:Package.swift\",\n)\n</code></pre>"},{"location":"development/bazel_spm/#bazelrc","title":".bazelrc","text":"<pre><code># Enable bzlmod\nbuild --enable_bzlmod\n\n# SPM integration\nbuild --experimental_enable_swift_package_manager\n\n# Caching configuration\nbuild --remote_cache=grpcs://cache.buildbuddy.io\nbuild --remote_timeout=3600\n</code></pre>"},{"location":"development/bazel_spm/#3-dependency-management","title":"3. Dependency Management","text":""},{"location":"development/bazel_spm/#31-spm-dependencies","title":"3.1 SPM Dependencies","text":"<ul> <li>CryptoSwift (v1.8.0+)</li> <li>SwiftyBeaver (v2.0.0+)</li> </ul>"},{"location":"development/bazel_spm/#32-bazel-dependencies","title":"3.2 Bazel Dependencies","text":"<ul> <li>rules_swift_package_manager</li> <li>rules_swift</li> <li>rules_apple (optional)</li> <li>Gazelle</li> </ul>"},{"location":"development/bazel_spm/#4-caching-strategy","title":"4. Caching Strategy","text":""},{"location":"development/bazel_spm/#41-cache-locations","title":"4.1 Cache Locations","text":"<ul> <li><code>spm-cache/</code>: SPM dependency cache</li> <li><code>spm-build/</code>: SPM build artifacts</li> <li><code>bazel-*/</code>: Bazel build outputs</li> <li><code>~/.cache/bazel</code>: Bazel system cache</li> </ul>"},{"location":"development/bazel_spm/#42-cicd-caching","title":"4.2 CI/CD Caching","text":"<pre><code>cache:\n  paths:\n    - ~/.cache/bazel\n    - spm-cache\n    - spm-build\n  key: ${CI_COMMIT_REF_SLUG}\n</code></pre>"},{"location":"development/bazel_spm/#5-common-operations","title":"5. Common Operations","text":""},{"location":"development/bazel_spm/#51-dependency-management","title":"5.1 Dependency Management","text":"<pre><code># Update all dependencies\nbazel run @swift_package//:update\n\n# Update specific package\nbazel run @swift_package//:update -- SwiftyBeaver\n\n# Resolve dependencies\nbazel run @swift_package//:resolve\n</code></pre>"},{"location":"development/bazel_spm/#52-build-operations","title":"5.2 Build Operations","text":"<pre><code># Build entire project\nbazel build //...\n\n# Run tests\nbazel test //...\n\n# Generate BUILD files\nbazel run //:update_build_files\n</code></pre>"},{"location":"development/bazel_spm/#6-best-practices","title":"6. Best Practices","text":""},{"location":"development/bazel_spm/#61-development-workflow","title":"6.1 Development Workflow","text":"<ol> <li>Use Bazel commands for all build operations</li> <li>Keep Package.swift minimal and focused</li> <li>Regularly update cached dependencies</li> <li>Monitor cache size and performance</li> </ol>"},{"location":"development/bazel_spm/#62-code-organisation","title":"6.2 Code Organisation","text":"<ol> <li>Follow module structure in Sources/</li> <li>Maintain clear dependency boundaries</li> <li>Use proper visibility declarations</li> <li>Keep BUILD files organised</li> </ol>"},{"location":"development/bazel_spm/#63-language-standards","title":"6.3 Language Standards","text":"<ol> <li>Use British English in:</li> <li>Documentation</li> <li>Comments</li> <li>User-facing text</li> <li>Use American English in:</li> <li>Code</li> <li>Build files</li> <li>Configuration</li> </ol>"},{"location":"development/bazel_spm/#7-performance-considerations","title":"7. Performance Considerations","text":""},{"location":"development/bazel_spm/#71-local-development","title":"7.1 Local Development","text":"<ul> <li>Use local caching</li> <li>Enable parallel builds</li> <li>Monitor resource usage</li> <li>Regular cache cleanup</li> </ul>"},{"location":"development/bazel_spm/#72-cicd-pipeline","title":"7.2 CI/CD Pipeline","text":"<ul> <li>Optimise cache sharing</li> <li>Use remote caching</li> <li>Enable parallel testing</li> <li>Monitor build times</li> </ul>"},{"location":"development/bazel_spm/#8-migration-timeline","title":"8. Migration Timeline","text":""},{"location":"development/bazel_spm/#phase-1-initial-setup-1-week","title":"Phase 1: Initial Setup (1 week)","text":"<ul> <li>[ ] Configure Bazel</li> <li>[ ] Set up SPM integration</li> <li>[ ] Configure caching</li> <li>[ ] Update documentation</li> </ul>"},{"location":"development/bazel_spm/#phase-2-build-migration-2-weeks","title":"Phase 2: Build Migration (2 weeks)","text":"<ul> <li>[ ] Generate BUILD files</li> <li>[ ] Test build system</li> <li>[ ] Validate dependencies</li> <li>[ ] Performance testing</li> </ul>"},{"location":"development/bazel_spm/#phase-3-cicd-integration-1-week","title":"Phase 3: CI/CD Integration (1 week)","text":"<ul> <li>[ ] Configure GitHub Actions</li> <li>[ ] Set up caching</li> <li>[ ] Test workflows</li> <li>[ ] Monitor performance</li> </ul>"},{"location":"development/bazel_spm/#9-support-and-maintenance","title":"9. Support and Maintenance","text":""},{"location":"development/bazel_spm/#91-regular-tasks","title":"9.1 Regular Tasks","text":"<ul> <li>Weekly dependency updates</li> <li>Monthly cache cleanup</li> <li>Quarterly performance review</li> <li>Regular documentation updates</li> </ul>"},{"location":"development/bazel_spm/#92-monitoring","title":"9.2 Monitoring","text":"<ul> <li>Build times</li> <li>Cache hit rates</li> <li>Dependency updates</li> <li>Resource usage</li> </ul>"},{"location":"development/bazel_spm/#10-references","title":"10. References","text":"<ol> <li>Bazel Documentation</li> <li>rules_swift_package_manager</li> <li>Swift Package Manager</li> <li>GitHub Actions Documentation</li> </ol>"},{"location":"development/contributing/","title":"Contributing to UmbraCore","text":"<p>This page will contain information about contributing to UmbraCore. Check back soon for updates.</p>"},{"location":"development/contributing/#coming-soon","title":"Coming Soon","text":"<ul> <li>Development setup</li> <li>Coding standards</li> <li>Testing guidelines</li> <li>Pull request process</li> <li>Documentation guidelines</li> </ul>"},{"location":"getting-started/","title":"Getting Started with UmbraCore","text":"<p>Welcome to UmbraCore! This guide will help you get up and running quickly with our secure backup solution for macOS developers.</p>"},{"location":"getting-started/#what-is-umbracore","title":"What is UmbraCore?","text":"<p>UmbraCore is a Swift-native interface to Restic, providing secure, efficient, and reliable backups specifically designed for macOS application developers. It offers:</p> <ul> <li>Type-safe Swift API</li> <li>Secure keychain integration</li> <li>Native macOS experience</li> <li>Complete Restic compatibility</li> </ul>"},{"location":"getting-started/#quick-navigation","title":"Quick Navigation","text":"<ul> <li>Installation: Set up UmbraCore in your project</li> <li>Quick Start: Create your first backup</li> <li>Configuration: Configure UmbraCore for your needs</li> </ul>"},{"location":"getting-started/installation/","title":"Getting Started with UmbraCore","text":""},{"location":"getting-started/installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>macOS 14.0 or later</li> <li>Xcode 15.2 or later</li> <li>Swift 6.0.3 or later</li> <li>Restic installed</li> </ul>"},{"location":"getting-started/installation/#installation","title":"Installation","text":""},{"location":"getting-started/installation/#swift-package-manager","title":"Swift Package Manager","text":"<p>Add UmbraCore as a dependency in your <code>Package.swift</code>:</p> <pre><code>dependencies: [\n    .package(url: \"https://github.com/mpy-dev-ml/UmbraCore.git\", from: \"1.0.0\")\n]\n</code></pre>"},{"location":"getting-started/installation/#manual-installation","title":"Manual Installation","text":"<ol> <li>Clone the repository</li> <li>Build the package</li> <li>Link the framework</li> </ol>"},{"location":"getting-started/installation/#quick-start-guide","title":"Quick Start Guide","text":""},{"location":"getting-started/installation/#1-basic-setup","title":"1. Basic Setup","text":"<pre><code>import UmbraCore\n\n// Initialize the core services\nlet keychainService = try UmbraKeychainService()\nlet cryptoService = try UmbraCryptoService()\n</code></pre>"},{"location":"getting-started/installation/#2-configure-logging","title":"2. Configure Logging","text":"<pre><code>import UmbraLogging\n\nUmbraLogger.configure(level: .info)\n</code></pre>"},{"location":"getting-started/installation/#3-basic-operations","title":"3. Basic Operations","text":"<pre><code>// Example: Store credentials\ntry await keychainService.store(\n    password: \"repository-password\",\n    forKey: \"backup-repo\"\n)\n\n// Example: Create a bookmark\ntry await bookmarkService.create(\n    for: URL(fileURLWithPath: \"/path/to/backup\"),\n    withName: \"documents\"\n)\n</code></pre>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<p>After installation, you might want to:</p> <ul> <li>Read the Architecture Guide</li> <li>Check out Security Best Practices</li> <li>View API Documentation</li> </ul>"},{"location":"getting-started/quick-start/","title":"Getting Started with UmbraCore","text":""},{"location":"getting-started/quick-start/#prerequisites","title":"Prerequisites","text":"<p>Before you begin working with UmbraCore, ensure you have the following installed:</p> <ul> <li>Xcode 15.0 or later</li> <li>Swift 5.9 or later</li> <li>Restic 0.16.0 or later</li> <li>macOS 13.0 (Ventura) or later</li> </ul>"},{"location":"getting-started/quick-start/#installation","title":"Installation","text":""},{"location":"getting-started/quick-start/#via-swift-package-manager","title":"Via Swift Package Manager","text":"<p>Add UmbraCore as a dependency to your <code>Package.swift</code>:</p> <pre><code>dependencies: [\n    .package(url: \"https://github.com/mpy-dev-ml/UmbraCore.git\", from: \"0.1.0\")\n]\n</code></pre>"},{"location":"getting-started/quick-start/#manual-build","title":"Manual Build","text":"<ol> <li> <p>Clone the repository:    <pre><code>git clone https://github.com/mpy-dev-ml/UmbraCore.git\ncd UmbraCore\n</code></pre></p> </li> <li> <p>Build the project:    <pre><code>swift build\n</code></pre></p> </li> <li> <p>Run the tests:    <pre><code>swift test\n</code></pre></p> </li> </ol>"},{"location":"getting-started/quick-start/#basic-usage","title":"Basic Usage","text":"<p>Here's a simple example of initialising UmbraCore and creating a backup:</p> <pre><code>import UmbraCore\n\n// Initialize the backup service\nlet service = try UmbraBackupService()\n\n// Create a backup\ntry await service.backup(\n    source: \"/path/to/source\",\n    repository: \"rest:https://backup.example.com/repo\",\n    password: \"your-secure-password\"\n)\n</code></pre>"},{"location":"getting-started/quick-start/#security-considerations","title":"Security Considerations","text":"<p>UmbraCore prioritises security in several ways:</p> <ol> <li>Keychain Integration: All sensitive data is stored in the macOS Keychain</li> <li>XPC Services: Security-critical operations run in isolated processes</li> <li>Secure Defaults: Conservative security defaults that follow best practices</li> </ol>"},{"location":"getting-started/quick-start/#next-steps","title":"Next Steps","text":"<p>Now that you have UmbraCore up and running, you might want to:</p> <ul> <li>Learn about Configuration Options</li> <li>Explore Advanced Features</li> <li>Read our Security Guide</li> <li>Check out the API Reference</li> </ul>"},{"location":"getting-started/quick-start/#getting-help","title":"Getting Help","text":"<p>If you encounter any issues or have questions:</p> <ol> <li>Check our Troubleshooting Guide</li> <li>Search existing GitHub Issues</li> <li>Create a new issue if your problem hasn't been reported</li> </ol>"},{"location":"getting-started/quick-start/#contributing","title":"Contributing","text":"<p>We welcome contributions! Please read our Contributing Guide to get started.</p>"},{"location":"guides/ARCHITECTURE/","title":"UmbraCore Architecture Guide","text":""},{"location":"guides/ARCHITECTURE/#overview","title":"Overview","text":"<p>UmbraCore is designed as a modular Swift library that provides a type-safe interface to Restic backup functionality. The architecture follows a service-oriented approach with clear separation of concerns.</p>"},{"location":"guides/ARCHITECTURE/#core-components","title":"Core Components","text":""},{"location":"guides/ARCHITECTURE/#1-security-layer","title":"1. Security Layer","text":"<ul> <li><code>SecurityTypes</code>: Base security primitives</li> <li><code>CryptoTypes</code>: Cryptographic operations</li> <li>Uses Apple's CryptoKit for hardware-backed security</li> <li>Provides core cryptographic primitives</li> <li>Handles secure key generation and management</li> <li><code>UmbraKeychainService</code>: Secure credential storage</li> </ul>"},{"location":"guides/ARCHITECTURE/#2-service-layer","title":"2. Service Layer","text":"<ul> <li><code>UmbraCryptoService</code>: Encryption/decryption operations</li> <li>Uses CryptoSwift for XPC service operations</li> <li>Platform-independent implementation</li> <li>Handles cross-process cryptographic operations</li> <li><code>UmbraBookmarkService</code>: File system bookmark management</li> <li><code>UmbraXPC</code>: Inter-process communication</li> </ul>"},{"location":"guides/ARCHITECTURE/#3-logging-infrastructure","title":"3. Logging Infrastructure","text":"<ul> <li><code>UmbraLogging</code>: Centralised logging system</li> <li>Structured logging with context</li> <li>Log level management</li> </ul>"},{"location":"guides/ARCHITECTURE/#design-patterns","title":"Design Patterns","text":""},{"location":"guides/ARCHITECTURE/#1-xpc-service-pattern","title":"1. XPC Service Pattern","text":"<p>Used for secure inter-process communication: <pre><code>protocol KeychainXPCProtocol {\n    func store(password: String, forKey: String) async throws\n    func retrieve(forKey: String) async throws -&gt; String\n}\n</code></pre></p>"},{"location":"guides/ARCHITECTURE/#2-protocol-oriented-design","title":"2. Protocol-Oriented Design","text":"<p>Services are defined by protocols for better testability: <pre><code>protocol CryptoServiceProtocol {\n    func encrypt(_ data: Data) async throws -&gt; Data\n    func decrypt(_ data: Data) async throws -&gt; Data\n}\n</code></pre></p>"},{"location":"guides/ARCHITECTURE/#3-error-handling-pattern","title":"3. Error Handling Pattern","text":"<p>Structured error types with context: <pre><code>enum KeychainError: Error {\n    case itemNotFound(String)\n    case duplicateItem(String)\n    case accessDenied(String)\n}\n</code></pre></p>"},{"location":"guides/ARCHITECTURE/#cryptographic-architecture","title":"Cryptographic Architecture","text":"<p>The framework employs a dual-library approach for cryptographic operations:</p> <ol> <li>CryptoKit (Main App Context)</li> <li>Hardware-backed security on Apple platforms</li> <li>Used in <code>DefaultCryptoService</code></li> <li>Handles core cryptographic operations</li> <li> <p>Optimal security for main app operations</p> </li> <li> <p>CryptoSwift (XPC Service Context)</p> </li> <li>Platform-independent implementation</li> <li>Used in <code>CryptoXPCService</code></li> <li>Enables reliable cross-process encryption</li> <li>Provides necessary flexibility for XPC operations</li> </ol> <p>This split architecture ensures: - Maximum security through hardware backing where available - Reliable cross-process cryptographic operations - Clear separation of concerns between contexts - Consistent cryptographic operations in each context</p>"},{"location":"guides/ARCHITECTURE/#threading-model","title":"Threading Model","text":"<ul> <li>All services are thread-safe</li> <li>Async/await for asynchronous operations</li> <li>XPC for background processing</li> </ul>"},{"location":"guides/ARCHITECTURE/#security-considerations","title":"Security Considerations","text":"<ul> <li>Keychain integration for secure storage</li> <li>XPC for privilege separation</li> <li>Audit logging</li> <li>Secure defaults</li> </ul>"},{"location":"guides/ARCHITECTURE/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Efficient memory usage</li> <li>Background processing</li> <li>Cache management</li> <li>Resource cleanup</li> </ul>"},{"location":"guides/ARCHITECTURE/#testing-strategy","title":"Testing Strategy","text":"<ul> <li>Unit tests for all components</li> <li>Integration tests for workflows</li> <li>Mock services for testing</li> <li>Performance benchmarks</li> </ul>"},{"location":"guides/ARCHITECTURE/#dependency-management","title":"Dependency Management","text":"<ul> <li>Minimal external dependencies</li> <li>Version pinning</li> <li>Security scanning</li> <li>Regular updates</li> </ul>"},{"location":"guides/ARCHITECTURE/#implementation-plan","title":"Implementation Plan","text":""},{"location":"guides/ARCHITECTURE/#phase-1-core-foundation","title":"Phase 1: Core Foundation","text":"<p>Currently in progress (Q1 2025):</p> <ul> <li>Command execution system</li> <li>Keychain integration</li> <li>XPC service implementation</li> <li>SSH key management</li> <li>Cloud provider integration</li> </ul>"},{"location":"guides/ARCHITECTURE/#phase-2-advanced-features","title":"Phase 2: Advanced Features","text":"<p>Planned for Q2 2025:</p> <ul> <li>Repository management</li> <li>Scheduling system</li> <li>Network operations</li> <li>State persistence</li> </ul>"},{"location":"guides/ARCHITECTURE/#phase-3-optimisation","title":"Phase 3: Optimisation","text":"<p>Scheduled for Q3 2025:</p> <ul> <li>Statistics &amp; analytics</li> <li>Health monitoring</li> <li>Event system</li> <li>Cache optimisation</li> </ul>"},{"location":"guides/ARCHITECTURE/#design-principles","title":"Design Principles","text":""},{"location":"guides/ARCHITECTURE/#1-security-first","title":"1. Security First","text":"<ul> <li>Secure by default</li> <li>Least privilege principle</li> <li>Comprehensive audit logging</li> <li>Regular security reviews</li> </ul>"},{"location":"guides/ARCHITECTURE/#2-reliability","title":"2. Reliability","text":"<ul> <li>Comprehensive error handling</li> <li>Automatic retry mechanisms</li> <li>Circuit breakers</li> <li>Fallback strategies</li> </ul>"},{"location":"guides/ARCHITECTURE/#3-performance","title":"3. Performance","text":"<ul> <li>Efficient resource usage</li> <li>Optimised I/O operations</li> <li>Memory management</li> <li>Cache strategies</li> </ul>"},{"location":"guides/ARCHITECTURE/#4-maintainability","title":"4. Maintainability","text":"<ul> <li>Protocol-oriented design</li> <li>Clear documentation</li> <li>Comprehensive testing</li> <li>Code review process</li> </ul>"},{"location":"guides/ARCHITECTURE/#integration-points","title":"Integration Points","text":"<p>UmbraCore serves as the foundation for:</p> <ul> <li>Rbum: Command-line interface</li> <li>Rbx: GUI application</li> <li>ResticBar: Menu bar application</li> </ul> <p>Each application utilises UmbraCore's components through well-defined protocols and interfaces.</p>"},{"location":"guides/ARCHITECTURE/#testing-strategy_1","title":"Testing Strategy","text":"<p>Comprehensive testing approach:</p> <ol> <li>Unit Tests</li> <li>Component isolation</li> <li>Edge case coverage</li> <li> <p>Mock implementations</p> </li> <li> <p>Integration Tests</p> </li> <li>Component interaction</li> <li>System workflows</li> <li> <p>Error scenarios</p> </li> <li> <p>Performance Tests</p> </li> <li>Resource usage</li> <li>Throughput metrics</li> <li> <p>Scalability checks</p> </li> <li> <p>Security Tests</p> </li> <li>Vulnerability scanning</li> <li>Penetration testing</li> <li>Compliance verification</li> </ol>"},{"location":"guides/bookmarks/","title":"UmbraBookmarkService Guide","text":""},{"location":"guides/bookmarks/#overview","title":"Overview","text":"<p><code>UmbraBookmarkService</code> manages persistent file system access through security-scoped bookmarks. It provides safe and reliable access to files and directories across app launches.</p>"},{"location":"guides/bookmarks/#features","title":"Features","text":"<ul> <li>Security-scoped bookmarks</li> <li>Persistent file access</li> <li>Thread-safe operations</li> <li>Automatic bookmark resolution</li> </ul>"},{"location":"guides/bookmarks/#basic-usage","title":"Basic Usage","text":""},{"location":"guides/bookmarks/#creating-bookmarks","title":"Creating Bookmarks","text":"<pre><code>let service = try UmbraBookmarkService()\n\n// Create bookmark for file\nlet fileURL = URL(fileURLWithPath: \"/path/to/file\")\ntry await service.create(\n    for: fileURL,\n    withName: \"important-file\"\n)\n\n// Create bookmark for directory\nlet dirURL = URL(fileURLWithPath: \"/path/to/directory\")\ntry await service.create(\n    for: dirURL,\n    withName: \"backup-directory\"\n)\n</code></pre>"},{"location":"guides/bookmarks/#resolving-bookmarks","title":"Resolving Bookmarks","text":"<pre><code>// Get URL from bookmark\nlet fileURL = try await service.resolve(name: \"important-file\")\n\n// Access with scope\ntry await service.access(name: \"backup-directory\") { url in\n    // Work with URL within security scope\n    let contents = try FileManager.default.contentsOfDirectory(at: url)\n}\n</code></pre>"},{"location":"guides/bookmarks/#removing-bookmarks","title":"Removing Bookmarks","text":"<pre><code>try await service.remove(name: \"important-file\")\n</code></pre>"},{"location":"guides/bookmarks/#error-handling","title":"Error Handling","text":"<pre><code>do {\n    try await service.create(for: url, withName: name)\n} catch BookmarkError.invalidURL(let url) {\n    // Handle invalid URL\n} catch BookmarkError.accessDenied(let reason) {\n    // Handle access denied\n} catch {\n    // Handle other errors\n}\n</code></pre>"},{"location":"guides/bookmarks/#best-practices","title":"Best Practices","text":""},{"location":"guides/bookmarks/#1-bookmark-naming","title":"1. Bookmark Naming","text":"<ul> <li>Use descriptive names</li> <li>Include context</li> <li>Follow naming conventions</li> </ul> <pre><code>// Good\n\"main-backup-directory\"\n\"config-file-production\"\n\n// Bad\n\"bookmark1\"\n\"file\"\n</code></pre>"},{"location":"guides/bookmarks/#2-access-scoping","title":"2. Access Scoping","text":"<ul> <li>Use scoped access</li> <li>Clean up resources</li> <li>Handle access errors</li> </ul>"},{"location":"guides/bookmarks/#3-error-recovery","title":"3. Error Recovery","text":"<ul> <li>Implement retry logic</li> <li>Provide user feedback</li> <li>Log access failures</li> </ul>"},{"location":"guides/bookmarks/#advanced-usage","title":"Advanced Usage","text":""},{"location":"guides/bookmarks/#1-custom-bookmark-options","title":"1. Custom Bookmark Options","text":"<pre><code>let options = BookmarkOptions(\n    securityScope: .workingDirectory,\n    persistence: .permanent\n)\n\ntry await service.create(\n    for: url,\n    withName: name,\n    options: options\n)\n</code></pre>"},{"location":"guides/bookmarks/#2-batch-operations","title":"2. Batch Operations","text":"<pre><code>let bookmarks = [\n    \"dir1\": url1,\n    \"dir2\": url2\n]\n\ntry await service.createBatch(bookmarks)\n</code></pre>"},{"location":"guides/bookmarks/#3-access-control","title":"3. Access Control","text":"<pre><code>let access = BookmarkAccess(\n    scope: .minimal,\n    duration: .temporary\n)\n\ntry await service.access(\n    name: \"secure-directory\",\n    access: access\n) { url in\n    // Limited scope access\n}\n</code></pre>"},{"location":"guides/bookmarks/#integration-examples","title":"Integration Examples","text":""},{"location":"guides/bookmarks/#1-backup-directory-management","title":"1. Backup Directory Management","text":"<pre><code>class BackupManager {\n    private let bookmarks: UmbraBookmarkService\n\n    init() throws {\n        bookmarks = try UmbraBookmarkService()\n    }\n\n    func configureBackupDirectory(_ url: URL) async throws {\n        // Create persistent bookmark\n        try await bookmarks.create(\n            for: url,\n            withName: \"backup-root\"\n        )\n    }\n\n    func performBackup() async throws {\n        try await bookmarks.access(\"backup-root\") { url in\n            // Perform backup operations\n            try await backupContents(of: url)\n        }\n    }\n}\n</code></pre>"},{"location":"guides/bookmarks/#2-configuration-file-access","title":"2. Configuration File Access","text":"<pre><code>class ConfigManager {\n    private let bookmarks: UmbraBookmarkService\n\n    func saveConfig(_ config: Config) async throws {\n        try await bookmarks.access(\"config-file\") { url in\n            let data = try JSONEncoder().encode(config)\n            try data.write(to: url)\n        }\n    }\n}\n</code></pre>"},{"location":"guides/bookmarks/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guides/bookmarks/#common-issues","title":"Common Issues","text":"<ol> <li> <p>Stale Bookmarks <pre><code>// Refresh bookmark if stale\nif await service.isStale(name: \"backup-dir\") {\n    try await service.refresh(name: \"backup-dir\")\n}\n</code></pre></p> </li> <li> <p>Access Denied <pre><code>// Request user permission if needed\nfunc ensureAccess(to name: String) async throws {\n    do {\n        try await service.verifyAccess(name: name)\n    } catch BookmarkError.accessDenied {\n        try await requestUserPermission(for: name)\n    }\n}\n</code></pre></p> </li> <li> <p>Resource Management <pre><code>// Proper resource cleanup\nfunc processDirectory() async throws {\n    try await service.access(\"work-dir\") { url in\n        defer {\n            // Cleanup code\n        }\n\n        // Process directory\n    }\n}\n</code></pre></p> </li> </ol>"},{"location":"guides/crypto-types/","title":"Cryptographic Types","text":"<p>This guide covers the cryptographic types used in UmbraCore for secure data handling.</p>"},{"location":"guides/crypto-types/#overview","title":"Overview","text":"<p>UmbraCore provides several cryptographic types to ensure secure handling of sensitive data:</p> <ul> <li><code>SecureString</code>: For handling passwords and other sensitive strings</li> <li><code>EncryptedData</code>: For encrypted binary data</li> <li><code>KeyMaterial</code>: For cryptographic key material</li> </ul>"},{"location":"guides/crypto-types/#securestring","title":"SecureString","text":"<p><code>SecureString</code> provides secure storage for sensitive string data:</p> <pre><code>let password = SecureString(\"sensitive-data\")\n// Memory is automatically zeroed when deallocated\n</code></pre>"},{"location":"guides/crypto-types/#encrypteddata","title":"EncryptedData","text":"<p><code>EncryptedData</code> handles encrypted binary data:</p> <pre><code>let encrypted = EncryptedData(data: someData, key: keyMaterial)\nlet decrypted = try encrypted.decrypt(using: keyMaterial)\n</code></pre>"},{"location":"guides/crypto-types/#keymaterial","title":"KeyMaterial","text":"<p><code>KeyMaterial</code> manages cryptographic keys:</p> <pre><code>let key = try KeyMaterial.generate()\nlet derived = try key.deriveKey(salt: salt, rounds: 100_000)\n</code></pre>"},{"location":"guides/crypto-types/#best-practices","title":"Best Practices","text":"<ol> <li>Always use <code>SecureString</code> for passwords and sensitive data</li> <li>Zero memory after use</li> <li>Use appropriate key derivation functions</li> <li>Implement proper key rotation</li> <li>Follow cryptographic hygiene</li> </ol>"},{"location":"guides/crypto/","title":"UmbraCryptoService Guide","text":""},{"location":"guides/crypto/#overview","title":"Overview","text":"<p><code>UmbraCryptoService</code> provides cryptographic operations for securing sensitive data. It supports encryption, decryption, and key management.</p>"},{"location":"guides/crypto/#features","title":"Features","text":"<ul> <li>Secure encryption/decryption</li> <li>Key management</li> <li>Thread-safe operations</li> <li>XPC-based processing</li> </ul>"},{"location":"guides/crypto/#basic-usage","title":"Basic Usage","text":""},{"location":"guides/crypto/#encryption","title":"Encryption","text":"<pre><code>let service = try UmbraCryptoService()\n\n// Encrypt data\nlet data = \"sensitive data\".data(using: .utf8)!\nlet encrypted = try await service.encrypt(data)\n\n// Encrypt with custom key\nlet key = try service.generateKey()\nlet customEncrypted = try await service.encrypt(data, using: key)\n</code></pre>"},{"location":"guides/crypto/#decryption","title":"Decryption","text":"<pre><code>// Decrypt data\nlet decrypted = try await service.decrypt(encrypted)\n\n// Decrypt with custom key\nlet customDecrypted = try await service.decrypt(customEncrypted, using: key)\n</code></pre>"},{"location":"guides/crypto/#key-management","title":"Key Management","text":"<pre><code>// Generate new key\nlet key = try service.generateKey()\n\n// Export key (protected)\nlet exportedKey = try service.exportKey(key)\n\n// Import key\nlet importedKey = try service.importKey(exportedKey)\n</code></pre>"},{"location":"guides/crypto/#error-handling","title":"Error Handling","text":"<pre><code>do {\n    let encrypted = try await service.encrypt(data)\n} catch CryptoError.invalidKey {\n    // Handle invalid key\n} catch CryptoError.encryptionFailed(let reason) {\n    // Handle encryption failure\n} catch {\n    // Handle other errors\n}\n</code></pre>"},{"location":"guides/crypto/#best-practices","title":"Best Practices","text":""},{"location":"guides/crypto/#1-key-management","title":"1. Key Management","text":"<ul> <li>Rotate keys regularly</li> <li>Secure key storage</li> <li>Use key derivation when appropriate</li> </ul>"},{"location":"guides/crypto/#2-data-protection","title":"2. Data Protection","text":"<ul> <li>Encrypt sensitive data immediately</li> <li>Clear sensitive data from memory</li> <li>Use secure random generation</li> </ul>"},{"location":"guides/crypto/#3-error-recovery","title":"3. Error Recovery","text":"<ul> <li>Implement retry logic</li> <li>Log cryptographic failures</li> <li>Provide appropriate user feedback</li> </ul>"},{"location":"guides/crypto/#advanced-usage","title":"Advanced Usage","text":""},{"location":"guides/crypto/#1-custom-encryption-parameters","title":"1. Custom Encryption Parameters","text":"<pre><code>let params = EncryptionParameters(\n    algorithm: .aes256GCM,\n    keySize: .bits256,\n    iterations: 10000\n)\n\nlet encrypted = try await service.encrypt(\n    data,\n    parameters: params\n)\n</code></pre>"},{"location":"guides/crypto/#2-key-derivation","title":"2. Key Derivation","text":"<pre><code>let derivedKey = try service.deriveKey(\n    fromPassword: \"user-password\",\n    salt: salt,\n    iterations: 10000\n)\n</code></pre>"},{"location":"guides/crypto/#3-batch-operations","title":"3. Batch Operations","text":"<pre><code>let dataItems = [\n    \"item1\": data1,\n    \"item2\": data2\n]\n\nlet encrypted = try await service.encryptBatch(dataItems)\n</code></pre>"},{"location":"guides/crypto/#integration-examples","title":"Integration Examples","text":""},{"location":"guides/crypto/#1-secure-configuration","title":"1. Secure Configuration","text":"<pre><code>class SecureConfig {\n    private let crypto: UmbraCryptoService\n\n    init() throws {\n        crypto = try UmbraCryptoService()\n    }\n\n    func saveConfig(_ config: Config) async throws {\n        let data = try JSONEncoder().encode(config)\n        let encrypted = try await crypto.encrypt(data)\n\n        try await FileManager.default.createFile(\n            at: configURL,\n            contents: encrypted\n        )\n    }\n}\n</code></pre>"},{"location":"guides/crypto/#2-secure-data-transfer","title":"2. Secure Data Transfer","text":"<pre><code>class SecureTransfer {\n    private let crypto: UmbraCryptoService\n\n    func secureUpload(_ data: Data) async throws {\n        // Encrypt before upload\n        let encrypted = try await crypto.encrypt(data)\n\n        // Upload encrypted data\n        try await uploadToServer(encrypted)\n    }\n}\n</code></pre>"},{"location":"guides/crypto/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guides/crypto/#common-issues","title":"Common Issues","text":"<ol> <li> <p>Key Validation <pre><code>// Validate key before use\nguard try service.validateKey(key) else {\n    throw CryptoError.invalidKey\n}\n</code></pre></p> </li> <li> <p>Memory Management <pre><code>// Clear sensitive data\ndefer {\n    key.zero()\n    plaintext.zero()\n}\n</code></pre></p> </li> <li> <p>Performance Optimization <pre><code>// Use batch operations for multiple items\nlet results = try await withThrowingTaskGroup(of: (String, Data).self) { group in\n    for (id, data) in items {\n        group.addTask {\n            let encrypted = try await service.encrypt(data)\n            return (id, encrypted)\n        }\n    }\n    return try await group.reduce(into: [:]) { $0[$1.0] = $1.1 }\n}\n</code></pre></p> </li> </ol>"},{"location":"guides/error-handling/","title":"Error Handling in UmbraCore","text":""},{"location":"guides/error-handling/#overview","title":"Overview","text":"<p>UmbraCore uses a structured error handling system that provides detailed error context, supports error recovery, and integrates with the logging system. This guide explains our error handling patterns and best practices.</p>"},{"location":"guides/error-handling/#error-types","title":"Error Types","text":""},{"location":"guides/error-handling/#1-common-errors","title":"1. Common Errors","text":"<p>Base error types shared across the library:</p> <pre><code>enum CommonError: Error {\n    case invalidArgument(String)\n    case resourceNotFound(String)\n    case permissionDenied(String)\n    case operationFailed(String)\n\n    var localizedDescription: String {\n        switch self {\n        case .invalidArgument(let details):\n            return \"Invalid argument: \\(details)\"\n        case .resourceNotFound(let resource):\n            return \"Resource not found: \\(resource)\"\n        case .permissionDenied(let operation):\n            return \"Permission denied for operation: \\(operation)\"\n        case .operationFailed(let reason):\n            return \"Operation failed: \\(reason)\"\n        }\n    }\n}\n</code></pre>"},{"location":"guides/error-handling/#2-service-specific-errors","title":"2. Service-Specific Errors","text":"<p>Each service defines its domain-specific errors:</p> <pre><code>enum KeychainError: Error {\n    case itemNotFound(String)\n    case duplicateItem(String)\n    case accessDenied(String)\n    case invalidData(String)\n}\n\nenum CryptoError: Error {\n    case encryptionFailed(String)\n    case decryptionFailed(String)\n    case invalidKey(String)\n    case algorithmNotSupported(String)\n}\n</code></pre>"},{"location":"guides/error-handling/#3-error-context","title":"3. Error Context","text":"<p>Additional context for debugging and recovery:</p> <pre><code>struct ErrorContext {\n    let file: String\n    let function: String\n    let line: Int\n    let timestamp: Date\n    let operationId: UUID\n    var userInfo: [String: Any]\n\n    var description: String {\n        \"\"\"\n        Error occurred in \\(function)\n        File: \\(file):\\(line)\n        Time: \\(timestamp)\n        Operation: \\(operationId)\n        Additional Info: \\(userInfo)\n        \"\"\"\n    }\n}\n</code></pre>"},{"location":"guides/error-handling/#best-practices","title":"Best Practices","text":""},{"location":"guides/error-handling/#1-error-creation","title":"1. Error Creation","text":"<p>Create informative errors with context:</p> <pre><code>func processFile(_ url: URL) async throws {\n    guard FileManager.default.fileExists(atPath: url.path) else {\n        throw CommonError.resourceNotFound(\n            \"\"\"\n            File not found at \\(url.path)\n            Check if the file exists and you have read permissions.\n            \"\"\"\n        )\n    }\n}\n</code></pre>"},{"location":"guides/error-handling/#2-error-handling","title":"2. Error Handling","text":"<p>Handle errors at appropriate levels:</p> <pre><code>func backupFiles() async throws {\n    do {\n        try await validatePermissions()\n        try await performBackup()\n        try await verifyBackup()\n    } catch KeychainError.accessDenied(let details) {\n        logger.error(\"Keychain access denied\", metadata: [\n            \"details\": details,\n            \"operation\": \"backup\"\n        ])\n        throw CommonError.permissionDenied(\"Keychain access required for backup\")\n    } catch CryptoError.encryptionFailed(let reason) {\n        logger.error(\"Encryption failed\", metadata: [\n            \"reason\": reason,\n            \"operation\": \"backup\"\n        ])\n        throw CommonError.operationFailed(\"Backup encryption failed\")\n    }\n}\n</code></pre>"},{"location":"guides/error-handling/#3-error-recovery","title":"3. Error Recovery","text":"<p>Implement recovery strategies:</p> <pre><code>actor RetryableOperation {\n    func execute() async throws -&gt; Result {\n        var attempts = 0\n        while attempts &lt; maxRetries {\n            do {\n                return try await performOperation()\n            } catch let error as RecoverableError {\n                attempts += 1\n                try await handleError(error, attempt: attempts)\n            } catch {\n                throw error // Non-recoverable error\n            }\n        }\n        throw CommonError.operationFailed(\"Max retry attempts exceeded\")\n    }\n}\n</code></pre>"},{"location":"guides/error-handling/#error-patterns","title":"Error Patterns","text":""},{"location":"guides/error-handling/#1-result-type-usage","title":"1. Result Type Usage","text":"<p>For operations that might fail:</p> <pre><code>enum OperationResult&lt;T&gt; {\n    case success(T)\n    case failure(Error)\n    case partial(T, [Error])\n\n    var value: T? {\n        switch self {\n        case .success(let value), .partial(let value, _):\n            return value\n        case .failure:\n            return nil\n        }\n    }\n}\n\nfunc processItems(_ items: [Item]) async -&gt; OperationResult&lt;[ProcessedItem]&gt; {\n    var processed: [ProcessedItem] = []\n    var errors: [Error] = []\n\n    for item in items {\n        do {\n            let result = try await process(item)\n            processed.append(result)\n        } catch {\n            errors.append(error)\n        }\n    }\n\n    if errors.isEmpty {\n        return .success(processed)\n    } else if processed.isEmpty {\n        return .failure(CommonError.operationFailed(\"All items failed\"))\n    } else {\n        return .partial(processed, errors)\n    }\n}\n</code></pre>"},{"location":"guides/error-handling/#2-error-transformation","title":"2. Error Transformation","text":"<p>Convert between error types while preserving context:</p> <pre><code>extension Error {\n    func asCommonError() -&gt; CommonError {\n        switch self {\n        case let error as KeychainError:\n            return error.toCommonError()\n        case let error as CryptoError:\n            return error.toCommonError()\n        default:\n            return .operationFailed(localizedDescription)\n        }\n    }\n}\n\nextension KeychainError {\n    func toCommonError() -&gt; CommonError {\n        switch self {\n        case .accessDenied(let details):\n            return .permissionDenied(\"Keychain: \\(details)\")\n        case .itemNotFound(let key):\n            return .resourceNotFound(\"Keychain item: \\(key)\")\n        // ... other cases\n        }\n    }\n}\n</code></pre>"},{"location":"guides/error-handling/#3-async-error-handling","title":"3. Async Error Handling","text":"<p>Handle errors in async contexts:</p> <pre><code>actor ErrorHandler {\n    func handle&lt;T&gt;(_ operation: @escaping () async throws -&gt; T) async throws -&gt; T {\n        do {\n            return try await operation()\n        } catch {\n            try await logError(error)\n            try await notifyObservers(of: error)\n            throw error\n        }\n    }\n}\n</code></pre>"},{"location":"guides/error-handling/#integration-with-logging","title":"Integration with Logging","text":""},{"location":"guides/error-handling/#1-error-logging","title":"1. Error Logging","text":"<p>Log errors with context:</p> <pre><code>extension Logger {\n    func logError(\n        _ error: Error,\n        context: ErrorContext,\n        file: String = #file,\n        function: String = #function,\n        line: Int = #line\n    ) {\n        error(\n            \"Error occurred\",\n            metadata: [\n                \"error\": \"\\(error)\",\n                \"context\": \"\\(context)\",\n                \"file\": \"\\(file)\",\n                \"function\": \"\\(function)\",\n                \"line\": \"\\(line)\"\n            ]\n        )\n    }\n}\n</code></pre>"},{"location":"guides/error-handling/#2-error-monitoring","title":"2. Error Monitoring","text":"<p>Track error patterns:</p> <pre><code>actor ErrorMonitor {\n    private var errorCounts: [String: Int] = [:]\n\n    func record(_ error: Error) async {\n        let key = String(describing: type(of: error))\n        errorCounts[key, default: 0] += 1\n\n        if errorCounts[key] ?? 0 &gt; threshold {\n            await notifyHighErrorRate(type: key)\n        }\n    }\n}\n</code></pre>"},{"location":"guides/error-handling/#testing","title":"Testing","text":""},{"location":"guides/error-handling/#1-error-scenarios","title":"1. Error Scenarios","text":"<p>Test error handling paths:</p> <pre><code>func testErrorHandling() async throws {\n    let service = TestService()\n\n    do {\n        try await service.operationThatFails()\n        XCTFail(\"Expected error not thrown\")\n    } catch let error as CommonError {\n        XCTAssertEqual(\n            error.localizedDescription,\n            \"Expected error message\"\n        )\n    }\n}\n</code></pre>"},{"location":"guides/error-handling/#2-recovery-testing","title":"2. Recovery Testing","text":"<p>Test error recovery mechanisms:</p> <pre><code>func testErrorRecovery() async throws {\n    let operation = RetryableOperation()\n\n    // Inject failures\n    operation.injectFailures(count: 2)\n\n    // Should succeed after retries\n    let result = try await operation.execute()\n    XCTAssertNotNil(result)\n}\n</code></pre>"},{"location":"guides/error-handling/#3-error-context-testing","title":"3. Error Context Testing","text":"<p>Verify error context information:</p> <p>```swift func testErrorContext() async throws {     let operation = ContextualOperation()</p> <pre><code>do {\n    try await operation.execute()\n    XCTFail(\"Expected error not thrown\")\n} catch {\n    let context = try XCTUnwrap(error.errorContext)\n    XCTAssertEqual(context.function, \"execute\")\n    XCTAssertNotNil(context.operationId)\n}\n</code></pre> <p>}</p>"},{"location":"guides/keychain/","title":"UmbraKeychainService Guide","text":""},{"location":"guides/keychain/#overview","title":"Overview","text":"<p><code>UmbraKeychainService</code> provides secure credential storage using macOS Keychain. It handles repository passwords, API keys, and other sensitive data.</p>"},{"location":"guides/keychain/#features","title":"Features","text":"<ul> <li>Secure credential storage</li> <li>XPC-based access</li> <li>Thread-safe operations</li> <li>Automatic error handling</li> </ul>"},{"location":"guides/keychain/#basic-usage","title":"Basic Usage","text":""},{"location":"guides/keychain/#storing-credentials","title":"Storing Credentials","text":"<pre><code>let service = try UmbraKeychainService()\n\n// Store a repository password\ntry await service.store(\n    password: \"secret-password\",\n    forKey: \"backup-repository\"\n)\n\n// Store an API key\ntry await service.store(\n    password: \"api-key-12345\",\n    forKey: \"cloud-provider\"\n)\n</code></pre>"},{"location":"guides/keychain/#retrieving-credentials","title":"Retrieving Credentials","text":"<pre><code>// Get repository password\nlet password = try await service.retrieve(forKey: \"backup-repository\")\n\n// Get API key\nlet apiKey = try await service.retrieve(forKey: \"cloud-provider\")\n</code></pre>"},{"location":"guides/keychain/#updating-credentials","title":"Updating Credentials","text":"<pre><code>try await service.update(\n    password: \"new-password\",\n    forKey: \"backup-repository\"\n)\n</code></pre>"},{"location":"guides/keychain/#removing-credentials","title":"Removing Credentials","text":"<pre><code>try await service.remove(forKey: \"backup-repository\")\n</code></pre>"},{"location":"guides/keychain/#error-handling","title":"Error Handling","text":"<pre><code>do {\n    try await service.store(password: \"secret\", forKey: \"key\")\n} catch KeychainError.duplicateItem(let key) {\n    // Handle duplicate item\n} catch KeychainError.accessDenied(let reason) {\n    // Handle access denied\n} catch {\n    // Handle other errors\n}\n</code></pre>"},{"location":"guides/keychain/#best-practices","title":"Best Practices","text":""},{"location":"guides/keychain/#1-key-naming","title":"1. Key Naming","text":"<ul> <li>Use descriptive, consistent keys</li> <li>Include context in key names</li> <li>Follow naming conventions</li> </ul> <pre><code>// Good\n\"backup-repo-main-password\"\n\"aws-access-key-prod\"\n\n// Bad\n\"pwd1\"\n\"key\"\n</code></pre>"},{"location":"guides/keychain/#2-error-recovery","title":"2. Error Recovery","text":"<ul> <li>Implement retry logic</li> <li>Provide user feedback</li> <li>Log failures appropriately</li> </ul>"},{"location":"guides/keychain/#3-security","title":"3. Security","text":"<ul> <li>Never store keys in code</li> <li>Use appropriate access control</li> <li>Clean up unused credentials</li> </ul>"},{"location":"guides/keychain/#advanced-usage","title":"Advanced Usage","text":""},{"location":"guides/keychain/#1-custom-item-attributes","title":"1. Custom Item Attributes","text":"<pre><code>let attributes = KeychainItemAttributes(\n    label: \"Main Backup Repository\",\n    comment: \"Production backup credentials\"\n)\n\ntry await service.store(\n    password: \"secret\",\n    forKey: \"backup-repo\",\n    attributes: attributes\n)\n</code></pre>"},{"location":"guides/keychain/#2-batch-operations","title":"2. Batch Operations","text":"<pre><code>let credentials = [\n    \"repo1\": \"password1\",\n    \"repo2\": \"password2\"\n]\n\ntry await service.storeBatch(credentials)\n</code></pre>"},{"location":"guides/keychain/#3-access-control","title":"3. Access Control","text":"<pre><code>let access = KeychainAccess(\n    accessibility: .whenUnlocked,\n    authentication: .biometric\n)\n\ntry await service.store(\n    password: \"secret\",\n    forKey: \"secure-key\",\n    access: access\n)\n</code></pre>"},{"location":"guides/keychain/#integration-examples","title":"Integration Examples","text":""},{"location":"guides/keychain/#1-repository-setup","title":"1. Repository Setup","text":"<pre><code>func setupRepository() async throws {\n    let service = try UmbraKeychainService()\n\n    // Store repository password\n    try await service.store(\n        password: repositoryPassword,\n        forKey: \"repo-\\(repoId)\"\n    )\n\n    // Store cloud credentials if needed\n    if let cloudKey = cloudCredentials {\n        try await service.store(\n            password: cloudKey,\n            forKey: \"cloud-\\(repoId)\"\n        )\n    }\n}\n</code></pre>"},{"location":"guides/keychain/#2-credential-management","title":"2. Credential Management","text":"<pre><code>class CredentialManager {\n    private let keychain: UmbraKeychainService\n\n    init() throws {\n        keychain = try UmbraKeychainService()\n    }\n\n    func rotateCredentials() async throws {\n        let newPassword = generateSecurePassword()\n\n        try await keychain.update(\n            password: newPassword,\n            forKey: \"repo-main\"\n        )\n\n        try await updateRemoteRepository(password: newPassword)\n    }\n}\n</code></pre>"},{"location":"guides/keychain/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guides/keychain/#common-issues","title":"Common Issues","text":"<ol> <li> <p>Access Denied <pre><code>// Check keychain access\ntry await service.checkAccess()\n\n// Request user permission if needed\ntry await service.requestAccess()\n</code></pre></p> </li> <li> <p>Duplicate Items <pre><code>// Update instead of store for existing items\nif await service.exists(forKey: key) {\n    try await service.update(password: newPassword, forKey: key)\n} else {\n    try await service.store(password: newPassword, forKey: key)\n}\n</code></pre></p> </li> <li> <p>Item Not Found <pre><code>// Implement fallback logic\nfunc getCredential(forKey key: String) async throws -&gt; String {\n    do {\n        return try await service.retrieve(forKey: key)\n    } catch KeychainError.itemNotFound {\n        // Implement recovery logic\n        return try await recoverCredential(forKey: key)\n    }\n}\n</code></pre></p> </li> </ol>"},{"location":"guides/logging/","title":"UmbraLogging Guide","text":""},{"location":"guides/logging/#overview","title":"Overview","text":"<p><code>UmbraLogging</code> provides a centralised, structured logging system built on SwiftyBeaver. It supports multiple destinations, log levels, and contextual metadata.</p>"},{"location":"guides/logging/#features","title":"Features","text":"<ul> <li>Structured logging</li> <li>Multiple log levels</li> <li>Context metadata</li> <li>File output</li> <li>Console output</li> <li>Custom formatters</li> </ul>"},{"location":"guides/logging/#basic-usage","title":"Basic Usage","text":""},{"location":"guides/logging/#configuration","title":"Configuration","text":"<pre><code>import UmbraLogging\n\n// Basic setup\nUmbraLogger.configure(level: .info)\n\n// Custom configuration\nlet config = LoggerConfiguration(\n    level: .debug,\n    destinations: [.console, .file],\n    metadata: [\"app\": \"UmbraCore\"]\n)\nUmbraLogger.configure(config)\n</code></pre>"},{"location":"guides/logging/#logging-messages","title":"Logging Messages","text":"<pre><code>// Basic logging\nlogger.info(\"Backup started\")\nlogger.error(\"Failed to access repository\")\n\n// With metadata\nlogger.info(\"File processed\", metadata: [\n    \"size\": fileSize,\n    \"path\": filePath\n])\n\n// With error context\nlogger.error(\"Backup failed\", error: error, metadata: [\n    \"repository\": repoId,\n    \"files\": fileCount\n])\n</code></pre>"},{"location":"guides/logging/#log-levels","title":"Log Levels","text":""},{"location":"guides/logging/#available-levels","title":"Available Levels","text":"<pre><code>// Verbose - detailed information\nlogger.verbose(\"Entering backup loop\")\n\n// Debug - debugging information\nlogger.debug(\"Processing file: \\(filename)\")\n\n// Info - general information\nlogger.info(\"Backup completed successfully\")\n\n// Warning - potential issues\nlogger.warning(\"Repository space low\")\n\n// Error - operation failures\nlogger.error(\"Failed to store credential\")\n\n// Critical - system-wide issues\nlogger.critical(\"Database corruption detected\")\n</code></pre>"},{"location":"guides/logging/#best-practices","title":"Best Practices","text":""},{"location":"guides/logging/#1-log-level-selection","title":"1. Log Level Selection","text":"<pre><code>// Development\n#if DEBUG\n    UmbraLogger.configure(level: .debug)\n#else\n    UmbraLogger.configure(level: .info)\n#endif\n\n// Production with environment override\nif let levelString = Environment.logLevel {\n    UmbraLogger.configure(level: LogLevel(string: levelString))\n}\n</code></pre>"},{"location":"guides/logging/#2-contextual-information","title":"2. Contextual Information","text":"<pre><code>// Add operation context\nlogger.info(\"Starting backup\", metadata: [\n    \"operation\": \"backup\",\n    \"type\": \"incremental\",\n    \"source\": sourcePath,\n    \"destination\": destPath\n])\n\n// Add error context\nlogger.error(\"Operation failed\", metadata: [\n    \"operation\": operation.name,\n    \"duration\": duration,\n    \"retries\": retryCount,\n    \"error\": error.localizedDescription\n])\n</code></pre>"},{"location":"guides/logging/#3-sensitive-data","title":"3. Sensitive Data","text":"<pre><code>// Never log credentials\nlogger.info(\"Connecting to repository\", metadata: [\n    \"url\": repository.url,\n    \"type\": repository.type\n    // DON'T include passwords or keys\n])\n\n// Mask sensitive data\nlogger.info(\"User authenticated\", metadata: [\n    \"user\": user.id,\n    \"token\": \"****\" // Masked token\n])\n</code></pre>"},{"location":"guides/logging/#advanced-usage","title":"Advanced Usage","text":""},{"location":"guides/logging/#1-custom-destinations","title":"1. Custom Destinations","text":"<pre><code>let customDestination = LogDestination(\n    identifier: \"analytics\",\n    minimumLevel: .info,\n    formatter: AnalyticsFormatter()\n)\n\nUmbraLogger.addDestination(customDestination)\n</code></pre>"},{"location":"guides/logging/#2-custom-formatters","title":"2. Custom Formatters","text":"<pre><code>class JSONFormatter: LogFormatter {\n    func format(_ entry: LogEntry) -&gt; String {\n        let json: [String: Any] = [\n            \"timestamp\": entry.timestamp,\n            \"level\": entry.level.rawValue,\n            \"message\": entry.message,\n            \"metadata\": entry.metadata\n        ]\n        return try! JSONSerialization.data(withJSONObject: json)\n    }\n}\n</code></pre>"},{"location":"guides/logging/#3-context-managers","title":"3. Context Managers","text":"<pre><code>class OperationContext {\n    private var metadata: [String: Any]\n\n    func execute(_ operation: String) async throws {\n        logger.withMetadata(metadata) {\n            logger.info(\"Starting operation\")\n            // Execute operation\n            logger.info(\"Operation completed\")\n        }\n    }\n}\n</code></pre>"},{"location":"guides/logging/#integration-examples","title":"Integration Examples","text":""},{"location":"guides/logging/#1-service-integration","title":"1. Service Integration","text":"<pre><code>class BackupService {\n    private let logger = UmbraLogger.forModule(\"BackupService\")\n\n    func performBackup() async throws {\n        logger.info(\"Starting backup\", metadata: [\n            \"type\": backupType,\n            \"files\": fileCount\n        ])\n\n        do {\n            try await runBackup()\n            logger.info(\"Backup completed\")\n        } catch {\n            logger.error(\"Backup failed\", error: error)\n            throw error\n        }\n    }\n}\n</code></pre>"},{"location":"guides/logging/#2-error-tracking","title":"2. Error Tracking","text":"<pre><code>class ErrorTracker {\n    private let logger = UmbraLogger.forModule(\"ErrorTracker\")\n\n    func track(_ error: Error, context: [String: Any]) {\n        logger.error(\"Error occurred\", metadata: [\n            \"error\": error.localizedDescription,\n            \"type\": String(describing: type(of: error)),\n            \"context\": context\n        ])\n    }\n}\n</code></pre>"},{"location":"guides/logging/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guides/logging/#common-issues","title":"Common Issues","text":"<ol> <li> <p>Log File Management <pre><code>// Rotate log files\nUmbraLogger.configure(\n    fileConfig: FileConfiguration(\n        directory: logDirectory,\n        maxFileSize: 10_000_000,  // 10MB\n        maxFileCount: 5\n    )\n)\n</code></pre></p> </li> <li> <p>Performance Optimization <pre><code>// Avoid expensive logging in production\nif logger.isEnabled(for: .debug) {\n    let expensive = calculateExpensiveMetadata()\n    logger.debug(\"Details\", metadata: expensive)\n}\n</code></pre></p> </li> <li> <p>Error Investigation <pre><code>// Enable full debug logging temporarily\nUmbraLogger.configure(\n    level: .verbose,\n    destinations: [.console, .file],\n    metadata: [\"debug\": true]\n)\n</code></pre></p> </li> </ol>"},{"location":"guides/performance/","title":"Performance Optimisation in UmbraCore","text":""},{"location":"guides/performance/#overview","title":"Overview","text":"<p>Performance is crucial for backup operations. This guide covers performance optimisation techniques used in UmbraCore and best practices for maintaining high performance.</p>"},{"location":"guides/performance/#core-principles","title":"Core Principles","text":""},{"location":"guides/performance/#1-asynchronous-operations","title":"1. Asynchronous Operations","text":"<p>Leverage Swift's async/await for non-blocking operations:</p> <pre><code>actor BackupCoordinator {\n    func backupMultipleDirectories(_ paths: [String]) async throws {\n        try await withThrowingTaskGroup(of: Void.self) { group in\n            for path in paths {\n                group.addTask {\n                    try await backupDirectory(path)\n                }\n            }\n            try await group.waitForAll()\n        }\n    }\n}\n</code></pre>"},{"location":"guides/performance/#2-memory-management","title":"2. Memory Management","text":"<p>Efficient memory usage patterns:</p> <pre><code>actor StreamProcessor {\n    // Use streams for large data\n    func processLargeFile(_ url: URL) async throws {\n        for try await line in url.lines {\n            try await processLine(line)\n        }\n    }\n\n    // Batch small operations\n    func processBatch(_ items: [Item]) async throws {\n        let batchSize = 100\n        for batch in items.chunked(into: batchSize) {\n            try await processBatchItems(batch)\n        }\n    }\n}\n</code></pre>"},{"location":"guides/performance/#3-resource-pooling","title":"3. Resource Pooling","text":"<p>Pool and reuse expensive resources:</p> <pre><code>actor ConnectionPool {\n    private var connections: [Connection] = []\n    private let maxConnections = 10\n\n    func acquire() async throws -&gt; Connection {\n        if let connection = connections.popLast() {\n            return connection\n        }\n\n        guard connections.count &lt; maxConnections else {\n            throw PoolError.maxConnectionsReached\n        }\n\n        return try await createConnection()\n    }\n\n    func release(_ connection: Connection) async {\n        if connections.count &lt; maxConnections {\n            connections.append(connection)\n        } else {\n            await connection.close()\n        }\n    }\n}\n</code></pre>"},{"location":"guides/performance/#optimisation-techniques","title":"Optimisation Techniques","text":""},{"location":"guides/performance/#1-caching","title":"1. Caching","text":"<p>Implement efficient caching strategies:</p> <pre><code>actor CacheManager {\n    private var cache = NSCache&lt;NSString, AnyObject&gt;()\n    private let fileManager = FileManager.default\n\n    func cachedValue(\n        forKey key: String,\n        generator: () async throws -&gt; Any\n    ) async throws -&gt; Any {\n        // Check memory cache\n        if let cached = cache.object(forKey: key as NSString) {\n            return cached\n        }\n\n        // Generate new value\n        let value = try await generator()\n        cache.setObject(value as AnyObject, forKey: key as NSString)\n        return value\n    }\n\n    func clearStaleEntries() async {\n        // Implement cache eviction policy\n    }\n}\n</code></pre>"},{"location":"guides/performance/#2-data-structures","title":"2. Data Structures","text":"<p>Choose appropriate data structures:</p> <pre><code>struct PerformanceOptimised {\n    // Use Set for fast lookups\n    private var processedItems: Set&lt;String&gt; = []\n\n    // Use Dictionary for O(1) access\n    private var itemCache: [String: Item] = [:]\n\n    // Use Array for ordered data\n    private var processingQueue: [Item] = []\n\n    // Use ContiguousArray for better performance with value types\n    private var metrics: ContiguousArray&lt;Double&gt; = []\n}\n</code></pre>"},{"location":"guides/performance/#3-lazy-loading","title":"3. Lazy Loading","text":"<p>Defer expensive operations:</p> <pre><code>class LazyResource {\n    private lazy var expensiveResource: Resource = {\n        createExpensiveResource()\n    }()\n\n    private func createExpensiveResource() -&gt; Resource {\n        // Only created when first accessed\n        Resource(configuration: loadConfiguration())\n    }\n}\n</code></pre>"},{"location":"guides/performance/#performance-monitoring","title":"Performance Monitoring","text":""},{"location":"guides/performance/#1-metrics-collection","title":"1. Metrics Collection","text":"<p>Track performance metrics:</p> <pre><code>actor PerformanceMonitor {\n    private var metrics: [String: [TimeInterval]] = [:]\n\n    func measure&lt;T&gt;(\n        operation: String,\n        block: () async throws -&gt; T\n    ) async throws -&gt; T {\n        let start = ProcessInfo.processInfo.systemUptime\n        let result = try await block()\n        let duration = ProcessInfo.processInfo.systemUptime - start\n\n        await record(operation: operation, duration: duration)\n        return result\n    }\n\n    private func record(operation: String, duration: TimeInterval) {\n        metrics[operation, default: []].append(duration)\n\n        if metrics[operation]?.count ?? 0 &gt; 1000 {\n            metrics[operation]?.removeFirst(500)\n        }\n    }\n\n    func getMetrics(for operation: String) -&gt; PerformanceMetrics {\n        guard let measurements = metrics[operation] else {\n            return PerformanceMetrics.empty\n        }\n\n        return PerformanceMetrics(\n            average: measurements.average,\n            median: measurements.median,\n            percentile95: measurements.percentile(95),\n            count: measurements.count\n        )\n    }\n}\n</code></pre>"},{"location":"guides/performance/#2-performance-logging","title":"2. Performance Logging","text":"<p>Log performance data:</p> <pre><code>extension Logger {\n    func logPerformance(\n        _ metrics: PerformanceMetrics,\n        operation: String,\n        file: String = #file,\n        function: String = #function\n    ) {\n        info(\n            \"Performance metrics\",\n            metadata: [\n                \"operation\": \"\\(operation)\",\n                \"average\": \"\\(metrics.average)\",\n                \"median\": \"\\(metrics.median)\",\n                \"p95\": \"\\(metrics.percentile95)\",\n                \"count\": \"\\(metrics.count)\",\n                \"file\": \"\\(file)\",\n                \"function\": \"\\(function)\"\n            ]\n        )\n    }\n}\n</code></pre>"},{"location":"guides/performance/#3-alerts-and-thresholds","title":"3. Alerts and Thresholds","text":"<p>Monitor performance thresholds:</p> <pre><code>actor PerformanceAlert {\n    private let thresholds: [String: TimeInterval]\n    private let notifier: AlertNotifier\n\n    func checkThresholds(_ metrics: PerformanceMetrics, operation: String) async {\n        guard let threshold = thresholds[operation] else { return }\n\n        if metrics.percentile95 &gt; threshold {\n            await notifier.alert(\n                \"\"\"\n                Performance degradation detected:\n                Operation: \\(operation)\n                P95: \\(metrics.percentile95)\n                Threshold: \\(threshold)\n                \"\"\"\n            )\n        }\n    }\n}\n</code></pre>"},{"location":"guides/performance/#best-practices","title":"Best Practices","text":""},{"location":"guides/performance/#1-batch-processing","title":"1. Batch Processing","text":"<p>Batch operations for efficiency:</p> <pre><code>actor BatchProcessor {\n    private let batchSize = 100\n\n    func process(_ items: [Item]) async throws {\n        let batches = items.chunked(into: batchSize)\n\n        try await withThrowingTaskGroup(of: Void.self) { group in\n            for batch in batches {\n                group.addTask {\n                    try await processBatch(batch)\n                }\n            }\n            try await group.waitForAll()\n        }\n    }\n}\n</code></pre>"},{"location":"guides/performance/#2-resource-management","title":"2. Resource Management","text":"<p>Proper resource cleanup:</p> <pre><code>class ManagedResource {\n    private var resources: [Resource] = []\n\n    func use&lt;T&gt;(_ resource: Resource, operation: (Resource) throws -&gt; T) throws -&gt; T {\n        resources.append(resource)\n        defer {\n            resource.cleanup()\n            resources.removeAll { $0 === resource }\n        }\n        return try operation(resource)\n    }\n}\n</code></pre>"},{"location":"guides/performance/#3-background-processing","title":"3. Background Processing","text":"<p>Offload heavy work:</p> <pre><code>actor BackgroundProcessor {\n    private let queue = DispatchQueue(\n        label: \"com.umbracore.background\",\n        qos: .background\n    )\n\n    func processInBackground(_ work: @escaping () -&gt; Void) {\n        queue.async {\n            work()\n        }\n    }\n}\n</code></pre>"},{"location":"guides/performance/#testing","title":"Testing","text":""},{"location":"guides/performance/#1-performance-tests","title":"1. Performance Tests","text":"<p>Test performance metrics:</p> <pre><code>class PerformanceTests: XCTestCase {\n    func testOperationPerformance() throws {\n        measure {\n            // Performance-critical code\n        }\n    }\n\n    func testAsyncPerformance() async throws {\n        let metrics = try await measureAsync {\n            try await performOperation()\n        }\n\n        XCTAssertLessThan(metrics.average, 0.1)\n        XCTAssertLessThan(metrics.percentile95, 0.2)\n    }\n}\n</code></pre>"},{"location":"guides/performance/#2-memory-tests","title":"2. Memory Tests","text":"<p>Test memory usage:</p> <pre><code>class MemoryTests: XCTestCase {\n    func testMemoryUsage() throws {\n        let tracker = MemoryTracker()\n\n        autoreleasepool {\n            // Memory-intensive operation\n        }\n\n        XCTAssertLessThan(\n            tracker.peakMemoryUsage,\n            50 * 1024 * 1024 // 50MB\n        )\n    }\n}\n</code></pre>"},{"location":"guides/performance/#3-load-tests","title":"3. Load Tests","text":"<p>Test under load:</p> <p>```swift class LoadTests: XCTestCase {     func testConcurrentOperations() async throws {         let operations = 1000         let service = TestService()</p> <pre><code>    try await withThrowingTaskGroup(of: Void.self) { group in\n        for _ in 0..&lt;operations {\n            group.addTask {\n                try await service.operation()\n            }\n        }\n        try await group.waitForAll()\n    }\n}\n</code></pre> <p>}</p>"},{"location":"guides/security/","title":"Security Guidelines","text":"<p>This guide outlines security best practices for using UmbraCore.</p>"},{"location":"guides/security/#core-principles","title":"Core Principles","text":"<ol> <li>Least Privilege: Only request necessary permissions</li> <li>Data Protection: Secure all sensitive data</li> <li>Secure Communication: Use encrypted channels</li> <li>Audit Logging: Track security-relevant events</li> </ol>"},{"location":"guides/security/#secure-storage","title":"Secure Storage","text":""},{"location":"guides/security/#password-storage","title":"Password Storage","text":"<ul> <li>Use <code>SecureString</code> for passwords</li> <li>Implement proper password policies</li> <li>Use secure key derivation</li> </ul>"},{"location":"guides/security/#repository-encryption","title":"Repository Encryption","text":"<ul> <li>Use strong encryption keys</li> <li>Implement key rotation</li> <li>Secure key storage</li> </ul>"},{"location":"guides/security/#network-security","title":"Network Security","text":""},{"location":"guides/security/#remote-repositories","title":"Remote Repositories","text":"<ul> <li>Use SSH or HTTPS</li> <li>Validate certificates</li> <li>Implement rate limiting</li> <li>Handle network errors securely</li> </ul>"},{"location":"guides/security/#api-security","title":"API Security","text":"<ul> <li>Use API tokens securely</li> <li>Implement request signing</li> <li>Validate all inputs</li> </ul>"},{"location":"guides/security/#error-handling","title":"Error Handling","text":""},{"location":"guides/security/#security-errors","title":"Security Errors","text":"<ul> <li>Log security events</li> <li>Don't expose sensitive data</li> <li>Implement proper error recovery</li> </ul>"},{"location":"guides/security/#access-control","title":"Access Control","text":"<ul> <li>Validate permissions</li> <li>Check file access rights</li> <li>Handle access denied errors</li> </ul>"},{"location":"guides/security/#best-practices","title":"Best Practices","text":"<ol> <li>Keep dependencies updated</li> <li>Regular security audits</li> <li>Follow cryptographic best practices</li> <li>Implement proper logging</li> <li>Regular penetration testing</li> </ol>"},{"location":"guides/thread-safety/","title":"Thread Safety in UmbraCore","text":""},{"location":"guides/thread-safety/#overview","title":"Overview","text":"<p>UmbraCore is designed to be thread-safe by default. All public APIs can be safely called from multiple threads concurrently. This guide explains our thread safety guarantees and best practices.</p>"},{"location":"guides/thread-safety/#core-principles","title":"Core Principles","text":""},{"location":"guides/thread-safety/#1-actor-based-services","title":"1. Actor-Based Services","text":"<p>All core services in UmbraCore use Swift's actor system to ensure thread safety:</p> <pre><code>actor KeychainService {\n    private var cache: [String: Data] = [:]\n\n    func store(_ data: Data, forKey key: String) async throws {\n        // Thread-safe access to cache\n        cache[key] = data\n        try await persistToKeychain(data, key)\n    }\n}\n</code></pre>"},{"location":"guides/thread-safety/#2-immutable-state","title":"2. Immutable State","text":"<p>We prefer immutable state to minimize synchronization needs:</p> <pre><code>struct BackupConfig {\n    // Immutable properties\n    let sourcePath: String\n    let destinationPath: String\n    let excludePatterns: [String]\n\n    // Instead of mutating, create new instance\n    func withExcludePattern(_ pattern: String) -&gt; BackupConfig {\n        var patterns = excludePatterns\n        patterns.append(pattern)\n        return BackupConfig(\n            sourcePath: sourcePath,\n            destinationPath: destinationPath,\n            excludePatterns: patterns\n        )\n    }\n}\n</code></pre>"},{"location":"guides/thread-safety/#3-synchronized-collections","title":"3. Synchronized Collections","text":"<p>When mutable state is necessary, we use synchronized collections:</p> <pre><code>actor CacheManager {\n    private var cache = [String: Any]()\n    private let queue = DispatchQueue(label: \"com.umbracore.cache\")\n\n    func set(_ value: Any, forKey key: String) {\n        queue.sync { cache[key] = value }\n    }\n\n    func get(_ key: String) -&gt; Any? {\n        queue.sync { cache[key] }\n    }\n}\n</code></pre>"},{"location":"guides/thread-safety/#best-practices","title":"Best Practices","text":""},{"location":"guides/thread-safety/#1-asyncawait-usage","title":"1. Async/Await Usage","text":"<p>Always use async/await for asynchronous operations:</p> <pre><code>// Good\nfunc backupFiles() async throws {\n    try await prepareBackup()\n    try await performBackup()\n    try await cleanup()\n}\n\n// Avoid\nfunc backupFiles(completion: @escaping (Error?) -&gt; Void) {\n    prepareBackup { error in\n        guard error == nil else {\n            completion(error)\n            return\n        }\n        // Callback hell continues...\n    }\n}\n</code></pre>"},{"location":"guides/thread-safety/#2-resource-access","title":"2. Resource Access","text":"<p>Use proper resource access patterns:</p> <pre><code>actor ResourceManager {\n    private var isLocked = false\n\n    func acquireResource() async throws {\n        guard !isLocked else {\n            throw ResourceError.alreadyLocked\n        }\n        isLocked = true\n    }\n\n    func releaseResource() {\n        isLocked = false\n    }\n}\n</code></pre>"},{"location":"guides/thread-safety/#3-shared-state","title":"3. Shared State","text":"<p>Minimize shared state, use message passing:</p> <pre><code>actor BackupCoordinator {\n    private var activeBackups: Set&lt;UUID&gt; = []\n\n    func startBackup() async throws -&gt; UUID {\n        let id = UUID()\n        activeBackups.insert(id)\n        return id\n    }\n\n    func completeBackup(_ id: UUID) {\n        activeBackups.remove(id)\n    }\n}\n</code></pre>"},{"location":"guides/thread-safety/#common-patterns","title":"Common Patterns","text":""},{"location":"guides/thread-safety/#1-double-checked-locking","title":"1. Double-Checked Locking","text":"<p>For expensive initialization:</p> <pre><code>actor ConfigurationManager {\n    private var config: Configuration?\n\n    func getConfiguration() async throws -&gt; Configuration {\n        if let existing = config {\n            return existing\n        }\n\n        let loaded = try await loadConfiguration()\n        config = loaded\n        return loaded\n    }\n}\n</code></pre>"},{"location":"guides/thread-safety/#2-reader-writer-pattern","title":"2. Reader-Writer Pattern","text":"<p>For concurrent read access:</p> <pre><code>actor DatabaseManager {\n    private var isWriting = false\n    private var activeReaders = 0\n\n    func read() async throws -&gt; Data {\n        while isWriting {\n            try await Task.sleep(nanoseconds: 100_000)\n        }\n        activeReaders += 1\n        defer { activeReaders -= 1 }\n        return try getData()\n    }\n\n    func write(_ data: Data) async throws {\n        while activeReaders &gt; 0 {\n            try await Task.sleep(nanoseconds: 100_000)\n        }\n        isWriting = true\n        defer { isWriting = false }\n        try await writeData(data)\n    }\n}\n</code></pre>"},{"location":"guides/thread-safety/#3-task-management","title":"3. Task Management","text":"<p>For concurrent operations:</p> <pre><code>class BackupTask {\n    func executeParallel(_ operations: [Operation]) async throws {\n        try await withThrowingTaskGroup(of: Void.self) { group in\n            for operation in operations {\n                group.addTask {\n                    try await operation.execute()\n                }\n            }\n            try await group.waitForAll()\n        }\n    }\n}\n</code></pre>"},{"location":"guides/thread-safety/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guides/thread-safety/#1-deadlock-prevention","title":"1. Deadlock Prevention","text":"<pre><code>actor Service {\n    // Avoid nested actor calls\n    func operation1() async {\n        await operation2() // Could deadlock if not careful\n    }\n\n    func operation2() async {\n        // Implementation\n    }\n}\n\n// Better approach\nactor Service {\n    func operation1() async {\n        // Execute independently\n        try await Task.sleep(nanoseconds: 100_000)\n        await operation2()\n    }\n}\n</code></pre>"},{"location":"guides/thread-safety/#2-race-condition-detection","title":"2. Race Condition Detection","text":"<pre><code>actor StateManager {\n    private var state: State\n    private var version: UInt64 = 0\n\n    func modify(_ change: (State) -&gt; State) async {\n        let currentVersion = version\n        state = change(state)\n\n        // Detect concurrent modifications\n        guard version == currentVersion else {\n            throw ConcurrencyError.stateModified\n        }\n        version += 1\n    }\n}\n</code></pre>"},{"location":"guides/thread-safety/#3-performance-issues","title":"3. Performance Issues","text":"<pre><code>actor PerformanceOptimized {\n    // Batch operations to reduce actor hops\n    func batchOperation(_ items: [Item]) async {\n        // Single actor hop for batch\n        items.forEach { process($0) }\n    }\n\n    // Avoid frequent actor hops\n    private func process(_ item: Item) {\n        // Local processing\n    }\n}\n</code></pre>"},{"location":"guides/thread-safety/#testing","title":"Testing","text":""},{"location":"guides/thread-safety/#1-concurrency-testing","title":"1. Concurrency Testing","text":"<pre><code>func testConcurrentAccess() async throws {\n    let service = SharedService()\n\n    try await withThrowingTaskGroup(of: Void.self) { group in\n        for _ in 0..&lt;100 {\n            group.addTask {\n                try await service.operation()\n            }\n        }\n        try await group.waitForAll()\n    }\n}\n</code></pre>"},{"location":"guides/thread-safety/#2-race-condition-testing","title":"2. Race Condition Testing","text":"<p>```swift func testRaceConditions() async throws {     let service = SharedService()</p> <pre><code>async let operation1 = service.modify()\nasync let operation2 = service.modify()\n\n// This should handle concurrent modifications gracefully\ntry await [operation1, operation2]\n</code></pre> <p>}</p>"},{"location":"guides/xpc/","title":"UmbraXPC Guide","text":""},{"location":"guides/xpc/#overview","title":"Overview","text":"<p><code>UmbraXPC</code> provides a secure inter-process communication layer for UmbraCore services. It enables privilege separation and sandboxing while maintaining type safety and async/await support.</p>"},{"location":"guides/xpc/#features","title":"Features","text":"<ul> <li>Secure IPC communication</li> <li>Type-safe protocols</li> <li>Async/await support</li> <li>Error handling</li> <li>Privilege separation</li> </ul>"},{"location":"guides/xpc/#basic-usage","title":"Basic Usage","text":""},{"location":"guides/xpc/#service-definition","title":"Service Definition","text":"<pre><code>// Define XPC protocol\n@objc protocol KeychainXPCProtocol {\n    func store(password: String, forKey: String) async throws\n    func retrieve(forKey: String) async throws -&gt; String\n    func remove(forKey: String) async throws\n}\n\n// Implement service\nclass KeychainXPCService: NSObject, KeychainXPCProtocol {\n    func store(password: String, forKey: String) async throws {\n        // Implementation\n    }\n\n    // Other implementations...\n}\n</code></pre>"},{"location":"guides/xpc/#service-registration","title":"Service Registration","text":"<pre><code>// Register service\nlet service = XPCService(\n    service: KeychainXPCService(),\n    protocol: KeychainXPCProtocol.self\n)\n\ntry await service.register()\n</code></pre>"},{"location":"guides/xpc/#client-usage","title":"Client Usage","text":"<pre><code>// Connect to service\nlet client = try XPCClient&lt;KeychainXPCProtocol&gt;()\n\n// Use service\ntry await client.store(password: \"secret\", forKey: \"key\")\nlet value = try await client.retrieve(forKey: \"key\")\n</code></pre>"},{"location":"guides/xpc/#error-handling","title":"Error Handling","text":"<pre><code>do {\n    try await client.store(password: \"secret\", forKey: \"key\")\n} catch XPCError.connectionFailed {\n    // Handle connection failure\n} catch XPCError.serviceStopped {\n    // Handle service stop\n} catch {\n    // Handle other errors\n}\n</code></pre>"},{"location":"guides/xpc/#best-practices","title":"Best Practices","text":""},{"location":"guides/xpc/#1-protocol-design","title":"1. Protocol Design","text":"<pre><code>// Good protocol design\n@objc protocol BackupXPCProtocol {\n    // Clear operation names\n    func startBackup(source: URL, destination: URL) async throws\n\n    // Specific error types\n    func checkAccess(path: String) async throws -&gt; Bool\n\n    // Progress reporting\n    func getProgress() async throws -&gt; Double\n}\n</code></pre>"},{"location":"guides/xpc/#2-error-handling","title":"2. Error Handling","text":"<pre><code>// Define specific errors\nenum BackupXPCError: Error {\n    case accessDenied(String)\n    case insufficientSpace(needed: UInt64, available: UInt64)\n    case connectionLost\n}\n\n// Handle errors appropriately\ndo {\n    try await service.startBackup(source: src, destination: dest)\n} catch BackupXPCError.accessDenied(let path) {\n    // Handle access denied\n} catch BackupXPCError.insufficientSpace(let needed, let available) {\n    // Handle space issues\n}\n</code></pre>"},{"location":"guides/xpc/#3-resource-management","title":"3. Resource Management","text":"<pre><code>// Proper cleanup\nclass XPCManager {\n    private var client: XPCClient&lt;BackupXPCProtocol&gt;?\n\n    func shutdown() async {\n        await client?.disconnect()\n        client = nil\n    }\n}\n</code></pre>"},{"location":"guides/xpc/#advanced-usage","title":"Advanced Usage","text":""},{"location":"guides/xpc/#1-custom-message-handling","title":"1. Custom Message Handling","text":"<pre><code>class CustomXPCService: XPCServiceDelegate {\n    func handleCustomMessage(_ message: [String: Any]) async throws -&gt; Any {\n        // Custom message handling\n        switch message[\"type\"] as? String {\n        case \"status\":\n            return await getStatus()\n        case \"control\":\n            return try await handleControl(message)\n        default:\n            throw XPCError.invalidMessage\n        }\n    }\n}\n</code></pre>"},{"location":"guides/xpc/#2-progress-reporting","title":"2. Progress Reporting","text":"<pre><code>protocol ProgressReporting {\n    func reportProgress(_ progress: Double) async\n}\n\nclass BackupXPCService: ProgressReporting {\n    private var progress: Double = 0\n\n    func reportProgress(_ progress: Double) async {\n        self.progress = progress\n        await notifyObservers()\n    }\n}\n</code></pre>"},{"location":"guides/xpc/#3-connection-management","title":"3. Connection Management","text":"<pre><code>class XPCConnectionManager {\n    private var connections: [String: XPCClient&lt;Any&gt;] = [:]\n\n    func getConnection&lt;T&gt;(_ type: T.Type) async throws -&gt; XPCClient&lt;T&gt; {\n        let id = String(describing: type)\n\n        if let existing = connections[id] as? XPCClient&lt;T&gt; {\n            return existing\n        }\n\n        let new = try XPCClient&lt;T&gt;()\n        connections[id] = new\n        return new\n    }\n}\n</code></pre>"},{"location":"guides/xpc/#integration-examples","title":"Integration Examples","text":""},{"location":"guides/xpc/#1-backup-service","title":"1. Backup Service","text":"<pre><code>class BackupManager {\n    private let xpc: XPCClient&lt;BackupXPCProtocol&gt;\n\n    func startBackup() async throws {\n        // Connect to XPC service\n        try await xpc.connect()\n\n        // Start backup operation\n        try await xpc.startBackup(\n            source: sourceURL,\n            destination: destURL\n        )\n\n        // Monitor progress\n        for await progress in xpc.progressUpdates() {\n            updateUI(progress)\n        }\n    }\n}\n</code></pre>"},{"location":"guides/xpc/#2-security-service","title":"2. Security Service","text":"<pre><code>class SecurityManager {\n    private let xpc: XPCClient&lt;SecurityXPCProtocol&gt;\n\n    func validateAccess() async throws -&gt; Bool {\n        try await xpc.withConnection { service in\n            try await service.checkSecurity([\n                \"operation\": \"backup\",\n                \"level\": \"system\"\n            ])\n        }\n    }\n}\n</code></pre>"},{"location":"guides/xpc/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guides/xpc/#common-issues","title":"Common Issues","text":"<ol> <li> <p>Connection Issues <pre><code>// Implement retry logic\nfunc connectWithRetry() async throws -&gt; XPCClient&lt;T&gt; {\n    var attempts = 0\n    while attempts &lt; 3 {\n        do {\n            return try await XPCClient&lt;T&gt;().connect()\n        } catch {\n            attempts += 1\n            try await Task.sleep(nanoseconds: 1_000_000_000)\n        }\n    }\n    throw XPCError.connectionFailed\n}\n</code></pre></p> </li> <li> <p>Service Recovery <pre><code>// Handle service interruption\nfunc handleServiceFailure() async throws {\n    try await xpc.disconnect()\n    try await Task.sleep(nanoseconds: 1_000_000_000)\n    try await xpc.connect()\n}\n</code></pre></p> </li> <li> <p>Resource Cleanup <pre><code>// Proper resource management\nclass XPCResource {\n    private var resources: Set&lt;XPCClient&lt;Any&gt;&gt; = []\n\n    func cleanup() async {\n        for resource in resources {\n            await resource.disconnect()\n        }\n        resources.removeAll()\n    }\n}\n</code></pre></p> </li> </ol>"},{"location":"security/SECURITY_GUIDELINES/","title":"Security Guidelines","text":""},{"location":"security/SECURITY_GUIDELINES/#overview","title":"Overview","text":"<p>UmbraCore handles sensitive data and requires careful attention to security. This guide outlines our security practices and requirements.</p>"},{"location":"security/SECURITY_GUIDELINES/#secure-storage","title":"Secure Storage","text":""},{"location":"security/SECURITY_GUIDELINES/#1-credentials","title":"1. Credentials","text":"<ul> <li>Always use <code>UmbraKeychainService</code> for storing:</li> <li>Repository passwords</li> <li>API keys</li> <li>Access tokens</li> <li>SSH keys</li> </ul> <pre><code>// DO THIS:\ntry await keychainService.store(password: \"secret\", forKey: \"repo-key\")\n\n// DON'T DO THIS:\nUserDefaults.standard.set(\"secret\", forKey: \"repo-key\") // UNSAFE!\n</code></pre>"},{"location":"security/SECURITY_GUIDELINES/#2-file-system-access","title":"2. File System Access","text":"<ul> <li>Use <code>UmbraBookmarkService</code> for persistent file access</li> <li>Never store raw file paths</li> <li>Always use security-scoped bookmarks</li> </ul>"},{"location":"security/SECURITY_GUIDELINES/#encryption","title":"Encryption","text":""},{"location":"security/SECURITY_GUIDELINES/#1-data-at-rest","title":"1. Data at Rest","text":"<ul> <li>All sensitive data must be encrypted</li> <li>Use <code>UmbraCryptoService</code> for encryption/decryption</li> <li>Never store encryption keys in code</li> </ul>"},{"location":"security/SECURITY_GUIDELINES/#2-data-in-transit","title":"2. Data in Transit","text":"<ul> <li>Use secure transport (HTTPS, SSH)</li> <li>Validate certificates</li> <li>Implement proper error handling</li> </ul>"},{"location":"security/SECURITY_GUIDELINES/#access-control","title":"Access Control","text":""},{"location":"security/SECURITY_GUIDELINES/#1-xpc-services","title":"1. XPC Services","text":"<ul> <li>Principle of least privilege</li> <li>Separate process for sensitive operations</li> <li>Validate all inputs</li> </ul>"},{"location":"security/SECURITY_GUIDELINES/#2-file-permissions","title":"2. File Permissions","text":"<ul> <li>Respect system permissions</li> <li>Use security-scoped resources</li> <li>Clean up temporary files</li> </ul>"},{"location":"security/SECURITY_GUIDELINES/#logging","title":"Logging","text":""},{"location":"security/SECURITY_GUIDELINES/#1-sensitive-data","title":"1. Sensitive Data","text":"<ul> <li>Never log credentials</li> <li>Mask sensitive information</li> <li>Use appropriate log levels</li> </ul>"},{"location":"security/SECURITY_GUIDELINES/#2-audit-trail","title":"2. Audit Trail","text":"<ul> <li>Log security-relevant events</li> <li>Include necessary context</li> <li>Maintain audit logs</li> </ul>"},{"location":"security/SECURITY_GUIDELINES/#error-handling","title":"Error Handling","text":""},{"location":"security/SECURITY_GUIDELINES/#1-security-errors","title":"1. Security Errors","text":"<ul> <li>Don't expose internal details</li> <li>Provide appropriate user feedback</li> <li>Log security failures</li> </ul>"},{"location":"security/SECURITY_GUIDELINES/#2-recovery","title":"2. Recovery","text":"<ul> <li>Implement secure fallbacks</li> <li>Clean up on failure</li> <li>Maintain system integrity</li> </ul>"},{"location":"security/SECURITY_GUIDELINES/#best-practices","title":"Best Practices","text":""},{"location":"security/SECURITY_GUIDELINES/#1-code","title":"1. Code","text":"<ul> <li>Use Swift's type safety</li> <li>Implement input validation</li> <li>Follow OWASP guidelines</li> </ul>"},{"location":"security/SECURITY_GUIDELINES/#2-testing","title":"2. Testing","text":"<ul> <li>Include security test cases</li> <li>Test error conditions</li> <li>Verify security boundaries</li> </ul>"},{"location":"security/SECURITY_GUIDELINES/#3-dependencies","title":"3. Dependencies","text":"<ul> <li>Regular security updates</li> <li>Vulnerability scanning</li> <li>Dependency pinning</li> </ul>"},{"location":"support/troubleshooting/","title":"Troubleshooting","text":"<p>This page will contain troubleshooting information for common UmbraCore issues. Check back soon for updates.</p>"},{"location":"support/troubleshooting/#coming-soon","title":"Coming Soon","text":"<ul> <li>Common issues</li> <li>Error messages</li> <li>Debug procedures</li> <li>Performance problems</li> <li>Known limitations</li> </ul>"},{"location":"user-guide/","title":"UmbraCore User Guide","text":"<p>This comprehensive guide covers everything you need to know about using UmbraCore effectively in your macOS applications.</p>"},{"location":"user-guide/#core-concepts","title":"Core Concepts","text":"<ul> <li>Configuration and setup</li> <li>Backup strategies</li> <li>Security best practices</li> <li>Advanced features</li> </ul>"},{"location":"user-guide/#available-guides","title":"Available Guides","text":"<ul> <li>Configuration: Detailed configuration options</li> <li>Advanced Features: Advanced usage and features</li> <li>Security: Security guidelines and best practices</li> </ul>"},{"location":"user-guide/advanced-features/","title":"Advanced Features","text":"<p>UmbraCore provides several advanced features for secure backup management. This guide covers cryptographic operations, keychain integration, and other advanced capabilities.</p>"},{"location":"user-guide/advanced-features/#cryptographic-operations","title":"Cryptographic Operations","text":""},{"location":"user-guide/advanced-features/#overview","title":"Overview","text":"<p>The <code>UmbraCryptoService</code> provides comprehensive cryptographic operations:</p> <pre><code>let service = try UmbraCryptoService()\n\n// Basic encryption\nlet data = \"sensitive data\".data(using: .utf8)!\nlet encrypted = try await service.encrypt(data)\n\n// Custom key encryption\nlet key = try service.generateKey()\nlet customEncrypted = try await service.encrypt(data, using: key)\n\n// Decryption\nlet decrypted = try await service.decrypt(encrypted)\n</code></pre>"},{"location":"user-guide/advanced-features/#advanced-encryption","title":"Advanced Encryption","text":"<p>Configure custom encryption parameters:</p> <pre><code>let params = EncryptionParameters(\n    algorithm: .aes256GCM,\n    keySize: .bits256,\n    iterations: 10000\n)\n\nlet encrypted = try await service.encrypt(\n    data,\n    parameters: params\n)\n</code></pre>"},{"location":"user-guide/advanced-features/#key-management","title":"Key Management","text":"<p>Secure key handling:</p> <pre><code>// Generate new key\nlet key = try service.generateKey()\n\n// Export key (protected)\nlet exportedKey = try service.exportKey(key)\n\n// Import key\nlet importedKey = try service.importKey(exportedKey)\n\n// Key derivation\nlet derivedKey = try service.deriveKey(\n    fromPassword: \"user-password\",\n    salt: salt,\n    iterations: 10000\n)\n</code></pre>"},{"location":"user-guide/advanced-features/#keychain-integration","title":"Keychain Integration","text":""},{"location":"user-guide/advanced-features/#overview_1","title":"Overview","text":"<p>The <code>UmbraKeychainService</code> provides secure credential storage:</p> <pre><code>let service = try UmbraKeychainService()\n\n// Store credentials\ntry await service.store(\n    password: \"secret-password\",\n    forKey: \"backup-repository\"\n)\n\n// Retrieve credentials\nlet password = try await service.retrieve(forKey: \"backup-repository\")\n\n// Update credentials\ntry await service.update(\n    password: \"new-password\",\n    forKey: \"backup-repository\"\n)\n\n// Remove credentials\ntry await service.remove(forKey: \"backup-repository\")\n</code></pre>"},{"location":"user-guide/advanced-features/#advanced-keychain-usage","title":"Advanced Keychain Usage","text":"<p>Custom item attributes:</p> <pre><code>let attributes = KeychainItemAttributes(\n    label: \"Main Backup Repository\",\n    comment: \"Production backup credentials\"\n)\n\ntry await service.store(\n    password: \"secret\",\n    forKey: \"main-repo\",\n    attributes: attributes\n)\n</code></pre>"},{"location":"user-guide/advanced-features/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/advanced-features/#cryptographic-security","title":"Cryptographic Security","text":"<ol> <li>Key Management</li> <li>Rotate keys regularly</li> <li>Secure key storage</li> <li> <p>Use key derivation when appropriate</p> </li> <li> <p>Data Protection</p> </li> <li>Encrypt sensitive data immediately</li> <li>Clear sensitive data from memory</li> <li> <p>Use secure random generation</p> </li> <li> <p>Error Recovery</p> </li> <li>Implement retry logic</li> <li>Log cryptographic failures</li> <li>Provide appropriate user feedback</li> </ol>"},{"location":"user-guide/advanced-features/#keychain-security","title":"Keychain Security","text":"<ol> <li> <p>Key Naming    <pre><code>// Good\n\"backup-repo-main-password\"\n\"aws-access-key-prod\"\n\n// Bad\n\"pwd1\"\n\"key\"\n</code></pre></p> </li> <li> <p>Error Recovery</p> </li> <li>Implement retry logic</li> <li>Provide user feedback</li> <li> <p>Log failures appropriately</p> </li> <li> <p>Security Practices</p> </li> <li>Never store keys in code</li> <li>Use appropriate access control</li> <li>Clean up unused credentials</li> </ol>"},{"location":"user-guide/advanced-features/#error-handling","title":"Error Handling","text":""},{"location":"user-guide/advanced-features/#cryptographic-errors","title":"Cryptographic Errors","text":"<pre><code>do {\n    let encrypted = try await cryptoService.encrypt(data)\n} catch CryptoError.invalidKey {\n    // Handle invalid key\n} catch CryptoError.encryptionFailed(let reason) {\n    // Handle encryption failure\n} catch {\n    // Handle other errors\n}\n</code></pre>"},{"location":"user-guide/advanced-features/#keychain-errors","title":"Keychain Errors","text":"<pre><code>do {\n    try await keychainService.store(password: \"secret\", forKey: \"key\")\n} catch KeychainError.duplicateItem(let key) {\n    // Handle duplicate item\n} catch KeychainError.accessDenied(let reason) {\n    // Handle access denied\n} catch {\n    // Handle other errors\n}\n</code></pre>"},{"location":"user-guide/advanced-features/#related-documentation","title":"Related Documentation","text":"<ul> <li>Security Guide - Comprehensive security information</li> <li>Configuration Guide - Configuration options</li> <li>API Reference - Complete API documentation</li> <li>Troubleshooting Guide - Common issues and solutions</li> </ul>"},{"location":"user-guide/configuration/","title":"Configuration Guide","text":""},{"location":"user-guide/configuration/#overview","title":"Overview","text":"<p>UmbraCore provides a robust configuration system with built-in error handling and validation. This guide covers configuration options and error handling patterns.</p>"},{"location":"user-guide/configuration/#error-handling","title":"Error Handling","text":""},{"location":"user-guide/configuration/#error-types","title":"Error Types","text":"<p>UmbraCore uses a structured error handling system:</p> <pre><code>// Common base errors\nenum CommonError: Error {\n    case invalidArgument(String)\n    case resourceNotFound(String)\n    case permissionDenied(String)\n    case operationFailed(String)\n}\n\n// Service-specific errors\nenum KeychainError: Error {\n    case itemNotFound(String)\n    case duplicateItem(String)\n    case accessDenied(String)\n    case invalidData(String)\n}\n</code></pre>"},{"location":"user-guide/configuration/#error-context","title":"Error Context","text":"<p>Errors include detailed context for debugging:</p> <pre><code>struct ErrorContext {\n    let file: String\n    let function: String\n    let line: Int\n    let timestamp: Date\n    let operationId: UUID\n    var userInfo: [String: Any]\n}\n</code></pre>"},{"location":"user-guide/configuration/#error-handling-patterns","title":"Error Handling Patterns","text":"<p>Handle errors appropriately in your code:</p> <pre><code>func backupFiles() async throws {\n    do {\n        try await validatePermissions()\n        try await performBackup()\n        try await verifyBackup()\n    } catch KeychainError.accessDenied(let details) {\n        logger.error(\"Keychain access denied\", metadata: [\n            \"details\": details,\n            \"operation\": \"backup\"\n        ])\n        throw CommonError.permissionDenied(\"Keychain access required for backup\")\n    }\n}\n</code></pre>"},{"location":"user-guide/configuration/#configuration-options","title":"Configuration Options","text":""},{"location":"user-guide/configuration/#backup-settings","title":"Backup Settings","text":"<p>Configure backup behaviour:</p> <pre><code>struct BackupConfiguration {\n    let compressionLevel: CompressionLevel\n    let excludePatterns: [String]\n    let retentionPolicy: RetentionPolicy\n    let verifyAfterBackup: Bool\n\n    static let `default` = BackupConfiguration(\n        compressionLevel: .balanced,\n        excludePatterns: [\".DS_Store\", \"*.tmp\"],\n        retentionPolicy: .standard,\n        verifyAfterBackup: true\n    )\n}\n</code></pre>"},{"location":"user-guide/configuration/#network-settings","title":"Network Settings","text":"<p>Control network behaviour:</p> <pre><code>struct NetworkConfiguration {\n    let timeoutSeconds: Double\n    let maxRetries: Int\n    let retryDelay: TimeInterval\n    let rateLimit: RateLimit?\n\n    static let `default` = NetworkConfiguration(\n        timeoutSeconds: 30,\n        maxRetries: 3,\n        retryDelay: 1.0,\n        rateLimit: .init(requestsPerMinute: 60)\n    )\n}\n</code></pre>"},{"location":"user-guide/configuration/#logging-configuration","title":"Logging Configuration","text":"<p>Configure logging behaviour:</p> <pre><code>struct LogConfiguration {\n    let level: LogLevel\n    let destination: LogDestination\n    let includeMetadata: Bool\n    let retentionDays: Int\n\n    static let `default` = LogConfiguration(\n        level: .info,\n        destination: .file,\n        includeMetadata: true,\n        retentionDays: 30\n    )\n}\n</code></pre>"},{"location":"user-guide/configuration/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/configuration/#configuration-validation","title":"Configuration Validation","text":"<p>Always validate configuration:</p> <pre><code>func validateConfiguration(_ config: BackupConfiguration) throws {\n    guard config.compressionLevel.isSupported else {\n        throw CommonError.invalidArgument(\n            \"Unsupported compression level: \\(config.compressionLevel)\"\n        )\n    }\n\n    for pattern in config.excludePatterns {\n        guard pattern.isValidGlobPattern else {\n            throw CommonError.invalidArgument(\n                \"Invalid exclude pattern: \\(pattern)\"\n            )\n        }\n    }\n}\n</code></pre>"},{"location":"user-guide/configuration/#error-recovery","title":"Error Recovery","text":"<p>Implement retry logic for recoverable errors:</p> <pre><code>actor RetryableOperation {\n    func execute() async throws -&gt; Result {\n        var attempts = 0\n        while attempts &lt; maxRetries {\n            do {\n                return try await performOperation()\n            } catch let error as RecoverableError {\n                attempts += 1\n                try await handleError(error, attempt: attempts)\n            } catch {\n                throw error // Non-recoverable error\n            }\n        }\n        throw CommonError.operationFailed(\"Max retry attempts exceeded\")\n    }\n}\n</code></pre>"},{"location":"user-guide/configuration/#related-documentation","title":"Related Documentation","text":"<ul> <li>Security Guide - Security configuration</li> <li>Advanced Features - Advanced configuration options</li> <li>API Reference - Complete API documentation</li> <li>Troubleshooting Guide - Common issues and solutions</li> </ul>"},{"location":"user-guide/security/","title":"Security Guidelines","text":""},{"location":"user-guide/security/#overview","title":"Overview","text":"<p>UmbraCore handles sensitive data and requires careful attention to security. This guide outlines our security practices and requirements for developers integrating UmbraCore into their applications.</p>"},{"location":"user-guide/security/#secure-storage","title":"Secure Storage","text":""},{"location":"user-guide/security/#credentials-management","title":"Credentials Management","text":"<p>UmbraCore provides secure storage mechanisms for sensitive data:</p> <pre><code>// Recommended: Use UmbraKeychainService\ntry await keychainService.store(password: \"secret\", forKey: \"repo-key\")\n\n// Never do this:\nUserDefaults.standard.set(\"secret\", forKey: \"repo-key\") // UNSAFE!\n</code></pre> <p>Always use <code>UmbraKeychainService</code> for storing: - Repository passwords - API keys - Access tokens - SSH keys</p>"},{"location":"user-guide/security/#file-system-access","title":"File System Access","text":"<p>UmbraCore implements secure file system access through: - <code>UmbraBookmarkService</code> for persistent file access - Security-scoped bookmarks - Proper permission handling</p> <p>Never store raw file paths - always use security-scoped bookmarks for persistent access.</p>"},{"location":"user-guide/security/#encryption","title":"Encryption","text":""},{"location":"user-guide/security/#data-at-rest","title":"Data at Rest","text":"<p>UmbraCore ensures data security through: - Mandatory encryption of all sensitive data - <code>UmbraCryptoService</code> for encryption/decryption operations - Secure key management (never stored in code)</p>"},{"location":"user-guide/security/#data-in-transit","title":"Data in Transit","text":"<p>Network security is maintained by: - Enforcing secure transport (HTTPS, SSH) - Certificate validation - Comprehensive error handling - Rate limiting and timeout management</p>"},{"location":"user-guide/security/#access-control","title":"Access Control","text":""},{"location":"user-guide/security/#xpc-services","title":"XPC Services","text":"<p>UmbraCore uses XPC services to: - Implement the principle of least privilege - Isolate sensitive operations in separate processes - Validate all inputs and outputs - Maintain process boundaries</p>"},{"location":"user-guide/security/#file-permissions","title":"File Permissions","text":"<p>The framework respects system security by: - Honouring system permissions - Using security-scoped resources - Implementing proper cleanup of temporary files - Validating access rights</p>"},{"location":"user-guide/security/#logging-and-auditing","title":"Logging and Auditing","text":""},{"location":"user-guide/security/#sensitive-data-handling","title":"Sensitive Data Handling","text":"<p>UmbraCore implements secure logging practices: - No credentials in logs - Automatic masking of sensitive information - Appropriate log levels for different contexts - Privacy-aware debug information</p>"},{"location":"user-guide/security/#audit-trail","title":"Audit Trail","text":"<p>Security events are tracked through: - Comprehensive event logging - Contextual information capture - Secure audit log maintenance - Structured log formats</p>"},{"location":"user-guide/security/#error-handling","title":"Error Handling","text":""},{"location":"user-guide/security/#security-errors","title":"Security Errors","text":"<p>The framework handles security errors by: - Abstracting internal details - Providing appropriate user feedback - Logging security failures securely - Implementing secure fallbacks</p>"},{"location":"user-guide/security/#recovery-procedures","title":"Recovery Procedures","text":"<p>Error recovery includes: - Clean state maintenance - Secure cleanup procedures - System integrity verification - Graceful degradation</p>"},{"location":"user-guide/security/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/security/#code-security","title":"Code Security","text":"<p>Developers should follow these practices: - Leverage Swift's type safety - Implement thorough input validation - Follow OWASP guidelines - Use strong types for sensitive data</p>"},{"location":"user-guide/security/#security-testing","title":"Security Testing","text":"<p>UmbraCore requires: - Comprehensive security test cases - Error condition testing - Security boundary verification - Regular security audits</p>"},{"location":"user-guide/security/#dependency-management","title":"Dependency Management","text":"<p>Maintain security through: - Regular security updates - Vulnerability scanning - Strict dependency pinning - Supply chain security</p>"},{"location":"user-guide/security/#getting-help","title":"Getting Help","text":"<p>If you discover a security vulnerability:</p> <ol> <li>DO NOT create a public issue</li> <li>Email security@mpy-dev.ml with details</li> <li>Expect a response within 24 hours</li> <li>Follow responsible disclosure practices</li> </ol>"},{"location":"user-guide/security/#related-documentation","title":"Related Documentation","text":"<ul> <li>Configuration Guide</li> <li>API Reference</li> <li>Troubleshooting Guide</li> </ul>"}]}