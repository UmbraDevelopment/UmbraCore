{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#umbracore-documentation","title":"UmbraCore Documentation","text":"<p>UmbraCore is built upon the foundation of Restic, a remarkable open-source backup programme that has set the standard for secure, efficient, and reliable backups. We are deeply grateful to the Restic team for their years of dedication in creating and maintaining such an exceptional tool.</p> <p>Our mission with UmbraCore is to extend Restic's capabilities specifically for macOS application developers, providing a type-safe, Swift-native interface while maintaining complete compatibility with Restic's core functionality. UmbraCore is not an alternative to Restic, but rather a complementary tool that makes Restic's powerful features more accessible in the macOS development ecosystem.</p>"},{"location":"#core-applications","title":"Core Applications","text":"<p>UmbraCore powers several macOS backup management tools: - ResticBar: macOS menu bar app for developers - Rbx: VS Code extension - Rbum: User-friendly GUI</p>"},{"location":"#features","title":"Features","text":""},{"location":"#implemented","title":"Implemented","text":"<ul> <li>Secure keychain operations with XPC service</li> <li>Comprehensive error handling and logging</li> <li>Thread-safe operations</li> <li>SwiftyBeaver logging integration</li> <li>Modular architecture</li> <li>Extensive test coverage</li> </ul>"},{"location":"#in-development","title":"In Development","text":"<ul> <li>SSH key management</li> <li>Cloud provider credentials</li> <li>Repository password handling</li> </ul>"},{"location":"#architecture","title":"Architecture","text":""},{"location":"#core-libraries","title":"Core Libraries","text":"<ul> <li>SecurityTypes: Base security primitives and protocols</li> <li>CryptoTypes: Cryptographic operations and types</li> <li>UmbraLogging: Centralised logging infrastructure</li> </ul>"},{"location":"#service-layer","title":"Service Layer","text":"<ul> <li>UmbraKeychainService: Secure keychain operations</li> <li>UmbraCryptoService: Cryptographic operations service</li> <li>UmbraBookmarkService: File system bookmark management</li> <li>UmbraXPC: XPC communication infrastructure</li> </ul>"},{"location":"#features_1","title":"Features","text":"<ul> <li>ResticCLIHelper: Command-line interface integration</li> <li>Repositories: Repository management and operations</li> <li>Snapshots: Snapshot creation and management</li> <li>Config: Configuration and settings management</li> <li>Logging: Privacy-aware structured logging</li> <li>ErrorHandling: Comprehensive error management</li> <li>Autocomplete: Context-aware command completion</li> </ul>"},{"location":"#project-status","title":"Project Status","text":"<p>UmbraCore is currently in active development with the following milestones:</p>"},{"location":"#q1-2025-current","title":"Q1 2025 (Current)","text":"<ul> <li>\u2713 Repository Management</li> <li>Secure repository initialisation</li> <li>Repository health monitoring</li> <li>Multi-repository support</li> <li>\u2713 Core Restic Integration</li> <li>Command execution system</li> <li>Output parsing</li> <li>Error handling</li> <li>Process management</li> <li>\u2713 Testing Infrastructure</li> <li>Unit testing framework</li> <li>Integration test suite</li> <li>Performance benchmarks</li> <li>Mock services</li> </ul>"},{"location":"#q2-2025-planned","title":"Q2 2025 (Planned)","text":"<ul> <li>Security Layer</li> <li>SSH key management</li> <li>Cloud provider credentials</li> <li>Repository password handling</li> <li>Configuration System</li> <li>Configuration file format</li> <li>Validation system</li> <li>Migration support</li> <li>Progress Monitoring</li> <li>Progress reporting protocol</li> <li>Status updates system</li> <li>Metrics collection</li> </ul>"},{"location":"#q3-2025-planned","title":"Q3 2025 (Planned)","text":"<ul> <li>Statistics &amp; Analytics</li> <li>Performance metrics</li> <li>Usage statistics</li> <li>Trend analysis</li> <li>Health Monitoring</li> <li>System diagnostics</li> <li>Performance monitoring</li> <li>Resource tracking</li> <li>Event System</li> <li>Event dispatching</li> <li>Notification management</li> <li>Webhook support</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Please refer to our Quick Start Guide for installation and basic usage instructions.</p>"},{"location":"#security","title":"Security","text":"<p>UmbraCore prioritises security in all aspects of its implementation. For details, see our Security Guide.</p>"},{"location":"#implementation-guides","title":"Implementation Guides","text":"<p>Our documentation covers various aspects of UmbraCore:</p> <ul> <li>Configuration: Configuration Guide</li> <li>Features: Advanced Features</li> <li>Development: API Reference</li> <li>Support: Troubleshooting Guide</li> </ul>"},{"location":"#support","title":"Support","text":"<p>If you find UmbraCore useful, please consider:</p> <ol> <li>Contributing to the project</li> <li>Supporting Restic</li> <li>Starring us on GitHub</li> <li>Sharing your experience with others</li> </ol>"},{"location":"#license","title":"License","text":"<p>UmbraCore is available under the MIT license. See the LICENSE file for more info.</p>"},{"location":"ACKNOWLEDGMENTS/","title":"Acknowledgments","text":"<p>UmbraCore stands on the shoulders of open-source giants. We're deeply grateful to the following open-source projects and their maintainers:</p>"},{"location":"ACKNOWLEDGMENTS/#core-dependencies","title":"Core Dependencies","text":""},{"location":"ACKNOWLEDGMENTS/#restic","title":"Restic","text":"<p>Restic is the backbone of UmbraCore's backup capabilities. It's a modern backup program written in Go which provides: - Fast, secure, and efficient backups - Deduplication - Encryption - Multiple backend support - Outstanding performance</p> <p>We highly recommend supporting the Restic project: - GitHub Repository - Documentation - Contributing Guide - Donate</p>"},{"location":"ACKNOWLEDGMENTS/#swiftybeaver","title":"SwiftyBeaver","text":"<p>SwiftyBeaver powers UmbraCore's logging infrastructure. It's a sophisticated logging system that offers: - Colourised console output - File logging - Cloud logging - Custom formats - Filters and threading support</p> <p>Support SwiftyBeaver: - GitHub Repository - Documentation - Pro Features</p>"},{"location":"ACKNOWLEDGMENTS/#cryptoswift","title":"CryptoSwift","text":"<p>CryptoSwift provides UmbraCore's cryptographic operations. It's a comprehensive cryptography framework offering: - AES encryption - Hash functions - HMAC - PBKDF - Extensible architecture</p> <p>Support CryptoSwift: - GitHub Repository - Documentation - Sponsor</p>"},{"location":"ACKNOWLEDGMENTS/#development-tools","title":"Development Tools","text":""},{"location":"ACKNOWLEDGMENTS/#just-the-docs","title":"Just the Docs","text":"<p>The beautiful documentation theme you're currently viewing. Features: - Clean, responsive design - Full-text search - Dark/light mode - Navigation structure - Customisation options</p> <p>Support Just the Docs: - GitHub Repository - Documentation - Contributing Guide</p>"},{"location":"ACKNOWLEDGMENTS/#jazzy","title":"Jazzy","text":"<p>Jazzy generates our API documentation. It provides: - Clean documentation generation - Markdown support - Search functionality - Cross-references</p> <p>Support Jazzy: - GitHub Repository - Documentation - Contributing Guide</p>"},{"location":"ACKNOWLEDGMENTS/#swiftlint","title":"SwiftLint","text":"<p>SwiftLint helps maintain our code quality. It offers: - Style and convention checking - Customisable rules - Automatic fixing - Xcode integration</p> <p>Support SwiftLint: - GitHub Repository - Documentation - Contributing Guide</p>"},{"location":"ACKNOWLEDGMENTS/#security-tools","title":"Security Tools","text":""},{"location":"ACKNOWLEDGMENTS/#snyk","title":"Snyk","text":"<p>Snyk helps keep UmbraCore secure by providing: - Vulnerability scanning - Dependency monitoring - Security updates - License compliance</p> <p>Support Snyk: - Website - Documentation - Blog</p>"},{"location":"ACKNOWLEDGMENTS/#codecov","title":"Codecov","text":"<p>Codecov helps maintain our test coverage by offering: - Coverage reporting - PR checks - Trending analysis - Quality gates</p> <p>Support Codecov: - Website - Documentation - GitHub Repository</p>"},{"location":"ACKNOWLEDGMENTS/#contributing","title":"Contributing","text":"<p>If you'd like to contribute to UmbraCore, please see our Contributing Guidelines. We welcome all contributions, from code to documentation improvements.</p>"},{"location":"ACKNOWLEDGMENTS/#supporting-open-source","title":"Supporting Open Source","text":"<p>We encourage users of UmbraCore to consider supporting these projects through: - Code contributions - Documentation improvements - Bug reports - Financial support where available - Spreading the word about their excellent work</p> <p>The strength of UmbraCore comes from these outstanding open-source projects. Supporting them helps ensure a vibrant and sustainable open-source ecosystem.</p>"},{"location":"GETTING_STARTED/","title":"Getting Started with UmbraCore","text":""},{"location":"GETTING_STARTED/#prerequisites","title":"Prerequisites","text":"<ul> <li>macOS 14.0 or later</li> <li>Xcode 15.2 or later</li> <li>Swift 6.0.3 or later</li> <li>Restic installed</li> </ul>"},{"location":"GETTING_STARTED/#installation","title":"Installation","text":""},{"location":"GETTING_STARTED/#swift-package-manager","title":"Swift Package Manager","text":"<p>Add UmbraCore as a dependency in your <code>Package.swift</code>:</p> <pre><code>dependencies: [\n    .package(url: \"https://github.com/mpy-dev-ml/UmbraCore.git\", from: \"1.0.0\")\n]\n</code></pre>"},{"location":"GETTING_STARTED/#manual-installation","title":"Manual Installation","text":"<ol> <li>Clone the repository</li> <li>Build the package</li> <li>Link the framework</li> </ol>"},{"location":"GETTING_STARTED/#quick-start-guide","title":"Quick Start Guide","text":""},{"location":"GETTING_STARTED/#1-basic-setup","title":"1. Basic Setup","text":"<pre><code>import UmbraCore\n\n// Initialize the core services\nlet keychainService = try UmbraKeychainService()\nlet cryptoService = try UmbraCryptoService()\n</code></pre>"},{"location":"GETTING_STARTED/#2-configure-logging","title":"2. Configure Logging","text":"<pre><code>import UmbraLogging\n\nUmbraLogger.configure(level: .info)\n</code></pre>"},{"location":"GETTING_STARTED/#3-basic-operations","title":"3. Basic Operations","text":"<pre><code>// Example: Store credentials\ntry await keychainService.store(\n    password: \"repository-password\",\n    forKey: \"backup-repo\"\n)\n\n// Example: Create a bookmark\ntry await bookmarkService.create(\n    for: URL(fileURLWithPath: \"/path/to/backup\"),\n    withName: \"documents\"\n)\n</code></pre>"},{"location":"GETTING_STARTED/#next-steps","title":"Next Steps","text":"<ul> <li>Read the Architecture Guide</li> <li>Check out Security Best Practices</li> <li>View API Documentation</li> </ul>"},{"location":"LICENSE/","title":"MIT License","text":"<p>Copyright (c) 2025 MPY Development</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"advanced-features/","title":"Advanced Features","text":"<p>UmbraCore provides several advanced features for secure backup management. This guide covers cryptographic operations, keychain integration, and other advanced capabilities.</p>"},{"location":"advanced-features/#cryptographic-operations","title":"Cryptographic Operations","text":""},{"location":"advanced-features/#overview","title":"Overview","text":"<p>The <code>UmbraCryptoService</code> provides comprehensive cryptographic operations:</p> <pre><code>let service = try UmbraCryptoService()\n\n// Basic encryption\nlet data = \"sensitive data\".data(using: .utf8)!\nlet encrypted = try await service.encrypt(data)\n\n// Custom key encryption\nlet key = try service.generateKey()\nlet customEncrypted = try await service.encrypt(data, using: key)\n\n// Decryption\nlet decrypted = try await service.decrypt(encrypted)\n</code></pre>"},{"location":"advanced-features/#advanced-encryption","title":"Advanced Encryption","text":"<p>Configure custom encryption parameters:</p> <pre><code>let params = EncryptionParameters(\n    algorithm: .aes256GCM,\n    keySize: .bits256,\n    iterations: 10000\n)\n\nlet encrypted = try await service.encrypt(\n    data,\n    parameters: params\n)\n</code></pre>"},{"location":"advanced-features/#key-management","title":"Key Management","text":"<p>Secure key handling:</p> <pre><code>// Generate new key\nlet key = try service.generateKey()\n\n// Export key (protected)\nlet exportedKey = try service.exportKey(key)\n\n// Import key\nlet importedKey = try service.importKey(exportedKey)\n\n// Key derivation\nlet derivedKey = try service.deriveKey(\n    fromPassword: \"user-password\",\n    salt: salt,\n    iterations: 10000\n)\n</code></pre>"},{"location":"advanced-features/#keychain-integration","title":"Keychain Integration","text":""},{"location":"advanced-features/#overview_1","title":"Overview","text":"<p>The <code>UmbraKeychainService</code> provides secure credential storage:</p> <pre><code>let service = try UmbraKeychainService()\n\n// Store credentials\ntry await service.store(\n    password: \"secret-password\",\n    forKey: \"backup-repository\"\n)\n\n// Retrieve credentials\nlet password = try await service.retrieve(forKey: \"backup-repository\")\n\n// Update credentials\ntry await service.update(\n    password: \"new-password\",\n    forKey: \"backup-repository\"\n)\n\n// Remove credentials\ntry await service.remove(forKey: \"backup-repository\")\n</code></pre>"},{"location":"advanced-features/#advanced-keychain-usage","title":"Advanced Keychain Usage","text":"<p>Custom item attributes:</p> <pre><code>let attributes = KeychainItemAttributes(\n    label: \"Main Backup Repository\",\n    comment: \"Production backup credentials\"\n)\n\ntry await service.store(\n    password: \"secret\",\n    forKey: \"main-repo\",\n    attributes: attributes\n)\n</code></pre>"},{"location":"advanced-features/#best-practices","title":"Best Practices","text":""},{"location":"advanced-features/#cryptographic-security","title":"Cryptographic Security","text":"<ol> <li>Key Management</li> <li>Rotate keys regularly</li> <li>Secure key storage</li> <li> <p>Use key derivation when appropriate</p> </li> <li> <p>Data Protection</p> </li> <li>Encrypt sensitive data immediately</li> <li>Clear sensitive data from memory</li> <li> <p>Use secure random generation</p> </li> <li> <p>Error Recovery</p> </li> <li>Implement retry logic</li> <li>Log cryptographic failures</li> <li>Provide appropriate user feedback</li> </ol>"},{"location":"advanced-features/#keychain-security","title":"Keychain Security","text":"<ol> <li> <p>Key Naming    <pre><code>// Good\n\"backup-repo-main-password\"\n\"aws-access-key-prod\"\n\n// Bad\n\"pwd1\"\n\"key\"\n</code></pre></p> </li> <li> <p>Error Recovery</p> </li> <li>Implement retry logic</li> <li>Provide user feedback</li> <li> <p>Log failures appropriately</p> </li> <li> <p>Security Practices</p> </li> <li>Never store keys in code</li> <li>Use appropriate access control</li> <li>Clean up unused credentials</li> </ol>"},{"location":"advanced-features/#error-handling","title":"Error Handling","text":""},{"location":"advanced-features/#cryptographic-errors","title":"Cryptographic Errors","text":"<pre><code>do {\n    let encrypted = try await cryptoService.encrypt(data)\n} catch CryptoError.invalidKey {\n    // Handle invalid key\n} catch CryptoError.encryptionFailed(let reason) {\n    // Handle encryption failure\n} catch {\n    // Handle other errors\n}\n</code></pre>"},{"location":"advanced-features/#keychain-errors","title":"Keychain Errors","text":"<pre><code>do {\n    try await keychainService.store(password: \"secret\", forKey: \"key\")\n} catch KeychainError.duplicateItem(let key) {\n    // Handle duplicate item\n} catch KeychainError.accessDenied(let reason) {\n    // Handle access denied\n} catch {\n    // Handle other errors\n}\n</code></pre>"},{"location":"advanced-features/#related-documentation","title":"Related Documentation","text":"<ul> <li>Security Guide - Comprehensive security information</li> <li>Configuration Guide - Configuration options</li> <li>API Reference - Complete API documentation</li> <li>Troubleshooting Guide - Common issues and solutions</li> </ul>"},{"location":"api-reference/","title":"API Reference","text":""},{"location":"api-reference/#core-services","title":"Core Services","text":""},{"location":"api-reference/#umbrakeychainservice","title":"UmbraKeychainService","text":"<p>Secure credential storage service for managing sensitive data:</p> <pre><code>// Initialize the service\nlet keychain = try UmbraKeychainService()\n\n// Store credentials\ntry await keychain.store(\n    password: \"secret\",\n    forKey: \"backup-repository\"\n)\n\n// Retrieve credentials\nlet password = try await keychain.retrieve(\n    forKey: \"backup-repository\"\n)\n</code></pre>"},{"location":"api-reference/#umbracryptoservice","title":"UmbraCryptoService","text":"<p>Cryptographic operations service for data security:</p> <pre><code>// Initialize the service\nlet crypto = try UmbraCryptoService()\n\n// Encrypt data\nlet encrypted = try await crypto.encrypt(\n    sensitiveData,\n    using: .aes256GCM\n)\n\n// Decrypt data\nlet decrypted = try await crypto.decrypt(\n    encrypted\n)\n</code></pre>"},{"location":"api-reference/#umbrabookmarkservice","title":"UmbraBookmarkService","text":"<p>File system bookmark management for persistent file access:</p> <pre><code>// Initialize the service\nlet bookmarks = try UmbraBookmarkService()\n\n// Create bookmark\nlet bookmark = try await bookmarks.create(\n    for: fileURL,\n    type: .securityScoped\n)\n\n// Resolve bookmark\nlet url = try await bookmarks.resolve(\n    bookmark: bookmark\n)\n</code></pre>"},{"location":"api-reference/#security-types","title":"Security Types","text":""},{"location":"api-reference/#securitytypes","title":"SecurityTypes","text":"<p>Base security primitives and protocols:</p> <pre><code>// Secure data container\nstruct SecureData: SecureContainer {\n    let data: Data\n    let metadata: SecurityMetadata\n}\n\n// Security context\nstruct SecurityContext {\n    let accessLevel: AccessLevel\n    let permissions: Permissions\n    let origin: SecurityOrigin\n}\n</code></pre>"},{"location":"api-reference/#cryptotypes","title":"CryptoTypes","text":"<p>Cryptographic types and operations:</p> <pre><code>// Encryption parameters\nstruct EncryptionParameters {\n    let algorithm: EncryptionAlgorithm\n    let keySize: KeySize\n    let iterations: Int\n}\n\n// Key types\nenum KeyType {\n    case aes256\n    case rsa2048\n    case rsa4096\n}\n</code></pre>"},{"location":"api-reference/#utilities","title":"Utilities","text":""},{"location":"api-reference/#umbralogging","title":"UmbraLogging","text":"<p>Centralised logging infrastructure:</p> <pre><code>// Initialize logger\nlet logger = UmbraLogger(\n    subsystem: \"com.example.app\",\n    category: \"backup\"\n)\n\n// Log events\nlogger.info(\"Starting backup\", metadata: [\n    \"repository\": \"main\",\n    \"files\": 100\n])\n\nlogger.error(\"Backup failed\", metadata: [\n    \"error\": error,\n    \"repository\": \"main\"\n])\n</code></pre>"},{"location":"api-reference/#umbraxpc","title":"UmbraXPC","text":"<p>XPC communication infrastructure:</p> <pre><code>// Define service protocol\nprotocol BackupService: XPCService {\n    func backup(source: URL) async throws\n    func restore(to: URL) async throws\n}\n\n// Create service connection\nlet service = try XPCConnection&lt;BackupService&gt;()\n\n// Call service\ntry await service.backup(source: sourceURL)\n</code></pre>"},{"location":"api-reference/#error-types","title":"Error Types","text":""},{"location":"api-reference/#commonerror","title":"CommonError","text":"<p>Shared error types across the framework:</p> <pre><code>enum CommonError: Error {\n    case invalidArgument(String)\n    case resourceNotFound(String)\n    case permissionDenied(String)\n    case operationFailed(String)\n}\n\nenum KeychainError: Error {\n    case itemNotFound(String)\n    case duplicateItem(String)\n    case accessDenied(String)\n}\n\nenum CryptoError: Error {\n    case encryptionFailed(String)\n    case decryptionFailed(String)\n    case invalidKey(String)\n}\n</code></pre>"},{"location":"api-reference/#best-practices","title":"Best Practices","text":""},{"location":"api-reference/#thread-safety","title":"Thread Safety","text":"<p>All services are designed to be thread-safe:</p> <pre><code>// Safe concurrent access\nlet service = try UmbraKeychainService()\nasync let task1 = service.store(password: \"secret1\", forKey: \"key1\")\nasync let task2 = service.store(password: \"secret2\", forKey: \"key2\")\ntry await [task1, task2]\n</code></pre>"},{"location":"api-reference/#error-handling","title":"Error Handling","text":"<p>Implement comprehensive error handling:</p> <pre><code>do {\n    try await service.backup(source: url)\n} catch CommonError.invalidArgument(let reason) {\n    logger.error(\"Invalid argument: \\(reason)\")\n} catch CommonError.permissionDenied(let operation) {\n    logger.error(\"Permission denied: \\(operation)\")\n} catch {\n    logger.error(\"Unknown error: \\(error)\")\n}\n</code></pre>"},{"location":"api-reference/#performance","title":"Performance","text":"<p>Follow performance best practices:</p> <pre><code>// Use batch operations\ntry await service.storeBatch([\n    (\"key1\", \"value1\"),\n    (\"key2\", \"value2\"),\n    (\"key3\", \"value3\")\n])\n\n// Implement cancellation\nlet task = Task {\n    try await service.longOperation()\n}\n// Later...\ntask.cancel()\n</code></pre>"},{"location":"api-reference/#related-documentation","title":"Related Documentation","text":"<ul> <li>Security Guide - Security implementation details</li> <li>Configuration Guide - Configuration options</li> <li>Advanced Features - Advanced usage</li> <li>Troubleshooting Guide - Common issues and solutions</li> </ul>"},{"location":"bazel_spm_integration/","title":"UmbraCore: Bazel and SPM Integration Brief","text":""},{"location":"bazel_spm_integration/#overview","title":"Overview","text":"<p>This document outlines our strategy for integrating Bazel build system while maintaining Swift Package Manager (SPM) compatibility in the UmbraCore project.</p>"},{"location":"bazel_spm_integration/#1-integration-goals","title":"1. Integration Goals","text":"<ul> <li>Maintain existing SPM dependencies</li> <li>Leverage Bazel's build caching</li> <li>Optimise CI/CD performance</li> <li>Support future scalability</li> </ul>"},{"location":"bazel_spm_integration/#2-technical-architecture","title":"2. Technical Architecture","text":""},{"location":"bazel_spm_integration/#21-build-system-components","title":"2.1 Build System Components","text":"<pre><code>UmbraCore/\n\u251c\u2500\u2500 WORKSPACE\n\u251c\u2500\u2500 MODULE.bazel          # Bazel module configuration\n\u251c\u2500\u2500 Package.swift         # SPM dependencies\n\u251c\u2500\u2500 Package.resolved      # SPM version lock\n\u251c\u2500\u2500 .bazelrc             # Bazel settings\n\u251c\u2500\u2500 BUILD.bazel          # Root build file\n\u251c\u2500\u2500 Sources/             # Source files\n\u2502   \u2514\u2500\u2500 */\n\u2502       \u251c\u2500\u2500 BUILD       # Generated by Gazelle\n\u2502       \u2514\u2500\u2500 *.swift\n\u2514\u2500\u2500 Tests/              # Test files\n    \u2514\u2500\u2500 */\n        \u251c\u2500\u2500 BUILD       # Generated by Gazelle\n        \u2514\u2500\u2500 *.swift\n</code></pre>"},{"location":"bazel_spm_integration/#22-key-configuration-files","title":"2.2 Key Configuration Files","text":""},{"location":"bazel_spm_integration/#modulebazel","title":"MODULE.bazel","text":"<pre><code>bazel_dep(name = \"rules_swift_package_manager\", version = \"0.46.0\")\n\nswift_deps = use_extension(\n    \"@rules_swift_package_manager//:extensions.bzl\",\n    \"swift_deps\",\n)\n\nswift_deps.configure_swift_package(\n    build_path = \"spm-build\",\n    cache_path = \"spm-cache\",\n    dependency_caching = \"true\",\n    manifest_cache = \"local\",\n    manifest_caching = \"true\",\n)\n\nswift_deps.from_package(\n    declare_swift_deps_info = True,\n    declare_swift_package = True,\n    resolved = \"//:Package.resolved\",\n    swift = \"//:Package.swift\",\n)\n</code></pre>"},{"location":"bazel_spm_integration/#bazelrc","title":".bazelrc","text":"<pre><code># Enable bzlmod\nbuild --enable_bzlmod\n\n# SPM integration\nbuild --experimental_enable_swift_package_manager\n\n# Caching configuration\nbuild --remote_cache=grpcs://cache.buildbuddy.io\nbuild --remote_timeout=3600\n</code></pre>"},{"location":"bazel_spm_integration/#3-dependency-management","title":"3. Dependency Management","text":""},{"location":"bazel_spm_integration/#31-spm-dependencies","title":"3.1 SPM Dependencies","text":"<ul> <li>CryptoSwift (v1.8.0+)</li> <li>SwiftyBeaver (v2.0.0+)</li> </ul>"},{"location":"bazel_spm_integration/#32-bazel-dependencies","title":"3.2 Bazel Dependencies","text":"<ul> <li>rules_swift_package_manager</li> <li>rules_swift</li> <li>rules_apple (optional)</li> <li>Gazelle</li> </ul>"},{"location":"bazel_spm_integration/#4-caching-strategy","title":"4. Caching Strategy","text":""},{"location":"bazel_spm_integration/#41-cache-locations","title":"4.1 Cache Locations","text":"<ul> <li><code>spm-cache/</code>: SPM dependency cache</li> <li><code>spm-build/</code>: SPM build artifacts</li> <li><code>bazel-*/</code>: Bazel build outputs</li> <li><code>~/.cache/bazel</code>: Bazel system cache</li> </ul>"},{"location":"bazel_spm_integration/#42-cicd-caching","title":"4.2 CI/CD Caching","text":"<pre><code>cache:\n  paths:\n    - ~/.cache/bazel\n    - spm-cache\n    - spm-build\n  key: ${CI_COMMIT_REF_SLUG}\n</code></pre>"},{"location":"bazel_spm_integration/#5-common-operations","title":"5. Common Operations","text":""},{"location":"bazel_spm_integration/#51-dependency-management","title":"5.1 Dependency Management","text":"<pre><code># Update all dependencies\nbazel run @swift_package//:update\n\n# Update specific package\nbazel run @swift_package//:update -- SwiftyBeaver\n\n# Resolve dependencies\nbazel run @swift_package//:resolve\n</code></pre>"},{"location":"bazel_spm_integration/#52-build-operations","title":"5.2 Build Operations","text":"<pre><code># Build entire project\nbazel build //...\n\n# Run tests\nbazel test //...\n\n# Generate BUILD files\nbazel run //:update_build_files\n</code></pre>"},{"location":"bazel_spm_integration/#6-best-practices","title":"6. Best Practices","text":""},{"location":"bazel_spm_integration/#61-development-workflow","title":"6.1 Development Workflow","text":"<ol> <li>Use Bazel commands for all build operations</li> <li>Keep Package.swift minimal and focused</li> <li>Regularly update cached dependencies</li> <li>Monitor cache size and performance</li> </ol>"},{"location":"bazel_spm_integration/#62-code-organisation","title":"6.2 Code Organisation","text":"<ol> <li>Follow module structure in Sources/</li> <li>Maintain clear dependency boundaries</li> <li>Use proper visibility declarations</li> <li>Keep BUILD files organised</li> </ol>"},{"location":"bazel_spm_integration/#63-language-standards","title":"6.3 Language Standards","text":"<ol> <li>Use British English in:</li> <li>Documentation</li> <li>Comments</li> <li>User-facing text</li> <li>Use American English in:</li> <li>Code</li> <li>Build files</li> <li>Configuration</li> </ol>"},{"location":"bazel_spm_integration/#7-performance-considerations","title":"7. Performance Considerations","text":""},{"location":"bazel_spm_integration/#71-local-development","title":"7.1 Local Development","text":"<ul> <li>Use local caching</li> <li>Enable parallel builds</li> <li>Monitor resource usage</li> <li>Regular cache cleanup</li> </ul>"},{"location":"bazel_spm_integration/#72-cicd-pipeline","title":"7.2 CI/CD Pipeline","text":"<ul> <li>Optimise cache sharing</li> <li>Use remote caching</li> <li>Enable parallel testing</li> <li>Monitor build times</li> </ul>"},{"location":"bazel_spm_integration/#8-migration-timeline","title":"8. Migration Timeline","text":""},{"location":"bazel_spm_integration/#phase-1-initial-setup-1-week","title":"Phase 1: Initial Setup (1 week)","text":"<ul> <li>[ ] Configure Bazel</li> <li>[ ] Set up SPM integration</li> <li>[ ] Configure caching</li> <li>[ ] Update documentation</li> </ul>"},{"location":"bazel_spm_integration/#phase-2-build-migration-2-weeks","title":"Phase 2: Build Migration (2 weeks)","text":"<ul> <li>[ ] Generate BUILD files</li> <li>[ ] Test build system</li> <li>[ ] Validate dependencies</li> <li>[ ] Performance testing</li> </ul>"},{"location":"bazel_spm_integration/#phase-3-cicd-integration-1-week","title":"Phase 3: CI/CD Integration (1 week)","text":"<ul> <li>[ ] Configure GitHub Actions</li> <li>[ ] Set up caching</li> <li>[ ] Test workflows</li> <li>[ ] Monitor performance</li> </ul>"},{"location":"bazel_spm_integration/#9-support-and-maintenance","title":"9. Support and Maintenance","text":""},{"location":"bazel_spm_integration/#91-regular-tasks","title":"9.1 Regular Tasks","text":"<ul> <li>Weekly dependency updates</li> <li>Monthly cache cleanup</li> <li>Quarterly performance review</li> <li>Regular documentation updates</li> </ul>"},{"location":"bazel_spm_integration/#92-monitoring","title":"9.2 Monitoring","text":"<ul> <li>Build times</li> <li>Cache hit rates</li> <li>Dependency updates</li> <li>Resource usage</li> </ul>"},{"location":"bazel_spm_integration/#10-references","title":"10. References","text":"<ol> <li>Bazel Documentation</li> <li>rules_swift_package_manager</li> <li>Swift Package Manager</li> <li>GitHub Actions Documentation</li> </ol>"},{"location":"configuration/","title":"Configuration Guide","text":""},{"location":"configuration/#overview","title":"Overview","text":"<p>UmbraCore provides a robust configuration system with built-in error handling and validation. This guide covers configuration options and error handling patterns.</p>"},{"location":"configuration/#error-handling","title":"Error Handling","text":""},{"location":"configuration/#error-types","title":"Error Types","text":"<p>UmbraCore uses a structured error handling system:</p> <pre><code>// Common base errors\nenum CommonError: Error {\n    case invalidArgument(String)\n    case resourceNotFound(String)\n    case permissionDenied(String)\n    case operationFailed(String)\n}\n\n// Service-specific errors\nenum KeychainError: Error {\n    case itemNotFound(String)\n    case duplicateItem(String)\n    case accessDenied(String)\n    case invalidData(String)\n}\n</code></pre>"},{"location":"configuration/#error-context","title":"Error Context","text":"<p>Errors include detailed context for debugging:</p> <pre><code>struct ErrorContext {\n    let file: String\n    let function: String\n    let line: Int\n    let timestamp: Date\n    let operationId: UUID\n    var userInfo: [String: Any]\n}\n</code></pre>"},{"location":"configuration/#error-handling-patterns","title":"Error Handling Patterns","text":"<p>Handle errors appropriately in your code:</p> <pre><code>func backupFiles() async throws {\n    do {\n        try await validatePermissions()\n        try await performBackup()\n        try await verifyBackup()\n    } catch KeychainError.accessDenied(let details) {\n        logger.error(\"Keychain access denied\", metadata: [\n            \"details\": details,\n            \"operation\": \"backup\"\n        ])\n        throw CommonError.permissionDenied(\"Keychain access required for backup\")\n    }\n}\n</code></pre>"},{"location":"configuration/#configuration-options","title":"Configuration Options","text":""},{"location":"configuration/#backup-settings","title":"Backup Settings","text":"<p>Configure backup behaviour:</p> <pre><code>struct BackupConfiguration {\n    let compressionLevel: CompressionLevel\n    let excludePatterns: [String]\n    let retentionPolicy: RetentionPolicy\n    let verifyAfterBackup: Bool\n\n    static let `default` = BackupConfiguration(\n        compressionLevel: .balanced,\n        excludePatterns: [\".DS_Store\", \"*.tmp\"],\n        retentionPolicy: .standard,\n        verifyAfterBackup: true\n    )\n}\n</code></pre>"},{"location":"configuration/#network-settings","title":"Network Settings","text":"<p>Control network behaviour:</p> <pre><code>struct NetworkConfiguration {\n    let timeoutSeconds: Double\n    let maxRetries: Int\n    let retryDelay: TimeInterval\n    let rateLimit: RateLimit?\n\n    static let `default` = NetworkConfiguration(\n        timeoutSeconds: 30,\n        maxRetries: 3,\n        retryDelay: 1.0,\n        rateLimit: .init(requestsPerMinute: 60)\n    )\n}\n</code></pre>"},{"location":"configuration/#logging-configuration","title":"Logging Configuration","text":"<p>Configure logging behaviour:</p> <pre><code>struct LogConfiguration {\n    let level: LogLevel\n    let destination: LogDestination\n    let includeMetadata: Bool\n    let retentionDays: Int\n\n    static let `default` = LogConfiguration(\n        level: .info,\n        destination: .file,\n        includeMetadata: true,\n        retentionDays: 30\n    )\n}\n</code></pre>"},{"location":"configuration/#best-practices","title":"Best Practices","text":""},{"location":"configuration/#configuration-validation","title":"Configuration Validation","text":"<p>Always validate configuration:</p> <pre><code>func validateConfiguration(_ config: BackupConfiguration) throws {\n    guard config.compressionLevel.isSupported else {\n        throw CommonError.invalidArgument(\n            \"Unsupported compression level: \\(config.compressionLevel)\"\n        )\n    }\n\n    for pattern in config.excludePatterns {\n        guard pattern.isValidGlobPattern else {\n            throw CommonError.invalidArgument(\n                \"Invalid exclude pattern: \\(pattern)\"\n            )\n        }\n    }\n}\n</code></pre>"},{"location":"configuration/#error-recovery","title":"Error Recovery","text":"<p>Implement retry logic for recoverable errors:</p> <pre><code>actor RetryableOperation {\n    func execute() async throws -&gt; Result {\n        var attempts = 0\n        while attempts &lt; maxRetries {\n            do {\n                return try await performOperation()\n            } catch let error as RecoverableError {\n                attempts += 1\n                try await handleError(error, attempt: attempts)\n            } catch {\n                throw error // Non-recoverable error\n            }\n        }\n        throw CommonError.operationFailed(\"Max retry attempts exceeded\")\n    }\n}\n</code></pre>"},{"location":"configuration/#related-documentation","title":"Related Documentation","text":"<ul> <li>Security Guide - Security configuration</li> <li>Advanced Features - Advanced configuration options</li> <li>API Reference - Complete API documentation</li> <li>Troubleshooting Guide - Common issues and solutions</li> </ul>"},{"location":"contributing/","title":"Contributing to UmbraCore","text":"<p>This page will contain information about contributing to UmbraCore. Check back soon for updates.</p>"},{"location":"contributing/#coming-soon","title":"Coming Soon","text":"<ul> <li>Development setup</li> <li>Coding standards</li> <li>Testing guidelines</li> <li>Pull request process</li> <li>Documentation guidelines</li> </ul>"},{"location":"getting-started/","title":"Getting Started with UmbraCore","text":""},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<p>Before you begin working with UmbraCore, ensure you have the following installed:</p> <ul> <li>Xcode 15.0 or later</li> <li>Swift 5.9 or later</li> <li>Restic 0.16.0 or later</li> <li>macOS 13.0 (Ventura) or later</li> </ul>"},{"location":"getting-started/#installation","title":"Installation","text":""},{"location":"getting-started/#via-swift-package-manager","title":"Via Swift Package Manager","text":"<p>Add UmbraCore as a dependency to your <code>Package.swift</code>:</p> <pre><code>dependencies: [\n    .package(url: \"https://github.com/mpy-dev-ml/UmbraCore.git\", from: \"0.1.0\")\n]\n</code></pre>"},{"location":"getting-started/#manual-build","title":"Manual Build","text":"<ol> <li> <p>Clone the repository:    <pre><code>git clone https://github.com/mpy-dev-ml/UmbraCore.git\ncd UmbraCore\n</code></pre></p> </li> <li> <p>Build the project:    <pre><code>swift build\n</code></pre></p> </li> <li> <p>Run the tests:    <pre><code>swift test\n</code></pre></p> </li> </ol>"},{"location":"getting-started/#basic-usage","title":"Basic Usage","text":"<p>Here's a simple example of initialising UmbraCore and creating a backup:</p> <pre><code>import UmbraCore\n\n// Initialize the backup service\nlet service = try UmbraBackupService()\n\n// Create a backup\ntry await service.backup(\n    source: \"/path/to/source\",\n    repository: \"rest:https://backup.example.com/repo\",\n    password: \"your-secure-password\"\n)\n</code></pre>"},{"location":"getting-started/#security-considerations","title":"Security Considerations","text":"<p>UmbraCore prioritises security in several ways:</p> <ol> <li>Keychain Integration: All sensitive data is stored in the macOS Keychain</li> <li>XPC Services: Security-critical operations run in isolated processes</li> <li>Secure Defaults: Conservative security defaults that follow best practices</li> </ol>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Configuration Options</li> <li>Explore Advanced Features</li> <li>Read our Security Guide</li> <li>Check out the API Reference</li> </ul>"},{"location":"getting-started/#getting-help","title":"Getting Help","text":"<p>If you encounter any issues or have questions:</p> <ol> <li>Check our Troubleshooting Guide</li> <li>Search existing GitHub Issues</li> <li>Create a new issue if your problem hasn't been reported</li> </ol>"},{"location":"getting-started/#contributing","title":"Contributing","text":"<p>We welcome contributions! Please read our Contributing Guide to get started.</p>"},{"location":"security/","title":"Security Guidelines","text":""},{"location":"security/#overview","title":"Overview","text":"<p>UmbraCore handles sensitive data and requires careful attention to security. This guide outlines our security practices and requirements for developers integrating UmbraCore into their applications.</p>"},{"location":"security/#secure-storage","title":"Secure Storage","text":""},{"location":"security/#credentials-management","title":"Credentials Management","text":"<p>UmbraCore provides secure storage mechanisms for sensitive data:</p> <pre><code>// Recommended: Use UmbraKeychainService\ntry await keychainService.store(password: \"secret\", forKey: \"repo-key\")\n\n// Never do this:\nUserDefaults.standard.set(\"secret\", forKey: \"repo-key\") // UNSAFE!\n</code></pre> <p>Always use <code>UmbraKeychainService</code> for storing: - Repository passwords - API keys - Access tokens - SSH keys</p>"},{"location":"security/#file-system-access","title":"File System Access","text":"<p>UmbraCore implements secure file system access through: - <code>UmbraBookmarkService</code> for persistent file access - Security-scoped bookmarks - Proper permission handling</p> <p>Never store raw file paths - always use security-scoped bookmarks for persistent access.</p>"},{"location":"security/#encryption","title":"Encryption","text":""},{"location":"security/#data-at-rest","title":"Data at Rest","text":"<p>UmbraCore ensures data security through: - Mandatory encryption of all sensitive data - <code>UmbraCryptoService</code> for encryption/decryption operations - Secure key management (never stored in code)</p>"},{"location":"security/#data-in-transit","title":"Data in Transit","text":"<p>Network security is maintained by: - Enforcing secure transport (HTTPS, SSH) - Certificate validation - Comprehensive error handling - Rate limiting and timeout management</p>"},{"location":"security/#access-control","title":"Access Control","text":""},{"location":"security/#xpc-services","title":"XPC Services","text":"<p>UmbraCore uses XPC services to: - Implement the principle of least privilege - Isolate sensitive operations in separate processes - Validate all inputs and outputs - Maintain process boundaries</p>"},{"location":"security/#file-permissions","title":"File Permissions","text":"<p>The framework respects system security by: - Honouring system permissions - Using security-scoped resources - Implementing proper cleanup of temporary files - Validating access rights</p>"},{"location":"security/#logging-and-auditing","title":"Logging and Auditing","text":""},{"location":"security/#sensitive-data-handling","title":"Sensitive Data Handling","text":"<p>UmbraCore implements secure logging practices: - No credentials in logs - Automatic masking of sensitive information - Appropriate log levels for different contexts - Privacy-aware debug information</p>"},{"location":"security/#audit-trail","title":"Audit Trail","text":"<p>Security events are tracked through: - Comprehensive event logging - Contextual information capture - Secure audit log maintenance - Structured log formats</p>"},{"location":"security/#error-handling","title":"Error Handling","text":""},{"location":"security/#security-errors","title":"Security Errors","text":"<p>The framework handles security errors by: - Abstracting internal details - Providing appropriate user feedback - Logging security failures securely - Implementing secure fallbacks</p>"},{"location":"security/#recovery-procedures","title":"Recovery Procedures","text":"<p>Error recovery includes: - Clean state maintenance - Secure cleanup procedures - System integrity verification - Graceful degradation</p>"},{"location":"security/#best-practices","title":"Best Practices","text":""},{"location":"security/#code-security","title":"Code Security","text":"<p>Developers should follow these practices: - Leverage Swift's type safety - Implement thorough input validation - Follow OWASP guidelines - Use strong types for sensitive data</p>"},{"location":"security/#security-testing","title":"Security Testing","text":"<p>UmbraCore requires: - Comprehensive security test cases - Error condition testing - Security boundary verification - Regular security audits</p>"},{"location":"security/#dependency-management","title":"Dependency Management","text":"<p>Maintain security through: - Regular security updates - Vulnerability scanning - Strict dependency pinning - Supply chain security</p>"},{"location":"security/#getting-help","title":"Getting Help","text":"<p>If you discover a security vulnerability:</p> <ol> <li>DO NOT create a public issue</li> <li>Email security@mpy-dev.ml with details</li> <li>Expect a response within 24 hours</li> <li>Follow responsible disclosure practices</li> </ol> <p>For general security questions, refer to: - Configuration Guide - API Reference - Troubleshooting Guide</p>"},{"location":"troubleshooting/","title":"Troubleshooting","text":"<p>This page will contain troubleshooting information for common UmbraCore issues. Check back soon for updates.</p>"},{"location":"troubleshooting/#coming-soon","title":"Coming Soon","text":"<ul> <li>Common issues</li> <li>Error messages</li> <li>Debug procedures</li> <li>Performance problems</li> <li>Known limitations</li> </ul>"},{"location":"api/","title":"API Documentation","text":""},{"location":"api/#core-services","title":"Core Services","text":""},{"location":"api/#umbrakeychainservice","title":"UmbraKeychainService","text":"<p>Secure credential storage service. - API Reference - Usage Guide</p>"},{"location":"api/#umbracryptoservice","title":"UmbraCryptoService","text":"<p>Cryptographic operations service. - API Reference - Usage Guide</p>"},{"location":"api/#umbrabookmarkservice","title":"UmbraBookmarkService","text":"<p>File system bookmark management. - API Reference - Usage Guide</p>"},{"location":"api/#security-types","title":"Security Types","text":""},{"location":"api/#securitytypes","title":"SecurityTypes","text":"<p>Base security primitives. - API Reference - Usage Guide</p>"},{"location":"api/#cryptotypes","title":"CryptoTypes","text":"<p>Cryptographic types and operations. - API Reference - Usage Guide</p>"},{"location":"api/#utilities","title":"Utilities","text":""},{"location":"api/#umbralogging","title":"UmbraLogging","text":"<p>Logging infrastructure. - API Reference - Usage Guide</p>"},{"location":"api/#umbraxpc","title":"UmbraXPC","text":"<p>XPC communication layer. - API Reference - Usage Guide</p>"},{"location":"api/#error-types","title":"Error Types","text":""},{"location":"api/#commonerror","title":"CommonError","text":"<p>Shared error types. - API Reference - Usage Guide</p>"},{"location":"api/#best-practices","title":"Best Practices","text":"<ul> <li>Thread Safety</li> <li>Error Handling</li> <li>Performance</li> <li>Security</li> </ul>"},{"location":"archive/ACKNOWLEDGMENTS/","title":"Acknowledgments","text":"<p>UmbraCore stands on the shoulders of open-source giants. We're deeply grateful to the following open-source projects and their maintainers:</p>"},{"location":"archive/ACKNOWLEDGMENTS/#core-dependencies","title":"Core Dependencies","text":""},{"location":"archive/ACKNOWLEDGMENTS/#restic","title":"Restic","text":"<p>Restic is the backbone of UmbraCore's backup capabilities. It's a modern backup program written in Go which provides: - Fast, secure, and efficient backups - Deduplication - Encryption - Multiple backend support - Outstanding performance</p> <p>We highly recommend supporting the Restic project: - GitHub Repository - Documentation - Contributing Guide - Donate</p>"},{"location":"archive/ACKNOWLEDGMENTS/#swiftybeaver","title":"SwiftyBeaver","text":"<p>SwiftyBeaver powers UmbraCore's logging infrastructure. It's a sophisticated logging system that offers: - Colourised console output - File logging - Cloud logging - Custom formats - Filters and threading support</p> <p>Support SwiftyBeaver: - GitHub Repository - Documentation - Pro Features</p>"},{"location":"archive/ACKNOWLEDGMENTS/#cryptoswift","title":"CryptoSwift","text":"<p>CryptoSwift provides UmbraCore's cryptographic operations. It's a comprehensive cryptography framework offering: - AES encryption - Hash functions - HMAC - PBKDF - Extensible architecture</p> <p>Support CryptoSwift: - GitHub Repository - Documentation - Sponsor</p>"},{"location":"archive/ACKNOWLEDGMENTS/#development-tools","title":"Development Tools","text":""},{"location":"archive/ACKNOWLEDGMENTS/#just-the-docs","title":"Just the Docs","text":"<p>The beautiful documentation theme you're currently viewing. Features: - Clean, responsive design - Full-text search - Dark/light mode - Navigation structure - Customisation options</p> <p>Support Just the Docs: - GitHub Repository - Documentation - Contributing Guide</p>"},{"location":"archive/ACKNOWLEDGMENTS/#jazzy","title":"Jazzy","text":"<p>Jazzy generates our API documentation. It provides: - Clean documentation generation - Markdown support - Search functionality - Cross-references</p> <p>Support Jazzy: - GitHub Repository - Documentation - Contributing Guide</p>"},{"location":"archive/ACKNOWLEDGMENTS/#swiftlint","title":"SwiftLint","text":"<p>SwiftLint helps maintain our code quality. It offers: - Style and convention checking - Customisable rules - Automatic fixing - Xcode integration</p> <p>Support SwiftLint: - GitHub Repository - Documentation - Contributing Guide</p>"},{"location":"archive/ACKNOWLEDGMENTS/#security-tools","title":"Security Tools","text":""},{"location":"archive/ACKNOWLEDGMENTS/#snyk","title":"Snyk","text":"<p>Snyk helps keep UmbraCore secure by providing: - Vulnerability scanning - Dependency monitoring - Security updates - License compliance</p> <p>Support Snyk: - Website - Documentation - Blog</p>"},{"location":"archive/ACKNOWLEDGMENTS/#codecov","title":"Codecov","text":"<p>Codecov helps maintain our test coverage by offering: - Coverage reporting - PR checks - Trending analysis - Quality gates</p> <p>Support Codecov: - Website - Documentation - GitHub Repository</p>"},{"location":"archive/ACKNOWLEDGMENTS/#contributing","title":"Contributing","text":"<p>If you'd like to contribute to UmbraCore, please see our Contributing Guidelines. We welcome all contributions, from code to documentation improvements.</p>"},{"location":"archive/ACKNOWLEDGMENTS/#supporting-open-source","title":"Supporting Open Source","text":"<p>We encourage users of UmbraCore to consider supporting these projects through: - Code contributions - Documentation improvements - Bug reports - Financial support where available - Spreading the word about their excellent work</p> <p>The strength of UmbraCore comes from these outstanding open-source projects. Supporting them helps ensure a vibrant and sustainable open-source ecosystem.</p>"},{"location":"archive/GETTING_STARTED/","title":"Getting Started with UmbraCore","text":""},{"location":"archive/GETTING_STARTED/#prerequisites","title":"Prerequisites","text":"<ul> <li>macOS 14.0 or later</li> <li>Xcode 15.2 or later</li> <li>Swift 6.0.3 or later</li> <li>Restic installed</li> </ul>"},{"location":"archive/GETTING_STARTED/#installation","title":"Installation","text":""},{"location":"archive/GETTING_STARTED/#swift-package-manager","title":"Swift Package Manager","text":"<p>Add UmbraCore as a dependency in your <code>Package.swift</code>:</p> <pre><code>dependencies: [\n    .package(url: \"https://github.com/mpy-dev-ml/UmbraCore.git\", from: \"1.0.0\")\n]\n</code></pre>"},{"location":"archive/GETTING_STARTED/#manual-installation","title":"Manual Installation","text":"<ol> <li>Clone the repository</li> <li>Build the package</li> <li>Link the framework</li> </ol>"},{"location":"archive/GETTING_STARTED/#quick-start-guide","title":"Quick Start Guide","text":""},{"location":"archive/GETTING_STARTED/#1-basic-setup","title":"1. Basic Setup","text":"<pre><code>import UmbraCore\n\n// Initialize the core services\nlet keychainService = try UmbraKeychainService()\nlet cryptoService = try UmbraCryptoService()\n</code></pre>"},{"location":"archive/GETTING_STARTED/#2-configure-logging","title":"2. Configure Logging","text":"<pre><code>import UmbraLogging\n\nUmbraLogger.configure(level: .info)\n</code></pre>"},{"location":"archive/GETTING_STARTED/#3-basic-operations","title":"3. Basic Operations","text":"<pre><code>// Example: Store credentials\ntry await keychainService.store(\n    password: \"repository-password\",\n    forKey: \"backup-repo\"\n)\n\n// Example: Create a bookmark\ntry await bookmarkService.create(\n    for: URL(fileURLWithPath: \"/path/to/backup\"),\n    withName: \"documents\"\n)\n</code></pre>"},{"location":"archive/GETTING_STARTED/#next-steps","title":"Next Steps","text":"<ul> <li>Read the Architecture Guide</li> <li>Check out Security Best Practices</li> <li>View API Documentation</li> </ul>"},{"location":"archive/LICENSE/","title":"MIT License","text":"<p>Copyright (c) 2025 MPY Development</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"archive/bazel_spm_integration/","title":"UmbraCore: Bazel and SPM Integration Brief","text":""},{"location":"archive/bazel_spm_integration/#overview","title":"Overview","text":"<p>This document outlines our strategy for integrating Bazel build system while maintaining Swift Package Manager (SPM) compatibility in the UmbraCore project.</p>"},{"location":"archive/bazel_spm_integration/#1-integration-goals","title":"1. Integration Goals","text":"<ul> <li>Maintain existing SPM dependencies</li> <li>Leverage Bazel's build caching</li> <li>Optimise CI/CD performance</li> <li>Support future scalability</li> </ul>"},{"location":"archive/bazel_spm_integration/#2-technical-architecture","title":"2. Technical Architecture","text":""},{"location":"archive/bazel_spm_integration/#21-build-system-components","title":"2.1 Build System Components","text":"<pre><code>UmbraCore/\n\u251c\u2500\u2500 WORKSPACE\n\u251c\u2500\u2500 MODULE.bazel          # Bazel module configuration\n\u251c\u2500\u2500 Package.swift         # SPM dependencies\n\u251c\u2500\u2500 Package.resolved      # SPM version lock\n\u251c\u2500\u2500 .bazelrc             # Bazel settings\n\u251c\u2500\u2500 BUILD.bazel          # Root build file\n\u251c\u2500\u2500 Sources/             # Source files\n\u2502   \u2514\u2500\u2500 */\n\u2502       \u251c\u2500\u2500 BUILD       # Generated by Gazelle\n\u2502       \u2514\u2500\u2500 *.swift\n\u2514\u2500\u2500 Tests/              # Test files\n    \u2514\u2500\u2500 */\n        \u251c\u2500\u2500 BUILD       # Generated by Gazelle\n        \u2514\u2500\u2500 *.swift\n</code></pre>"},{"location":"archive/bazel_spm_integration/#22-key-configuration-files","title":"2.2 Key Configuration Files","text":""},{"location":"archive/bazel_spm_integration/#modulebazel","title":"MODULE.bazel","text":"<pre><code>bazel_dep(name = \"rules_swift_package_manager\", version = \"0.46.0\")\n\nswift_deps = use_extension(\n    \"@rules_swift_package_manager//:extensions.bzl\",\n    \"swift_deps\",\n)\n\nswift_deps.configure_swift_package(\n    build_path = \"spm-build\",\n    cache_path = \"spm-cache\",\n    dependency_caching = \"true\",\n    manifest_cache = \"local\",\n    manifest_caching = \"true\",\n)\n\nswift_deps.from_package(\n    declare_swift_deps_info = True,\n    declare_swift_package = True,\n    resolved = \"//:Package.resolved\",\n    swift = \"//:Package.swift\",\n)\n</code></pre>"},{"location":"archive/bazel_spm_integration/#bazelrc","title":".bazelrc","text":"<pre><code># Enable bzlmod\nbuild --enable_bzlmod\n\n# SPM integration\nbuild --experimental_enable_swift_package_manager\n\n# Caching configuration\nbuild --remote_cache=grpcs://cache.buildbuddy.io\nbuild --remote_timeout=3600\n</code></pre>"},{"location":"archive/bazel_spm_integration/#3-dependency-management","title":"3. Dependency Management","text":""},{"location":"archive/bazel_spm_integration/#31-spm-dependencies","title":"3.1 SPM Dependencies","text":"<ul> <li>CryptoSwift (v1.8.0+)</li> <li>SwiftyBeaver (v2.0.0+)</li> </ul>"},{"location":"archive/bazel_spm_integration/#32-bazel-dependencies","title":"3.2 Bazel Dependencies","text":"<ul> <li>rules_swift_package_manager</li> <li>rules_swift</li> <li>rules_apple (optional)</li> <li>Gazelle</li> </ul>"},{"location":"archive/bazel_spm_integration/#4-caching-strategy","title":"4. Caching Strategy","text":""},{"location":"archive/bazel_spm_integration/#41-cache-locations","title":"4.1 Cache Locations","text":"<ul> <li><code>spm-cache/</code>: SPM dependency cache</li> <li><code>spm-build/</code>: SPM build artifacts</li> <li><code>bazel-*/</code>: Bazel build outputs</li> <li><code>~/.cache/bazel</code>: Bazel system cache</li> </ul>"},{"location":"archive/bazel_spm_integration/#42-cicd-caching","title":"4.2 CI/CD Caching","text":"<pre><code>cache:\n  paths:\n    - ~/.cache/bazel\n    - spm-cache\n    - spm-build\n  key: ${CI_COMMIT_REF_SLUG}\n</code></pre>"},{"location":"archive/bazel_spm_integration/#5-common-operations","title":"5. Common Operations","text":""},{"location":"archive/bazel_spm_integration/#51-dependency-management","title":"5.1 Dependency Management","text":"<pre><code># Update all dependencies\nbazel run @swift_package//:update\n\n# Update specific package\nbazel run @swift_package//:update -- SwiftyBeaver\n\n# Resolve dependencies\nbazel run @swift_package//:resolve\n</code></pre>"},{"location":"archive/bazel_spm_integration/#52-build-operations","title":"5.2 Build Operations","text":"<pre><code># Build entire project\nbazel build //...\n\n# Run tests\nbazel test //...\n\n# Generate BUILD files\nbazel run //:update_build_files\n</code></pre>"},{"location":"archive/bazel_spm_integration/#6-best-practices","title":"6. Best Practices","text":""},{"location":"archive/bazel_spm_integration/#61-development-workflow","title":"6.1 Development Workflow","text":"<ol> <li>Use Bazel commands for all build operations</li> <li>Keep Package.swift minimal and focused</li> <li>Regularly update cached dependencies</li> <li>Monitor cache size and performance</li> </ol>"},{"location":"archive/bazel_spm_integration/#62-code-organisation","title":"6.2 Code Organisation","text":"<ol> <li>Follow module structure in Sources/</li> <li>Maintain clear dependency boundaries</li> <li>Use proper visibility declarations</li> <li>Keep BUILD files organised</li> </ol>"},{"location":"archive/bazel_spm_integration/#63-language-standards","title":"6.3 Language Standards","text":"<ol> <li>Use British English in:</li> <li>Documentation</li> <li>Comments</li> <li>User-facing text</li> <li>Use American English in:</li> <li>Code</li> <li>Build files</li> <li>Configuration</li> </ol>"},{"location":"archive/bazel_spm_integration/#7-performance-considerations","title":"7. Performance Considerations","text":""},{"location":"archive/bazel_spm_integration/#71-local-development","title":"7.1 Local Development","text":"<ul> <li>Use local caching</li> <li>Enable parallel builds</li> <li>Monitor resource usage</li> <li>Regular cache cleanup</li> </ul>"},{"location":"archive/bazel_spm_integration/#72-cicd-pipeline","title":"7.2 CI/CD Pipeline","text":"<ul> <li>Optimise cache sharing</li> <li>Use remote caching</li> <li>Enable parallel testing</li> <li>Monitor build times</li> </ul>"},{"location":"archive/bazel_spm_integration/#8-migration-timeline","title":"8. Migration Timeline","text":""},{"location":"archive/bazel_spm_integration/#phase-1-initial-setup-1-week","title":"Phase 1: Initial Setup (1 week)","text":"<ul> <li>[ ] Configure Bazel</li> <li>[ ] Set up SPM integration</li> <li>[ ] Configure caching</li> <li>[ ] Update documentation</li> </ul>"},{"location":"archive/bazel_spm_integration/#phase-2-build-migration-2-weeks","title":"Phase 2: Build Migration (2 weeks)","text":"<ul> <li>[ ] Generate BUILD files</li> <li>[ ] Test build system</li> <li>[ ] Validate dependencies</li> <li>[ ] Performance testing</li> </ul>"},{"location":"archive/bazel_spm_integration/#phase-3-cicd-integration-1-week","title":"Phase 3: CI/CD Integration (1 week)","text":"<ul> <li>[ ] Configure GitHub Actions</li> <li>[ ] Set up caching</li> <li>[ ] Test workflows</li> <li>[ ] Monitor performance</li> </ul>"},{"location":"archive/bazel_spm_integration/#9-support-and-maintenance","title":"9. Support and Maintenance","text":""},{"location":"archive/bazel_spm_integration/#91-regular-tasks","title":"9.1 Regular Tasks","text":"<ul> <li>Weekly dependency updates</li> <li>Monthly cache cleanup</li> <li>Quarterly performance review</li> <li>Regular documentation updates</li> </ul>"},{"location":"archive/bazel_spm_integration/#92-monitoring","title":"9.2 Monitoring","text":"<ul> <li>Build times</li> <li>Cache hit rates</li> <li>Dependency updates</li> <li>Resource usage</li> </ul>"},{"location":"archive/bazel_spm_integration/#10-references","title":"10. References","text":"<ol> <li>Bazel Documentation</li> <li>rules_swift_package_manager</li> <li>Swift Package Manager</li> <li>GitHub Actions Documentation</li> </ol>"},{"location":"archive/api/","title":"API Documentation","text":""},{"location":"archive/api/#core-services","title":"Core Services","text":""},{"location":"archive/api/#umbrakeychainservice","title":"UmbraKeychainService","text":"<p>Secure credential storage service. - API Reference - Usage Guide</p>"},{"location":"archive/api/#umbracryptoservice","title":"UmbraCryptoService","text":"<p>Cryptographic operations service. - API Reference - Usage Guide</p>"},{"location":"archive/api/#umbrabookmarkservice","title":"UmbraBookmarkService","text":"<p>File system bookmark management. - API Reference - Usage Guide</p>"},{"location":"archive/api/#security-types","title":"Security Types","text":""},{"location":"archive/api/#securitytypes","title":"SecurityTypes","text":"<p>Base security primitives. - API Reference - Usage Guide</p>"},{"location":"archive/api/#cryptotypes","title":"CryptoTypes","text":"<p>Cryptographic types and operations. - API Reference - Usage Guide</p>"},{"location":"archive/api/#utilities","title":"Utilities","text":""},{"location":"archive/api/#umbralogging","title":"UmbraLogging","text":"<p>Logging infrastructure. - API Reference - Usage Guide</p>"},{"location":"archive/api/#umbraxpc","title":"UmbraXPC","text":"<p>XPC communication layer. - API Reference - Usage Guide</p>"},{"location":"archive/api/#error-types","title":"Error Types","text":""},{"location":"archive/api/#commonerror","title":"CommonError","text":"<p>Shared error types. - API Reference - Usage Guide</p>"},{"location":"archive/api/#best-practices","title":"Best Practices","text":"<ul> <li>Thread Safety</li> <li>Error Handling</li> <li>Performance</li> <li>Security</li> </ul>"},{"location":"archive/contributing/CONTRIBUTING/","title":"Contributing to UmbraCore","text":""},{"location":"archive/contributing/CONTRIBUTING/#getting-started","title":"Getting Started","text":""},{"location":"archive/contributing/CONTRIBUTING/#1-development-environment","title":"1. Development Environment","text":"<ul> <li>macOS 14.0+</li> <li>Xcode 15.2+</li> <li>Swift 6.0.3+</li> <li>SwiftLint</li> <li>Restic</li> </ul>"},{"location":"archive/contributing/CONTRIBUTING/#2-setup","title":"2. Setup","text":"<ol> <li>Fork the repository</li> <li>Clone your fork</li> <li>Install dependencies</li> <li>Run tests</li> </ol>"},{"location":"archive/contributing/CONTRIBUTING/#development-process","title":"Development Process","text":""},{"location":"archive/contributing/CONTRIBUTING/#1-branching","title":"1. Branching","text":"<ul> <li><code>main</code>: Production-ready code</li> <li><code>develop</code>: Integration branch</li> <li>Feature branches: <code>feature/description</code></li> <li>Bug fixes: <code>fix/description</code></li> </ul>"},{"location":"archive/contributing/CONTRIBUTING/#2-commit-messages","title":"2. Commit Messages","text":"<p>Follow conventional commits: <pre><code>type(scope): description\n\n[optional body]\n\n[optional footer]\n</code></pre></p> <p>Types: - feat: New feature - fix: Bug fix - docs: Documentation - style: Formatting - refactor: Code restructuring - test: Adding tests - chore: Maintenance</p>"},{"location":"archive/contributing/CONTRIBUTING/#3-code-style","title":"3. Code Style","text":"<ul> <li>Follow Swift API Design Guidelines</li> <li>Use SwiftLint rules</li> <li>Document public APIs</li> <li>Write meaningful comments</li> </ul>"},{"location":"archive/contributing/CONTRIBUTING/#4-testing","title":"4. Testing","text":"<ul> <li>Write unit tests</li> <li>Include integration tests</li> <li>Maintain test coverage</li> <li>Test error conditions</li> </ul>"},{"location":"archive/contributing/CONTRIBUTING/#5-documentation","title":"5. Documentation","text":"<ul> <li>Update API documentation</li> <li>Include code examples</li> <li>Document breaking changes</li> <li>Update guides if needed</li> </ul>"},{"location":"archive/contributing/CONTRIBUTING/#pull-requests","title":"Pull Requests","text":""},{"location":"archive/contributing/CONTRIBUTING/#1-preparation","title":"1. Preparation","text":"<ul> <li>Update from upstream</li> <li>Run all tests</li> <li>Check code coverage</li> <li>Run SwiftLint</li> </ul>"},{"location":"archive/contributing/CONTRIBUTING/#2-submission","title":"2. Submission","text":"<ul> <li>Clear description</li> <li>Link related issues</li> <li>Include test cases</li> <li>Update documentation</li> </ul>"},{"location":"archive/contributing/CONTRIBUTING/#3-review-process","title":"3. Review Process","text":"<ul> <li>Address feedback</li> <li>Keep changes focused</li> <li>Maintain clean history</li> <li>Update as needed</li> </ul>"},{"location":"archive/contributing/CONTRIBUTING/#release-process","title":"Release Process","text":""},{"location":"archive/contributing/CONTRIBUTING/#1-versioning","title":"1. Versioning","text":"<p>Follow semantic versioning: - MAJOR: Breaking changes - MINOR: New features - PATCH: Bug fixes</p>"},{"location":"archive/contributing/CONTRIBUTING/#2-release-checklist","title":"2. Release Checklist","text":"<ul> <li>Update changelog</li> <li>Update version</li> <li>Run full test suite</li> <li>Update documentation</li> <li>Create release notes</li> </ul>"},{"location":"archive/contributing/CONTRIBUTING/#additional-resources","title":"Additional Resources","text":"<ul> <li>Swift API Design Guidelines</li> <li>SwiftLint Rules</li> <li>Conventional Commits</li> </ul>"},{"location":"archive/guides/ARCHITECTURE/","title":"UmbraCore Architecture Guide","text":""},{"location":"archive/guides/ARCHITECTURE/#overview","title":"Overview","text":"<p>UmbraCore is designed as a modular Swift library that provides a type-safe interface to Restic backup functionality. The architecture follows a service-oriented approach with clear separation of concerns.</p>"},{"location":"archive/guides/ARCHITECTURE/#core-components","title":"Core Components","text":""},{"location":"archive/guides/ARCHITECTURE/#1-security-layer","title":"1. Security Layer","text":"<ul> <li><code>SecurityTypes</code>: Base security primitives</li> <li><code>CryptoTypes</code>: Cryptographic operations</li> <li>Uses Apple's CryptoKit for hardware-backed security</li> <li>Provides core cryptographic primitives</li> <li>Handles secure key generation and management</li> <li><code>UmbraKeychainService</code>: Secure credential storage</li> </ul>"},{"location":"archive/guides/ARCHITECTURE/#2-service-layer","title":"2. Service Layer","text":"<ul> <li><code>UmbraCryptoService</code>: Encryption/decryption operations</li> <li>Uses CryptoSwift for XPC service operations</li> <li>Platform-independent implementation</li> <li>Handles cross-process cryptographic operations</li> <li><code>UmbraBookmarkService</code>: File system bookmark management</li> <li><code>UmbraXPC</code>: Inter-process communication</li> </ul>"},{"location":"archive/guides/ARCHITECTURE/#3-logging-infrastructure","title":"3. Logging Infrastructure","text":"<ul> <li><code>UmbraLogging</code>: Centralised logging system</li> <li>Structured logging with context</li> <li>Log level management</li> </ul>"},{"location":"archive/guides/ARCHITECTURE/#design-patterns","title":"Design Patterns","text":""},{"location":"archive/guides/ARCHITECTURE/#1-xpc-service-pattern","title":"1. XPC Service Pattern","text":"<p>Used for secure inter-process communication: <pre><code>protocol KeychainXPCProtocol {\n    func store(password: String, forKey: String) async throws\n    func retrieve(forKey: String) async throws -&gt; String\n}\n</code></pre></p>"},{"location":"archive/guides/ARCHITECTURE/#2-protocol-oriented-design","title":"2. Protocol-Oriented Design","text":"<p>Services are defined by protocols for better testability: <pre><code>protocol CryptoServiceProtocol {\n    func encrypt(_ data: Data) async throws -&gt; Data\n    func decrypt(_ data: Data) async throws -&gt; Data\n}\n</code></pre></p>"},{"location":"archive/guides/ARCHITECTURE/#3-error-handling-pattern","title":"3. Error Handling Pattern","text":"<p>Structured error types with context: <pre><code>enum KeychainError: Error {\n    case itemNotFound(String)\n    case duplicateItem(String)\n    case accessDenied(String)\n}\n</code></pre></p>"},{"location":"archive/guides/ARCHITECTURE/#cryptographic-architecture","title":"Cryptographic Architecture","text":"<p>The framework employs a dual-library approach for cryptographic operations:</p> <ol> <li>CryptoKit (Main App Context)</li> <li>Hardware-backed security on Apple platforms</li> <li>Used in <code>DefaultCryptoService</code></li> <li>Handles core cryptographic operations</li> <li> <p>Optimal security for main app operations</p> </li> <li> <p>CryptoSwift (XPC Service Context)</p> </li> <li>Platform-independent implementation</li> <li>Used in <code>CryptoXPCService</code></li> <li>Enables reliable cross-process encryption</li> <li>Provides necessary flexibility for XPC operations</li> </ol> <p>This split architecture ensures: - Maximum security through hardware backing where available - Reliable cross-process cryptographic operations - Clear separation of concerns between contexts - Consistent cryptographic operations in each context</p>"},{"location":"archive/guides/ARCHITECTURE/#threading-model","title":"Threading Model","text":"<ul> <li>All services are thread-safe</li> <li>Async/await for asynchronous operations</li> <li>XPC for background processing</li> </ul>"},{"location":"archive/guides/ARCHITECTURE/#security-considerations","title":"Security Considerations","text":"<ul> <li>Keychain integration for secure storage</li> <li>XPC for privilege separation</li> <li>Audit logging</li> <li>Secure defaults</li> </ul>"},{"location":"archive/guides/ARCHITECTURE/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Efficient memory usage</li> <li>Background processing</li> <li>Cache management</li> <li>Resource cleanup</li> </ul>"},{"location":"archive/guides/ARCHITECTURE/#testing-strategy","title":"Testing Strategy","text":"<ul> <li>Unit tests for all components</li> <li>Integration tests for workflows</li> <li>Mock services for testing</li> <li>Performance benchmarks</li> </ul>"},{"location":"archive/guides/ARCHITECTURE/#dependency-management","title":"Dependency Management","text":"<ul> <li>Minimal external dependencies</li> <li>Version pinning</li> <li>Security scanning</li> <li>Regular updates</li> </ul>"},{"location":"archive/guides/ARCHITECTURE/#implementation-plan","title":"Implementation Plan","text":""},{"location":"archive/guides/ARCHITECTURE/#phase-1-core-foundation","title":"Phase 1: Core Foundation","text":"<p>Currently in progress (Q1 2025):</p> <ul> <li>Command execution system</li> <li>Keychain integration</li> <li>XPC service implementation</li> <li>SSH key management</li> <li>Cloud provider integration</li> </ul>"},{"location":"archive/guides/ARCHITECTURE/#phase-2-advanced-features","title":"Phase 2: Advanced Features","text":"<p>Planned for Q2 2025:</p> <ul> <li>Repository management</li> <li>Scheduling system</li> <li>Network operations</li> <li>State persistence</li> </ul>"},{"location":"archive/guides/ARCHITECTURE/#phase-3-optimisation","title":"Phase 3: Optimisation","text":"<p>Scheduled for Q3 2025:</p> <ul> <li>Statistics &amp; analytics</li> <li>Health monitoring</li> <li>Event system</li> <li>Cache optimisation</li> </ul>"},{"location":"archive/guides/ARCHITECTURE/#design-principles","title":"Design Principles","text":""},{"location":"archive/guides/ARCHITECTURE/#1-security-first","title":"1. Security First","text":"<ul> <li>Secure by default</li> <li>Least privilege principle</li> <li>Comprehensive audit logging</li> <li>Regular security reviews</li> </ul>"},{"location":"archive/guides/ARCHITECTURE/#2-reliability","title":"2. Reliability","text":"<ul> <li>Comprehensive error handling</li> <li>Automatic retry mechanisms</li> <li>Circuit breakers</li> <li>Fallback strategies</li> </ul>"},{"location":"archive/guides/ARCHITECTURE/#3-performance","title":"3. Performance","text":"<ul> <li>Efficient resource usage</li> <li>Optimised I/O operations</li> <li>Memory management</li> <li>Cache strategies</li> </ul>"},{"location":"archive/guides/ARCHITECTURE/#4-maintainability","title":"4. Maintainability","text":"<ul> <li>Protocol-oriented design</li> <li>Clear documentation</li> <li>Comprehensive testing</li> <li>Code review process</li> </ul>"},{"location":"archive/guides/ARCHITECTURE/#integration-points","title":"Integration Points","text":"<p>UmbraCore serves as the foundation for:</p> <ul> <li>Rbum: Command-line interface</li> <li>Rbx: GUI application</li> <li>ResticBar: Menu bar application</li> </ul> <p>Each application utilises UmbraCore's components through well-defined protocols and interfaces.</p>"},{"location":"archive/guides/ARCHITECTURE/#testing-strategy_1","title":"Testing Strategy","text":"<p>Comprehensive testing approach:</p> <ol> <li>Unit Tests</li> <li>Component isolation</li> <li>Edge case coverage</li> <li> <p>Mock implementations</p> </li> <li> <p>Integration Tests</p> </li> <li>Component interaction</li> <li>System workflows</li> <li> <p>Error scenarios</p> </li> <li> <p>Performance Tests</p> </li> <li>Resource usage</li> <li>Throughput metrics</li> <li> <p>Scalability checks</p> </li> <li> <p>Security Tests</p> </li> <li>Vulnerability scanning</li> <li>Penetration testing</li> <li>Compliance verification</li> </ol>"},{"location":"archive/guides/bookmarks/","title":"UmbraBookmarkService Guide","text":""},{"location":"archive/guides/bookmarks/#overview","title":"Overview","text":"<p><code>UmbraBookmarkService</code> manages persistent file system access through security-scoped bookmarks. It provides safe and reliable access to files and directories across app launches.</p>"},{"location":"archive/guides/bookmarks/#features","title":"Features","text":"<ul> <li>Security-scoped bookmarks</li> <li>Persistent file access</li> <li>Thread-safe operations</li> <li>Automatic bookmark resolution</li> </ul>"},{"location":"archive/guides/bookmarks/#basic-usage","title":"Basic Usage","text":""},{"location":"archive/guides/bookmarks/#creating-bookmarks","title":"Creating Bookmarks","text":"<pre><code>let service = try UmbraBookmarkService()\n\n// Create bookmark for file\nlet fileURL = URL(fileURLWithPath: \"/path/to/file\")\ntry await service.create(\n    for: fileURL,\n    withName: \"important-file\"\n)\n\n// Create bookmark for directory\nlet dirURL = URL(fileURLWithPath: \"/path/to/directory\")\ntry await service.create(\n    for: dirURL,\n    withName: \"backup-directory\"\n)\n</code></pre>"},{"location":"archive/guides/bookmarks/#resolving-bookmarks","title":"Resolving Bookmarks","text":"<pre><code>// Get URL from bookmark\nlet fileURL = try await service.resolve(name: \"important-file\")\n\n// Access with scope\ntry await service.access(name: \"backup-directory\") { url in\n    // Work with URL within security scope\n    let contents = try FileManager.default.contentsOfDirectory(at: url)\n}\n</code></pre>"},{"location":"archive/guides/bookmarks/#removing-bookmarks","title":"Removing Bookmarks","text":"<pre><code>try await service.remove(name: \"important-file\")\n</code></pre>"},{"location":"archive/guides/bookmarks/#error-handling","title":"Error Handling","text":"<pre><code>do {\n    try await service.create(for: url, withName: name)\n} catch BookmarkError.invalidURL(let url) {\n    // Handle invalid URL\n} catch BookmarkError.accessDenied(let reason) {\n    // Handle access denied\n} catch {\n    // Handle other errors\n}\n</code></pre>"},{"location":"archive/guides/bookmarks/#best-practices","title":"Best Practices","text":""},{"location":"archive/guides/bookmarks/#1-bookmark-naming","title":"1. Bookmark Naming","text":"<ul> <li>Use descriptive names</li> <li>Include context</li> <li>Follow naming conventions</li> </ul> <pre><code>// Good\n\"main-backup-directory\"\n\"config-file-production\"\n\n// Bad\n\"bookmark1\"\n\"file\"\n</code></pre>"},{"location":"archive/guides/bookmarks/#2-access-scoping","title":"2. Access Scoping","text":"<ul> <li>Use scoped access</li> <li>Clean up resources</li> <li>Handle access errors</li> </ul>"},{"location":"archive/guides/bookmarks/#3-error-recovery","title":"3. Error Recovery","text":"<ul> <li>Implement retry logic</li> <li>Provide user feedback</li> <li>Log access failures</li> </ul>"},{"location":"archive/guides/bookmarks/#advanced-usage","title":"Advanced Usage","text":""},{"location":"archive/guides/bookmarks/#1-custom-bookmark-options","title":"1. Custom Bookmark Options","text":"<pre><code>let options = BookmarkOptions(\n    securityScope: .workingDirectory,\n    persistence: .permanent\n)\n\ntry await service.create(\n    for: url,\n    withName: name,\n    options: options\n)\n</code></pre>"},{"location":"archive/guides/bookmarks/#2-batch-operations","title":"2. Batch Operations","text":"<pre><code>let bookmarks = [\n    \"dir1\": url1,\n    \"dir2\": url2\n]\n\ntry await service.createBatch(bookmarks)\n</code></pre>"},{"location":"archive/guides/bookmarks/#3-access-control","title":"3. Access Control","text":"<pre><code>let access = BookmarkAccess(\n    scope: .minimal,\n    duration: .temporary\n)\n\ntry await service.access(\n    name: \"secure-directory\",\n    access: access\n) { url in\n    // Limited scope access\n}\n</code></pre>"},{"location":"archive/guides/bookmarks/#integration-examples","title":"Integration Examples","text":""},{"location":"archive/guides/bookmarks/#1-backup-directory-management","title":"1. Backup Directory Management","text":"<pre><code>class BackupManager {\n    private let bookmarks: UmbraBookmarkService\n\n    init() throws {\n        bookmarks = try UmbraBookmarkService()\n    }\n\n    func configureBackupDirectory(_ url: URL) async throws {\n        // Create persistent bookmark\n        try await bookmarks.create(\n            for: url,\n            withName: \"backup-root\"\n        )\n    }\n\n    func performBackup() async throws {\n        try await bookmarks.access(\"backup-root\") { url in\n            // Perform backup operations\n            try await backupContents(of: url)\n        }\n    }\n}\n</code></pre>"},{"location":"archive/guides/bookmarks/#2-configuration-file-access","title":"2. Configuration File Access","text":"<pre><code>class ConfigManager {\n    private let bookmarks: UmbraBookmarkService\n\n    func saveConfig(_ config: Config) async throws {\n        try await bookmarks.access(\"config-file\") { url in\n            let data = try JSONEncoder().encode(config)\n            try data.write(to: url)\n        }\n    }\n}\n</code></pre>"},{"location":"archive/guides/bookmarks/#troubleshooting","title":"Troubleshooting","text":""},{"location":"archive/guides/bookmarks/#common-issues","title":"Common Issues","text":"<ol> <li> <p>Stale Bookmarks <pre><code>// Refresh bookmark if stale\nif await service.isStale(name: \"backup-dir\") {\n    try await service.refresh(name: \"backup-dir\")\n}\n</code></pre></p> </li> <li> <p>Access Denied <pre><code>// Request user permission if needed\nfunc ensureAccess(to name: String) async throws {\n    do {\n        try await service.verifyAccess(name: name)\n    } catch BookmarkError.accessDenied {\n        try await requestUserPermission(for: name)\n    }\n}\n</code></pre></p> </li> <li> <p>Resource Management <pre><code>// Proper resource cleanup\nfunc processDirectory() async throws {\n    try await service.access(\"work-dir\") { url in\n        defer {\n            // Cleanup code\n        }\n\n        // Process directory\n    }\n}\n</code></pre></p> </li> </ol>"},{"location":"archive/guides/crypto-types/","title":"Cryptographic Types","text":"<p>This guide covers the cryptographic types used in UmbraCore for secure data handling.</p>"},{"location":"archive/guides/crypto-types/#overview","title":"Overview","text":"<p>UmbraCore provides several cryptographic types to ensure secure handling of sensitive data:</p> <ul> <li><code>SecureString</code>: For handling passwords and other sensitive strings</li> <li><code>EncryptedData</code>: For encrypted binary data</li> <li><code>KeyMaterial</code>: For cryptographic key material</li> </ul>"},{"location":"archive/guides/crypto-types/#securestring","title":"SecureString","text":"<p><code>SecureString</code> provides secure storage for sensitive string data:</p> <pre><code>let password = SecureString(\"sensitive-data\")\n// Memory is automatically zeroed when deallocated\n</code></pre>"},{"location":"archive/guides/crypto-types/#encrypteddata","title":"EncryptedData","text":"<p><code>EncryptedData</code> handles encrypted binary data:</p> <pre><code>let encrypted = EncryptedData(data: someData, key: keyMaterial)\nlet decrypted = try encrypted.decrypt(using: keyMaterial)\n</code></pre>"},{"location":"archive/guides/crypto-types/#keymaterial","title":"KeyMaterial","text":"<p><code>KeyMaterial</code> manages cryptographic keys:</p> <pre><code>let key = try KeyMaterial.generate()\nlet derived = try key.deriveKey(salt: salt, rounds: 100_000)\n</code></pre>"},{"location":"archive/guides/crypto-types/#best-practices","title":"Best Practices","text":"<ol> <li>Always use <code>SecureString</code> for passwords and sensitive data</li> <li>Zero memory after use</li> <li>Use appropriate key derivation functions</li> <li>Implement proper key rotation</li> <li>Follow cryptographic hygiene</li> </ol>"},{"location":"archive/guides/crypto/","title":"UmbraCryptoService Guide","text":""},{"location":"archive/guides/crypto/#overview","title":"Overview","text":"<p><code>UmbraCryptoService</code> provides cryptographic operations for securing sensitive data. It supports encryption, decryption, and key management.</p>"},{"location":"archive/guides/crypto/#features","title":"Features","text":"<ul> <li>Secure encryption/decryption</li> <li>Key management</li> <li>Thread-safe operations</li> <li>XPC-based processing</li> </ul>"},{"location":"archive/guides/crypto/#basic-usage","title":"Basic Usage","text":""},{"location":"archive/guides/crypto/#encryption","title":"Encryption","text":"<pre><code>let service = try UmbraCryptoService()\n\n// Encrypt data\nlet data = \"sensitive data\".data(using: .utf8)!\nlet encrypted = try await service.encrypt(data)\n\n// Encrypt with custom key\nlet key = try service.generateKey()\nlet customEncrypted = try await service.encrypt(data, using: key)\n</code></pre>"},{"location":"archive/guides/crypto/#decryption","title":"Decryption","text":"<pre><code>// Decrypt data\nlet decrypted = try await service.decrypt(encrypted)\n\n// Decrypt with custom key\nlet customDecrypted = try await service.decrypt(customEncrypted, using: key)\n</code></pre>"},{"location":"archive/guides/crypto/#key-management","title":"Key Management","text":"<pre><code>// Generate new key\nlet key = try service.generateKey()\n\n// Export key (protected)\nlet exportedKey = try service.exportKey(key)\n\n// Import key\nlet importedKey = try service.importKey(exportedKey)\n</code></pre>"},{"location":"archive/guides/crypto/#error-handling","title":"Error Handling","text":"<pre><code>do {\n    let encrypted = try await service.encrypt(data)\n} catch CryptoError.invalidKey {\n    // Handle invalid key\n} catch CryptoError.encryptionFailed(let reason) {\n    // Handle encryption failure\n} catch {\n    // Handle other errors\n}\n</code></pre>"},{"location":"archive/guides/crypto/#best-practices","title":"Best Practices","text":""},{"location":"archive/guides/crypto/#1-key-management","title":"1. Key Management","text":"<ul> <li>Rotate keys regularly</li> <li>Secure key storage</li> <li>Use key derivation when appropriate</li> </ul>"},{"location":"archive/guides/crypto/#2-data-protection","title":"2. Data Protection","text":"<ul> <li>Encrypt sensitive data immediately</li> <li>Clear sensitive data from memory</li> <li>Use secure random generation</li> </ul>"},{"location":"archive/guides/crypto/#3-error-recovery","title":"3. Error Recovery","text":"<ul> <li>Implement retry logic</li> <li>Log cryptographic failures</li> <li>Provide appropriate user feedback</li> </ul>"},{"location":"archive/guides/crypto/#advanced-usage","title":"Advanced Usage","text":""},{"location":"archive/guides/crypto/#1-custom-encryption-parameters","title":"1. Custom Encryption Parameters","text":"<pre><code>let params = EncryptionParameters(\n    algorithm: .aes256GCM,\n    keySize: .bits256,\n    iterations: 10000\n)\n\nlet encrypted = try await service.encrypt(\n    data,\n    parameters: params\n)\n</code></pre>"},{"location":"archive/guides/crypto/#2-key-derivation","title":"2. Key Derivation","text":"<pre><code>let derivedKey = try service.deriveKey(\n    fromPassword: \"user-password\",\n    salt: salt,\n    iterations: 10000\n)\n</code></pre>"},{"location":"archive/guides/crypto/#3-batch-operations","title":"3. Batch Operations","text":"<pre><code>let dataItems = [\n    \"item1\": data1,\n    \"item2\": data2\n]\n\nlet encrypted = try await service.encryptBatch(dataItems)\n</code></pre>"},{"location":"archive/guides/crypto/#integration-examples","title":"Integration Examples","text":""},{"location":"archive/guides/crypto/#1-secure-configuration","title":"1. Secure Configuration","text":"<pre><code>class SecureConfig {\n    private let crypto: UmbraCryptoService\n\n    init() throws {\n        crypto = try UmbraCryptoService()\n    }\n\n    func saveConfig(_ config: Config) async throws {\n        let data = try JSONEncoder().encode(config)\n        let encrypted = try await crypto.encrypt(data)\n\n        try await FileManager.default.createFile(\n            at: configURL,\n            contents: encrypted\n        )\n    }\n}\n</code></pre>"},{"location":"archive/guides/crypto/#2-secure-data-transfer","title":"2. Secure Data Transfer","text":"<pre><code>class SecureTransfer {\n    private let crypto: UmbraCryptoService\n\n    func secureUpload(_ data: Data) async throws {\n        // Encrypt before upload\n        let encrypted = try await crypto.encrypt(data)\n\n        // Upload encrypted data\n        try await uploadToServer(encrypted)\n    }\n}\n</code></pre>"},{"location":"archive/guides/crypto/#troubleshooting","title":"Troubleshooting","text":""},{"location":"archive/guides/crypto/#common-issues","title":"Common Issues","text":"<ol> <li> <p>Key Validation <pre><code>// Validate key before use\nguard try service.validateKey(key) else {\n    throw CryptoError.invalidKey\n}\n</code></pre></p> </li> <li> <p>Memory Management <pre><code>// Clear sensitive data\ndefer {\n    key.zero()\n    plaintext.zero()\n}\n</code></pre></p> </li> <li> <p>Performance Optimization <pre><code>// Use batch operations for multiple items\nlet results = try await withThrowingTaskGroup(of: (String, Data).self) { group in\n    for (id, data) in items {\n        group.addTask {\n            let encrypted = try await service.encrypt(data)\n            return (id, encrypted)\n        }\n    }\n    return try await group.reduce(into: [:]) { $0[$1.0] = $1.1 }\n}\n</code></pre></p> </li> </ol>"},{"location":"archive/guides/error-handling/","title":"Error Handling in UmbraCore","text":""},{"location":"archive/guides/error-handling/#overview","title":"Overview","text":"<p>UmbraCore uses a structured error handling system that provides detailed error context, supports error recovery, and integrates with the logging system. This guide explains our error handling patterns and best practices.</p>"},{"location":"archive/guides/error-handling/#error-types","title":"Error Types","text":""},{"location":"archive/guides/error-handling/#1-common-errors","title":"1. Common Errors","text":"<p>Base error types shared across the library:</p> <pre><code>enum CommonError: Error {\n    case invalidArgument(String)\n    case resourceNotFound(String)\n    case permissionDenied(String)\n    case operationFailed(String)\n\n    var localizedDescription: String {\n        switch self {\n        case .invalidArgument(let details):\n            return \"Invalid argument: \\(details)\"\n        case .resourceNotFound(let resource):\n            return \"Resource not found: \\(resource)\"\n        case .permissionDenied(let operation):\n            return \"Permission denied for operation: \\(operation)\"\n        case .operationFailed(let reason):\n            return \"Operation failed: \\(reason)\"\n        }\n    }\n}\n</code></pre>"},{"location":"archive/guides/error-handling/#2-service-specific-errors","title":"2. Service-Specific Errors","text":"<p>Each service defines its domain-specific errors:</p> <pre><code>enum KeychainError: Error {\n    case itemNotFound(String)\n    case duplicateItem(String)\n    case accessDenied(String)\n    case invalidData(String)\n}\n\nenum CryptoError: Error {\n    case encryptionFailed(String)\n    case decryptionFailed(String)\n    case invalidKey(String)\n    case algorithmNotSupported(String)\n}\n</code></pre>"},{"location":"archive/guides/error-handling/#3-error-context","title":"3. Error Context","text":"<p>Additional context for debugging and recovery:</p> <pre><code>struct ErrorContext {\n    let file: String\n    let function: String\n    let line: Int\n    let timestamp: Date\n    let operationId: UUID\n    var userInfo: [String: Any]\n\n    var description: String {\n        \"\"\"\n        Error occurred in \\(function)\n        File: \\(file):\\(line)\n        Time: \\(timestamp)\n        Operation: \\(operationId)\n        Additional Info: \\(userInfo)\n        \"\"\"\n    }\n}\n</code></pre>"},{"location":"archive/guides/error-handling/#best-practices","title":"Best Practices","text":""},{"location":"archive/guides/error-handling/#1-error-creation","title":"1. Error Creation","text":"<p>Create informative errors with context:</p> <pre><code>func processFile(_ url: URL) async throws {\n    guard FileManager.default.fileExists(atPath: url.path) else {\n        throw CommonError.resourceNotFound(\n            \"\"\"\n            File not found at \\(url.path)\n            Check if the file exists and you have read permissions.\n            \"\"\"\n        )\n    }\n}\n</code></pre>"},{"location":"archive/guides/error-handling/#2-error-handling","title":"2. Error Handling","text":"<p>Handle errors at appropriate levels:</p> <pre><code>func backupFiles() async throws {\n    do {\n        try await validatePermissions()\n        try await performBackup()\n        try await verifyBackup()\n    } catch KeychainError.accessDenied(let details) {\n        logger.error(\"Keychain access denied\", metadata: [\n            \"details\": details,\n            \"operation\": \"backup\"\n        ])\n        throw CommonError.permissionDenied(\"Keychain access required for backup\")\n    } catch CryptoError.encryptionFailed(let reason) {\n        logger.error(\"Encryption failed\", metadata: [\n            \"reason\": reason,\n            \"operation\": \"backup\"\n        ])\n        throw CommonError.operationFailed(\"Backup encryption failed\")\n    }\n}\n</code></pre>"},{"location":"archive/guides/error-handling/#3-error-recovery","title":"3. Error Recovery","text":"<p>Implement recovery strategies:</p> <pre><code>actor RetryableOperation {\n    func execute() async throws -&gt; Result {\n        var attempts = 0\n        while attempts &lt; maxRetries {\n            do {\n                return try await performOperation()\n            } catch let error as RecoverableError {\n                attempts += 1\n                try await handleError(error, attempt: attempts)\n            } catch {\n                throw error // Non-recoverable error\n            }\n        }\n        throw CommonError.operationFailed(\"Max retry attempts exceeded\")\n    }\n}\n</code></pre>"},{"location":"archive/guides/error-handling/#error-patterns","title":"Error Patterns","text":""},{"location":"archive/guides/error-handling/#1-result-type-usage","title":"1. Result Type Usage","text":"<p>For operations that might fail:</p> <pre><code>enum OperationResult&lt;T&gt; {\n    case success(T)\n    case failure(Error)\n    case partial(T, [Error])\n\n    var value: T? {\n        switch self {\n        case .success(let value), .partial(let value, _):\n            return value\n        case .failure:\n            return nil\n        }\n    }\n}\n\nfunc processItems(_ items: [Item]) async -&gt; OperationResult&lt;[ProcessedItem]&gt; {\n    var processed: [ProcessedItem] = []\n    var errors: [Error] = []\n\n    for item in items {\n        do {\n            let result = try await process(item)\n            processed.append(result)\n        } catch {\n            errors.append(error)\n        }\n    }\n\n    if errors.isEmpty {\n        return .success(processed)\n    } else if processed.isEmpty {\n        return .failure(CommonError.operationFailed(\"All items failed\"))\n    } else {\n        return .partial(processed, errors)\n    }\n}\n</code></pre>"},{"location":"archive/guides/error-handling/#2-error-transformation","title":"2. Error Transformation","text":"<p>Convert between error types while preserving context:</p> <pre><code>extension Error {\n    func asCommonError() -&gt; CommonError {\n        switch self {\n        case let error as KeychainError:\n            return error.toCommonError()\n        case let error as CryptoError:\n            return error.toCommonError()\n        default:\n            return .operationFailed(localizedDescription)\n        }\n    }\n}\n\nextension KeychainError {\n    func toCommonError() -&gt; CommonError {\n        switch self {\n        case .accessDenied(let details):\n            return .permissionDenied(\"Keychain: \\(details)\")\n        case .itemNotFound(let key):\n            return .resourceNotFound(\"Keychain item: \\(key)\")\n        // ... other cases\n        }\n    }\n}\n</code></pre>"},{"location":"archive/guides/error-handling/#3-async-error-handling","title":"3. Async Error Handling","text":"<p>Handle errors in async contexts:</p> <pre><code>actor ErrorHandler {\n    func handle&lt;T&gt;(_ operation: @escaping () async throws -&gt; T) async throws -&gt; T {\n        do {\n            return try await operation()\n        } catch {\n            try await logError(error)\n            try await notifyObservers(of: error)\n            throw error\n        }\n    }\n}\n</code></pre>"},{"location":"archive/guides/error-handling/#integration-with-logging","title":"Integration with Logging","text":""},{"location":"archive/guides/error-handling/#1-error-logging","title":"1. Error Logging","text":"<p>Log errors with context:</p> <pre><code>extension Logger {\n    func logError(\n        _ error: Error,\n        context: ErrorContext,\n        file: String = #file,\n        function: String = #function,\n        line: Int = #line\n    ) {\n        error(\n            \"Error occurred\",\n            metadata: [\n                \"error\": \"\\(error)\",\n                \"context\": \"\\(context)\",\n                \"file\": \"\\(file)\",\n                \"function\": \"\\(function)\",\n                \"line\": \"\\(line)\"\n            ]\n        )\n    }\n}\n</code></pre>"},{"location":"archive/guides/error-handling/#2-error-monitoring","title":"2. Error Monitoring","text":"<p>Track error patterns:</p> <pre><code>actor ErrorMonitor {\n    private var errorCounts: [String: Int] = [:]\n\n    func record(_ error: Error) async {\n        let key = String(describing: type(of: error))\n        errorCounts[key, default: 0] += 1\n\n        if errorCounts[key] ?? 0 &gt; threshold {\n            await notifyHighErrorRate(type: key)\n        }\n    }\n}\n</code></pre>"},{"location":"archive/guides/error-handling/#testing","title":"Testing","text":""},{"location":"archive/guides/error-handling/#1-error-scenarios","title":"1. Error Scenarios","text":"<p>Test error handling paths:</p> <pre><code>func testErrorHandling() async throws {\n    let service = TestService()\n\n    do {\n        try await service.operationThatFails()\n        XCTFail(\"Expected error not thrown\")\n    } catch let error as CommonError {\n        XCTAssertEqual(\n            error.localizedDescription,\n            \"Expected error message\"\n        )\n    }\n}\n</code></pre>"},{"location":"archive/guides/error-handling/#2-recovery-testing","title":"2. Recovery Testing","text":"<p>Test error recovery mechanisms:</p> <pre><code>func testErrorRecovery() async throws {\n    let operation = RetryableOperation()\n\n    // Inject failures\n    operation.injectFailures(count: 2)\n\n    // Should succeed after retries\n    let result = try await operation.execute()\n    XCTAssertNotNil(result)\n}\n</code></pre>"},{"location":"archive/guides/error-handling/#3-error-context-testing","title":"3. Error Context Testing","text":"<p>Verify error context information:</p> <p>```swift func testErrorContext() async throws {     let operation = ContextualOperation()</p> <pre><code>do {\n    try await operation.execute()\n    XCTFail(\"Expected error not thrown\")\n} catch {\n    let context = try XCTUnwrap(error.errorContext)\n    XCTAssertEqual(context.function, \"execute\")\n    XCTAssertNotNil(context.operationId)\n}\n</code></pre> <p>}</p>"},{"location":"archive/guides/keychain/","title":"UmbraKeychainService Guide","text":""},{"location":"archive/guides/keychain/#overview","title":"Overview","text":"<p><code>UmbraKeychainService</code> provides secure credential storage using macOS Keychain. It handles repository passwords, API keys, and other sensitive data.</p>"},{"location":"archive/guides/keychain/#features","title":"Features","text":"<ul> <li>Secure credential storage</li> <li>XPC-based access</li> <li>Thread-safe operations</li> <li>Automatic error handling</li> </ul>"},{"location":"archive/guides/keychain/#basic-usage","title":"Basic Usage","text":""},{"location":"archive/guides/keychain/#storing-credentials","title":"Storing Credentials","text":"<pre><code>let service = try UmbraKeychainService()\n\n// Store a repository password\ntry await service.store(\n    password: \"secret-password\",\n    forKey: \"backup-repository\"\n)\n\n// Store an API key\ntry await service.store(\n    password: \"api-key-12345\",\n    forKey: \"cloud-provider\"\n)\n</code></pre>"},{"location":"archive/guides/keychain/#retrieving-credentials","title":"Retrieving Credentials","text":"<pre><code>// Get repository password\nlet password = try await service.retrieve(forKey: \"backup-repository\")\n\n// Get API key\nlet apiKey = try await service.retrieve(forKey: \"cloud-provider\")\n</code></pre>"},{"location":"archive/guides/keychain/#updating-credentials","title":"Updating Credentials","text":"<pre><code>try await service.update(\n    password: \"new-password\",\n    forKey: \"backup-repository\"\n)\n</code></pre>"},{"location":"archive/guides/keychain/#removing-credentials","title":"Removing Credentials","text":"<pre><code>try await service.remove(forKey: \"backup-repository\")\n</code></pre>"},{"location":"archive/guides/keychain/#error-handling","title":"Error Handling","text":"<pre><code>do {\n    try await service.store(password: \"secret\", forKey: \"key\")\n} catch KeychainError.duplicateItem(let key) {\n    // Handle duplicate item\n} catch KeychainError.accessDenied(let reason) {\n    // Handle access denied\n} catch {\n    // Handle other errors\n}\n</code></pre>"},{"location":"archive/guides/keychain/#best-practices","title":"Best Practices","text":""},{"location":"archive/guides/keychain/#1-key-naming","title":"1. Key Naming","text":"<ul> <li>Use descriptive, consistent keys</li> <li>Include context in key names</li> <li>Follow naming conventions</li> </ul> <pre><code>// Good\n\"backup-repo-main-password\"\n\"aws-access-key-prod\"\n\n// Bad\n\"pwd1\"\n\"key\"\n</code></pre>"},{"location":"archive/guides/keychain/#2-error-recovery","title":"2. Error Recovery","text":"<ul> <li>Implement retry logic</li> <li>Provide user feedback</li> <li>Log failures appropriately</li> </ul>"},{"location":"archive/guides/keychain/#3-security","title":"3. Security","text":"<ul> <li>Never store keys in code</li> <li>Use appropriate access control</li> <li>Clean up unused credentials</li> </ul>"},{"location":"archive/guides/keychain/#advanced-usage","title":"Advanced Usage","text":""},{"location":"archive/guides/keychain/#1-custom-item-attributes","title":"1. Custom Item Attributes","text":"<pre><code>let attributes = KeychainItemAttributes(\n    label: \"Main Backup Repository\",\n    comment: \"Production backup credentials\"\n)\n\ntry await service.store(\n    password: \"secret\",\n    forKey: \"backup-repo\",\n    attributes: attributes\n)\n</code></pre>"},{"location":"archive/guides/keychain/#2-batch-operations","title":"2. Batch Operations","text":"<pre><code>let credentials = [\n    \"repo1\": \"password1\",\n    \"repo2\": \"password2\"\n]\n\ntry await service.storeBatch(credentials)\n</code></pre>"},{"location":"archive/guides/keychain/#3-access-control","title":"3. Access Control","text":"<pre><code>let access = KeychainAccess(\n    accessibility: .whenUnlocked,\n    authentication: .biometric\n)\n\ntry await service.store(\n    password: \"secret\",\n    forKey: \"secure-key\",\n    access: access\n)\n</code></pre>"},{"location":"archive/guides/keychain/#integration-examples","title":"Integration Examples","text":""},{"location":"archive/guides/keychain/#1-repository-setup","title":"1. Repository Setup","text":"<pre><code>func setupRepository() async throws {\n    let service = try UmbraKeychainService()\n\n    // Store repository password\n    try await service.store(\n        password: repositoryPassword,\n        forKey: \"repo-\\(repoId)\"\n    )\n\n    // Store cloud credentials if needed\n    if let cloudKey = cloudCredentials {\n        try await service.store(\n            password: cloudKey,\n            forKey: \"cloud-\\(repoId)\"\n        )\n    }\n}\n</code></pre>"},{"location":"archive/guides/keychain/#2-credential-management","title":"2. Credential Management","text":"<pre><code>class CredentialManager {\n    private let keychain: UmbraKeychainService\n\n    init() throws {\n        keychain = try UmbraKeychainService()\n    }\n\n    func rotateCredentials() async throws {\n        let newPassword = generateSecurePassword()\n\n        try await keychain.update(\n            password: newPassword,\n            forKey: \"repo-main\"\n        )\n\n        try await updateRemoteRepository(password: newPassword)\n    }\n}\n</code></pre>"},{"location":"archive/guides/keychain/#troubleshooting","title":"Troubleshooting","text":""},{"location":"archive/guides/keychain/#common-issues","title":"Common Issues","text":"<ol> <li> <p>Access Denied <pre><code>// Check keychain access\ntry await service.checkAccess()\n\n// Request user permission if needed\ntry await service.requestAccess()\n</code></pre></p> </li> <li> <p>Duplicate Items <pre><code>// Update instead of store for existing items\nif await service.exists(forKey: key) {\n    try await service.update(password: newPassword, forKey: key)\n} else {\n    try await service.store(password: newPassword, forKey: key)\n}\n</code></pre></p> </li> <li> <p>Item Not Found <pre><code>// Implement fallback logic\nfunc getCredential(forKey key: String) async throws -&gt; String {\n    do {\n        return try await service.retrieve(forKey: key)\n    } catch KeychainError.itemNotFound {\n        // Implement recovery logic\n        return try await recoverCredential(forKey: key)\n    }\n}\n</code></pre></p> </li> </ol>"},{"location":"archive/guides/logging/","title":"UmbraLogging Guide","text":""},{"location":"archive/guides/logging/#overview","title":"Overview","text":"<p><code>UmbraLogging</code> provides a centralised, structured logging system built on SwiftyBeaver. It supports multiple destinations, log levels, and contextual metadata.</p>"},{"location":"archive/guides/logging/#features","title":"Features","text":"<ul> <li>Structured logging</li> <li>Multiple log levels</li> <li>Context metadata</li> <li>File output</li> <li>Console output</li> <li>Custom formatters</li> </ul>"},{"location":"archive/guides/logging/#basic-usage","title":"Basic Usage","text":""},{"location":"archive/guides/logging/#configuration","title":"Configuration","text":"<pre><code>import UmbraLogging\n\n// Basic setup\nUmbraLogger.configure(level: .info)\n\n// Custom configuration\nlet config = LoggerConfiguration(\n    level: .debug,\n    destinations: [.console, .file],\n    metadata: [\"app\": \"UmbraCore\"]\n)\nUmbraLogger.configure(config)\n</code></pre>"},{"location":"archive/guides/logging/#logging-messages","title":"Logging Messages","text":"<pre><code>// Basic logging\nlogger.info(\"Backup started\")\nlogger.error(\"Failed to access repository\")\n\n// With metadata\nlogger.info(\"File processed\", metadata: [\n    \"size\": fileSize,\n    \"path\": filePath\n])\n\n// With error context\nlogger.error(\"Backup failed\", error: error, metadata: [\n    \"repository\": repoId,\n    \"files\": fileCount\n])\n</code></pre>"},{"location":"archive/guides/logging/#log-levels","title":"Log Levels","text":""},{"location":"archive/guides/logging/#available-levels","title":"Available Levels","text":"<pre><code>// Verbose - detailed information\nlogger.verbose(\"Entering backup loop\")\n\n// Debug - debugging information\nlogger.debug(\"Processing file: \\(filename)\")\n\n// Info - general information\nlogger.info(\"Backup completed successfully\")\n\n// Warning - potential issues\nlogger.warning(\"Repository space low\")\n\n// Error - operation failures\nlogger.error(\"Failed to store credential\")\n\n// Critical - system-wide issues\nlogger.critical(\"Database corruption detected\")\n</code></pre>"},{"location":"archive/guides/logging/#best-practices","title":"Best Practices","text":""},{"location":"archive/guides/logging/#1-log-level-selection","title":"1. Log Level Selection","text":"<pre><code>// Development\n#if DEBUG\n    UmbraLogger.configure(level: .debug)\n#else\n    UmbraLogger.configure(level: .info)\n#endif\n\n// Production with environment override\nif let levelString = Environment.logLevel {\n    UmbraLogger.configure(level: LogLevel(string: levelString))\n}\n</code></pre>"},{"location":"archive/guides/logging/#2-contextual-information","title":"2. Contextual Information","text":"<pre><code>// Add operation context\nlogger.info(\"Starting backup\", metadata: [\n    \"operation\": \"backup\",\n    \"type\": \"incremental\",\n    \"source\": sourcePath,\n    \"destination\": destPath\n])\n\n// Add error context\nlogger.error(\"Operation failed\", metadata: [\n    \"operation\": operation.name,\n    \"duration\": duration,\n    \"retries\": retryCount,\n    \"error\": error.localizedDescription\n])\n</code></pre>"},{"location":"archive/guides/logging/#3-sensitive-data","title":"3. Sensitive Data","text":"<pre><code>// Never log credentials\nlogger.info(\"Connecting to repository\", metadata: [\n    \"url\": repository.url,\n    \"type\": repository.type\n    // DON'T include passwords or keys\n])\n\n// Mask sensitive data\nlogger.info(\"User authenticated\", metadata: [\n    \"user\": user.id,\n    \"token\": \"****\" // Masked token\n])\n</code></pre>"},{"location":"archive/guides/logging/#advanced-usage","title":"Advanced Usage","text":""},{"location":"archive/guides/logging/#1-custom-destinations","title":"1. Custom Destinations","text":"<pre><code>let customDestination = LogDestination(\n    identifier: \"analytics\",\n    minimumLevel: .info,\n    formatter: AnalyticsFormatter()\n)\n\nUmbraLogger.addDestination(customDestination)\n</code></pre>"},{"location":"archive/guides/logging/#2-custom-formatters","title":"2. Custom Formatters","text":"<pre><code>class JSONFormatter: LogFormatter {\n    func format(_ entry: LogEntry) -&gt; String {\n        let json: [String: Any] = [\n            \"timestamp\": entry.timestamp,\n            \"level\": entry.level.rawValue,\n            \"message\": entry.message,\n            \"metadata\": entry.metadata\n        ]\n        return try! JSONSerialization.data(withJSONObject: json)\n    }\n}\n</code></pre>"},{"location":"archive/guides/logging/#3-context-managers","title":"3. Context Managers","text":"<pre><code>class OperationContext {\n    private var metadata: [String: Any]\n\n    func execute(_ operation: String) async throws {\n        logger.withMetadata(metadata) {\n            logger.info(\"Starting operation\")\n            // Execute operation\n            logger.info(\"Operation completed\")\n        }\n    }\n}\n</code></pre>"},{"location":"archive/guides/logging/#integration-examples","title":"Integration Examples","text":""},{"location":"archive/guides/logging/#1-service-integration","title":"1. Service Integration","text":"<pre><code>class BackupService {\n    private let logger = UmbraLogger.forModule(\"BackupService\")\n\n    func performBackup() async throws {\n        logger.info(\"Starting backup\", metadata: [\n            \"type\": backupType,\n            \"files\": fileCount\n        ])\n\n        do {\n            try await runBackup()\n            logger.info(\"Backup completed\")\n        } catch {\n            logger.error(\"Backup failed\", error: error)\n            throw error\n        }\n    }\n}\n</code></pre>"},{"location":"archive/guides/logging/#2-error-tracking","title":"2. Error Tracking","text":"<pre><code>class ErrorTracker {\n    private let logger = UmbraLogger.forModule(\"ErrorTracker\")\n\n    func track(_ error: Error, context: [String: Any]) {\n        logger.error(\"Error occurred\", metadata: [\n            \"error\": error.localizedDescription,\n            \"type\": String(describing: type(of: error)),\n            \"context\": context\n        ])\n    }\n}\n</code></pre>"},{"location":"archive/guides/logging/#troubleshooting","title":"Troubleshooting","text":""},{"location":"archive/guides/logging/#common-issues","title":"Common Issues","text":"<ol> <li> <p>Log File Management <pre><code>// Rotate log files\nUmbraLogger.configure(\n    fileConfig: FileConfiguration(\n        directory: logDirectory,\n        maxFileSize: 10_000_000,  // 10MB\n        maxFileCount: 5\n    )\n)\n</code></pre></p> </li> <li> <p>Performance Optimization <pre><code>// Avoid expensive logging in production\nif logger.isEnabled(for: .debug) {\n    let expensive = calculateExpensiveMetadata()\n    logger.debug(\"Details\", metadata: expensive)\n}\n</code></pre></p> </li> <li> <p>Error Investigation <pre><code>// Enable full debug logging temporarily\nUmbraLogger.configure(\n    level: .verbose,\n    destinations: [.console, .file],\n    metadata: [\"debug\": true]\n)\n</code></pre></p> </li> </ol>"},{"location":"archive/guides/performance/","title":"Performance Optimisation in UmbraCore","text":""},{"location":"archive/guides/performance/#overview","title":"Overview","text":"<p>Performance is crucial for backup operations. This guide covers performance optimisation techniques used in UmbraCore and best practices for maintaining high performance.</p>"},{"location":"archive/guides/performance/#core-principles","title":"Core Principles","text":""},{"location":"archive/guides/performance/#1-asynchronous-operations","title":"1. Asynchronous Operations","text":"<p>Leverage Swift's async/await for non-blocking operations:</p> <pre><code>actor BackupCoordinator {\n    func backupMultipleDirectories(_ paths: [String]) async throws {\n        try await withThrowingTaskGroup(of: Void.self) { group in\n            for path in paths {\n                group.addTask {\n                    try await backupDirectory(path)\n                }\n            }\n            try await group.waitForAll()\n        }\n    }\n}\n</code></pre>"},{"location":"archive/guides/performance/#2-memory-management","title":"2. Memory Management","text":"<p>Efficient memory usage patterns:</p> <pre><code>actor StreamProcessor {\n    // Use streams for large data\n    func processLargeFile(_ url: URL) async throws {\n        for try await line in url.lines {\n            try await processLine(line)\n        }\n    }\n\n    // Batch small operations\n    func processBatch(_ items: [Item]) async throws {\n        let batchSize = 100\n        for batch in items.chunked(into: batchSize) {\n            try await processBatchItems(batch)\n        }\n    }\n}\n</code></pre>"},{"location":"archive/guides/performance/#3-resource-pooling","title":"3. Resource Pooling","text":"<p>Pool and reuse expensive resources:</p> <pre><code>actor ConnectionPool {\n    private var connections: [Connection] = []\n    private let maxConnections = 10\n\n    func acquire() async throws -&gt; Connection {\n        if let connection = connections.popLast() {\n            return connection\n        }\n\n        guard connections.count &lt; maxConnections else {\n            throw PoolError.maxConnectionsReached\n        }\n\n        return try await createConnection()\n    }\n\n    func release(_ connection: Connection) async {\n        if connections.count &lt; maxConnections {\n            connections.append(connection)\n        } else {\n            await connection.close()\n        }\n    }\n}\n</code></pre>"},{"location":"archive/guides/performance/#optimisation-techniques","title":"Optimisation Techniques","text":""},{"location":"archive/guides/performance/#1-caching","title":"1. Caching","text":"<p>Implement efficient caching strategies:</p> <pre><code>actor CacheManager {\n    private var cache = NSCache&lt;NSString, AnyObject&gt;()\n    private let fileManager = FileManager.default\n\n    func cachedValue(\n        forKey key: String,\n        generator: () async throws -&gt; Any\n    ) async throws -&gt; Any {\n        // Check memory cache\n        if let cached = cache.object(forKey: key as NSString) {\n            return cached\n        }\n\n        // Generate new value\n        let value = try await generator()\n        cache.setObject(value as AnyObject, forKey: key as NSString)\n        return value\n    }\n\n    func clearStaleEntries() async {\n        // Implement cache eviction policy\n    }\n}\n</code></pre>"},{"location":"archive/guides/performance/#2-data-structures","title":"2. Data Structures","text":"<p>Choose appropriate data structures:</p> <pre><code>struct PerformanceOptimised {\n    // Use Set for fast lookups\n    private var processedItems: Set&lt;String&gt; = []\n\n    // Use Dictionary for O(1) access\n    private var itemCache: [String: Item] = [:]\n\n    // Use Array for ordered data\n    private var processingQueue: [Item] = []\n\n    // Use ContiguousArray for better performance with value types\n    private var metrics: ContiguousArray&lt;Double&gt; = []\n}\n</code></pre>"},{"location":"archive/guides/performance/#3-lazy-loading","title":"3. Lazy Loading","text":"<p>Defer expensive operations:</p> <pre><code>class LazyResource {\n    private lazy var expensiveResource: Resource = {\n        createExpensiveResource()\n    }()\n\n    private func createExpensiveResource() -&gt; Resource {\n        // Only created when first accessed\n        Resource(configuration: loadConfiguration())\n    }\n}\n</code></pre>"},{"location":"archive/guides/performance/#performance-monitoring","title":"Performance Monitoring","text":""},{"location":"archive/guides/performance/#1-metrics-collection","title":"1. Metrics Collection","text":"<p>Track performance metrics:</p> <pre><code>actor PerformanceMonitor {\n    private var metrics: [String: [TimeInterval]] = [:]\n\n    func measure&lt;T&gt;(\n        operation: String,\n        block: () async throws -&gt; T\n    ) async throws -&gt; T {\n        let start = ProcessInfo.processInfo.systemUptime\n        let result = try await block()\n        let duration = ProcessInfo.processInfo.systemUptime - start\n\n        await record(operation: operation, duration: duration)\n        return result\n    }\n\n    private func record(operation: String, duration: TimeInterval) {\n        metrics[operation, default: []].append(duration)\n\n        if metrics[operation]?.count ?? 0 &gt; 1000 {\n            metrics[operation]?.removeFirst(500)\n        }\n    }\n\n    func getMetrics(for operation: String) -&gt; PerformanceMetrics {\n        guard let measurements = metrics[operation] else {\n            return PerformanceMetrics.empty\n        }\n\n        return PerformanceMetrics(\n            average: measurements.average,\n            median: measurements.median,\n            percentile95: measurements.percentile(95),\n            count: measurements.count\n        )\n    }\n}\n</code></pre>"},{"location":"archive/guides/performance/#2-performance-logging","title":"2. Performance Logging","text":"<p>Log performance data:</p> <pre><code>extension Logger {\n    func logPerformance(\n        _ metrics: PerformanceMetrics,\n        operation: String,\n        file: String = #file,\n        function: String = #function\n    ) {\n        info(\n            \"Performance metrics\",\n            metadata: [\n                \"operation\": \"\\(operation)\",\n                \"average\": \"\\(metrics.average)\",\n                \"median\": \"\\(metrics.median)\",\n                \"p95\": \"\\(metrics.percentile95)\",\n                \"count\": \"\\(metrics.count)\",\n                \"file\": \"\\(file)\",\n                \"function\": \"\\(function)\"\n            ]\n        )\n    }\n}\n</code></pre>"},{"location":"archive/guides/performance/#3-alerts-and-thresholds","title":"3. Alerts and Thresholds","text":"<p>Monitor performance thresholds:</p> <pre><code>actor PerformanceAlert {\n    private let thresholds: [String: TimeInterval]\n    private let notifier: AlertNotifier\n\n    func checkThresholds(_ metrics: PerformanceMetrics, operation: String) async {\n        guard let threshold = thresholds[operation] else { return }\n\n        if metrics.percentile95 &gt; threshold {\n            await notifier.alert(\n                \"\"\"\n                Performance degradation detected:\n                Operation: \\(operation)\n                P95: \\(metrics.percentile95)\n                Threshold: \\(threshold)\n                \"\"\"\n            )\n        }\n    }\n}\n</code></pre>"},{"location":"archive/guides/performance/#best-practices","title":"Best Practices","text":""},{"location":"archive/guides/performance/#1-batch-processing","title":"1. Batch Processing","text":"<p>Batch operations for efficiency:</p> <pre><code>actor BatchProcessor {\n    private let batchSize = 100\n\n    func process(_ items: [Item]) async throws {\n        let batches = items.chunked(into: batchSize)\n\n        try await withThrowingTaskGroup(of: Void.self) { group in\n            for batch in batches {\n                group.addTask {\n                    try await processBatch(batch)\n                }\n            }\n            try await group.waitForAll()\n        }\n    }\n}\n</code></pre>"},{"location":"archive/guides/performance/#2-resource-management","title":"2. Resource Management","text":"<p>Proper resource cleanup:</p> <pre><code>class ManagedResource {\n    private var resources: [Resource] = []\n\n    func use&lt;T&gt;(_ resource: Resource, operation: (Resource) throws -&gt; T) throws -&gt; T {\n        resources.append(resource)\n        defer {\n            resource.cleanup()\n            resources.removeAll { $0 === resource }\n        }\n        return try operation(resource)\n    }\n}\n</code></pre>"},{"location":"archive/guides/performance/#3-background-processing","title":"3. Background Processing","text":"<p>Offload heavy work:</p> <pre><code>actor BackgroundProcessor {\n    private let queue = DispatchQueue(\n        label: \"com.umbracore.background\",\n        qos: .background\n    )\n\n    func processInBackground(_ work: @escaping () -&gt; Void) {\n        queue.async {\n            work()\n        }\n    }\n}\n</code></pre>"},{"location":"archive/guides/performance/#testing","title":"Testing","text":""},{"location":"archive/guides/performance/#1-performance-tests","title":"1. Performance Tests","text":"<p>Test performance metrics:</p> <pre><code>class PerformanceTests: XCTestCase {\n    func testOperationPerformance() throws {\n        measure {\n            // Performance-critical code\n        }\n    }\n\n    func testAsyncPerformance() async throws {\n        let metrics = try await measureAsync {\n            try await performOperation()\n        }\n\n        XCTAssertLessThan(metrics.average, 0.1)\n        XCTAssertLessThan(metrics.percentile95, 0.2)\n    }\n}\n</code></pre>"},{"location":"archive/guides/performance/#2-memory-tests","title":"2. Memory Tests","text":"<p>Test memory usage:</p> <pre><code>class MemoryTests: XCTestCase {\n    func testMemoryUsage() throws {\n        let tracker = MemoryTracker()\n\n        autoreleasepool {\n            // Memory-intensive operation\n        }\n\n        XCTAssertLessThan(\n            tracker.peakMemoryUsage,\n            50 * 1024 * 1024 // 50MB\n        )\n    }\n}\n</code></pre>"},{"location":"archive/guides/performance/#3-load-tests","title":"3. Load Tests","text":"<p>Test under load:</p> <p>```swift class LoadTests: XCTestCase {     func testConcurrentOperations() async throws {         let operations = 1000         let service = TestService()</p> <pre><code>    try await withThrowingTaskGroup(of: Void.self) { group in\n        for _ in 0..&lt;operations {\n            group.addTask {\n                try await service.operation()\n            }\n        }\n        try await group.waitForAll()\n    }\n}\n</code></pre> <p>}</p>"},{"location":"archive/guides/security/","title":"Security Guidelines","text":"<p>This guide outlines security best practices for using UmbraCore.</p>"},{"location":"archive/guides/security/#core-principles","title":"Core Principles","text":"<ol> <li>Least Privilege: Only request necessary permissions</li> <li>Data Protection: Secure all sensitive data</li> <li>Secure Communication: Use encrypted channels</li> <li>Audit Logging: Track security-relevant events</li> </ol>"},{"location":"archive/guides/security/#secure-storage","title":"Secure Storage","text":""},{"location":"archive/guides/security/#password-storage","title":"Password Storage","text":"<ul> <li>Use <code>SecureString</code> for passwords</li> <li>Implement proper password policies</li> <li>Use secure key derivation</li> </ul>"},{"location":"archive/guides/security/#repository-encryption","title":"Repository Encryption","text":"<ul> <li>Use strong encryption keys</li> <li>Implement key rotation</li> <li>Secure key storage</li> </ul>"},{"location":"archive/guides/security/#network-security","title":"Network Security","text":""},{"location":"archive/guides/security/#remote-repositories","title":"Remote Repositories","text":"<ul> <li>Use SSH or HTTPS</li> <li>Validate certificates</li> <li>Implement rate limiting</li> <li>Handle network errors securely</li> </ul>"},{"location":"archive/guides/security/#api-security","title":"API Security","text":"<ul> <li>Use API tokens securely</li> <li>Implement request signing</li> <li>Validate all inputs</li> </ul>"},{"location":"archive/guides/security/#error-handling","title":"Error Handling","text":""},{"location":"archive/guides/security/#security-errors","title":"Security Errors","text":"<ul> <li>Log security events</li> <li>Don't expose sensitive data</li> <li>Implement proper error recovery</li> </ul>"},{"location":"archive/guides/security/#access-control","title":"Access Control","text":"<ul> <li>Validate permissions</li> <li>Check file access rights</li> <li>Handle access denied errors</li> </ul>"},{"location":"archive/guides/security/#best-practices","title":"Best Practices","text":"<ol> <li>Keep dependencies updated</li> <li>Regular security audits</li> <li>Follow cryptographic best practices</li> <li>Implement proper logging</li> <li>Regular penetration testing</li> </ol>"},{"location":"archive/guides/thread-safety/","title":"Thread Safety in UmbraCore","text":""},{"location":"archive/guides/thread-safety/#overview","title":"Overview","text":"<p>UmbraCore is designed to be thread-safe by default. All public APIs can be safely called from multiple threads concurrently. This guide explains our thread safety guarantees and best practices.</p>"},{"location":"archive/guides/thread-safety/#core-principles","title":"Core Principles","text":""},{"location":"archive/guides/thread-safety/#1-actor-based-services","title":"1. Actor-Based Services","text":"<p>All core services in UmbraCore use Swift's actor system to ensure thread safety:</p> <pre><code>actor KeychainService {\n    private var cache: [String: Data] = [:]\n\n    func store(_ data: Data, forKey key: String) async throws {\n        // Thread-safe access to cache\n        cache[key] = data\n        try await persistToKeychain(data, key)\n    }\n}\n</code></pre>"},{"location":"archive/guides/thread-safety/#2-immutable-state","title":"2. Immutable State","text":"<p>We prefer immutable state to minimize synchronization needs:</p> <pre><code>struct BackupConfig {\n    // Immutable properties\n    let sourcePath: String\n    let destinationPath: String\n    let excludePatterns: [String]\n\n    // Instead of mutating, create new instance\n    func withExcludePattern(_ pattern: String) -&gt; BackupConfig {\n        var patterns = excludePatterns\n        patterns.append(pattern)\n        return BackupConfig(\n            sourcePath: sourcePath,\n            destinationPath: destinationPath,\n            excludePatterns: patterns\n        )\n    }\n}\n</code></pre>"},{"location":"archive/guides/thread-safety/#3-synchronized-collections","title":"3. Synchronized Collections","text":"<p>When mutable state is necessary, we use synchronized collections:</p> <pre><code>actor CacheManager {\n    private var cache = [String: Any]()\n    private let queue = DispatchQueue(label: \"com.umbracore.cache\")\n\n    func set(_ value: Any, forKey key: String) {\n        queue.sync { cache[key] = value }\n    }\n\n    func get(_ key: String) -&gt; Any? {\n        queue.sync { cache[key] }\n    }\n}\n</code></pre>"},{"location":"archive/guides/thread-safety/#best-practices","title":"Best Practices","text":""},{"location":"archive/guides/thread-safety/#1-asyncawait-usage","title":"1. Async/Await Usage","text":"<p>Always use async/await for asynchronous operations:</p> <pre><code>// Good\nfunc backupFiles() async throws {\n    try await prepareBackup()\n    try await performBackup()\n    try await cleanup()\n}\n\n// Avoid\nfunc backupFiles(completion: @escaping (Error?) -&gt; Void) {\n    prepareBackup { error in\n        guard error == nil else {\n            completion(error)\n            return\n        }\n        // Callback hell continues...\n    }\n}\n</code></pre>"},{"location":"archive/guides/thread-safety/#2-resource-access","title":"2. Resource Access","text":"<p>Use proper resource access patterns:</p> <pre><code>actor ResourceManager {\n    private var isLocked = false\n\n    func acquireResource() async throws {\n        guard !isLocked else {\n            throw ResourceError.alreadyLocked\n        }\n        isLocked = true\n    }\n\n    func releaseResource() {\n        isLocked = false\n    }\n}\n</code></pre>"},{"location":"archive/guides/thread-safety/#3-shared-state","title":"3. Shared State","text":"<p>Minimize shared state, use message passing:</p> <pre><code>actor BackupCoordinator {\n    private var activeBackups: Set&lt;UUID&gt; = []\n\n    func startBackup() async throws -&gt; UUID {\n        let id = UUID()\n        activeBackups.insert(id)\n        return id\n    }\n\n    func completeBackup(_ id: UUID) {\n        activeBackups.remove(id)\n    }\n}\n</code></pre>"},{"location":"archive/guides/thread-safety/#common-patterns","title":"Common Patterns","text":""},{"location":"archive/guides/thread-safety/#1-double-checked-locking","title":"1. Double-Checked Locking","text":"<p>For expensive initialization:</p> <pre><code>actor ConfigurationManager {\n    private var config: Configuration?\n\n    func getConfiguration() async throws -&gt; Configuration {\n        if let existing = config {\n            return existing\n        }\n\n        let loaded = try await loadConfiguration()\n        config = loaded\n        return loaded\n    }\n}\n</code></pre>"},{"location":"archive/guides/thread-safety/#2-reader-writer-pattern","title":"2. Reader-Writer Pattern","text":"<p>For concurrent read access:</p> <pre><code>actor DatabaseManager {\n    private var isWriting = false\n    private var activeReaders = 0\n\n    func read() async throws -&gt; Data {\n        while isWriting {\n            try await Task.sleep(nanoseconds: 100_000)\n        }\n        activeReaders += 1\n        defer { activeReaders -= 1 }\n        return try getData()\n    }\n\n    func write(_ data: Data) async throws {\n        while activeReaders &gt; 0 {\n            try await Task.sleep(nanoseconds: 100_000)\n        }\n        isWriting = true\n        defer { isWriting = false }\n        try await writeData(data)\n    }\n}\n</code></pre>"},{"location":"archive/guides/thread-safety/#3-task-management","title":"3. Task Management","text":"<p>For concurrent operations:</p> <pre><code>class BackupTask {\n    func executeParallel(_ operations: [Operation]) async throws {\n        try await withThrowingTaskGroup(of: Void.self) { group in\n            for operation in operations {\n                group.addTask {\n                    try await operation.execute()\n                }\n            }\n            try await group.waitForAll()\n        }\n    }\n}\n</code></pre>"},{"location":"archive/guides/thread-safety/#troubleshooting","title":"Troubleshooting","text":""},{"location":"archive/guides/thread-safety/#1-deadlock-prevention","title":"1. Deadlock Prevention","text":"<pre><code>actor Service {\n    // Avoid nested actor calls\n    func operation1() async {\n        await operation2() // Could deadlock if not careful\n    }\n\n    func operation2() async {\n        // Implementation\n    }\n}\n\n// Better approach\nactor Service {\n    func operation1() async {\n        // Execute independently\n        try await Task.sleep(nanoseconds: 100_000)\n        await operation2()\n    }\n}\n</code></pre>"},{"location":"archive/guides/thread-safety/#2-race-condition-detection","title":"2. Race Condition Detection","text":"<pre><code>actor StateManager {\n    private var state: State\n    private var version: UInt64 = 0\n\n    func modify(_ change: (State) -&gt; State) async {\n        let currentVersion = version\n        state = change(state)\n\n        // Detect concurrent modifications\n        guard version == currentVersion else {\n            throw ConcurrencyError.stateModified\n        }\n        version += 1\n    }\n}\n</code></pre>"},{"location":"archive/guides/thread-safety/#3-performance-issues","title":"3. Performance Issues","text":"<pre><code>actor PerformanceOptimized {\n    // Batch operations to reduce actor hops\n    func batchOperation(_ items: [Item]) async {\n        // Single actor hop for batch\n        items.forEach { process($0) }\n    }\n\n    // Avoid frequent actor hops\n    private func process(_ item: Item) {\n        // Local processing\n    }\n}\n</code></pre>"},{"location":"archive/guides/thread-safety/#testing","title":"Testing","text":""},{"location":"archive/guides/thread-safety/#1-concurrency-testing","title":"1. Concurrency Testing","text":"<pre><code>func testConcurrentAccess() async throws {\n    let service = SharedService()\n\n    try await withThrowingTaskGroup(of: Void.self) { group in\n        for _ in 0..&lt;100 {\n            group.addTask {\n                try await service.operation()\n            }\n        }\n        try await group.waitForAll()\n    }\n}\n</code></pre>"},{"location":"archive/guides/thread-safety/#2-race-condition-testing","title":"2. Race Condition Testing","text":"<p>```swift func testRaceConditions() async throws {     let service = SharedService()</p> <pre><code>async let operation1 = service.modify()\nasync let operation2 = service.modify()\n\n// This should handle concurrent modifications gracefully\ntry await [operation1, operation2]\n</code></pre> <p>}</p>"},{"location":"archive/guides/xpc/","title":"UmbraXPC Guide","text":""},{"location":"archive/guides/xpc/#overview","title":"Overview","text":"<p><code>UmbraXPC</code> provides a secure inter-process communication layer for UmbraCore services. It enables privilege separation and sandboxing while maintaining type safety and async/await support.</p>"},{"location":"archive/guides/xpc/#features","title":"Features","text":"<ul> <li>Secure IPC communication</li> <li>Type-safe protocols</li> <li>Async/await support</li> <li>Error handling</li> <li>Privilege separation</li> </ul>"},{"location":"archive/guides/xpc/#basic-usage","title":"Basic Usage","text":""},{"location":"archive/guides/xpc/#service-definition","title":"Service Definition","text":"<pre><code>// Define XPC protocol\n@objc protocol KeychainXPCProtocol {\n    func store(password: String, forKey: String) async throws\n    func retrieve(forKey: String) async throws -&gt; String\n    func remove(forKey: String) async throws\n}\n\n// Implement service\nclass KeychainXPCService: NSObject, KeychainXPCProtocol {\n    func store(password: String, forKey: String) async throws {\n        // Implementation\n    }\n\n    // Other implementations...\n}\n</code></pre>"},{"location":"archive/guides/xpc/#service-registration","title":"Service Registration","text":"<pre><code>// Register service\nlet service = XPCService(\n    service: KeychainXPCService(),\n    protocol: KeychainXPCProtocol.self\n)\n\ntry await service.register()\n</code></pre>"},{"location":"archive/guides/xpc/#client-usage","title":"Client Usage","text":"<pre><code>// Connect to service\nlet client = try XPCClient&lt;KeychainXPCProtocol&gt;()\n\n// Use service\ntry await client.store(password: \"secret\", forKey: \"key\")\nlet value = try await client.retrieve(forKey: \"key\")\n</code></pre>"},{"location":"archive/guides/xpc/#error-handling","title":"Error Handling","text":"<pre><code>do {\n    try await client.store(password: \"secret\", forKey: \"key\")\n} catch XPCError.connectionFailed {\n    // Handle connection failure\n} catch XPCError.serviceStopped {\n    // Handle service stop\n} catch {\n    // Handle other errors\n}\n</code></pre>"},{"location":"archive/guides/xpc/#best-practices","title":"Best Practices","text":""},{"location":"archive/guides/xpc/#1-protocol-design","title":"1. Protocol Design","text":"<pre><code>// Good protocol design\n@objc protocol BackupXPCProtocol {\n    // Clear operation names\n    func startBackup(source: URL, destination: URL) async throws\n\n    // Specific error types\n    func checkAccess(path: String) async throws -&gt; Bool\n\n    // Progress reporting\n    func getProgress() async throws -&gt; Double\n}\n</code></pre>"},{"location":"archive/guides/xpc/#2-error-handling","title":"2. Error Handling","text":"<pre><code>// Define specific errors\nenum BackupXPCError: Error {\n    case accessDenied(String)\n    case insufficientSpace(needed: UInt64, available: UInt64)\n    case connectionLost\n}\n\n// Handle errors appropriately\ndo {\n    try await service.startBackup(source: src, destination: dest)\n} catch BackupXPCError.accessDenied(let path) {\n    // Handle access denied\n} catch BackupXPCError.insufficientSpace(let needed, let available) {\n    // Handle space issues\n}\n</code></pre>"},{"location":"archive/guides/xpc/#3-resource-management","title":"3. Resource Management","text":"<pre><code>// Proper cleanup\nclass XPCManager {\n    private var client: XPCClient&lt;BackupXPCProtocol&gt;?\n\n    func shutdown() async {\n        await client?.disconnect()\n        client = nil\n    }\n}\n</code></pre>"},{"location":"archive/guides/xpc/#advanced-usage","title":"Advanced Usage","text":""},{"location":"archive/guides/xpc/#1-custom-message-handling","title":"1. Custom Message Handling","text":"<pre><code>class CustomXPCService: XPCServiceDelegate {\n    func handleCustomMessage(_ message: [String: Any]) async throws -&gt; Any {\n        // Custom message handling\n        switch message[\"type\"] as? String {\n        case \"status\":\n            return await getStatus()\n        case \"control\":\n            return try await handleControl(message)\n        default:\n            throw XPCError.invalidMessage\n        }\n    }\n}\n</code></pre>"},{"location":"archive/guides/xpc/#2-progress-reporting","title":"2. Progress Reporting","text":"<pre><code>protocol ProgressReporting {\n    func reportProgress(_ progress: Double) async\n}\n\nclass BackupXPCService: ProgressReporting {\n    private var progress: Double = 0\n\n    func reportProgress(_ progress: Double) async {\n        self.progress = progress\n        await notifyObservers()\n    }\n}\n</code></pre>"},{"location":"archive/guides/xpc/#3-connection-management","title":"3. Connection Management","text":"<pre><code>class XPCConnectionManager {\n    private var connections: [String: XPCClient&lt;Any&gt;] = [:]\n\n    func getConnection&lt;T&gt;(_ type: T.Type) async throws -&gt; XPCClient&lt;T&gt; {\n        let id = String(describing: type)\n\n        if let existing = connections[id] as? XPCClient&lt;T&gt; {\n            return existing\n        }\n\n        let new = try XPCClient&lt;T&gt;()\n        connections[id] = new\n        return new\n    }\n}\n</code></pre>"},{"location":"archive/guides/xpc/#integration-examples","title":"Integration Examples","text":""},{"location":"archive/guides/xpc/#1-backup-service","title":"1. Backup Service","text":"<pre><code>class BackupManager {\n    private let xpc: XPCClient&lt;BackupXPCProtocol&gt;\n\n    func startBackup() async throws {\n        // Connect to XPC service\n        try await xpc.connect()\n\n        // Start backup operation\n        try await xpc.startBackup(\n            source: sourceURL,\n            destination: destURL\n        )\n\n        // Monitor progress\n        for await progress in xpc.progressUpdates() {\n            updateUI(progress)\n        }\n    }\n}\n</code></pre>"},{"location":"archive/guides/xpc/#2-security-service","title":"2. Security Service","text":"<pre><code>class SecurityManager {\n    private let xpc: XPCClient&lt;SecurityXPCProtocol&gt;\n\n    func validateAccess() async throws -&gt; Bool {\n        try await xpc.withConnection { service in\n            try await service.checkSecurity([\n                \"operation\": \"backup\",\n                \"level\": \"system\"\n            ])\n        }\n    }\n}\n</code></pre>"},{"location":"archive/guides/xpc/#troubleshooting","title":"Troubleshooting","text":""},{"location":"archive/guides/xpc/#common-issues","title":"Common Issues","text":"<ol> <li> <p>Connection Issues <pre><code>// Implement retry logic\nfunc connectWithRetry() async throws -&gt; XPCClient&lt;T&gt; {\n    var attempts = 0\n    while attempts &lt; 3 {\n        do {\n            return try await XPCClient&lt;T&gt;().connect()\n        } catch {\n            attempts += 1\n            try await Task.sleep(nanoseconds: 1_000_000_000)\n        }\n    }\n    throw XPCError.connectionFailed\n}\n</code></pre></p> </li> <li> <p>Service Recovery <pre><code>// Handle service interruption\nfunc handleServiceFailure() async throws {\n    try await xpc.disconnect()\n    try await Task.sleep(nanoseconds: 1_000_000_000)\n    try await xpc.connect()\n}\n</code></pre></p> </li> <li> <p>Resource Cleanup <pre><code>// Proper resource management\nclass XPCResource {\n    private var resources: Set&lt;XPCClient&lt;Any&gt;&gt; = []\n\n    func cleanup() async {\n        for resource in resources {\n            await resource.disconnect()\n        }\n        resources.removeAll()\n    }\n}\n</code></pre></p> </li> </ol>"},{"location":"archive/security/SECURITY_GUIDELINES/","title":"Security Guidelines","text":""},{"location":"archive/security/SECURITY_GUIDELINES/#overview","title":"Overview","text":"<p>UmbraCore handles sensitive data and requires careful attention to security. This guide outlines our security practices and requirements.</p>"},{"location":"archive/security/SECURITY_GUIDELINES/#secure-storage","title":"Secure Storage","text":""},{"location":"archive/security/SECURITY_GUIDELINES/#1-credentials","title":"1. Credentials","text":"<ul> <li>Always use <code>UmbraKeychainService</code> for storing:</li> <li>Repository passwords</li> <li>API keys</li> <li>Access tokens</li> <li>SSH keys</li> </ul> <pre><code>// DO THIS:\ntry await keychainService.store(password: \"secret\", forKey: \"repo-key\")\n\n// DON'T DO THIS:\nUserDefaults.standard.set(\"secret\", forKey: \"repo-key\") // UNSAFE!\n</code></pre>"},{"location":"archive/security/SECURITY_GUIDELINES/#2-file-system-access","title":"2. File System Access","text":"<ul> <li>Use <code>UmbraBookmarkService</code> for persistent file access</li> <li>Never store raw file paths</li> <li>Always use security-scoped bookmarks</li> </ul>"},{"location":"archive/security/SECURITY_GUIDELINES/#encryption","title":"Encryption","text":""},{"location":"archive/security/SECURITY_GUIDELINES/#1-data-at-rest","title":"1. Data at Rest","text":"<ul> <li>All sensitive data must be encrypted</li> <li>Use <code>UmbraCryptoService</code> for encryption/decryption</li> <li>Never store encryption keys in code</li> </ul>"},{"location":"archive/security/SECURITY_GUIDELINES/#2-data-in-transit","title":"2. Data in Transit","text":"<ul> <li>Use secure transport (HTTPS, SSH)</li> <li>Validate certificates</li> <li>Implement proper error handling</li> </ul>"},{"location":"archive/security/SECURITY_GUIDELINES/#access-control","title":"Access Control","text":""},{"location":"archive/security/SECURITY_GUIDELINES/#1-xpc-services","title":"1. XPC Services","text":"<ul> <li>Principle of least privilege</li> <li>Separate process for sensitive operations</li> <li>Validate all inputs</li> </ul>"},{"location":"archive/security/SECURITY_GUIDELINES/#2-file-permissions","title":"2. File Permissions","text":"<ul> <li>Respect system permissions</li> <li>Use security-scoped resources</li> <li>Clean up temporary files</li> </ul>"},{"location":"archive/security/SECURITY_GUIDELINES/#logging","title":"Logging","text":""},{"location":"archive/security/SECURITY_GUIDELINES/#1-sensitive-data","title":"1. Sensitive Data","text":"<ul> <li>Never log credentials</li> <li>Mask sensitive information</li> <li>Use appropriate log levels</li> </ul>"},{"location":"archive/security/SECURITY_GUIDELINES/#2-audit-trail","title":"2. Audit Trail","text":"<ul> <li>Log security-relevant events</li> <li>Include necessary context</li> <li>Maintain audit logs</li> </ul>"},{"location":"archive/security/SECURITY_GUIDELINES/#error-handling","title":"Error Handling","text":""},{"location":"archive/security/SECURITY_GUIDELINES/#1-security-errors","title":"1. Security Errors","text":"<ul> <li>Don't expose internal details</li> <li>Provide appropriate user feedback</li> <li>Log security failures</li> </ul>"},{"location":"archive/security/SECURITY_GUIDELINES/#2-recovery","title":"2. Recovery","text":"<ul> <li>Implement secure fallbacks</li> <li>Clean up on failure</li> <li>Maintain system integrity</li> </ul>"},{"location":"archive/security/SECURITY_GUIDELINES/#best-practices","title":"Best Practices","text":""},{"location":"archive/security/SECURITY_GUIDELINES/#1-code","title":"1. Code","text":"<ul> <li>Use Swift's type safety</li> <li>Implement input validation</li> <li>Follow OWASP guidelines</li> </ul>"},{"location":"archive/security/SECURITY_GUIDELINES/#2-testing","title":"2. Testing","text":"<ul> <li>Include security test cases</li> <li>Test error conditions</li> <li>Verify security boundaries</li> </ul>"},{"location":"archive/security/SECURITY_GUIDELINES/#3-dependencies","title":"3. Dependencies","text":"<ul> <li>Regular security updates</li> <li>Vulnerability scanning</li> <li>Dependency pinning</li> </ul>"},{"location":"contributing/CONTRIBUTING/","title":"Contributing to UmbraCore","text":""},{"location":"contributing/CONTRIBUTING/#getting-started","title":"Getting Started","text":""},{"location":"contributing/CONTRIBUTING/#1-development-environment","title":"1. Development Environment","text":"<ul> <li>macOS 14.0+</li> <li>Xcode 15.2+</li> <li>Swift 6.0.3+</li> <li>SwiftLint</li> <li>Restic</li> </ul>"},{"location":"contributing/CONTRIBUTING/#2-setup","title":"2. Setup","text":"<ol> <li>Fork the repository</li> <li>Clone your fork</li> <li>Install dependencies</li> <li>Run tests</li> </ol>"},{"location":"contributing/CONTRIBUTING/#development-process","title":"Development Process","text":""},{"location":"contributing/CONTRIBUTING/#1-branching","title":"1. Branching","text":"<ul> <li><code>main</code>: Production-ready code</li> <li><code>develop</code>: Integration branch</li> <li>Feature branches: <code>feature/description</code></li> <li>Bug fixes: <code>fix/description</code></li> </ul>"},{"location":"contributing/CONTRIBUTING/#2-commit-messages","title":"2. Commit Messages","text":"<p>Follow conventional commits: <pre><code>type(scope): description\n\n[optional body]\n\n[optional footer]\n</code></pre></p> <p>Types: - feat: New feature - fix: Bug fix - docs: Documentation - style: Formatting - refactor: Code restructuring - test: Adding tests - chore: Maintenance</p>"},{"location":"contributing/CONTRIBUTING/#3-code-style","title":"3. Code Style","text":"<ul> <li>Follow Swift API Design Guidelines</li> <li>Use SwiftLint rules</li> <li>Document public APIs</li> <li>Write meaningful comments</li> </ul>"},{"location":"contributing/CONTRIBUTING/#4-testing","title":"4. Testing","text":"<ul> <li>Write unit tests</li> <li>Include integration tests</li> <li>Maintain test coverage</li> <li>Test error conditions</li> </ul>"},{"location":"contributing/CONTRIBUTING/#5-documentation","title":"5. Documentation","text":"<ul> <li>Update API documentation</li> <li>Include code examples</li> <li>Document breaking changes</li> <li>Update guides if needed</li> </ul>"},{"location":"contributing/CONTRIBUTING/#pull-requests","title":"Pull Requests","text":""},{"location":"contributing/CONTRIBUTING/#1-preparation","title":"1. Preparation","text":"<ul> <li>Update from upstream</li> <li>Run all tests</li> <li>Check code coverage</li> <li>Run SwiftLint</li> </ul>"},{"location":"contributing/CONTRIBUTING/#2-submission","title":"2. Submission","text":"<ul> <li>Clear description</li> <li>Link related issues</li> <li>Include test cases</li> <li>Update documentation</li> </ul>"},{"location":"contributing/CONTRIBUTING/#3-review-process","title":"3. Review Process","text":"<ul> <li>Address feedback</li> <li>Keep changes focused</li> <li>Maintain clean history</li> <li>Update as needed</li> </ul>"},{"location":"contributing/CONTRIBUTING/#release-process","title":"Release Process","text":""},{"location":"contributing/CONTRIBUTING/#1-versioning","title":"1. Versioning","text":"<p>Follow semantic versioning: - MAJOR: Breaking changes - MINOR: New features - PATCH: Bug fixes</p>"},{"location":"contributing/CONTRIBUTING/#2-release-checklist","title":"2. Release Checklist","text":"<ul> <li>Update changelog</li> <li>Update version</li> <li>Run full test suite</li> <li>Update documentation</li> <li>Create release notes</li> </ul>"},{"location":"contributing/CONTRIBUTING/#additional-resources","title":"Additional Resources","text":"<ul> <li>Swift API Design Guidelines</li> <li>SwiftLint Rules</li> <li>Conventional Commits</li> </ul>"},{"location":"guides/ARCHITECTURE/","title":"UmbraCore Architecture Guide","text":""},{"location":"guides/ARCHITECTURE/#overview","title":"Overview","text":"<p>UmbraCore is designed as a modular Swift library that provides a type-safe interface to Restic backup functionality. The architecture follows a service-oriented approach with clear separation of concerns.</p>"},{"location":"guides/ARCHITECTURE/#core-components","title":"Core Components","text":""},{"location":"guides/ARCHITECTURE/#1-security-layer","title":"1. Security Layer","text":"<ul> <li><code>SecurityTypes</code>: Base security primitives</li> <li><code>CryptoTypes</code>: Cryptographic operations</li> <li>Uses Apple's CryptoKit for hardware-backed security</li> <li>Provides core cryptographic primitives</li> <li>Handles secure key generation and management</li> <li><code>UmbraKeychainService</code>: Secure credential storage</li> </ul>"},{"location":"guides/ARCHITECTURE/#2-service-layer","title":"2. Service Layer","text":"<ul> <li><code>UmbraCryptoService</code>: Encryption/decryption operations</li> <li>Uses CryptoSwift for XPC service operations</li> <li>Platform-independent implementation</li> <li>Handles cross-process cryptographic operations</li> <li><code>UmbraBookmarkService</code>: File system bookmark management</li> <li><code>UmbraXPC</code>: Inter-process communication</li> </ul>"},{"location":"guides/ARCHITECTURE/#3-logging-infrastructure","title":"3. Logging Infrastructure","text":"<ul> <li><code>UmbraLogging</code>: Centralised logging system</li> <li>Structured logging with context</li> <li>Log level management</li> </ul>"},{"location":"guides/ARCHITECTURE/#design-patterns","title":"Design Patterns","text":""},{"location":"guides/ARCHITECTURE/#1-xpc-service-pattern","title":"1. XPC Service Pattern","text":"<p>Used for secure inter-process communication: <pre><code>protocol KeychainXPCProtocol {\n    func store(password: String, forKey: String) async throws\n    func retrieve(forKey: String) async throws -&gt; String\n}\n</code></pre></p>"},{"location":"guides/ARCHITECTURE/#2-protocol-oriented-design","title":"2. Protocol-Oriented Design","text":"<p>Services are defined by protocols for better testability: <pre><code>protocol CryptoServiceProtocol {\n    func encrypt(_ data: Data) async throws -&gt; Data\n    func decrypt(_ data: Data) async throws -&gt; Data\n}\n</code></pre></p>"},{"location":"guides/ARCHITECTURE/#3-error-handling-pattern","title":"3. Error Handling Pattern","text":"<p>Structured error types with context: <pre><code>enum KeychainError: Error {\n    case itemNotFound(String)\n    case duplicateItem(String)\n    case accessDenied(String)\n}\n</code></pre></p>"},{"location":"guides/ARCHITECTURE/#cryptographic-architecture","title":"Cryptographic Architecture","text":"<p>The framework employs a dual-library approach for cryptographic operations:</p> <ol> <li>CryptoKit (Main App Context)</li> <li>Hardware-backed security on Apple platforms</li> <li>Used in <code>DefaultCryptoService</code></li> <li>Handles core cryptographic operations</li> <li> <p>Optimal security for main app operations</p> </li> <li> <p>CryptoSwift (XPC Service Context)</p> </li> <li>Platform-independent implementation</li> <li>Used in <code>CryptoXPCService</code></li> <li>Enables reliable cross-process encryption</li> <li>Provides necessary flexibility for XPC operations</li> </ol> <p>This split architecture ensures: - Maximum security through hardware backing where available - Reliable cross-process cryptographic operations - Clear separation of concerns between contexts - Consistent cryptographic operations in each context</p>"},{"location":"guides/ARCHITECTURE/#threading-model","title":"Threading Model","text":"<ul> <li>All services are thread-safe</li> <li>Async/await for asynchronous operations</li> <li>XPC for background processing</li> </ul>"},{"location":"guides/ARCHITECTURE/#security-considerations","title":"Security Considerations","text":"<ul> <li>Keychain integration for secure storage</li> <li>XPC for privilege separation</li> <li>Audit logging</li> <li>Secure defaults</li> </ul>"},{"location":"guides/ARCHITECTURE/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Efficient memory usage</li> <li>Background processing</li> <li>Cache management</li> <li>Resource cleanup</li> </ul>"},{"location":"guides/ARCHITECTURE/#testing-strategy","title":"Testing Strategy","text":"<ul> <li>Unit tests for all components</li> <li>Integration tests for workflows</li> <li>Mock services for testing</li> <li>Performance benchmarks</li> </ul>"},{"location":"guides/ARCHITECTURE/#dependency-management","title":"Dependency Management","text":"<ul> <li>Minimal external dependencies</li> <li>Version pinning</li> <li>Security scanning</li> <li>Regular updates</li> </ul>"},{"location":"guides/ARCHITECTURE/#implementation-plan","title":"Implementation Plan","text":""},{"location":"guides/ARCHITECTURE/#phase-1-core-foundation","title":"Phase 1: Core Foundation","text":"<p>Currently in progress (Q1 2025):</p> <ul> <li>Command execution system</li> <li>Keychain integration</li> <li>XPC service implementation</li> <li>SSH key management</li> <li>Cloud provider integration</li> </ul>"},{"location":"guides/ARCHITECTURE/#phase-2-advanced-features","title":"Phase 2: Advanced Features","text":"<p>Planned for Q2 2025:</p> <ul> <li>Repository management</li> <li>Scheduling system</li> <li>Network operations</li> <li>State persistence</li> </ul>"},{"location":"guides/ARCHITECTURE/#phase-3-optimisation","title":"Phase 3: Optimisation","text":"<p>Scheduled for Q3 2025:</p> <ul> <li>Statistics &amp; analytics</li> <li>Health monitoring</li> <li>Event system</li> <li>Cache optimisation</li> </ul>"},{"location":"guides/ARCHITECTURE/#design-principles","title":"Design Principles","text":""},{"location":"guides/ARCHITECTURE/#1-security-first","title":"1. Security First","text":"<ul> <li>Secure by default</li> <li>Least privilege principle</li> <li>Comprehensive audit logging</li> <li>Regular security reviews</li> </ul>"},{"location":"guides/ARCHITECTURE/#2-reliability","title":"2. Reliability","text":"<ul> <li>Comprehensive error handling</li> <li>Automatic retry mechanisms</li> <li>Circuit breakers</li> <li>Fallback strategies</li> </ul>"},{"location":"guides/ARCHITECTURE/#3-performance","title":"3. Performance","text":"<ul> <li>Efficient resource usage</li> <li>Optimised I/O operations</li> <li>Memory management</li> <li>Cache strategies</li> </ul>"},{"location":"guides/ARCHITECTURE/#4-maintainability","title":"4. Maintainability","text":"<ul> <li>Protocol-oriented design</li> <li>Clear documentation</li> <li>Comprehensive testing</li> <li>Code review process</li> </ul>"},{"location":"guides/ARCHITECTURE/#integration-points","title":"Integration Points","text":"<p>UmbraCore serves as the foundation for:</p> <ul> <li>Rbum: Command-line interface</li> <li>Rbx: GUI application</li> <li>ResticBar: Menu bar application</li> </ul> <p>Each application utilises UmbraCore's components through well-defined protocols and interfaces.</p>"},{"location":"guides/ARCHITECTURE/#testing-strategy_1","title":"Testing Strategy","text":"<p>Comprehensive testing approach:</p> <ol> <li>Unit Tests</li> <li>Component isolation</li> <li>Edge case coverage</li> <li> <p>Mock implementations</p> </li> <li> <p>Integration Tests</p> </li> <li>Component interaction</li> <li>System workflows</li> <li> <p>Error scenarios</p> </li> <li> <p>Performance Tests</p> </li> <li>Resource usage</li> <li>Throughput metrics</li> <li> <p>Scalability checks</p> </li> <li> <p>Security Tests</p> </li> <li>Vulnerability scanning</li> <li>Penetration testing</li> <li>Compliance verification</li> </ol>"},{"location":"guides/bookmarks/","title":"UmbraBookmarkService Guide","text":""},{"location":"guides/bookmarks/#overview","title":"Overview","text":"<p><code>UmbraBookmarkService</code> manages persistent file system access through security-scoped bookmarks. It provides safe and reliable access to files and directories across app launches.</p>"},{"location":"guides/bookmarks/#features","title":"Features","text":"<ul> <li>Security-scoped bookmarks</li> <li>Persistent file access</li> <li>Thread-safe operations</li> <li>Automatic bookmark resolution</li> </ul>"},{"location":"guides/bookmarks/#basic-usage","title":"Basic Usage","text":""},{"location":"guides/bookmarks/#creating-bookmarks","title":"Creating Bookmarks","text":"<pre><code>let service = try UmbraBookmarkService()\n\n// Create bookmark for file\nlet fileURL = URL(fileURLWithPath: \"/path/to/file\")\ntry await service.create(\n    for: fileURL,\n    withName: \"important-file\"\n)\n\n// Create bookmark for directory\nlet dirURL = URL(fileURLWithPath: \"/path/to/directory\")\ntry await service.create(\n    for: dirURL,\n    withName: \"backup-directory\"\n)\n</code></pre>"},{"location":"guides/bookmarks/#resolving-bookmarks","title":"Resolving Bookmarks","text":"<pre><code>// Get URL from bookmark\nlet fileURL = try await service.resolve(name: \"important-file\")\n\n// Access with scope\ntry await service.access(name: \"backup-directory\") { url in\n    // Work with URL within security scope\n    let contents = try FileManager.default.contentsOfDirectory(at: url)\n}\n</code></pre>"},{"location":"guides/bookmarks/#removing-bookmarks","title":"Removing Bookmarks","text":"<pre><code>try await service.remove(name: \"important-file\")\n</code></pre>"},{"location":"guides/bookmarks/#error-handling","title":"Error Handling","text":"<pre><code>do {\n    try await service.create(for: url, withName: name)\n} catch BookmarkError.invalidURL(let url) {\n    // Handle invalid URL\n} catch BookmarkError.accessDenied(let reason) {\n    // Handle access denied\n} catch {\n    // Handle other errors\n}\n</code></pre>"},{"location":"guides/bookmarks/#best-practices","title":"Best Practices","text":""},{"location":"guides/bookmarks/#1-bookmark-naming","title":"1. Bookmark Naming","text":"<ul> <li>Use descriptive names</li> <li>Include context</li> <li>Follow naming conventions</li> </ul> <pre><code>// Good\n\"main-backup-directory\"\n\"config-file-production\"\n\n// Bad\n\"bookmark1\"\n\"file\"\n</code></pre>"},{"location":"guides/bookmarks/#2-access-scoping","title":"2. Access Scoping","text":"<ul> <li>Use scoped access</li> <li>Clean up resources</li> <li>Handle access errors</li> </ul>"},{"location":"guides/bookmarks/#3-error-recovery","title":"3. Error Recovery","text":"<ul> <li>Implement retry logic</li> <li>Provide user feedback</li> <li>Log access failures</li> </ul>"},{"location":"guides/bookmarks/#advanced-usage","title":"Advanced Usage","text":""},{"location":"guides/bookmarks/#1-custom-bookmark-options","title":"1. Custom Bookmark Options","text":"<pre><code>let options = BookmarkOptions(\n    securityScope: .workingDirectory,\n    persistence: .permanent\n)\n\ntry await service.create(\n    for: url,\n    withName: name,\n    options: options\n)\n</code></pre>"},{"location":"guides/bookmarks/#2-batch-operations","title":"2. Batch Operations","text":"<pre><code>let bookmarks = [\n    \"dir1\": url1,\n    \"dir2\": url2\n]\n\ntry await service.createBatch(bookmarks)\n</code></pre>"},{"location":"guides/bookmarks/#3-access-control","title":"3. Access Control","text":"<pre><code>let access = BookmarkAccess(\n    scope: .minimal,\n    duration: .temporary\n)\n\ntry await service.access(\n    name: \"secure-directory\",\n    access: access\n) { url in\n    // Limited scope access\n}\n</code></pre>"},{"location":"guides/bookmarks/#integration-examples","title":"Integration Examples","text":""},{"location":"guides/bookmarks/#1-backup-directory-management","title":"1. Backup Directory Management","text":"<pre><code>class BackupManager {\n    private let bookmarks: UmbraBookmarkService\n\n    init() throws {\n        bookmarks = try UmbraBookmarkService()\n    }\n\n    func configureBackupDirectory(_ url: URL) async throws {\n        // Create persistent bookmark\n        try await bookmarks.create(\n            for: url,\n            withName: \"backup-root\"\n        )\n    }\n\n    func performBackup() async throws {\n        try await bookmarks.access(\"backup-root\") { url in\n            // Perform backup operations\n            try await backupContents(of: url)\n        }\n    }\n}\n</code></pre>"},{"location":"guides/bookmarks/#2-configuration-file-access","title":"2. Configuration File Access","text":"<pre><code>class ConfigManager {\n    private let bookmarks: UmbraBookmarkService\n\n    func saveConfig(_ config: Config) async throws {\n        try await bookmarks.access(\"config-file\") { url in\n            let data = try JSONEncoder().encode(config)\n            try data.write(to: url)\n        }\n    }\n}\n</code></pre>"},{"location":"guides/bookmarks/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guides/bookmarks/#common-issues","title":"Common Issues","text":"<ol> <li> <p>Stale Bookmarks <pre><code>// Refresh bookmark if stale\nif await service.isStale(name: \"backup-dir\") {\n    try await service.refresh(name: \"backup-dir\")\n}\n</code></pre></p> </li> <li> <p>Access Denied <pre><code>// Request user permission if needed\nfunc ensureAccess(to name: String) async throws {\n    do {\n        try await service.verifyAccess(name: name)\n    } catch BookmarkError.accessDenied {\n        try await requestUserPermission(for: name)\n    }\n}\n</code></pre></p> </li> <li> <p>Resource Management <pre><code>// Proper resource cleanup\nfunc processDirectory() async throws {\n    try await service.access(\"work-dir\") { url in\n        defer {\n            // Cleanup code\n        }\n\n        // Process directory\n    }\n}\n</code></pre></p> </li> </ol>"},{"location":"guides/crypto-types/","title":"Cryptographic Types","text":"<p>This guide covers the cryptographic types used in UmbraCore for secure data handling.</p>"},{"location":"guides/crypto-types/#overview","title":"Overview","text":"<p>UmbraCore provides several cryptographic types to ensure secure handling of sensitive data:</p> <ul> <li><code>SecureString</code>: For handling passwords and other sensitive strings</li> <li><code>EncryptedData</code>: For encrypted binary data</li> <li><code>KeyMaterial</code>: For cryptographic key material</li> </ul>"},{"location":"guides/crypto-types/#securestring","title":"SecureString","text":"<p><code>SecureString</code> provides secure storage for sensitive string data:</p> <pre><code>let password = SecureString(\"sensitive-data\")\n// Memory is automatically zeroed when deallocated\n</code></pre>"},{"location":"guides/crypto-types/#encrypteddata","title":"EncryptedData","text":"<p><code>EncryptedData</code> handles encrypted binary data:</p> <pre><code>let encrypted = EncryptedData(data: someData, key: keyMaterial)\nlet decrypted = try encrypted.decrypt(using: keyMaterial)\n</code></pre>"},{"location":"guides/crypto-types/#keymaterial","title":"KeyMaterial","text":"<p><code>KeyMaterial</code> manages cryptographic keys:</p> <pre><code>let key = try KeyMaterial.generate()\nlet derived = try key.deriveKey(salt: salt, rounds: 100_000)\n</code></pre>"},{"location":"guides/crypto-types/#best-practices","title":"Best Practices","text":"<ol> <li>Always use <code>SecureString</code> for passwords and sensitive data</li> <li>Zero memory after use</li> <li>Use appropriate key derivation functions</li> <li>Implement proper key rotation</li> <li>Follow cryptographic hygiene</li> </ol>"},{"location":"guides/crypto/","title":"UmbraCryptoService Guide","text":""},{"location":"guides/crypto/#overview","title":"Overview","text":"<p><code>UmbraCryptoService</code> provides cryptographic operations for securing sensitive data. It supports encryption, decryption, and key management.</p>"},{"location":"guides/crypto/#features","title":"Features","text":"<ul> <li>Secure encryption/decryption</li> <li>Key management</li> <li>Thread-safe operations</li> <li>XPC-based processing</li> </ul>"},{"location":"guides/crypto/#basic-usage","title":"Basic Usage","text":""},{"location":"guides/crypto/#encryption","title":"Encryption","text":"<pre><code>let service = try UmbraCryptoService()\n\n// Encrypt data\nlet data = \"sensitive data\".data(using: .utf8)!\nlet encrypted = try await service.encrypt(data)\n\n// Encrypt with custom key\nlet key = try service.generateKey()\nlet customEncrypted = try await service.encrypt(data, using: key)\n</code></pre>"},{"location":"guides/crypto/#decryption","title":"Decryption","text":"<pre><code>// Decrypt data\nlet decrypted = try await service.decrypt(encrypted)\n\n// Decrypt with custom key\nlet customDecrypted = try await service.decrypt(customEncrypted, using: key)\n</code></pre>"},{"location":"guides/crypto/#key-management","title":"Key Management","text":"<pre><code>// Generate new key\nlet key = try service.generateKey()\n\n// Export key (protected)\nlet exportedKey = try service.exportKey(key)\n\n// Import key\nlet importedKey = try service.importKey(exportedKey)\n</code></pre>"},{"location":"guides/crypto/#error-handling","title":"Error Handling","text":"<pre><code>do {\n    let encrypted = try await service.encrypt(data)\n} catch CryptoError.invalidKey {\n    // Handle invalid key\n} catch CryptoError.encryptionFailed(let reason) {\n    // Handle encryption failure\n} catch {\n    // Handle other errors\n}\n</code></pre>"},{"location":"guides/crypto/#best-practices","title":"Best Practices","text":""},{"location":"guides/crypto/#1-key-management","title":"1. Key Management","text":"<ul> <li>Rotate keys regularly</li> <li>Secure key storage</li> <li>Use key derivation when appropriate</li> </ul>"},{"location":"guides/crypto/#2-data-protection","title":"2. Data Protection","text":"<ul> <li>Encrypt sensitive data immediately</li> <li>Clear sensitive data from memory</li> <li>Use secure random generation</li> </ul>"},{"location":"guides/crypto/#3-error-recovery","title":"3. Error Recovery","text":"<ul> <li>Implement retry logic</li> <li>Log cryptographic failures</li> <li>Provide appropriate user feedback</li> </ul>"},{"location":"guides/crypto/#advanced-usage","title":"Advanced Usage","text":""},{"location":"guides/crypto/#1-custom-encryption-parameters","title":"1. Custom Encryption Parameters","text":"<pre><code>let params = EncryptionParameters(\n    algorithm: .aes256GCM,\n    keySize: .bits256,\n    iterations: 10000\n)\n\nlet encrypted = try await service.encrypt(\n    data,\n    parameters: params\n)\n</code></pre>"},{"location":"guides/crypto/#2-key-derivation","title":"2. Key Derivation","text":"<pre><code>let derivedKey = try service.deriveKey(\n    fromPassword: \"user-password\",\n    salt: salt,\n    iterations: 10000\n)\n</code></pre>"},{"location":"guides/crypto/#3-batch-operations","title":"3. Batch Operations","text":"<pre><code>let dataItems = [\n    \"item1\": data1,\n    \"item2\": data2\n]\n\nlet encrypted = try await service.encryptBatch(dataItems)\n</code></pre>"},{"location":"guides/crypto/#integration-examples","title":"Integration Examples","text":""},{"location":"guides/crypto/#1-secure-configuration","title":"1. Secure Configuration","text":"<pre><code>class SecureConfig {\n    private let crypto: UmbraCryptoService\n\n    init() throws {\n        crypto = try UmbraCryptoService()\n    }\n\n    func saveConfig(_ config: Config) async throws {\n        let data = try JSONEncoder().encode(config)\n        let encrypted = try await crypto.encrypt(data)\n\n        try await FileManager.default.createFile(\n            at: configURL,\n            contents: encrypted\n        )\n    }\n}\n</code></pre>"},{"location":"guides/crypto/#2-secure-data-transfer","title":"2. Secure Data Transfer","text":"<pre><code>class SecureTransfer {\n    private let crypto: UmbraCryptoService\n\n    func secureUpload(_ data: Data) async throws {\n        // Encrypt before upload\n        let encrypted = try await crypto.encrypt(data)\n\n        // Upload encrypted data\n        try await uploadToServer(encrypted)\n    }\n}\n</code></pre>"},{"location":"guides/crypto/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guides/crypto/#common-issues","title":"Common Issues","text":"<ol> <li> <p>Key Validation <pre><code>// Validate key before use\nguard try service.validateKey(key) else {\n    throw CryptoError.invalidKey\n}\n</code></pre></p> </li> <li> <p>Memory Management <pre><code>// Clear sensitive data\ndefer {\n    key.zero()\n    plaintext.zero()\n}\n</code></pre></p> </li> <li> <p>Performance Optimization <pre><code>// Use batch operations for multiple items\nlet results = try await withThrowingTaskGroup(of: (String, Data).self) { group in\n    for (id, data) in items {\n        group.addTask {\n            let encrypted = try await service.encrypt(data)\n            return (id, encrypted)\n        }\n    }\n    return try await group.reduce(into: [:]) { $0[$1.0] = $1.1 }\n}\n</code></pre></p> </li> </ol>"},{"location":"guides/error-handling/","title":"Error Handling in UmbraCore","text":""},{"location":"guides/error-handling/#overview","title":"Overview","text":"<p>UmbraCore uses a structured error handling system that provides detailed error context, supports error recovery, and integrates with the logging system. This guide explains our error handling patterns and best practices.</p>"},{"location":"guides/error-handling/#error-types","title":"Error Types","text":""},{"location":"guides/error-handling/#1-common-errors","title":"1. Common Errors","text":"<p>Base error types shared across the library:</p> <pre><code>enum CommonError: Error {\n    case invalidArgument(String)\n    case resourceNotFound(String)\n    case permissionDenied(String)\n    case operationFailed(String)\n\n    var localizedDescription: String {\n        switch self {\n        case .invalidArgument(let details):\n            return \"Invalid argument: \\(details)\"\n        case .resourceNotFound(let resource):\n            return \"Resource not found: \\(resource)\"\n        case .permissionDenied(let operation):\n            return \"Permission denied for operation: \\(operation)\"\n        case .operationFailed(let reason):\n            return \"Operation failed: \\(reason)\"\n        }\n    }\n}\n</code></pre>"},{"location":"guides/error-handling/#2-service-specific-errors","title":"2. Service-Specific Errors","text":"<p>Each service defines its domain-specific errors:</p> <pre><code>enum KeychainError: Error {\n    case itemNotFound(String)\n    case duplicateItem(String)\n    case accessDenied(String)\n    case invalidData(String)\n}\n\nenum CryptoError: Error {\n    case encryptionFailed(String)\n    case decryptionFailed(String)\n    case invalidKey(String)\n    case algorithmNotSupported(String)\n}\n</code></pre>"},{"location":"guides/error-handling/#3-error-context","title":"3. Error Context","text":"<p>Additional context for debugging and recovery:</p> <pre><code>struct ErrorContext {\n    let file: String\n    let function: String\n    let line: Int\n    let timestamp: Date\n    let operationId: UUID\n    var userInfo: [String: Any]\n\n    var description: String {\n        \"\"\"\n        Error occurred in \\(function)\n        File: \\(file):\\(line)\n        Time: \\(timestamp)\n        Operation: \\(operationId)\n        Additional Info: \\(userInfo)\n        \"\"\"\n    }\n}\n</code></pre>"},{"location":"guides/error-handling/#best-practices","title":"Best Practices","text":""},{"location":"guides/error-handling/#1-error-creation","title":"1. Error Creation","text":"<p>Create informative errors with context:</p> <pre><code>func processFile(_ url: URL) async throws {\n    guard FileManager.default.fileExists(atPath: url.path) else {\n        throw CommonError.resourceNotFound(\n            \"\"\"\n            File not found at \\(url.path)\n            Check if the file exists and you have read permissions.\n            \"\"\"\n        )\n    }\n}\n</code></pre>"},{"location":"guides/error-handling/#2-error-handling","title":"2. Error Handling","text":"<p>Handle errors at appropriate levels:</p> <pre><code>func backupFiles() async throws {\n    do {\n        try await validatePermissions()\n        try await performBackup()\n        try await verifyBackup()\n    } catch KeychainError.accessDenied(let details) {\n        logger.error(\"Keychain access denied\", metadata: [\n            \"details\": details,\n            \"operation\": \"backup\"\n        ])\n        throw CommonError.permissionDenied(\"Keychain access required for backup\")\n    } catch CryptoError.encryptionFailed(let reason) {\n        logger.error(\"Encryption failed\", metadata: [\n            \"reason\": reason,\n            \"operation\": \"backup\"\n        ])\n        throw CommonError.operationFailed(\"Backup encryption failed\")\n    }\n}\n</code></pre>"},{"location":"guides/error-handling/#3-error-recovery","title":"3. Error Recovery","text":"<p>Implement recovery strategies:</p> <pre><code>actor RetryableOperation {\n    func execute() async throws -&gt; Result {\n        var attempts = 0\n        while attempts &lt; maxRetries {\n            do {\n                return try await performOperation()\n            } catch let error as RecoverableError {\n                attempts += 1\n                try await handleError(error, attempt: attempts)\n            } catch {\n                throw error // Non-recoverable error\n            }\n        }\n        throw CommonError.operationFailed(\"Max retry attempts exceeded\")\n    }\n}\n</code></pre>"},{"location":"guides/error-handling/#error-patterns","title":"Error Patterns","text":""},{"location":"guides/error-handling/#1-result-type-usage","title":"1. Result Type Usage","text":"<p>For operations that might fail:</p> <pre><code>enum OperationResult&lt;T&gt; {\n    case success(T)\n    case failure(Error)\n    case partial(T, [Error])\n\n    var value: T? {\n        switch self {\n        case .success(let value), .partial(let value, _):\n            return value\n        case .failure:\n            return nil\n        }\n    }\n}\n\nfunc processItems(_ items: [Item]) async -&gt; OperationResult&lt;[ProcessedItem]&gt; {\n    var processed: [ProcessedItem] = []\n    var errors: [Error] = []\n\n    for item in items {\n        do {\n            let result = try await process(item)\n            processed.append(result)\n        } catch {\n            errors.append(error)\n        }\n    }\n\n    if errors.isEmpty {\n        return .success(processed)\n    } else if processed.isEmpty {\n        return .failure(CommonError.operationFailed(\"All items failed\"))\n    } else {\n        return .partial(processed, errors)\n    }\n}\n</code></pre>"},{"location":"guides/error-handling/#2-error-transformation","title":"2. Error Transformation","text":"<p>Convert between error types while preserving context:</p> <pre><code>extension Error {\n    func asCommonError() -&gt; CommonError {\n        switch self {\n        case let error as KeychainError:\n            return error.toCommonError()\n        case let error as CryptoError:\n            return error.toCommonError()\n        default:\n            return .operationFailed(localizedDescription)\n        }\n    }\n}\n\nextension KeychainError {\n    func toCommonError() -&gt; CommonError {\n        switch self {\n        case .accessDenied(let details):\n            return .permissionDenied(\"Keychain: \\(details)\")\n        case .itemNotFound(let key):\n            return .resourceNotFound(\"Keychain item: \\(key)\")\n        // ... other cases\n        }\n    }\n}\n</code></pre>"},{"location":"guides/error-handling/#3-async-error-handling","title":"3. Async Error Handling","text":"<p>Handle errors in async contexts:</p> <pre><code>actor ErrorHandler {\n    func handle&lt;T&gt;(_ operation: @escaping () async throws -&gt; T) async throws -&gt; T {\n        do {\n            return try await operation()\n        } catch {\n            try await logError(error)\n            try await notifyObservers(of: error)\n            throw error\n        }\n    }\n}\n</code></pre>"},{"location":"guides/error-handling/#integration-with-logging","title":"Integration with Logging","text":""},{"location":"guides/error-handling/#1-error-logging","title":"1. Error Logging","text":"<p>Log errors with context:</p> <pre><code>extension Logger {\n    func logError(\n        _ error: Error,\n        context: ErrorContext,\n        file: String = #file,\n        function: String = #function,\n        line: Int = #line\n    ) {\n        error(\n            \"Error occurred\",\n            metadata: [\n                \"error\": \"\\(error)\",\n                \"context\": \"\\(context)\",\n                \"file\": \"\\(file)\",\n                \"function\": \"\\(function)\",\n                \"line\": \"\\(line)\"\n            ]\n        )\n    }\n}\n</code></pre>"},{"location":"guides/error-handling/#2-error-monitoring","title":"2. Error Monitoring","text":"<p>Track error patterns:</p> <pre><code>actor ErrorMonitor {\n    private var errorCounts: [String: Int] = [:]\n\n    func record(_ error: Error) async {\n        let key = String(describing: type(of: error))\n        errorCounts[key, default: 0] += 1\n\n        if errorCounts[key] ?? 0 &gt; threshold {\n            await notifyHighErrorRate(type: key)\n        }\n    }\n}\n</code></pre>"},{"location":"guides/error-handling/#testing","title":"Testing","text":""},{"location":"guides/error-handling/#1-error-scenarios","title":"1. Error Scenarios","text":"<p>Test error handling paths:</p> <pre><code>func testErrorHandling() async throws {\n    let service = TestService()\n\n    do {\n        try await service.operationThatFails()\n        XCTFail(\"Expected error not thrown\")\n    } catch let error as CommonError {\n        XCTAssertEqual(\n            error.localizedDescription,\n            \"Expected error message\"\n        )\n    }\n}\n</code></pre>"},{"location":"guides/error-handling/#2-recovery-testing","title":"2. Recovery Testing","text":"<p>Test error recovery mechanisms:</p> <pre><code>func testErrorRecovery() async throws {\n    let operation = RetryableOperation()\n\n    // Inject failures\n    operation.injectFailures(count: 2)\n\n    // Should succeed after retries\n    let result = try await operation.execute()\n    XCTAssertNotNil(result)\n}\n</code></pre>"},{"location":"guides/error-handling/#3-error-context-testing","title":"3. Error Context Testing","text":"<p>Verify error context information:</p> <p>```swift func testErrorContext() async throws {     let operation = ContextualOperation()</p> <pre><code>do {\n    try await operation.execute()\n    XCTFail(\"Expected error not thrown\")\n} catch {\n    let context = try XCTUnwrap(error.errorContext)\n    XCTAssertEqual(context.function, \"execute\")\n    XCTAssertNotNil(context.operationId)\n}\n</code></pre> <p>}</p>"},{"location":"guides/keychain/","title":"UmbraKeychainService Guide","text":""},{"location":"guides/keychain/#overview","title":"Overview","text":"<p><code>UmbraKeychainService</code> provides secure credential storage using macOS Keychain. It handles repository passwords, API keys, and other sensitive data.</p>"},{"location":"guides/keychain/#features","title":"Features","text":"<ul> <li>Secure credential storage</li> <li>XPC-based access</li> <li>Thread-safe operations</li> <li>Automatic error handling</li> </ul>"},{"location":"guides/keychain/#basic-usage","title":"Basic Usage","text":""},{"location":"guides/keychain/#storing-credentials","title":"Storing Credentials","text":"<pre><code>let service = try UmbraKeychainService()\n\n// Store a repository password\ntry await service.store(\n    password: \"secret-password\",\n    forKey: \"backup-repository\"\n)\n\n// Store an API key\ntry await service.store(\n    password: \"api-key-12345\",\n    forKey: \"cloud-provider\"\n)\n</code></pre>"},{"location":"guides/keychain/#retrieving-credentials","title":"Retrieving Credentials","text":"<pre><code>// Get repository password\nlet password = try await service.retrieve(forKey: \"backup-repository\")\n\n// Get API key\nlet apiKey = try await service.retrieve(forKey: \"cloud-provider\")\n</code></pre>"},{"location":"guides/keychain/#updating-credentials","title":"Updating Credentials","text":"<pre><code>try await service.update(\n    password: \"new-password\",\n    forKey: \"backup-repository\"\n)\n</code></pre>"},{"location":"guides/keychain/#removing-credentials","title":"Removing Credentials","text":"<pre><code>try await service.remove(forKey: \"backup-repository\")\n</code></pre>"},{"location":"guides/keychain/#error-handling","title":"Error Handling","text":"<pre><code>do {\n    try await service.store(password: \"secret\", forKey: \"key\")\n} catch KeychainError.duplicateItem(let key) {\n    // Handle duplicate item\n} catch KeychainError.accessDenied(let reason) {\n    // Handle access denied\n} catch {\n    // Handle other errors\n}\n</code></pre>"},{"location":"guides/keychain/#best-practices","title":"Best Practices","text":""},{"location":"guides/keychain/#1-key-naming","title":"1. Key Naming","text":"<ul> <li>Use descriptive, consistent keys</li> <li>Include context in key names</li> <li>Follow naming conventions</li> </ul> <pre><code>// Good\n\"backup-repo-main-password\"\n\"aws-access-key-prod\"\n\n// Bad\n\"pwd1\"\n\"key\"\n</code></pre>"},{"location":"guides/keychain/#2-error-recovery","title":"2. Error Recovery","text":"<ul> <li>Implement retry logic</li> <li>Provide user feedback</li> <li>Log failures appropriately</li> </ul>"},{"location":"guides/keychain/#3-security","title":"3. Security","text":"<ul> <li>Never store keys in code</li> <li>Use appropriate access control</li> <li>Clean up unused credentials</li> </ul>"},{"location":"guides/keychain/#advanced-usage","title":"Advanced Usage","text":""},{"location":"guides/keychain/#1-custom-item-attributes","title":"1. Custom Item Attributes","text":"<pre><code>let attributes = KeychainItemAttributes(\n    label: \"Main Backup Repository\",\n    comment: \"Production backup credentials\"\n)\n\ntry await service.store(\n    password: \"secret\",\n    forKey: \"backup-repo\",\n    attributes: attributes\n)\n</code></pre>"},{"location":"guides/keychain/#2-batch-operations","title":"2. Batch Operations","text":"<pre><code>let credentials = [\n    \"repo1\": \"password1\",\n    \"repo2\": \"password2\"\n]\n\ntry await service.storeBatch(credentials)\n</code></pre>"},{"location":"guides/keychain/#3-access-control","title":"3. Access Control","text":"<pre><code>let access = KeychainAccess(\n    accessibility: .whenUnlocked,\n    authentication: .biometric\n)\n\ntry await service.store(\n    password: \"secret\",\n    forKey: \"secure-key\",\n    access: access\n)\n</code></pre>"},{"location":"guides/keychain/#integration-examples","title":"Integration Examples","text":""},{"location":"guides/keychain/#1-repository-setup","title":"1. Repository Setup","text":"<pre><code>func setupRepository() async throws {\n    let service = try UmbraKeychainService()\n\n    // Store repository password\n    try await service.store(\n        password: repositoryPassword,\n        forKey: \"repo-\\(repoId)\"\n    )\n\n    // Store cloud credentials if needed\n    if let cloudKey = cloudCredentials {\n        try await service.store(\n            password: cloudKey,\n            forKey: \"cloud-\\(repoId)\"\n        )\n    }\n}\n</code></pre>"},{"location":"guides/keychain/#2-credential-management","title":"2. Credential Management","text":"<pre><code>class CredentialManager {\n    private let keychain: UmbraKeychainService\n\n    init() throws {\n        keychain = try UmbraKeychainService()\n    }\n\n    func rotateCredentials() async throws {\n        let newPassword = generateSecurePassword()\n\n        try await keychain.update(\n            password: newPassword,\n            forKey: \"repo-main\"\n        )\n\n        try await updateRemoteRepository(password: newPassword)\n    }\n}\n</code></pre>"},{"location":"guides/keychain/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guides/keychain/#common-issues","title":"Common Issues","text":"<ol> <li> <p>Access Denied <pre><code>// Check keychain access\ntry await service.checkAccess()\n\n// Request user permission if needed\ntry await service.requestAccess()\n</code></pre></p> </li> <li> <p>Duplicate Items <pre><code>// Update instead of store for existing items\nif await service.exists(forKey: key) {\n    try await service.update(password: newPassword, forKey: key)\n} else {\n    try await service.store(password: newPassword, forKey: key)\n}\n</code></pre></p> </li> <li> <p>Item Not Found <pre><code>// Implement fallback logic\nfunc getCredential(forKey key: String) async throws -&gt; String {\n    do {\n        return try await service.retrieve(forKey: key)\n    } catch KeychainError.itemNotFound {\n        // Implement recovery logic\n        return try await recoverCredential(forKey: key)\n    }\n}\n</code></pre></p> </li> </ol>"},{"location":"guides/logging/","title":"UmbraLogging Guide","text":""},{"location":"guides/logging/#overview","title":"Overview","text":"<p><code>UmbraLogging</code> provides a centralised, structured logging system built on SwiftyBeaver. It supports multiple destinations, log levels, and contextual metadata.</p>"},{"location":"guides/logging/#features","title":"Features","text":"<ul> <li>Structured logging</li> <li>Multiple log levels</li> <li>Context metadata</li> <li>File output</li> <li>Console output</li> <li>Custom formatters</li> </ul>"},{"location":"guides/logging/#basic-usage","title":"Basic Usage","text":""},{"location":"guides/logging/#configuration","title":"Configuration","text":"<pre><code>import UmbraLogging\n\n// Basic setup\nUmbraLogger.configure(level: .info)\n\n// Custom configuration\nlet config = LoggerConfiguration(\n    level: .debug,\n    destinations: [.console, .file],\n    metadata: [\"app\": \"UmbraCore\"]\n)\nUmbraLogger.configure(config)\n</code></pre>"},{"location":"guides/logging/#logging-messages","title":"Logging Messages","text":"<pre><code>// Basic logging\nlogger.info(\"Backup started\")\nlogger.error(\"Failed to access repository\")\n\n// With metadata\nlogger.info(\"File processed\", metadata: [\n    \"size\": fileSize,\n    \"path\": filePath\n])\n\n// With error context\nlogger.error(\"Backup failed\", error: error, metadata: [\n    \"repository\": repoId,\n    \"files\": fileCount\n])\n</code></pre>"},{"location":"guides/logging/#log-levels","title":"Log Levels","text":""},{"location":"guides/logging/#available-levels","title":"Available Levels","text":"<pre><code>// Verbose - detailed information\nlogger.verbose(\"Entering backup loop\")\n\n// Debug - debugging information\nlogger.debug(\"Processing file: \\(filename)\")\n\n// Info - general information\nlogger.info(\"Backup completed successfully\")\n\n// Warning - potential issues\nlogger.warning(\"Repository space low\")\n\n// Error - operation failures\nlogger.error(\"Failed to store credential\")\n\n// Critical - system-wide issues\nlogger.critical(\"Database corruption detected\")\n</code></pre>"},{"location":"guides/logging/#best-practices","title":"Best Practices","text":""},{"location":"guides/logging/#1-log-level-selection","title":"1. Log Level Selection","text":"<pre><code>// Development\n#if DEBUG\n    UmbraLogger.configure(level: .debug)\n#else\n    UmbraLogger.configure(level: .info)\n#endif\n\n// Production with environment override\nif let levelString = Environment.logLevel {\n    UmbraLogger.configure(level: LogLevel(string: levelString))\n}\n</code></pre>"},{"location":"guides/logging/#2-contextual-information","title":"2. Contextual Information","text":"<pre><code>// Add operation context\nlogger.info(\"Starting backup\", metadata: [\n    \"operation\": \"backup\",\n    \"type\": \"incremental\",\n    \"source\": sourcePath,\n    \"destination\": destPath\n])\n\n// Add error context\nlogger.error(\"Operation failed\", metadata: [\n    \"operation\": operation.name,\n    \"duration\": duration,\n    \"retries\": retryCount,\n    \"error\": error.localizedDescription\n])\n</code></pre>"},{"location":"guides/logging/#3-sensitive-data","title":"3. Sensitive Data","text":"<pre><code>// Never log credentials\nlogger.info(\"Connecting to repository\", metadata: [\n    \"url\": repository.url,\n    \"type\": repository.type\n    // DON'T include passwords or keys\n])\n\n// Mask sensitive data\nlogger.info(\"User authenticated\", metadata: [\n    \"user\": user.id,\n    \"token\": \"****\" // Masked token\n])\n</code></pre>"},{"location":"guides/logging/#advanced-usage","title":"Advanced Usage","text":""},{"location":"guides/logging/#1-custom-destinations","title":"1. Custom Destinations","text":"<pre><code>let customDestination = LogDestination(\n    identifier: \"analytics\",\n    minimumLevel: .info,\n    formatter: AnalyticsFormatter()\n)\n\nUmbraLogger.addDestination(customDestination)\n</code></pre>"},{"location":"guides/logging/#2-custom-formatters","title":"2. Custom Formatters","text":"<pre><code>class JSONFormatter: LogFormatter {\n    func format(_ entry: LogEntry) -&gt; String {\n        let json: [String: Any] = [\n            \"timestamp\": entry.timestamp,\n            \"level\": entry.level.rawValue,\n            \"message\": entry.message,\n            \"metadata\": entry.metadata\n        ]\n        return try! JSONSerialization.data(withJSONObject: json)\n    }\n}\n</code></pre>"},{"location":"guides/logging/#3-context-managers","title":"3. Context Managers","text":"<pre><code>class OperationContext {\n    private var metadata: [String: Any]\n\n    func execute(_ operation: String) async throws {\n        logger.withMetadata(metadata) {\n            logger.info(\"Starting operation\")\n            // Execute operation\n            logger.info(\"Operation completed\")\n        }\n    }\n}\n</code></pre>"},{"location":"guides/logging/#integration-examples","title":"Integration Examples","text":""},{"location":"guides/logging/#1-service-integration","title":"1. Service Integration","text":"<pre><code>class BackupService {\n    private let logger = UmbraLogger.forModule(\"BackupService\")\n\n    func performBackup() async throws {\n        logger.info(\"Starting backup\", metadata: [\n            \"type\": backupType,\n            \"files\": fileCount\n        ])\n\n        do {\n            try await runBackup()\n            logger.info(\"Backup completed\")\n        } catch {\n            logger.error(\"Backup failed\", error: error)\n            throw error\n        }\n    }\n}\n</code></pre>"},{"location":"guides/logging/#2-error-tracking","title":"2. Error Tracking","text":"<pre><code>class ErrorTracker {\n    private let logger = UmbraLogger.forModule(\"ErrorTracker\")\n\n    func track(_ error: Error, context: [String: Any]) {\n        logger.error(\"Error occurred\", metadata: [\n            \"error\": error.localizedDescription,\n            \"type\": String(describing: type(of: error)),\n            \"context\": context\n        ])\n    }\n}\n</code></pre>"},{"location":"guides/logging/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guides/logging/#common-issues","title":"Common Issues","text":"<ol> <li> <p>Log File Management <pre><code>// Rotate log files\nUmbraLogger.configure(\n    fileConfig: FileConfiguration(\n        directory: logDirectory,\n        maxFileSize: 10_000_000,  // 10MB\n        maxFileCount: 5\n    )\n)\n</code></pre></p> </li> <li> <p>Performance Optimization <pre><code>// Avoid expensive logging in production\nif logger.isEnabled(for: .debug) {\n    let expensive = calculateExpensiveMetadata()\n    logger.debug(\"Details\", metadata: expensive)\n}\n</code></pre></p> </li> <li> <p>Error Investigation <pre><code>// Enable full debug logging temporarily\nUmbraLogger.configure(\n    level: .verbose,\n    destinations: [.console, .file],\n    metadata: [\"debug\": true]\n)\n</code></pre></p> </li> </ol>"},{"location":"guides/performance/","title":"Performance Optimisation in UmbraCore","text":""},{"location":"guides/performance/#overview","title":"Overview","text":"<p>Performance is crucial for backup operations. This guide covers performance optimisation techniques used in UmbraCore and best practices for maintaining high performance.</p>"},{"location":"guides/performance/#core-principles","title":"Core Principles","text":""},{"location":"guides/performance/#1-asynchronous-operations","title":"1. Asynchronous Operations","text":"<p>Leverage Swift's async/await for non-blocking operations:</p> <pre><code>actor BackupCoordinator {\n    func backupMultipleDirectories(_ paths: [String]) async throws {\n        try await withThrowingTaskGroup(of: Void.self) { group in\n            for path in paths {\n                group.addTask {\n                    try await backupDirectory(path)\n                }\n            }\n            try await group.waitForAll()\n        }\n    }\n}\n</code></pre>"},{"location":"guides/performance/#2-memory-management","title":"2. Memory Management","text":"<p>Efficient memory usage patterns:</p> <pre><code>actor StreamProcessor {\n    // Use streams for large data\n    func processLargeFile(_ url: URL) async throws {\n        for try await line in url.lines {\n            try await processLine(line)\n        }\n    }\n\n    // Batch small operations\n    func processBatch(_ items: [Item]) async throws {\n        let batchSize = 100\n        for batch in items.chunked(into: batchSize) {\n            try await processBatchItems(batch)\n        }\n    }\n}\n</code></pre>"},{"location":"guides/performance/#3-resource-pooling","title":"3. Resource Pooling","text":"<p>Pool and reuse expensive resources:</p> <pre><code>actor ConnectionPool {\n    private var connections: [Connection] = []\n    private let maxConnections = 10\n\n    func acquire() async throws -&gt; Connection {\n        if let connection = connections.popLast() {\n            return connection\n        }\n\n        guard connections.count &lt; maxConnections else {\n            throw PoolError.maxConnectionsReached\n        }\n\n        return try await createConnection()\n    }\n\n    func release(_ connection: Connection) async {\n        if connections.count &lt; maxConnections {\n            connections.append(connection)\n        } else {\n            await connection.close()\n        }\n    }\n}\n</code></pre>"},{"location":"guides/performance/#optimisation-techniques","title":"Optimisation Techniques","text":""},{"location":"guides/performance/#1-caching","title":"1. Caching","text":"<p>Implement efficient caching strategies:</p> <pre><code>actor CacheManager {\n    private var cache = NSCache&lt;NSString, AnyObject&gt;()\n    private let fileManager = FileManager.default\n\n    func cachedValue(\n        forKey key: String,\n        generator: () async throws -&gt; Any\n    ) async throws -&gt; Any {\n        // Check memory cache\n        if let cached = cache.object(forKey: key as NSString) {\n            return cached\n        }\n\n        // Generate new value\n        let value = try await generator()\n        cache.setObject(value as AnyObject, forKey: key as NSString)\n        return value\n    }\n\n    func clearStaleEntries() async {\n        // Implement cache eviction policy\n    }\n}\n</code></pre>"},{"location":"guides/performance/#2-data-structures","title":"2. Data Structures","text":"<p>Choose appropriate data structures:</p> <pre><code>struct PerformanceOptimised {\n    // Use Set for fast lookups\n    private var processedItems: Set&lt;String&gt; = []\n\n    // Use Dictionary for O(1) access\n    private var itemCache: [String: Item] = [:]\n\n    // Use Array for ordered data\n    private var processingQueue: [Item] = []\n\n    // Use ContiguousArray for better performance with value types\n    private var metrics: ContiguousArray&lt;Double&gt; = []\n}\n</code></pre>"},{"location":"guides/performance/#3-lazy-loading","title":"3. Lazy Loading","text":"<p>Defer expensive operations:</p> <pre><code>class LazyResource {\n    private lazy var expensiveResource: Resource = {\n        createExpensiveResource()\n    }()\n\n    private func createExpensiveResource() -&gt; Resource {\n        // Only created when first accessed\n        Resource(configuration: loadConfiguration())\n    }\n}\n</code></pre>"},{"location":"guides/performance/#performance-monitoring","title":"Performance Monitoring","text":""},{"location":"guides/performance/#1-metrics-collection","title":"1. Metrics Collection","text":"<p>Track performance metrics:</p> <pre><code>actor PerformanceMonitor {\n    private var metrics: [String: [TimeInterval]] = [:]\n\n    func measure&lt;T&gt;(\n        operation: String,\n        block: () async throws -&gt; T\n    ) async throws -&gt; T {\n        let start = ProcessInfo.processInfo.systemUptime\n        let result = try await block()\n        let duration = ProcessInfo.processInfo.systemUptime - start\n\n        await record(operation: operation, duration: duration)\n        return result\n    }\n\n    private func record(operation: String, duration: TimeInterval) {\n        metrics[operation, default: []].append(duration)\n\n        if metrics[operation]?.count ?? 0 &gt; 1000 {\n            metrics[operation]?.removeFirst(500)\n        }\n    }\n\n    func getMetrics(for operation: String) -&gt; PerformanceMetrics {\n        guard let measurements = metrics[operation] else {\n            return PerformanceMetrics.empty\n        }\n\n        return PerformanceMetrics(\n            average: measurements.average,\n            median: measurements.median,\n            percentile95: measurements.percentile(95),\n            count: measurements.count\n        )\n    }\n}\n</code></pre>"},{"location":"guides/performance/#2-performance-logging","title":"2. Performance Logging","text":"<p>Log performance data:</p> <pre><code>extension Logger {\n    func logPerformance(\n        _ metrics: PerformanceMetrics,\n        operation: String,\n        file: String = #file,\n        function: String = #function\n    ) {\n        info(\n            \"Performance metrics\",\n            metadata: [\n                \"operation\": \"\\(operation)\",\n                \"average\": \"\\(metrics.average)\",\n                \"median\": \"\\(metrics.median)\",\n                \"p95\": \"\\(metrics.percentile95)\",\n                \"count\": \"\\(metrics.count)\",\n                \"file\": \"\\(file)\",\n                \"function\": \"\\(function)\"\n            ]\n        )\n    }\n}\n</code></pre>"},{"location":"guides/performance/#3-alerts-and-thresholds","title":"3. Alerts and Thresholds","text":"<p>Monitor performance thresholds:</p> <pre><code>actor PerformanceAlert {\n    private let thresholds: [String: TimeInterval]\n    private let notifier: AlertNotifier\n\n    func checkThresholds(_ metrics: PerformanceMetrics, operation: String) async {\n        guard let threshold = thresholds[operation] else { return }\n\n        if metrics.percentile95 &gt; threshold {\n            await notifier.alert(\n                \"\"\"\n                Performance degradation detected:\n                Operation: \\(operation)\n                P95: \\(metrics.percentile95)\n                Threshold: \\(threshold)\n                \"\"\"\n            )\n        }\n    }\n}\n</code></pre>"},{"location":"guides/performance/#best-practices","title":"Best Practices","text":""},{"location":"guides/performance/#1-batch-processing","title":"1. Batch Processing","text":"<p>Batch operations for efficiency:</p> <pre><code>actor BatchProcessor {\n    private let batchSize = 100\n\n    func process(_ items: [Item]) async throws {\n        let batches = items.chunked(into: batchSize)\n\n        try await withThrowingTaskGroup(of: Void.self) { group in\n            for batch in batches {\n                group.addTask {\n                    try await processBatch(batch)\n                }\n            }\n            try await group.waitForAll()\n        }\n    }\n}\n</code></pre>"},{"location":"guides/performance/#2-resource-management","title":"2. Resource Management","text":"<p>Proper resource cleanup:</p> <pre><code>class ManagedResource {\n    private var resources: [Resource] = []\n\n    func use&lt;T&gt;(_ resource: Resource, operation: (Resource) throws -&gt; T) throws -&gt; T {\n        resources.append(resource)\n        defer {\n            resource.cleanup()\n            resources.removeAll { $0 === resource }\n        }\n        return try operation(resource)\n    }\n}\n</code></pre>"},{"location":"guides/performance/#3-background-processing","title":"3. Background Processing","text":"<p>Offload heavy work:</p> <pre><code>actor BackgroundProcessor {\n    private let queue = DispatchQueue(\n        label: \"com.umbracore.background\",\n        qos: .background\n    )\n\n    func processInBackground(_ work: @escaping () -&gt; Void) {\n        queue.async {\n            work()\n        }\n    }\n}\n</code></pre>"},{"location":"guides/performance/#testing","title":"Testing","text":""},{"location":"guides/performance/#1-performance-tests","title":"1. Performance Tests","text":"<p>Test performance metrics:</p> <pre><code>class PerformanceTests: XCTestCase {\n    func testOperationPerformance() throws {\n        measure {\n            // Performance-critical code\n        }\n    }\n\n    func testAsyncPerformance() async throws {\n        let metrics = try await measureAsync {\n            try await performOperation()\n        }\n\n        XCTAssertLessThan(metrics.average, 0.1)\n        XCTAssertLessThan(metrics.percentile95, 0.2)\n    }\n}\n</code></pre>"},{"location":"guides/performance/#2-memory-tests","title":"2. Memory Tests","text":"<p>Test memory usage:</p> <pre><code>class MemoryTests: XCTestCase {\n    func testMemoryUsage() throws {\n        let tracker = MemoryTracker()\n\n        autoreleasepool {\n            // Memory-intensive operation\n        }\n\n        XCTAssertLessThan(\n            tracker.peakMemoryUsage,\n            50 * 1024 * 1024 // 50MB\n        )\n    }\n}\n</code></pre>"},{"location":"guides/performance/#3-load-tests","title":"3. Load Tests","text":"<p>Test under load:</p> <p>```swift class LoadTests: XCTestCase {     func testConcurrentOperations() async throws {         let operations = 1000         let service = TestService()</p> <pre><code>    try await withThrowingTaskGroup(of: Void.self) { group in\n        for _ in 0..&lt;operations {\n            group.addTask {\n                try await service.operation()\n            }\n        }\n        try await group.waitForAll()\n    }\n}\n</code></pre> <p>}</p>"},{"location":"guides/security/","title":"Security Guidelines","text":"<p>This guide outlines security best practices for using UmbraCore.</p>"},{"location":"guides/security/#core-principles","title":"Core Principles","text":"<ol> <li>Least Privilege: Only request necessary permissions</li> <li>Data Protection: Secure all sensitive data</li> <li>Secure Communication: Use encrypted channels</li> <li>Audit Logging: Track security-relevant events</li> </ol>"},{"location":"guides/security/#secure-storage","title":"Secure Storage","text":""},{"location":"guides/security/#password-storage","title":"Password Storage","text":"<ul> <li>Use <code>SecureString</code> for passwords</li> <li>Implement proper password policies</li> <li>Use secure key derivation</li> </ul>"},{"location":"guides/security/#repository-encryption","title":"Repository Encryption","text":"<ul> <li>Use strong encryption keys</li> <li>Implement key rotation</li> <li>Secure key storage</li> </ul>"},{"location":"guides/security/#network-security","title":"Network Security","text":""},{"location":"guides/security/#remote-repositories","title":"Remote Repositories","text":"<ul> <li>Use SSH or HTTPS</li> <li>Validate certificates</li> <li>Implement rate limiting</li> <li>Handle network errors securely</li> </ul>"},{"location":"guides/security/#api-security","title":"API Security","text":"<ul> <li>Use API tokens securely</li> <li>Implement request signing</li> <li>Validate all inputs</li> </ul>"},{"location":"guides/security/#error-handling","title":"Error Handling","text":""},{"location":"guides/security/#security-errors","title":"Security Errors","text":"<ul> <li>Log security events</li> <li>Don't expose sensitive data</li> <li>Implement proper error recovery</li> </ul>"},{"location":"guides/security/#access-control","title":"Access Control","text":"<ul> <li>Validate permissions</li> <li>Check file access rights</li> <li>Handle access denied errors</li> </ul>"},{"location":"guides/security/#best-practices","title":"Best Practices","text":"<ol> <li>Keep dependencies updated</li> <li>Regular security audits</li> <li>Follow cryptographic best practices</li> <li>Implement proper logging</li> <li>Regular penetration testing</li> </ol>"},{"location":"guides/thread-safety/","title":"Thread Safety in UmbraCore","text":""},{"location":"guides/thread-safety/#overview","title":"Overview","text":"<p>UmbraCore is designed to be thread-safe by default. All public APIs can be safely called from multiple threads concurrently. This guide explains our thread safety guarantees and best practices.</p>"},{"location":"guides/thread-safety/#core-principles","title":"Core Principles","text":""},{"location":"guides/thread-safety/#1-actor-based-services","title":"1. Actor-Based Services","text":"<p>All core services in UmbraCore use Swift's actor system to ensure thread safety:</p> <pre><code>actor KeychainService {\n    private var cache: [String: Data] = [:]\n\n    func store(_ data: Data, forKey key: String) async throws {\n        // Thread-safe access to cache\n        cache[key] = data\n        try await persistToKeychain(data, key)\n    }\n}\n</code></pre>"},{"location":"guides/thread-safety/#2-immutable-state","title":"2. Immutable State","text":"<p>We prefer immutable state to minimize synchronization needs:</p> <pre><code>struct BackupConfig {\n    // Immutable properties\n    let sourcePath: String\n    let destinationPath: String\n    let excludePatterns: [String]\n\n    // Instead of mutating, create new instance\n    func withExcludePattern(_ pattern: String) -&gt; BackupConfig {\n        var patterns = excludePatterns\n        patterns.append(pattern)\n        return BackupConfig(\n            sourcePath: sourcePath,\n            destinationPath: destinationPath,\n            excludePatterns: patterns\n        )\n    }\n}\n</code></pre>"},{"location":"guides/thread-safety/#3-synchronized-collections","title":"3. Synchronized Collections","text":"<p>When mutable state is necessary, we use synchronized collections:</p> <pre><code>actor CacheManager {\n    private var cache = [String: Any]()\n    private let queue = DispatchQueue(label: \"com.umbracore.cache\")\n\n    func set(_ value: Any, forKey key: String) {\n        queue.sync { cache[key] = value }\n    }\n\n    func get(_ key: String) -&gt; Any? {\n        queue.sync { cache[key] }\n    }\n}\n</code></pre>"},{"location":"guides/thread-safety/#best-practices","title":"Best Practices","text":""},{"location":"guides/thread-safety/#1-asyncawait-usage","title":"1. Async/Await Usage","text":"<p>Always use async/await for asynchronous operations:</p> <pre><code>// Good\nfunc backupFiles() async throws {\n    try await prepareBackup()\n    try await performBackup()\n    try await cleanup()\n}\n\n// Avoid\nfunc backupFiles(completion: @escaping (Error?) -&gt; Void) {\n    prepareBackup { error in\n        guard error == nil else {\n            completion(error)\n            return\n        }\n        // Callback hell continues...\n    }\n}\n</code></pre>"},{"location":"guides/thread-safety/#2-resource-access","title":"2. Resource Access","text":"<p>Use proper resource access patterns:</p> <pre><code>actor ResourceManager {\n    private var isLocked = false\n\n    func acquireResource() async throws {\n        guard !isLocked else {\n            throw ResourceError.alreadyLocked\n        }\n        isLocked = true\n    }\n\n    func releaseResource() {\n        isLocked = false\n    }\n}\n</code></pre>"},{"location":"guides/thread-safety/#3-shared-state","title":"3. Shared State","text":"<p>Minimize shared state, use message passing:</p> <pre><code>actor BackupCoordinator {\n    private var activeBackups: Set&lt;UUID&gt; = []\n\n    func startBackup() async throws -&gt; UUID {\n        let id = UUID()\n        activeBackups.insert(id)\n        return id\n    }\n\n    func completeBackup(_ id: UUID) {\n        activeBackups.remove(id)\n    }\n}\n</code></pre>"},{"location":"guides/thread-safety/#common-patterns","title":"Common Patterns","text":""},{"location":"guides/thread-safety/#1-double-checked-locking","title":"1. Double-Checked Locking","text":"<p>For expensive initialization:</p> <pre><code>actor ConfigurationManager {\n    private var config: Configuration?\n\n    func getConfiguration() async throws -&gt; Configuration {\n        if let existing = config {\n            return existing\n        }\n\n        let loaded = try await loadConfiguration()\n        config = loaded\n        return loaded\n    }\n}\n</code></pre>"},{"location":"guides/thread-safety/#2-reader-writer-pattern","title":"2. Reader-Writer Pattern","text":"<p>For concurrent read access:</p> <pre><code>actor DatabaseManager {\n    private var isWriting = false\n    private var activeReaders = 0\n\n    func read() async throws -&gt; Data {\n        while isWriting {\n            try await Task.sleep(nanoseconds: 100_000)\n        }\n        activeReaders += 1\n        defer { activeReaders -= 1 }\n        return try getData()\n    }\n\n    func write(_ data: Data) async throws {\n        while activeReaders &gt; 0 {\n            try await Task.sleep(nanoseconds: 100_000)\n        }\n        isWriting = true\n        defer { isWriting = false }\n        try await writeData(data)\n    }\n}\n</code></pre>"},{"location":"guides/thread-safety/#3-task-management","title":"3. Task Management","text":"<p>For concurrent operations:</p> <pre><code>class BackupTask {\n    func executeParallel(_ operations: [Operation]) async throws {\n        try await withThrowingTaskGroup(of: Void.self) { group in\n            for operation in operations {\n                group.addTask {\n                    try await operation.execute()\n                }\n            }\n            try await group.waitForAll()\n        }\n    }\n}\n</code></pre>"},{"location":"guides/thread-safety/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guides/thread-safety/#1-deadlock-prevention","title":"1. Deadlock Prevention","text":"<pre><code>actor Service {\n    // Avoid nested actor calls\n    func operation1() async {\n        await operation2() // Could deadlock if not careful\n    }\n\n    func operation2() async {\n        // Implementation\n    }\n}\n\n// Better approach\nactor Service {\n    func operation1() async {\n        // Execute independently\n        try await Task.sleep(nanoseconds: 100_000)\n        await operation2()\n    }\n}\n</code></pre>"},{"location":"guides/thread-safety/#2-race-condition-detection","title":"2. Race Condition Detection","text":"<pre><code>actor StateManager {\n    private var state: State\n    private var version: UInt64 = 0\n\n    func modify(_ change: (State) -&gt; State) async {\n        let currentVersion = version\n        state = change(state)\n\n        // Detect concurrent modifications\n        guard version == currentVersion else {\n            throw ConcurrencyError.stateModified\n        }\n        version += 1\n    }\n}\n</code></pre>"},{"location":"guides/thread-safety/#3-performance-issues","title":"3. Performance Issues","text":"<pre><code>actor PerformanceOptimized {\n    // Batch operations to reduce actor hops\n    func batchOperation(_ items: [Item]) async {\n        // Single actor hop for batch\n        items.forEach { process($0) }\n    }\n\n    // Avoid frequent actor hops\n    private func process(_ item: Item) {\n        // Local processing\n    }\n}\n</code></pre>"},{"location":"guides/thread-safety/#testing","title":"Testing","text":""},{"location":"guides/thread-safety/#1-concurrency-testing","title":"1. Concurrency Testing","text":"<pre><code>func testConcurrentAccess() async throws {\n    let service = SharedService()\n\n    try await withThrowingTaskGroup(of: Void.self) { group in\n        for _ in 0..&lt;100 {\n            group.addTask {\n                try await service.operation()\n            }\n        }\n        try await group.waitForAll()\n    }\n}\n</code></pre>"},{"location":"guides/thread-safety/#2-race-condition-testing","title":"2. Race Condition Testing","text":"<p>```swift func testRaceConditions() async throws {     let service = SharedService()</p> <pre><code>async let operation1 = service.modify()\nasync let operation2 = service.modify()\n\n// This should handle concurrent modifications gracefully\ntry await [operation1, operation2]\n</code></pre> <p>}</p>"},{"location":"guides/xpc/","title":"UmbraXPC Guide","text":""},{"location":"guides/xpc/#overview","title":"Overview","text":"<p><code>UmbraXPC</code> provides a secure inter-process communication layer for UmbraCore services. It enables privilege separation and sandboxing while maintaining type safety and async/await support.</p>"},{"location":"guides/xpc/#features","title":"Features","text":"<ul> <li>Secure IPC communication</li> <li>Type-safe protocols</li> <li>Async/await support</li> <li>Error handling</li> <li>Privilege separation</li> </ul>"},{"location":"guides/xpc/#basic-usage","title":"Basic Usage","text":""},{"location":"guides/xpc/#service-definition","title":"Service Definition","text":"<pre><code>// Define XPC protocol\n@objc protocol KeychainXPCProtocol {\n    func store(password: String, forKey: String) async throws\n    func retrieve(forKey: String) async throws -&gt; String\n    func remove(forKey: String) async throws\n}\n\n// Implement service\nclass KeychainXPCService: NSObject, KeychainXPCProtocol {\n    func store(password: String, forKey: String) async throws {\n        // Implementation\n    }\n\n    // Other implementations...\n}\n</code></pre>"},{"location":"guides/xpc/#service-registration","title":"Service Registration","text":"<pre><code>// Register service\nlet service = XPCService(\n    service: KeychainXPCService(),\n    protocol: KeychainXPCProtocol.self\n)\n\ntry await service.register()\n</code></pre>"},{"location":"guides/xpc/#client-usage","title":"Client Usage","text":"<pre><code>// Connect to service\nlet client = try XPCClient&lt;KeychainXPCProtocol&gt;()\n\n// Use service\ntry await client.store(password: \"secret\", forKey: \"key\")\nlet value = try await client.retrieve(forKey: \"key\")\n</code></pre>"},{"location":"guides/xpc/#error-handling","title":"Error Handling","text":"<pre><code>do {\n    try await client.store(password: \"secret\", forKey: \"key\")\n} catch XPCError.connectionFailed {\n    // Handle connection failure\n} catch XPCError.serviceStopped {\n    // Handle service stop\n} catch {\n    // Handle other errors\n}\n</code></pre>"},{"location":"guides/xpc/#best-practices","title":"Best Practices","text":""},{"location":"guides/xpc/#1-protocol-design","title":"1. Protocol Design","text":"<pre><code>// Good protocol design\n@objc protocol BackupXPCProtocol {\n    // Clear operation names\n    func startBackup(source: URL, destination: URL) async throws\n\n    // Specific error types\n    func checkAccess(path: String) async throws -&gt; Bool\n\n    // Progress reporting\n    func getProgress() async throws -&gt; Double\n}\n</code></pre>"},{"location":"guides/xpc/#2-error-handling","title":"2. Error Handling","text":"<pre><code>// Define specific errors\nenum BackupXPCError: Error {\n    case accessDenied(String)\n    case insufficientSpace(needed: UInt64, available: UInt64)\n    case connectionLost\n}\n\n// Handle errors appropriately\ndo {\n    try await service.startBackup(source: src, destination: dest)\n} catch BackupXPCError.accessDenied(let path) {\n    // Handle access denied\n} catch BackupXPCError.insufficientSpace(let needed, let available) {\n    // Handle space issues\n}\n</code></pre>"},{"location":"guides/xpc/#3-resource-management","title":"3. Resource Management","text":"<pre><code>// Proper cleanup\nclass XPCManager {\n    private var client: XPCClient&lt;BackupXPCProtocol&gt;?\n\n    func shutdown() async {\n        await client?.disconnect()\n        client = nil\n    }\n}\n</code></pre>"},{"location":"guides/xpc/#advanced-usage","title":"Advanced Usage","text":""},{"location":"guides/xpc/#1-custom-message-handling","title":"1. Custom Message Handling","text":"<pre><code>class CustomXPCService: XPCServiceDelegate {\n    func handleCustomMessage(_ message: [String: Any]) async throws -&gt; Any {\n        // Custom message handling\n        switch message[\"type\"] as? String {\n        case \"status\":\n            return await getStatus()\n        case \"control\":\n            return try await handleControl(message)\n        default:\n            throw XPCError.invalidMessage\n        }\n    }\n}\n</code></pre>"},{"location":"guides/xpc/#2-progress-reporting","title":"2. Progress Reporting","text":"<pre><code>protocol ProgressReporting {\n    func reportProgress(_ progress: Double) async\n}\n\nclass BackupXPCService: ProgressReporting {\n    private var progress: Double = 0\n\n    func reportProgress(_ progress: Double) async {\n        self.progress = progress\n        await notifyObservers()\n    }\n}\n</code></pre>"},{"location":"guides/xpc/#3-connection-management","title":"3. Connection Management","text":"<pre><code>class XPCConnectionManager {\n    private var connections: [String: XPCClient&lt;Any&gt;] = [:]\n\n    func getConnection&lt;T&gt;(_ type: T.Type) async throws -&gt; XPCClient&lt;T&gt; {\n        let id = String(describing: type)\n\n        if let existing = connections[id] as? XPCClient&lt;T&gt; {\n            return existing\n        }\n\n        let new = try XPCClient&lt;T&gt;()\n        connections[id] = new\n        return new\n    }\n}\n</code></pre>"},{"location":"guides/xpc/#integration-examples","title":"Integration Examples","text":""},{"location":"guides/xpc/#1-backup-service","title":"1. Backup Service","text":"<pre><code>class BackupManager {\n    private let xpc: XPCClient&lt;BackupXPCProtocol&gt;\n\n    func startBackup() async throws {\n        // Connect to XPC service\n        try await xpc.connect()\n\n        // Start backup operation\n        try await xpc.startBackup(\n            source: sourceURL,\n            destination: destURL\n        )\n\n        // Monitor progress\n        for await progress in xpc.progressUpdates() {\n            updateUI(progress)\n        }\n    }\n}\n</code></pre>"},{"location":"guides/xpc/#2-security-service","title":"2. Security Service","text":"<pre><code>class SecurityManager {\n    private let xpc: XPCClient&lt;SecurityXPCProtocol&gt;\n\n    func validateAccess() async throws -&gt; Bool {\n        try await xpc.withConnection { service in\n            try await service.checkSecurity([\n                \"operation\": \"backup\",\n                \"level\": \"system\"\n            ])\n        }\n    }\n}\n</code></pre>"},{"location":"guides/xpc/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guides/xpc/#common-issues","title":"Common Issues","text":"<ol> <li> <p>Connection Issues <pre><code>// Implement retry logic\nfunc connectWithRetry() async throws -&gt; XPCClient&lt;T&gt; {\n    var attempts = 0\n    while attempts &lt; 3 {\n        do {\n            return try await XPCClient&lt;T&gt;().connect()\n        } catch {\n            attempts += 1\n            try await Task.sleep(nanoseconds: 1_000_000_000)\n        }\n    }\n    throw XPCError.connectionFailed\n}\n</code></pre></p> </li> <li> <p>Service Recovery <pre><code>// Handle service interruption\nfunc handleServiceFailure() async throws {\n    try await xpc.disconnect()\n    try await Task.sleep(nanoseconds: 1_000_000_000)\n    try await xpc.connect()\n}\n</code></pre></p> </li> <li> <p>Resource Cleanup <pre><code>// Proper resource management\nclass XPCResource {\n    private var resources: Set&lt;XPCClient&lt;Any&gt;&gt; = []\n\n    func cleanup() async {\n        for resource in resources {\n            await resource.disconnect()\n        }\n        resources.removeAll()\n    }\n}\n</code></pre></p> </li> </ol>"},{"location":"security/SECURITY_GUIDELINES/","title":"Security Guidelines","text":""},{"location":"security/SECURITY_GUIDELINES/#overview","title":"Overview","text":"<p>UmbraCore handles sensitive data and requires careful attention to security. This guide outlines our security practices and requirements.</p>"},{"location":"security/SECURITY_GUIDELINES/#secure-storage","title":"Secure Storage","text":""},{"location":"security/SECURITY_GUIDELINES/#1-credentials","title":"1. Credentials","text":"<ul> <li>Always use <code>UmbraKeychainService</code> for storing:</li> <li>Repository passwords</li> <li>API keys</li> <li>Access tokens</li> <li>SSH keys</li> </ul> <pre><code>// DO THIS:\ntry await keychainService.store(password: \"secret\", forKey: \"repo-key\")\n\n// DON'T DO THIS:\nUserDefaults.standard.set(\"secret\", forKey: \"repo-key\") // UNSAFE!\n</code></pre>"},{"location":"security/SECURITY_GUIDELINES/#2-file-system-access","title":"2. File System Access","text":"<ul> <li>Use <code>UmbraBookmarkService</code> for persistent file access</li> <li>Never store raw file paths</li> <li>Always use security-scoped bookmarks</li> </ul>"},{"location":"security/SECURITY_GUIDELINES/#encryption","title":"Encryption","text":""},{"location":"security/SECURITY_GUIDELINES/#1-data-at-rest","title":"1. Data at Rest","text":"<ul> <li>All sensitive data must be encrypted</li> <li>Use <code>UmbraCryptoService</code> for encryption/decryption</li> <li>Never store encryption keys in code</li> </ul>"},{"location":"security/SECURITY_GUIDELINES/#2-data-in-transit","title":"2. Data in Transit","text":"<ul> <li>Use secure transport (HTTPS, SSH)</li> <li>Validate certificates</li> <li>Implement proper error handling</li> </ul>"},{"location":"security/SECURITY_GUIDELINES/#access-control","title":"Access Control","text":""},{"location":"security/SECURITY_GUIDELINES/#1-xpc-services","title":"1. XPC Services","text":"<ul> <li>Principle of least privilege</li> <li>Separate process for sensitive operations</li> <li>Validate all inputs</li> </ul>"},{"location":"security/SECURITY_GUIDELINES/#2-file-permissions","title":"2. File Permissions","text":"<ul> <li>Respect system permissions</li> <li>Use security-scoped resources</li> <li>Clean up temporary files</li> </ul>"},{"location":"security/SECURITY_GUIDELINES/#logging","title":"Logging","text":""},{"location":"security/SECURITY_GUIDELINES/#1-sensitive-data","title":"1. Sensitive Data","text":"<ul> <li>Never log credentials</li> <li>Mask sensitive information</li> <li>Use appropriate log levels</li> </ul>"},{"location":"security/SECURITY_GUIDELINES/#2-audit-trail","title":"2. Audit Trail","text":"<ul> <li>Log security-relevant events</li> <li>Include necessary context</li> <li>Maintain audit logs</li> </ul>"},{"location":"security/SECURITY_GUIDELINES/#error-handling","title":"Error Handling","text":""},{"location":"security/SECURITY_GUIDELINES/#1-security-errors","title":"1. Security Errors","text":"<ul> <li>Don't expose internal details</li> <li>Provide appropriate user feedback</li> <li>Log security failures</li> </ul>"},{"location":"security/SECURITY_GUIDELINES/#2-recovery","title":"2. Recovery","text":"<ul> <li>Implement secure fallbacks</li> <li>Clean up on failure</li> <li>Maintain system integrity</li> </ul>"},{"location":"security/SECURITY_GUIDELINES/#best-practices","title":"Best Practices","text":""},{"location":"security/SECURITY_GUIDELINES/#1-code","title":"1. Code","text":"<ul> <li>Use Swift's type safety</li> <li>Implement input validation</li> <li>Follow OWASP guidelines</li> </ul>"},{"location":"security/SECURITY_GUIDELINES/#2-testing","title":"2. Testing","text":"<ul> <li>Include security test cases</li> <li>Test error conditions</li> <li>Verify security boundaries</li> </ul>"},{"location":"security/SECURITY_GUIDELINES/#3-dependencies","title":"3. Dependencies","text":"<ul> <li>Regular security updates</li> <li>Vulnerability scanning</li> <li>Dependency pinning</li> </ul>"}]}