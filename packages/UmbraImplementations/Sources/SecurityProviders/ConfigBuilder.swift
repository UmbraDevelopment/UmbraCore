/**
 # UmbraCore Security Configuration Builder

 This file provides functionality for creating and validating security configurations
 used in the UmbraCore security framework. It handles the conversion of options from
 various formats into properly structured SecurityConfigDTO objects.

 ## Responsibilities

 * Create properly configured SecurityConfigDTO objects
 * Apply sensible defaults for unspecified configuration options
 * Validate configuration parameters
 * Convert between different data formats for configuration options

 ## Usage

 The ConfigBuilder is typically used by the SecurityProvider to create configurations
 based on user-provided options. It handles the complexities of parameter validation
 and ensures that all required options are present with appropriate defaults.
 */

import CoreSecurityTypes
import DomainSecurityTypes
import Foundation
import SecurityCoreInterfaces
import UmbraErrors

/// Builds and validates security configurations
///
/// ConfigBuilder is responsible for creating properly structured security configurations
/// from raw options dictionaries, applying appropriate defaults, and ensuring parameter
/// validity.
final class ConfigBuilder {
  // MARK: - Initialisation

  /// Creates a new ConfigBuilder instance
  init() {
    // No initialisation needed - stateless service
  }

  // MARK: - Configuration Building

  /**
   Create a secure configuration with appropriate defaults for the security subsystem.

   - Parameter options: Optional dictionary of configuration options
   - Returns: A properly configured SecurityConfigDTO

   ## Available Options

   * `algorithm`: String - The encryption algorithm to use (default: "AES-GCM")
   * `keySize`: Int - The key size in bits (default: 256)
   * `iv`: String - Hex-encoded initialisation vector
   * `keyIdentifier`: String - Identifier for a key in the key manager
   * `inputData`: String - Base64-encoded input data

   ## Default Configuration

   If no options are provided, the method will return a configuration with:
   - Algorithm: AES-GCM
   - Key Size: 256 bits
   - No IV (a random one will be generated by the crypto service)
   - No key identifier (key must be provided separately)
   - No input data
   */
  func createConfig(options: [String: Any]?) -> SecurityConfigDTO {
    // Extract options from the dictionary or use defaults
    let algorithmString=options?["algorithm"] as? String ?? "AES-GCM"
    let _=options?["keySize"] as? Int ?? 256 // Key size is handled by the enum types now
    let hashAlgString=options?["hashAlgorithm"] as? String ?? "SHA-256"
    let providerString=options?["providerType"] as? String ?? "Basic"

    // Determine whether to enable detailed logging
    let enableDetailedLogging=options?["enableDetailedLogging"] as? Bool ?? false

    // Determine key derivation iterations
    let keyDerivationIterations=options?["keyDerivationIterations"] as? Int ?? 100_000

    // Determine memory limit for key derivation
    let memoryLimitBytes=options?["memoryLimitBytes"] as? Int ?? 65536

    // Determine whether to use hardware acceleration
    let useHardwareAcceleration=options?["useHardwareAcceleration"] as? Bool ?? true

    // Determine operation timeout
    let operationTimeoutSeconds=options?["operationTimeoutSeconds"] as? TimeInterval ?? 30.0

    // Determine whether to verify operations
    let verifyOperations=options?["verifyOperations"] as? Bool ?? true

    // Map to encryption algorithm enum
    var encryptionAlgorithm=CoreSecurityTypes.EncryptionAlgorithm.aes128CBC
    if algorithmString.contains("GCM") {
      encryptionAlgorithm = .aes128GCM
    } else if algorithmString.contains("Poly1305") || algorithmString.contains("ChaCha") {
      encryptionAlgorithm = .chacha20Poly1305
    }

    // Map to hash algorithm enum
    var hashAlgorithm=CoreSecurityTypes.HashAlgorithm.sha256
    if hashAlgString.contains("512") {
      hashAlgorithm = .sha512
    } else if hashAlgString.lowercased().contains("blake") {
      hashAlgorithm = .blake2b
    }

    // Map to provider type enum
    var providerType=SecurityProviderType.basic
    switch providerString.lowercased() {
      case "cryptokit":
        providerType = .cryptoKit
      case "ring":
        providerType = .ring
      case "system":
        providerType = .system
      case "hsm":
        providerType = .hsm
      default:
        providerType = .basic
    }

    // Create SecurityConfigOptions with the parsed values
    let configOptions=SecurityConfigOptions(
      enableDetailedLogging: enableDetailedLogging,
      keyDerivationIterations: keyDerivationIterations,
      memoryLimitBytes: memoryLimitBytes,
      useHardwareAcceleration: useHardwareAcceleration,
      operationTimeoutSeconds: operationTimeoutSeconds,
      verifyOperations: verifyOperations
    )

    // Create a configuration with the proper enum values and options
    return SecurityConfigDTO(
      encryptionAlgorithm: encryptionAlgorithm,
      hashAlgorithm: hashAlgorithm,
      providerType: providerType,
      options: configOptions
    )
  }

  // MARK: - Option Validation

  /**
   Validates a key size for a specific algorithm.

   - Parameters:
     - keySize: The key size in bits
     - algorithm: The encryption algorithm
   - Returns: True if the key size is valid for the algorithm
   */
  func isValidKeySize(_ keySize: Int, forAlgorithm algorithm: String) -> Bool {
    switch algorithm.uppercased() {
      case "AES":
        [128, 192, 256].contains(keySize)
      case "CHACHA20":
        keySize == 256
      case "RSA":
        [2048, 3072, 4096].contains(keySize)
      case "ECDSA", "ED25519":
        [256, 384, 521].contains(keySize)
      default:
        false
    }
  }
}

// Extension to provide convenience methods for SecurityConfigDTO
extension SecurityConfigDTO {
  /**
   Add an initialisation vector to the configuration.

   - Parameter iv: The initialisation vector to add
   - Returns: A new configuration with the IV added
   */
  func withInitialisationVector(_ iv: Data) -> SecurityConfigDTO {
    // Create a new options object if needed, or use the existing one
    var existingOptions=options ?? SecurityConfigOptions()

    // Store the IV data as a custom property in a metadata dictionary
    var customMetadata=existingOptions.metadata ?? [:]
    customMetadata["iv"]=iv.base64EncodedString()
    existingOptions.metadata=customMetadata

    // Create a new SecurityConfigDTO with updated options
    return SecurityConfigDTO(
      encryptionAlgorithm: encryptionAlgorithm,
      hashAlgorithm: hashAlgorithm,
      providerType: providerType,
      options: existingOptions
    )
  }

  /**
   Add input data to the configuration.

   - Parameter data: The input data to add
   - Returns: A new configuration with the data added
   */
  func withInputData(_ data: Data) -> SecurityConfigDTO {
    // Create a new options object if needed, or use the existing one
    var existingOptions=options ?? SecurityConfigOptions()

    // Store the data as a custom property in a metadata dictionary
    var customMetadata=existingOptions.metadata ?? [:]
    customMetadata["data"]=data.base64EncodedString()
    existingOptions.metadata=customMetadata

    // Create a new SecurityConfigDTO with updated options
    return SecurityConfigDTO(
      encryptionAlgorithm: encryptionAlgorithm,
      hashAlgorithm: hashAlgorithm,
      providerType: providerType,
      options: existingOptions
    )
  }

  /**
   Add a key to the configuration.

   - Parameter key: The key to add
   - Returns: A new configuration with the key added
   */
  func withKey(_ key: Data) -> SecurityConfigDTO {
    // Create a new options object if needed, or use the existing one
    var existingOptions=options ?? SecurityConfigOptions()

    // Store the key data as a custom property in a metadata dictionary
    var customMetadata=existingOptions.metadata ?? [:]
    customMetadata["key"]=key.base64EncodedString()
    existingOptions.metadata=customMetadata

    // Create a new SecurityConfigDTO with updated options
    return SecurityConfigDTO(
      encryptionAlgorithm: encryptionAlgorithm,
      hashAlgorithm: hashAlgorithm,
      providerType: providerType,
      options: existingOptions
    )
  }

  /**
   Add a key identifier to the configuration.

   - Parameter identifier: The key identifier to add
   - Returns: A new configuration with the key identifier added
   */
  func withKeyIdentifier(_ identifier: String) -> SecurityConfigDTO {
    // Create a new options object if needed, or use the existing one
    var existingOptions=options ?? SecurityConfigOptions()

    // Store the key identifier as a custom property in a metadata dictionary
    var customMetadata=existingOptions.metadata ?? [:]
    customMetadata["keyIdentifier"]=identifier
    existingOptions.metadata=customMetadata

    // Create a new SecurityConfigDTO with updated options
    return SecurityConfigDTO(
      encryptionAlgorithm: encryptionAlgorithm,
      hashAlgorithm: hashAlgorithm,
      providerType: providerType,
      options: existingOptions
    )
  }
}
