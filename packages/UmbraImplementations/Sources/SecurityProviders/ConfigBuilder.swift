/**
 # UmbraCore Security Configuration Builder

 This file provides functionality for creating and validating security configurations
 used in the UmbraCore security framework. It handles the conversion of options from
 various formats into properly structured SecurityConfigDTO objects.

 ## Responsibilities

 * Create properly configured SecurityConfigDTO objects
 * Apply sensible defaults for unspecified configuration options
 * Validate configuration parameters
 * Convert between different data formats for configuration options

 ## Usage

 The ConfigBuilder is typically used by the SecurityProvider to create configurations
 based on user-provided options. It handles the complexities of parameter validation
 and ensures that all required options are present with appropriate defaults.
 */

import Foundation
import SecurityCoreInterfaces
import SecurityCoreTypes
import SecurityTypes
import UmbraErrors

/// Builds and validates security configurations
///
/// ConfigBuilder is responsible for creating properly structured security configurations
/// from raw options dictionaries, applying appropriate defaults, and ensuring parameter
/// validity.
final class ConfigBuilder {
  // MARK: - Initialisation

  /// Creates a new ConfigBuilder instance
  init() {
    // No initialisation needed - stateless service
  }

  // MARK: - Configuration Building

  /**
   Create a secure configuration with appropriate defaults for the security subsystem.

   - Parameter options: Optional dictionary of configuration options
   - Returns: A properly configured SecurityConfigDTO

   ## Available Options

   * `algorithm`: String - The encryption algorithm to use (default: "AES-GCM")
   * `keySize`: Int - The key size in bits (default: 256)
   * `iv`: String - Hex-encoded initialisation vector
   * `keyIdentifier`: String - Identifier for a key in the key manager
   * `inputData`: String - Base64-encoded input data

   ## Default Configuration

   If no options are provided, the method will return a configuration with:
   - Algorithm: AES-GCM
   - Key Size: 256 bits
   - No IV (a random one will be generated by the crypto service)
   - No key identifier (key must be provided separately)
   - No input data
   */
  func createConfig(options: [String: Any]?) -> SecurityConfigDTO {
    // Extract options from the dictionary or use defaults
    let algorithmString = options?["algorithm"] as? String ?? "AES-GCM"
    let keySize = options?["keySize"] as? Int ?? 256
    
    // Parse algorithm and mode from the algorithm string
    var algorithm: SecurityConfigDTO.Algorithm = .aes
    var mode: SecurityConfigDTO.Mode? = .gcm
    
    // Handle parsing algorithm-mode combinations like "AES-GCM"
    if algorithmString.contains("-") {
      let components = algorithmString.split(separator: "-")
      if components.count >= 2 {
        // Try to parse the algorithm
        if let parsedAlgorithm = SecurityConfigDTO.Algorithm(rawValue: String(components[0])) {
          algorithm = parsedAlgorithm
        }
        
        // Try to parse the mode
        if let parsedMode = SecurityConfigDTO.Mode(rawValue: String(components[1])) {
          mode = parsedMode
        }
      }
    } else {
      // Handle single algorithm names without a mode
      if let parsedAlgorithm = SecurityConfigDTO.Algorithm(rawValue: algorithmString) {
        algorithm = parsedAlgorithm
      }
    }
    
    // Create a basic configuration with the correct initialiser parameters
    let config = SecurityConfigDTO(
      keySize: keySize,
      algorithm: algorithm,
      mode: mode
    )
    
    // Create a mutable options dictionary for our config
    var configOptions = config.options
    
    // Add any additional options that were provided
    if let ivHex = options?["iv"] as? String {
      if let ivData = Utilities.hexStringToData(ivHex) {
        // Convert [UInt8] to Data before using base64EncodedString
        let ivDataObj = Data(ivData)
        configOptions["initializationVector"] = ivDataObj.base64EncodedString()
      }
    }
    
    if let keyId = options?["keyIdentifier"] as? String {
      configOptions["keyIdentifier"] = keyId
    }
    
    if let inputB64 = options?["inputData"] as? String {
      configOptions["inputData"] = inputB64
    }
    
    // Create a new config with the updated options
    return SecurityConfigDTO(
      keySize: config.keySize,
      algorithm: config.algorithm,
      mode: config.mode,
      hashAlgorithm: config.hashAlgorithm,
      authenticationData: config.authenticationData,
      options: configOptions
    )
  }
}

// MARK: - Extension to SecurityConfigDTO for fluent configuration

/// Utility functions to add to the SecurityConfigDTO type
extension SecurityConfigDTO {
  /// Add an initialization vector to the configuration
  /// - Parameter iv: The initialization vector to add
  /// - Returns: A new configuration with the IV added
  func withInitializationVector(_ iv: SecureBytes) -> SecurityConfigDTO {
    // Convert IV to base64 string
    var bytes = [UInt8]()
    for i in 0..<iv.count {
      bytes.append(iv[i])
    }
    let ivBase64 = Data(bytes).base64EncodedString()
    
    // Add to options
    var newOptions = self.options
    newOptions["initializationVector"] = ivBase64
    
    // Return new configuration
    return SecurityConfigDTO(
      keySize: self.keySize,
      algorithm: self.algorithm,
      mode: self.mode,
      hashAlgorithm: self.hashAlgorithm,
      authenticationData: self.authenticationData,
      options: newOptions
    )
  }
  
  /// Add a key identifier to the configuration
  /// - Parameter keyId: The key identifier to add
  /// - Returns: A new configuration with the key identifier added
  func withKeyIdentifier(_ keyId: String) -> SecurityConfigDTO {
    // Add to options
    var newOptions = self.options
    newOptions["keyIdentifier"] = keyId
    
    // Return new configuration
    return SecurityConfigDTO(
      keySize: self.keySize,
      algorithm: self.algorithm,
      mode: self.mode,
      hashAlgorithm: self.hashAlgorithm,
      authenticationData: self.authenticationData,
      options: newOptions
    )
  }
  
  /// Add input data to the configuration
  /// - Parameter data: The input data to add
  /// - Returns: A new configuration with the input data added
  func withInputData(_ data: SecureBytes) -> SecurityConfigDTO {
    // Convert data to base64 string
    var bytes = [UInt8]()
    for i in 0..<data.count {
      bytes.append(data[i])
    }
    let dataBase64 = Data(bytes).base64EncodedString()
    
    // Add to options
    var newOptions = self.options
    newOptions["inputData"] = dataBase64
    
    // Return new configuration
    return SecurityConfigDTO(
      keySize: self.keySize,
      algorithm: self.algorithm,
      mode: self.mode,
      hashAlgorithm: self.hashAlgorithm,
      authenticationData: self.authenticationData,
      options: newOptions
    )
  }
  
  /// Get the input data from the configuration
  var inputData: SecureBytes? {
    guard let dataBase64 = options["inputData"],
          let data = Data(base64Encoded: dataBase64) else {
      return nil
    }
    
    return SecureBytes(bytes: [UInt8](data))
  }
}
