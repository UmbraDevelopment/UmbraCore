/**
 # UmbraCore Security Configuration Builder

 This file provides functionality for creating and validating security configurations
 used in the UmbraCore security framework. It handles the conversion of options from
 various formats into properly structured SecurityConfigDTO objects.

 ## Responsibilities

 * Create properly configured SecurityConfigDTO objects
 * Apply sensible defaults for unspecified configuration options
 * Validate configuration parameters
 * Convert between different data formats for configuration options

 ## Usage

 The ConfigBuilder is typically used by the SecurityProvider to create configurations
 based on user-provided options. It handles the complexities of parameter validation
 and ensures that all required options are present with appropriate defaults.
 */

import CoreSecurityTypes
import DomainSecurityTypes
import Foundation
import SecurityCoreInterfaces
import UmbraErrors

/// Builds and validates security configurations
///
/// ConfigBuilder is responsible for creating properly structured security configurations
/// from raw options dictionaries, applying appropriate defaults, and ensuring parameter
/// validity.
final class ConfigBuilder {
  // MARK: - Initialisation

  /// Creates a new ConfigBuilder instance
  init() {
    // No initialisation needed - stateless service
  }

  // MARK: - Configuration Building

  /**
   Create a secure configuration with appropriate defaults for the security subsystem.

   - Parameter options: Optional dictionary of configuration options
   - Returns: A properly configured SecurityConfigDTO

   ## Available Options

   * `algorithm`: String - The encryption algorithm to use (default: "AES-GCM")
   * `keySize`: Int - The key size in bits (default: 256)
   * `iv`: String - Hex-encoded initialisation vector
   * `keyIdentifier`: String - Identifier for a key in the key manager
   * `inputData`: String - Base64-encoded input data

   ## Default Configuration

   If no options are provided, the method will return a configuration with:
   - Algorithm: AES-GCM
   - Key Size: 256 bits
   - No IV (a random one will be generated by the crypto service)
   - No key identifier (key must be provided separately)
   - No input data
   */
  func createConfig(options: [String: Any]?) -> SecurityConfigDTO {
    // Extract options from the dictionary or use defaults
    let algorithmString=options?["algorithm"] as? String ?? "AES-GCM"
    let keySize=options?["keySize"] as? Int ?? 256

    // Parse algorithm and mode from the algorithm string
    var algorithm="AES"
    var mode: String?="GCM"

    // Handle parsing algorithm-mode combinations like "AES-GCM"
    if algorithmString.contains("-") {
      let components=algorithmString.split(separator: "-")
      if components.count >= 2 {
        // Set the algorithm and mode from the components
        algorithm=String(components[0])
        mode=String(components[1])
      }
    } else {
      // Handle single algorithm names without a mode
      algorithm=algorithmString

      // For RSA and other asymmetric algorithms, mode is not applicable
      if ["RSA", "ECDSA", "ED25519"].contains(algorithm) {
        mode=nil
      }
    }

    // Extract string options that should be passed to the configuration
    var configOptions: [String: String]=[:]

    // Process options and convert to appropriate types
    if let options {
      for (key, value) in options {
        if key != "algorithm" && key != "keySize" && key != "mode" {
          if let stringValue=value as? String {
            configOptions[key]=stringValue
          } else if let intValue=value as? Int {
            configOptions[key]=String(intValue)
          } else if let boolValue=value as? Bool {
            configOptions[key]=boolValue ? "true" : "false"
          } else if let dataValue=value as? Data {
            configOptions[key]=dataValue.base64EncodedString()
          }
        }
      }
    }

    // Create a configuration with the parsed values
    return SecurityConfigDTO(
      algorithm: algorithm,
      keySize: keySize,
      mode: mode,
      options: configOptions
    )
  }

  /**
   Validate security configuration parameters.

   - Parameter config: The configuration to validate
   - Returns: True if the configuration is valid, false otherwise
   */
  func validateConfig(_ config: SecurityConfigDTO) -> Bool {
    let algorithm=config.algorithm
    let keySize=config.keySize

    // Check for supported algorithms
    let supportedAlgorithms=["AES", "RSA", "ChaCha20", "ECDSA", "ED25519"]
    guard supportedAlgorithms.contains(algorithm) else {
      return false
    }

    // Validate key size based on algorithm
    switch algorithm {
      case "AES":
        return [128, 192, 256].contains(keySize)
      case "RSA":
        return [1024, 2048, 4096].contains(keySize)
      case "ChaCha20":
        return keySize == 256
      case "ECDSA":
        return [256, 384, 521].contains(keySize)
      case "ED25519":
        return keySize == 256
      default:
        return false
    }
  }
}

// MARK: - Extensions

extension SecurityConfigDTO {
  /**
   Add an initialisation vector to the configuration.

   - Parameter iv: The initialisation vector to add
   - Returns: A new configuration with the IV added
   */
  func withInitialisationVector(_ iv: Data) -> SecurityConfigDTO {
    var updatedOptions=options
    updatedOptions["iv"]=iv.base64EncodedString()

    return SecurityConfigDTO(
      algorithm: algorithm,
      keySize: keySize,
      mode: mode,
      hashAlgorithm: hashAlgorithm,
      options: updatedOptions
    )
  }

  /**
   Add a key identifier to the configuration.

   - Parameter keyId: The key identifier to add
   - Returns: A new configuration with the key identifier added
   */
  func withKeyIdentifier(_ keyID: String) -> SecurityConfigDTO {
    var updatedOptions=options
    updatedOptions["keyIdentifier"]=keyID

    return SecurityConfigDTO(
      algorithm: algorithm,
      keySize: keySize,
      mode: mode,
      hashAlgorithm: hashAlgorithm,
      options: updatedOptions
    )
  }

  /**
   Add input data to the configuration.

   - Parameter data: The input data to add
   - Returns: A new configuration with the input data added
   */
  func withInputData(_ data: Data) -> SecurityConfigDTO {
    var updatedOptions=options
    updatedOptions["inputData"]=data.base64EncodedString()

    return SecurityConfigDTO(
      algorithm: algorithm,
      keySize: keySize,
      mode: mode,
      hashAlgorithm: hashAlgorithm,
      options: updatedOptions
    )
  }

  /**
   Add authentication data to the configuration.

   - Parameter data: The authentication data to add
   - Returns: A new configuration with the authentication data added
   */
  func withAuthenticationData(_ data: Data) -> SecurityConfigDTO {
    var updatedOptions=options
    updatedOptions["authenticationData"]=data.base64EncodedString()

    return SecurityConfigDTO(
      algorithm: algorithm,
      keySize: keySize,
      mode: mode,
      hashAlgorithm: hashAlgorithm,
      options: updatedOptions
    )
  }
}
