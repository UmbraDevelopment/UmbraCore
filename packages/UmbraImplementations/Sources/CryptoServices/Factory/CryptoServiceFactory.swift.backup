import CryptoInterfaces
import SecurityCoreInterfaces

import CryptoTypes
import DomainSecurityTypes
import Foundation
import LoggingInterfaces
import LoggingServices
import SecurityCoreInterfaces
import SecurityInterfaces // Temporary, until we fully migrate SecureStorageConfig
import UmbraErrors
import CoreSecurityTypes

/**
 # CryptoServiceFactory

 Factory for creating CryptoServiceProtocol implementations.
 This factory follows the Alpha Dot Five architecture pattern
 of providing asynchronous factory methods that return actor-based
 implementations.

 This is the canonical factory for all cryptographic service implementations
 in the UmbraCore project, consolidating functionality previously split between
 multiple factory implementations.

 ## Usage Examples

 ### Standard Implementation
 ```swift
 // Create a default implementation
 let cryptoService = await CryptoServiceFactory.createDefault(secureStorage: mySecureStorage)

 // Create a service with custom secure logger
 let customService = await CryptoServiceFactory.createDefaultService(
   secureStorage: mySecureStorage,
   secureLogger: mySecureLogger
 )
 ```

 ### Security Provider-Specific Implementations
 ```swift
 // Create a service with a specific provider type
 let cryptoWithProvider = await CryptoServiceFactory.createWithProviderType(
   providerType: .cryptoKit,
   logger: myLogger
 )

 // For more control, create with explicit provider instance
 let myProvider = await ProviderFactory.createProvider(.appleCommonCrypto)
 let cryptoService = await CryptoServiceFactory.createWithProvider(
   provider: myProvider,
   secureStorage: mySecureStorage,
   logger: myLogger
 )
 ```

 ### Logging and Testing Implementations
 ```swift
 // Create a logging implementation
 let loggingService = await CryptoServiceFactory.createLoggingDecorator(
   wrapped: cryptoService,
   logger: myLogger,
   secureLogger: mySecureLogger
 )

 // Create a mock implementation for testing
 let mockService = await CryptoServiceFactory.createMock()
 ```
 */
public enum CryptoServiceFactory {
  // MARK: - Standard Implementations

  /**
   Creates a default crypto service implementation.

   - Parameter secureStorage: Optional secure storage service to use
   - Returns: A CryptoServiceProtocol implementation
   */
  public static func createDefault(
    secureStorage: SecureStorageProtocol? = nil
  ) async -> CryptoServiceProtocol {
    await createDefaultService(secureStorage: secureStorage)
  }

  /**
   Creates a standard crypto service implementation with custom loggers.

   - Parameters:
     - secureStorage: Optional secure storage service to use
     - logger: Logger for operations
     - secureLogger: Privacy-aware secure logger for sensitive operations
   - Returns: A CryptoServiceProtocol implementation
   */
  public static func createDefaultService(
    secureStorage: SecureStorageProtocol? = nil,
    logger: LoggingProtocol? = nil,
    secureLogger: PrivacyAwareLoggingProtocol? = nil
  ) async -> CryptoServiceProtocol {
    let actualLogger = logger ?? DefaultConsoleLogger()
    let actualSecureLogger = secureLogger
    
    let service = await DefaultCryptoServiceImpl(
      secureStorage: secureStorage ?? await createLocalSecureStorage(logger: actualLogger),
      logger: actualLogger
    )
    
    if let actualSecureLogger = actualSecureLogger {
      // Create enhanced privacy-aware logging implementation
      return await EnhancedLoggingCryptoServiceImpl(
        wrapped: service,
        logger: actualSecureLogger
      )
    } else {
      // Create standard logging implementation
      return await LoggingCryptoServiceImpl(
        wrapped: service,
        logger: actualLogger
      )
    }
  }

  /**
   Creates a high security crypto service implementation.

   - Parameters:
     - secureStorage: Optional secure storage service to use
     - logger: Logger for operations
   - Returns: A CryptoServiceProtocol implementation with enhanced security
   */
  public static func createHighSecurityService(
    secureStorage: SecureStorageProtocol? = nil,
    logger: LoggingProtocol? = nil
  ) async -> CryptoServiceProtocol {
    let actualLogger = logger ?? DefaultConsoleLogger()
    
    // Create secure service with enhanced parameters
    let service = await SecureCryptoServiceImpl(
      wrapped: await DefaultCryptoServiceImpl(
        secureStorage: secureStorage ?? await createLocalSecureStorage(logger: actualLogger),
        logger: actualLogger,
        options: CryptoServiceOptions(
          defaultIterations: 10000, // Higher iteration count for PBKDF2
          enforceStrongKeys: true
        )
      ),
      storage: await createSecureStorage(),
      logger: actualLogger
    )
    
    return await LoggingCryptoServiceImpl(
      wrapped: service,
      logger: actualLogger
    )
  }
  
  // MARK: - Provider-Specific Implementations
  
  /**
   Creates a new crypto service with the specified provider type.
   This is the consolidated implementation that handles provider creation internally.
   
   This method integrates functionality previously available in separate factory implementations,
   providing a unified interface for creating cryptographic services with specific provider types.

   - Parameters:
     - providerType: The type of security provider to use
     - secureStorage: Optional secure storage service to use
     - logger: Logger for recording operations
   - Returns: A new actor-based implementation of CryptoServiceProtocol
   */
  public static func createWithProviderType(
    providerType: SecurityProviderType,
    secureStorage: SecureStorageProtocol? = nil,
    logger: LoggingProtocol? = nil
  ) async -> CryptoServiceProtocol {
    let actualLogger = logger ?? DefaultConsoleLogger()
    
    // Use the provided secure storage or create a default one
    let actualSecureStorage = secureStorage ?? await createLocalSecureStorage(logger: actualLogger)
    
    // Create provider based on the specified type
    // This approach uses the provider registry to create providers dynamically
    let provider: SecurityProviderProtocol?
    
    switch providerType {
    case .cryptoKit:
      provider = await createBasicSecurityProvider(.cryptoKit)
    case .ring:
      provider = await createBasicSecurityProvider(.ring)
    case .basic:
      provider = await createBasicSecurityProvider(.basic) 
    case .system:
      provider = await createBasicSecurityProvider(.system)
    case .hsm:
      provider = await createBasicSecurityProvider(.basic) // Fallback for HSM
    }
    
    guard let provider = provider else {
      await actualLogger.error(
        "Failed to create provider of type \(providerType). Falling back to mock implementation.",
        metadata: LogMetadataDTOCollection().toPrivacyMetadata(),
        source: "CryptoServiceFactory"
      )
      
      // Return a mock implementation as fallback
      return await createWithProviderType(
        .basic,
        secureStorage: actualSecureStorage,
        logger: actualLogger
      )
    }
    
    // Now use the provider to create the crypto service
    return await createWithProvider(
      provider: provider,
      secureStorage: actualSecureStorage,
      logger: actualLogger
    )
  }
  
  /**
   Creates a new crypto service with the specified security provider.
   The implementation follows the actor-based concurrency model of the
   Alpha Dot Five architecture.

   - Parameters:
      - provider: The security provider to use (should be obtained from appropriate factory)
      - secureStorage: Optional secure storage service to use
      - logger: Logger for recording operations
   - Returns: A new actor-based implementation of CryptoServiceProtocol
   */
  public static func createWithProvider(
    provider: SecurityProviderProtocol,
    secureStorage: SecureStorageProtocol? = nil,
    logger: LoggingProtocol? = nil
  ) async -> CryptoServiceProtocol {
    let actualLogger = logger ?? DefaultConsoleLogger()
    
    // Use the provided secure storage or create a default one
    let actualSecureStorage = secureStorage ?? await createLocalSecureStorage(logger: actualLogger)
    
    // Create a crypto service implementation using DefaultCryptoServiceWithProviderImpl
    // instead of directly using CryptoServiceActor to avoid circular dependency
    let cryptoService = await DefaultCryptoServiceWithProviderImpl(
      provider: provider,
      secureStorage: actualSecureStorage,
      logger: actualLogger
    )
    
    // Return as the protocol type
    return cryptoService
  }
  
  /**
   Creates a new crypto service with the specified provider type.
   This method maintains backward compatibility with existing code.
   
   Note: This method requires that a factory for the specified provider type
   is available elsewhere in the application. It doesn't directly create
   security provider implementations to avoid circular dependencies.

   - Parameters:
      - providerType: The type of security provider to use
      - logger: Logger for recording operations
   - Returns: A new actor-based implementation of CryptoServiceProtocol, or nil if provider creation fails
   */
  @available(*, deprecated, message: "Use createWithProviderType(providerType:secureStorage:logger:) instead")
  public static func createWithProvider(
    providerType: SecurityProviderType,
    logger: LoggingProtocol? = nil
  ) async -> CryptoServiceProtocol? {
    // Log deprecation warning and delegate to the new implementation
    let actualLogger = logger ?? DefaultConsoleLogger()
    
    await actualLogger.warning(
      "Using deprecated createWithProvider(providerType:) method. Use createWithProviderType(providerType:secureStorage:logger:) instead.",
      metadata: LogMetadataDTOCollection().toPrivacyMetadata(),
      source: "CryptoServiceFactory"
    )
    
    return await createWithProviderType(
      providerType: providerType, 
      logger: actualLogger
    )
  }
  
  /**
   Creates a new secure storage service for key management.

   - Parameters:
      - storageURL: Custom URL for key storage
      - logger: Logger for recording operations
   - Returns: A new secure storage implementation
   */
  public static func createSecureStorage(
    storageURL: URL,
    logger: LoggingProtocol
  ) async -> SecureStorageProtocol {
    // Create a simple in-memory secure storage to avoid dependencies
    return InMemorySecureStorage(
      logger: logger,
      baseURL: storageURL
    )
  }
  
  /**
   Creates a cryptographic service implementation of the requested type.
   
   - Parameters:
     - type: Type of cryptographic service to create
     - logger: Logger to use for the service
     - secureStorage: Secure storage to use for the service
   - Returns: A CryptoServiceProtocol implementation
   */
  public static func create(
    type: SecurityProviderType,
    logger: LoggingProtocol,
    secureStorage: SecureStorageProtocol? = nil
  ) async -> CryptoServiceProtocol {
    // Log creation of crypto service
    logger.log(
      level: .debug,
      message: "Creating crypto service with provider type: \(type)",
      privacy: LogMetadataDTOCollection().toPrivacyMetadata()
    )
    
    // Create secure storage if not provided
    let storage = secureStorage ?? await createSecureStorage()
    
    // If mock is requested, create a mock implementation
    if type == .basic {
      let provider = BasicSecurityProvider(type: .basic)
      
      return await DefaultCryptoServiceWithProviderImpl(
        provider: provider,
        secureStorage: storage,
        logger: logger
      )
    }
    
    // Create the appropriate provider based on the type
    switch type {
    case .cryptoKit:
      if #available(macOS 10.15, iOS 13, *) {
        // Use Apple's CryptoKit on supported platforms
        let provider = AppleSecurityProvider(type: .cryptoKit)
        
        return await DefaultCryptoServiceWithProviderImpl(
          provider: provider,
          secureStorage: storage,
          logger: logger
        )
      } else {
        // Fall back to basic provider on unsupported platforms
        logger.log(
          level: .warning,
          message: "CryptoKit provider requested but not available on this platform. Falling back to basic provider.",
          privacy: LogMetadataDTOCollection().toPrivacyMetadata()
        )
        
        let provider = BasicSecurityProvider(type: .basic)
        
        return await DefaultCryptoServiceWithProviderImpl(
          provider: provider,
          secureStorage: storage,
          logger: logger
        )
      }
      
    case .ring:
      // Use Rust Ring cryptography via FFI
      let provider = RingSecurityProvider(type: .ring)
      
      return await DefaultCryptoServiceWithProviderImpl(
        provider: provider,
        secureStorage: storage,
        logger: logger
      )
      
    case .system:
      // Use the system's native cryptography implementation
      if #available(macOS 10.15, iOS 13, *) {
        // On newer Apple platforms, use CryptoKit
        let provider = AppleSecurityProvider(type: .system)
        
        return await DefaultCryptoServiceWithProviderImpl(
          provider: provider,
          secureStorage: storage,
          logger: logger
        )
      } else {
        // On other platforms, use the basic implementation
        let provider = BasicSecurityProvider(type: .basic)
        
        return await DefaultCryptoServiceWithProviderImpl(
          provider: provider,
          secureStorage: storage,
          logger: logger
        )
      }
      
    default:
      // Use the basic implementation for everything else
      let provider = BasicSecurityProvider(type: .basic)
      
      return await DefaultCryptoServiceWithProviderImpl(
        provider: provider,
        secureStorage: storage,
        logger: logger
      )
    }
  }
}

/**
 A simple in-memory secure storage implementation to avoid circular dependencies.
 This is an internal implementation used when no external storage is provided.
 */
fileprivate actor InMemorySecureStorage: SecureStorageProtocol {
  private var storage: [String: [UInt8]] = [:]
  private let logger: LoggingProtocol
  private let baseURL: URL
  
  init(logger: LoggingProtocol, baseURL: URL) {
    self.logger = logger
    self.baseURL = baseURL
  }
  
  func storeSecurely(data: [UInt8], withIdentifier identifier: String) async -> Result<Bool, SecurityStorageError> {
    await logger.debug("Storing data with identifier: \(identifier)", metadata: LogMetadataDTOCollection().toPrivacyMetadata(), source: "InMemorySecureStorage")
    storage[identifier] = data
    return .success(true)
  }
  
  func retrieveSecurely(withIdentifier identifier: String) async -> Result<[UInt8], SecurityStorageError> {
    guard let data = storage[identifier] else {
      await logger.error("Failed to retrieve data with identifier: \(identifier)", metadata: LogMetadataDTOCollection().toPrivacyMetadata(), source: "InMemorySecureStorage")
      return .failure(.keyNotFound)
    }
    return .success(data)
  }
  
  func deleteSecurely(withIdentifier identifier: String) async -> Result<Bool, SecurityStorageError> {
    guard storage[identifier] != nil else {
      await logger.error("Failed to delete data with identifier: \(identifier) - not found", metadata: LogMetadataDTOCollection().toPrivacyMetadata(), source: "InMemorySecureStorage")
      return .failure(.keyNotFound)
    }
    
    storage.removeValue(forKey: identifier)
    return .success(true)
  }
}

/**
 Implementation of CryptoServiceProtocol that uses a security provider.
 This implementation avoids circular dependencies by being defined directly
 within the CryptoServices module rather than relying on external actors.
 */
fileprivate actor DefaultCryptoServiceWithProviderImpl: CryptoServiceProtocol {
  private let provider: SecurityProviderProtocol
  private let secureStorage: SecureStorageProtocol
  private let logger: LoggingProtocol
  
  init(
    provider: SecurityProviderProtocol,
    secureStorage: SecureStorageProtocol,
    logger: LoggingProtocol
  ) {
    self.provider = provider
    self.secureStorage = secureStorage
    self.logger = logger
  }
  
  // MARK: - CryptoServiceProtocol Implementation
  
  /**
   Implementation of encrypt method that uses the security provider.
   
   - Parameters:
     - dataIdentifier: Identifier of the data to encrypt in secure storage
     - keyIdentifier: Identifier of the encryption key in secure storage
     - options: Optional encryption configuration
   - Returns: Identifier for the encrypted data in secure storage, or an error
   */
  public func encrypt(
    dataIdentifier: String,
    keyIdentifier: String,
    options: SecurityCoreInterfaces.EncryptionOptions?
  ) async -> Result<String, SecurityStorageError> {
    // Retrieve the data to encrypt from secure storage
    let dataResult = await self.exportData(identifier: dataIdentifier)
    guard case let .success(data) = dataResult else {
      if case let .failure(error) = dataResult {
        return .failure(error)
      }
      return .failure(.keyNotFound)
    }
    
    // Retrieve the encryption key from secure storage
    let keyResult = await self.exportData(identifier: keyIdentifier)
    guard case let .success(keyData) = keyResult else {
      if case let .failure(error) = keyResult {
        return .failure(error)
      }
      return .failure(.keyNotFound)
    }
    
    // Convert options type if needed
    let interfaceOptions: SecurityCoreInterfaces.EncryptionOptions?
    if let options = options {
      // Create equivalent SecurityCoreInterfaces options from CryptoServices options
      interfaceOptions = SecurityCoreInterfaces.EncryptionOptions(
        algorithm: .aes256GCM
      )
    } else {
      interfaceOptions = nil
    }
    
    // Create config for provider
    let config = SecurityConfigDTO(
      encryptionAlgorithm: .aes256GCM,
      hashAlgorithm: .sha256,
      providerType: .basic,
      options: SecurityConfigOptions(metadata: ["keyData": "keyData", "inputData": "data"])
    )
    
    do {
      // Call provider to encrypt
      let result = try await provider.encrypt(config: config)
      
      // Store the encrypted data
      let encryptedId = "encrypted_\(UUID().uuidString)"
      let storeResult = await self.importData(result.resultData?.data?.data, customIdentifier: encryptedId)
      
      return storeResult
    } catch {
      return .failure(.operationFailed("Encryption operation failed"))
    }
  }
  
  /**
   Implementation of decrypt method that uses the security provider.
   
   - Parameters:
     - encryptedDataIdentifier: Identifier of the encrypted data in secure storage
     - keyIdentifier: Identifier of the decryption key in secure storage
     - options: Optional decryption configuration
   - Returns: Identifier for the decrypted data in secure storage, or an error
   */
  public func decrypt(
    encryptedDataIdentifier: String,
    keyIdentifier: String,
    options: SecurityCoreInterfaces.DecryptionOptions?
  ) async -> Result<String, SecurityStorageError> {
    // Retrieve the encrypted data from secure storage
    let dataResult = await self.exportData(identifier: encryptedDataIdentifier)
    guard case let .success(data) = dataResult else {
      if case let .failure(error) = dataResult {
        return .failure(error)
      }
      return .failure(.keyNotFound)
    }
    
    // Retrieve the decryption key from secure storage
    let keyResult = await self.exportData(identifier: keyIdentifier)
    guard case let .success(keyData) = keyResult else {
      if case let .failure(error) = keyResult {
        return .failure(error)
      }
      return .failure(.keyNotFound)
    }
    
    // Convert options type if needed
    let interfaceOptions: SecurityCoreInterfaces.DecryptionOptions?
    if let options = options {
      // Create equivalent SecurityCoreInterfaces options from CryptoServices options
      interfaceOptions = SecurityCoreInterfaces.DecryptionOptions(
        algorithm: .aes256GCM
      )
    } else {
      interfaceOptions = nil
    }
    
    // Create config for provider
    let config = SecurityConfigDTO(
      encryptionAlgorithm: .aes256GCM,
      hashAlgorithm: .sha256,
      providerType: .basic,
      options: SecurityConfigOptions(metadata: ["keyData": "keyData", "inputData": "data"])
    )
    
    do {
      // Call provider to decrypt
      let result = try await provider.decrypt(config: config)
      
      // Store the decrypted data
      let decryptedId = "decrypted_\(UUID().uuidString)"
      let storeResult = await self.importData(result.resultData?.data?.data, customIdentifier: decryptedId)
      
      return storeResult
    } catch {
      return .failure(.operationFailed("Decryption operation failed"))
    }
  }
  
  /**
   Computes a cryptographic hash of data in secure storage.
   
   - Parameters:
     - dataIdentifier: Identifier of the data to hash in secure storage
     - options: Optional hashing configuration
   - Returns: Identifier for the hash in secure storage, or an error
   */
  public func hash(
    dataIdentifier: String,
    options: SecurityCoreInterfaces.HashingOptions?
  ) async -> Result<String, SecurityStorageError> {
    // Retrieve the data to hash from secure storage
    let dataResult = await self.exportData(identifier: dataIdentifier)
    guard case let .success(data) = dataResult else {
      if case let .failure(error) = dataResult {
        return .failure(error)
      }
      return .failure(.keyNotFound)
    }
    
    // Convert options type if needed
    let interfaceOptions: SecurityCoreInterfaces.HashingOptions?
    if let options = options {
      // Create equivalent SecurityCoreInterfaces options from CryptoServices options
      interfaceOptions = SecurityCoreInterfaces.HashingOptions(
        algorithm: .sha256
      )
    } else {
      interfaceOptions = nil
    }
    
    // Create config for provider
    let config = SecurityConfigDTO(
      encryptionAlgorithm: .aes256CBC,
      hashAlgorithm: .sha256,
      providerType: .basic
    )
    
    do {
      // Call provider to hash
      let result = try await provider.hash(data: data, config: config)
      
      // Store the hash
      let hashId = "hash_\(UUID().uuidString)"
      let storeResult = await self.importData(result.resultData?.data?.data, customIdentifier: hashId)
      
      return storeResult
    } catch {
      return .failure(.operationFailed("Hashing operation failed"))
    }
  }
  
  /**
   Verifies a cryptographic hash against data in secure storage.
   
   - Parameters:
     - dataIdentifier: Identifier of the data to verify in secure storage
     - hashIdentifier: Identifier of the expected hash in secure storage
     - options: Optional hashing configuration
   - Returns: `true` if the hash matches, `false` if not, or an error
   */
  public func verifyHash(
    dataIdentifier: String,
    hashIdentifier: String,
    options: SecurityCoreInterfaces.HashingOptions?
  ) async -> Result<Bool, SecurityStorageError> {
    // Get the data to verify
    let dataResult = await self.exportData(identifier: dataIdentifier)
    guard case let .success(data) = dataResult else {
      if case let .failure(error) = dataResult {
        return .failure(error)
      }
      return .failure(.keyNotFound)
    }
    
    // Get the expected hash
    let hashResult = await self.exportData(identifier: hashIdentifier)
    guard case let .success(hash) = hashResult else {
      if case let .failure(error) = hashResult {
        return .failure(error)
      }
      return .failure(.keyNotFound)
    }
    
    // Convert options type if needed
    let interfaceOptions: SecurityCoreInterfaces.HashingOptions?
    if let options = options {
      // Create equivalent SecurityCoreInterfaces options from CryptoServices options
      interfaceOptions = SecurityCoreInterfaces.HashingOptions(
        algorithm: .sha256
      )
    } else {
      interfaceOptions = nil
    }
    
    // Create config for provider
    let config = SecurityConfigDTO(
      encryptionAlgorithm: .aes256CBC,
      hashAlgorithm: .sha256,
      providerType: .basic,
      options: SecurityConfigOptions(metadata: ["expectedHash": "hash"])
    )
    do {
      // Call provider to verify hash
      let result = try await provider.verifyHash(data: data, hash: hash, config: config)
      return .success(result.verified)
    } catch {
      return .failure(.operationFailed("Hash verification failed"))
    }
  }
  
  /**
   Generates a cryptographic key and stores it securely.
   
   - Parameters:
     - length: Key length in bits
     - options: Optional key generation configuration
   - Returns: Identifier for the generated key in secure storage, or an error
   */
  public func generateKey(
    length: Int,
    options: SecurityCoreInterfaces.KeyGenerationOptions?
  ) async -> Result<String, SecurityStorageError> {
    // Build configuration
    let config = SecurityConfigDTO(
      encryptionAlgorithm: .aes256GCM,
      hashAlgorithm: .sha256,
      providerType: .basic,
      options: SecurityConfigOptions(["keyLength": String(length)])
    )
    
    do {
      // Generate key using provider
      let result = try await provider.generateKey(config: config)
      let keyData = result.resultData
      
      // Store the key in secure storage
      let keyId = "key_\(UUID().uuidString)"
      let storeResult = await self.importData(result.resultData?.data?.data, customIdentifier: keyId)
      
      return storeResult
    } catch {
      return .failure(.operationFailed("Key generation failed"))
    }
  }
  
  /**
   Imports data into secure storage.
   
   - Parameters:
     - data: Data to import into secure storage
     - customIdentifier: Optional custom identifier for the data
   - Returns: Identifier for the data in secure storage, or an error
   */
  public func importData(
    _ data: [UInt8],
    customIdentifier: String? = nil
  ) async -> Result<String, SecurityStorageError> {
    // Create identifier if not provided
    let identifier = customIdentifier ?? "data_\(UUID().uuidString)"
    
    // Store data
    do {
      let result = await self.secureStorage.storeData(data, withIdentifier: identifier)
      
      switch result {
      case .success:
        return .success(identifier)
      case .failure(let error):
        return .failure(error)
      }
  }
  
  /**
   Exports data from secure storage.
   
   - Parameter identifier: Identifier of the data to export
   - Returns: The raw data bytes, or an error
   */
  func exportData(
    identifier: String
  ) async -> Result<[UInt8], SecurityStorageError> {
    // Retrieve data from secure storage
    return await self.secureStorage.retrieveData(withIdentifier: identifier)
  }
}

/**
 A basic implementation of SecurityProviderProtocol for internal use.
 */
fileprivate actor BasicSecurityProvider: SecurityProviderProtocol {
  private let providerType: SecurityProviderType
  
  init(type: SecurityProviderType) {
    self.providerType = type
  }
  
  func encrypt(config: SecurityConfigDTO) async throws -> SecurityResultDTO {
    // Basic implementation that provides a simulated encryption result
    let outputData: [UInt8] = Array("encrypted_data_\(UUID().uuidString)".utf8)
    return SecurityResultDTO.success(resultData: Data(outputData), executionTimeMs: 0.0)
  }
  
  func decrypt(config: SecurityConfigDTO) async throws -> SecurityResultDTO {
    // Basic implementation that provides a simulated decryption result
    let outputData: [UInt8] = Array("decrypted_data_\(UUID().uuidString)".utf8)
    return SecurityResultDTO.success(resultData: Data(outputData), executionTimeMs: 0.0)
  }
  
  func generateKey(config: SecurityConfigDTO) async throws -> SecurityResultDTO {
    var keyData: [UInt8]
    
    // Generate a random key based on the algorithm
    switch config.encryptionAlgorithm {
    case .aes256CBC, .aes256GCM:
      keyData = [UInt8](repeating: 0, count: 32) // 256 bits
    case .chacha20Poly1305:
      keyData = [UInt8](repeating: 0, count: 32) // 256 bits
    }
    
    return SecurityResultDTO.success(resultData: Data(keyData), executionTimeMs: 0.0)
  }
  
  func verifyHash(config: SecurityConfigDTO) async throws -> SecurityResultDTO {
    // Basic implementation that simulates hash verification
    return SecurityResultDTO.success(resultData: Data([]), executionTimeMs: 0.0)
  }
  
  func hash(config: SecurityConfigDTO) async throws -> SecurityResultDTO {
    // Basic implementation that provides a simulated hash result
    let outputData: [UInt8] = Array("hash_result_\(UUID().uuidString)".utf8)
    return SecurityResultDTO.success(resultData: Data(outputData), executionTimeMs: 0.0)
  }
}

/**
 Mock implementation of CryptoServiceProtocol for testing.
 This implementation allows for configurable responses to test
 various success and failure scenarios.
 */
public actor MockCryptoServiceImpl: CryptoServiceProtocol {
  /// Configuration options for the mock
  public struct Configuration: Sendable {
    /// Whether encryption operations should succeed
    public let encryptionSucceeds: Bool
    
    /// Whether decryption operations should succeed
    public let decryptionSucceeds: Bool
    
    /// Whether hash operations should succeed
    public let hashingSucceeds: Bool
    
    /// Whether verification operations should succeed
    public let verificationSucceeds: Bool
    
    /// Whether key generation operations should succeed
    public let keyGenerationSucceeds: Bool
    
    /// Whether data import operations should succeed
    public let dataImportSucceeds: Bool
    
    /// Whether data export operations should succeed
    public let dataExportSucceeds: Bool
    
    /// Initialise with default configuration (all operations succeed)
    public init(
      encryptionSucceeds: Bool = true,
      decryptionSucceeds: Bool = true,
      hashingSucceeds: Bool = true,
      verificationSucceeds: Bool = true,
      keyGenerationSucceeds: Bool = true,
      dataImportSucceeds: Bool = true,
      dataExportSucceeds: Bool = true
    ) {
      self.encryptionSucceeds = encryptionSucceeds
      self.decryptionSucceeds = decryptionSucceeds
      self.hashingSucceeds = hashingSucceeds
      self.verificationSucceeds = verificationSucceeds
      self.keyGenerationSucceeds = keyGenerationSucceeds
      self.dataImportSucceeds = dataImportSucceeds
      self.dataExportSucceeds = dataExportSucceeds
    }
  }
  
  /// The mock secure storage
  public nonisolated let secureStorage: SecureStorageProtocol
  
  /// The configuration for this mock
  private let configuration: Configuration
  
  /// Initialize with specific configuration
  public init(
    secureStorage: SecureStorageProtocol,
    configuration: Configuration=Configuration()
  ) {
    self.secureStorage = secureStorage
    self.configuration = configuration
  }
  
  /// Encrypts binary data using a key from secure storage.
  /// - Parameters:
  ///   - dataIdentifier: Identifier of the data to encrypt in secure storage.
  ///   - keyIdentifier: Identifier of the encryption key in secure storage.
  ///   - options: Optional encryption configuration.
  /// - Returns: Identifier for the encrypted data in secure storage, or an error.
  public func encrypt(
    dataIdentifier: String,
    keyIdentifier: String,
    options: EncryptionOptions?
  ) async -> Result<String, SecurityStorageError> {
    if configuration.encryptionSucceeds {
      return .success("mock_encrypted_\(UUID().uuidString)")
    } else {
      return .failure(.operationFailed("Operation failed"))
    }
  }
  
  /// Decrypts binary data using a key from secure storage.
  /// - Parameters:
  ///   - encryptedDataIdentifier: Identifier of the encrypted data in secure storage.
  ///   - keyIdentifier: Identifier of the decryption key in secure storage.
  ///   - options: Optional decryption configuration.
  /// - Returns: Identifier for the decrypted data in secure storage, or an error.
  public func decrypt(
    encryptedDataIdentifier: String,
    keyIdentifier: String,
    options: DecryptionOptions?
  ) async -> Result<String, SecurityStorageError> {
    if configuration.decryptionSucceeds {
      return .success("mock_decrypted_\(UUID().uuidString)")
    } else {
      return .failure(.operationFailed("Operation failed"))
    }
  }
  
  /// Computes a cryptographic hash of data in secure storage.
  /// - Parameter dataIdentifier: Identifier of the data to hash in secure storage.
  /// - Returns: Identifier for the hash in secure storage, or an error.
  public func hash(
    dataIdentifier: String,
    options: HashingOptions?
  ) async -> Result<String, SecurityStorageError> {
    if configuration.hashingSucceeds {
      return .success("mock_hash_\(UUID().uuidString)")
    } else {
      return .failure(.operationFailed("Operation failed"))
    }
  }
  
  /// Verifies a cryptographic hash against the expected value, both stored securely.
  /// - Parameters:
  ///   - dataIdentifier: Identifier of the data to verify in secure storage.
  ///   - hashIdentifier: Identifier of the expected hash in secure storage.
  /// - Returns: `true` if the hash matches, `false` if not, or an error.
  public func verifyHash(
    dataIdentifier: String,
    hashIdentifier: String,
    options: HashingOptions?
  ) async -> Result<Bool, SecurityStorageError> {
    if configuration.verificationSucceeds {
      return .success(true)
    } else {
      return .failure(.operationFailed("Operation failed"))
    }
  }
  
  /// Generates a cryptographic key and stores it securely.
  /// - Parameters:
  ///   - length: The length of the key to generate in bytes.
  ///   - options: Optional key generation configuration.
  /// - Returns: Identifier for the generated key in secure storage, or an error.
  public func generateKey(
    length: Int,
    options: KeyGenerationOptions?
  ) async -> Result<String, SecurityStorageError> {
    if configuration.keyGenerationSucceeds {
      return .success("mock_key_\(UUID().uuidString)")
    } else {
      return .failure(.operationFailed("Operation failed"))
    }
  }
  
  /// Imports data into secure storage for use with cryptographic operations.
  /// - Parameters:
  ///   - data: The raw data to store securely.
  ///   - customIdentifier: Optional custom identifier for the data. If nil, a random identifier is
  /// generated.
  /// - Returns: The identifier for the data in secure storage, or an error.
  public func importData(
    _ data: [UInt8],
    customIdentifier: String?
  ) async -> Result<String, SecurityStorageError> {
    if configuration.dataImportSucceeds {
      let identifier = customIdentifier ?? "mock_imported_\(UUID().uuidString)"
      return .success(identifier)
    } else {
      return .failure(.operationFailed("Operation failed"))
    }
  }
  
  /// Exports data from secure storage.
  /// - Parameter identifier: The identifier of the data to export.
  /// - Returns: The raw data, or an error.
  /// - Warning: Use with caution as this exposes sensitive data.
  func exportData(
    identifier: String
  ) async -> Result<[UInt8], SecurityStorageError> {
    if configuration.dataExportSucceeds {
      // Return some mock data
      return .success([1, 2, 3, 4, 5])
    } else {
      return .failure(.keyNotFound)
    }
  }
}

/**
 # LoggingCryptoServiceImpl

 A decorator for CryptoServiceProtocol that adds logging capabilities.
 This implementation logs all cryptographic operations while delegating
 the actual work to a wrapped implementation.
 */
public actor LoggingCryptoServiceImpl: CryptoServiceProtocol {
  /// The wrapped implementation
  private let wrapped: CryptoServiceProtocol

  /// The logger to use
  private let logger: LoggingProtocol

  /// The secure storage used for handling sensitive data
  public nonisolated var secureStorage: SecureStorageProtocol {
    wrapped.secureStorage
  }

  /**
   Initialises a new logging-enhanced crypto service.

   - Parameters:
     - wrapped: The underlying crypto service to wrap
     - logger: The logger to use
   */
  public init(wrapped: CryptoServiceProtocol, logger: LoggingProtocol) {
    self.wrapped=wrapped
    self.logger=logger
  }

  public func encrypt(
    dataIdentifier: String,
    keyIdentifier: String,
    options: EncryptionOptions?
  ) async -> Result<String, SecurityStorageError> {
    var metadata=LogMetadataDTOCollection()
    metadata = metadata.with(key: "dataId", value: dataIdentifier, privacyLevel: .private)
    metadata = metadata.with(key: "keyId", value: keyIdentifier, privacyLevel: .private)

    await logger.debug("Starting encryption operation", metadata: metadata.toPrivacyMetadata(), source: "CryptoService")

    let result=await wrapped.encrypt(
      dataIdentifier: dataIdentifier,
      keyIdentifier: keyIdentifier,
      options: options as? SecurityCoreInterfaces.EncryptionOptions as? SecurityCoreInterfaces.EncryptionOptions
    )

    switch result {
      case .success:
        await logger.debug(
          "Encryption completed successfully",
          metadata: metadata.toPrivacyMetadata(),
          source: "CryptoService"
        )
      case let .failure(error):
        await logger.error(
          "Encryption failed: \(error.localizedDescription)",
          metadata: metadata.toPrivacyMetadata(),
          source: "CryptoService"
        )
    }

    return result
  }

  public func decrypt(
    encryptedDataIdentifier: String,
    keyIdentifier: String,
    options: DecryptionOptions?
  ) async -> Result<String, SecurityStorageError> {
    await logger.debug(
      "LoggingCryptoService: Starting decryption operation for data identifier: \(encryptedDataIdentifier)",
      metadata: LogMetadataDTOCollection().toPrivacyMetadata(),
      source: "LoggingCryptoService"
    )

    let startTime=Date()
    let result=await wrapped.decrypt(
      encryptedDataIdentifier: encryptedDataIdentifier,
      keyIdentifier: keyIdentifier,
      options: options as? SecurityCoreInterfaces.EncryptionOptions as? SecurityCoreInterfaces.EncryptionOptions
    )
    let elapsedTime=Date().timeIntervalSince(startTime) * 1000

    switch result {
      case let .success(identifier):
        await logger.debug(
          "LoggingCryptoService: Decryption completed successfully in \(elapsedTime) ms",
          metadata: LogMetadataDTOCollection().toPrivacyMetadata(),
          source: "LoggingCryptoService"
        )
        return .success(identifier)
      case let .failure(error):
        await logger.error(
          "LoggingCryptoService: Decryption failed: \(error.localizedDescription)",
          metadata: LogMetadataDTOCollection().toPrivacyMetadata(),
          source: "LoggingCryptoService"
        )
        return .failure(error)
    }
  }

  public func hash(
    dataIdentifier: String,
    options: HashingOptions?
  ) async -> Result<String, SecurityStorageError> {
    await logger.debug(
      "LoggingCryptoService: Starting hash operation for data identifier: \(dataIdentifier)",
      metadata: LogMetadataDTOCollection().toPrivacyMetadata(),
      source: "LoggingCryptoService"
    )

    let startTime=Date()
    let result=await wrapped.hash(
      dataIdentifier: dataIdentifier,
      options: options as? SecurityCoreInterfaces.EncryptionOptions as? SecurityCoreInterfaces.EncryptionOptions
    )
    let elapsedTime=Date().timeIntervalSince(startTime) * 1000

    switch result {
      case let .success(identifier):
        await logger.debug(
          "LoggingCryptoService: Hashing completed successfully in \(elapsedTime) ms",
          metadata: LogMetadataDTOCollection().toPrivacyMetadata(),
          source: "LoggingCryptoService"
        )
        return .success(identifier)
      case let .failure(error):
        await logger.error(
          "LoggingCryptoService: Hashing failed: \(error.localizedDescription)",
          metadata: LogMetadataDTOCollection().toPrivacyMetadata(),
          source: "LoggingCryptoService"
        )
        return .failure(error)
    }
  }

  public func verifyHash(
    dataIdentifier: String,
    hashIdentifier: String,
    options: HashingOptions?
  ) async -> Result<Bool, SecurityStorageError> {
    await logger.debug(
      "LoggingCryptoService: Verifying hash for data identifier: \(dataIdentifier)",
      metadata: LogMetadataDTOCollection().toPrivacyMetadata(),
      source: "LoggingCryptoService"
    )

    let startTime=Date()
    let result=await wrapped.verifyHash(
      dataIdentifier: dataIdentifier,
      hashIdentifier: hashIdentifier,
      options: options as? SecurityCoreInterfaces.EncryptionOptions as? SecurityCoreInterfaces.EncryptionOptions
    )
    let elapsedTime=Date().timeIntervalSince(startTime) * 1000

    switch result {
      case let .success(matches):
        await logger.debug(
          "LoggingCryptoService: Hash verification completed (matches: \(matches)) in \(elapsedTime) ms",
          metadata: LogMetadataDTOCollection().toPrivacyMetadata(),
          source: "LoggingCryptoService"
        )
        return .success(matches)
      case let .failure(error):
        await logger.error(
          "LoggingCryptoService: Hash verification failed: \(error.localizedDescription)",
          metadata: LogMetadataDTOCollection().toPrivacyMetadata(),
          source: "LoggingCryptoService"
        )
        return .failure(error)
    }
  }

  public func generateKey(
    length: Int,
    options: KeyGenerationOptions?
  ) async -> Result<String, SecurityStorageError> {
    await logger.debug(
      "LoggingCryptoService: Generating key of length \(length) bits",
      metadata: LogMetadataDTOCollection().toPrivacyMetadata(),
      source: "LoggingCryptoService"
    )

    let startTime=Date()
    let result=await wrapped.generateKey(
      length: length,
      options: options as? SecurityCoreInterfaces.EncryptionOptions as? SecurityCoreInterfaces.EncryptionOptions
    )
    let elapsedTime=Date().timeIntervalSince(startTime) * 1000

    switch result {
      case let .success(identifier):
        await logger.debug(
          "LoggingCryptoService: Key generation completed successfully in \(elapsedTime) ms",
          metadata: LogMetadataDTOCollection().toPrivacyMetadata(),
          source: "LoggingCryptoService"
        )
        return .success(identifier)
      case let .failure(error):
        await logger.error(
          "LoggingCryptoService: Key generation failed: \(error.localizedDescription)",
          metadata: LogMetadataDTOCollection().toPrivacyMetadata(),
          source: "LoggingCryptoService"
        )
        return .failure(error)
    }
  }

  public func importData(
    _ data: [UInt8],
    customIdentifier: String? = nil
  ) async -> Result<String, SecurityStorageError> {
    await logger.debug(
      "LoggingCryptoService: Importing data with\(customIdentifier != nil ? " custom identifier: \(customIdentifier!)" : "out custom identifier")",
      metadata: LogMetadataDTOCollection().toPrivacyMetadata(),
      source: "LoggingCryptoService"
    )

    let startTime=Date()
    let result=await wrapped.importData(
      data,
      customIdentifier: customIdentifier
    )
    let elapsedTime=Date().timeIntervalSince(startTime) * 1000

    switch result {
      case let .success(identifier):
        await logger.debug(
          "LoggingCryptoService: Data import completed successfully in \(elapsedTime) ms",
          metadata: LogMetadataDTOCollection().toPrivacyMetadata(),
          source: "LoggingCryptoService"
        )
        return .success(identifier)
      case let .failure(error):
        await logger.error(
          "LoggingCryptoService: Data import failed: \(error.localizedDescription)",
          metadata: LogMetadataDTOCollection().toPrivacyMetadata(),
          source: "LoggingCryptoService"
        )
        return .failure(error)
    }
  }

  func exportData(
    identifier: String
  ) async -> Result<[UInt8], SecurityStorageError> {
    await logger.debug(
      "LoggingCryptoService: Exporting data for identifier: \(identifier)",
      metadata: LogMetadataDTOCollection().toPrivacyMetadata(),
      source: "LoggingCryptoService"
    )

    let startTime=Date()
    let result=await wrapped.exportData(
      identifier: identifier
    )
    let elapsedTime=Date().timeIntervalSince(startTime) * 1000

    switch result {
      case let .success(data):
        await logger.debug(
          "LoggingCryptoService: Data export completed successfully in \(elapsedTime) ms",
          metadata: LogMetadataDTOCollection().toPrivacyMetadata(),
          source: "LoggingCryptoService"
        )
        return .success(data)
      case let .failure(error):
        await logger.error(
          "LoggingCryptoService: Data export failed: \(error.localizedDescription)",
          metadata: LogMetadataDTOCollection().toPrivacyMetadata(),
          source: "LoggingCryptoService"
        )
        return .failure(error)
    }
  }
}

/**
 # EnhancedLoggingCryptoServiceImpl

 A decorator for CryptoServiceProtocol that adds privacy-aware logging capabilities.
 This implementation uses SecureLoggerActor to ensure that sensitive information
 is properly tagged with privacy levels when logged.
 */
public actor EnhancedLoggingCryptoServiceImpl: CryptoServiceProtocol {
  /// The wrapped implementation
  private let wrapped: CryptoServiceProtocol

  /// Enhanced privacy-aware logger
  private let logger: PrivacyAwareLoggingProtocol

  /// The secure storage used for handling sensitive data
  public nonisolated var secureStorage: SecureStorageProtocol {
    wrapped.secureStorage
  }

  /**
   Initialise with a wrapped implementation and privacy-aware logger

   - Parameters:
     - wrapped: The implementation to delegate to
     - logger: Privacy-aware logger for secure logging
   */
  public init(wrapped: CryptoServiceProtocol, logger: PrivacyAwareLoggingProtocol) {
    self.wrapped = wrapped
    self.logger = logger
  }

  /**
   Encrypts binary data using a key from secure storage.
   - Parameters:
     - dataIdentifier: Identifier of the data to encrypt in secure storage.
     - keyIdentifier: Identifier of the encryption key in secure storage.
     - options: Optional encryption configuration.
   - Returns: Identifier for the encrypted data in secure storage, or an error.
   */
  public func encrypt(
    dataIdentifier: String,
    keyIdentifier: String,
    options: EncryptionOptions?
  ) async -> Result<String, SecurityStorageError> {
    // Create an enhanced log context with proper privacy tags
    var context = createEnhancedLogContext(
      operation: "encrypt",
      identifiers: [
        "dataIdentifier": dataIdentifier,
        "keyIdentifier": keyIdentifier
      ]
    )

    // Log operation start with privacy controls
    await logger.debug("Starting encryption operation", metadata: context.metadata.toPrivacyMetadata(), source: context.source ?? "CryptoServiceFactory")

    // Perform the operation
    let result = await wrapped.encrypt(
      dataIdentifier: dataIdentifier,
      keyIdentifier: keyIdentifier,
      options: options as? SecurityCoreInterfaces.EncryptionOptions as? SecurityCoreInterfaces.EncryptionOptions
    )

    // Log the result with appropriate privacy controls
    switch result {
    case .success(let identifier):
      var resultContext = context
      resultContext.metadata = resultContext.metadata.with(key: "resultIdentifier", value: identifier, privacyLevel: .private)
      await logger.info("Encryption completed successfully", metadata: resultContext.metadata.toPrivacyMetadata(), source: resultContext.source ?? "CryptoServiceFactory")
      return .success(identifier)
    case .failure(let error):
      var errorContext = context
      errorContext.metadata = errorContext.metadata.with(key: "error", value: error.localizedDescription, privacyLevel: .public)
      await logger.error("Encryption failed: \(error.localizedDescription)", metadata: errorContext.metadata.toPrivacyMetadata(), source: errorContext.source ?? "CryptoServiceFactory")
      return .failure(error)
    }
  }

  /**
   Decrypts binary data using a key from secure storage.
   - Parameters:
     - encryptedDataIdentifier: Identifier of the encrypted data in secure storage.
     - keyIdentifier: Identifier of the decryption key in secure storage.
     - options: Optional decryption configuration.
   - Returns: Identifier for the decrypted data in secure storage, or an error.
   */
  public func decrypt(
    encryptedDataIdentifier: String,
    keyIdentifier: String,
    options: DecryptionOptions?
  ) async -> Result<String, SecurityStorageError> {
    // Create an enhanced log context with proper privacy tags
    var context = createEnhancedLogContext(
      operation: "decrypt",
      identifiers: [
        "encryptedDataIdentifier": encryptedDataIdentifier,
        "keyIdentifier": keyIdentifier
      ]
    )

    // Log operation start with privacy controls
    await logger.debug("Starting decryption operation", metadata: context.metadata.toPrivacyMetadata(), source: context.source ?? "CryptoServiceFactory")

    // Perform the operation
    let result = await wrapped.decrypt(
      encryptedDataIdentifier: encryptedDataIdentifier,
      keyIdentifier: keyIdentifier,
      options: options as? SecurityCoreInterfaces.EncryptionOptions as? SecurityCoreInterfaces.EncryptionOptions
    )

    // Log the result with appropriate privacy controls
    switch result {
    case .success(let identifier):
      var resultContext = context
      resultContext.metadata = resultContext.metadata.with(key: "resultIdentifier", value: identifier, privacyLevel: .private)
      await logger.info("Decryption completed successfully", metadata: resultContext.metadata.toPrivacyMetadata(), source: resultContext.source ?? "CryptoServiceFactory")
      return .success(identifier)
    case .failure(let error):
      var errorContext = context
      errorContext.metadata = errorContext.metadata.with(key: "error", value: error.localizedDescription, privacyLevel: .public)
      await logger.error("Decryption failed: \(error.localizedDescription)", metadata: errorContext.metadata.toPrivacyMetadata(), source: errorContext.source ?? "CryptoServiceFactory")
      return .failure(error)
    }
  }

  /**
   Computes a cryptographic hash of data in secure storage.
   - Parameter dataIdentifier: Identifier of the data to hash in secure storage.
   - Returns: Identifier for the hash in secure storage, or an error.
   */
  public func hash(
    dataIdentifier: String,
    options: HashingOptions?
  ) async -> Result<String, SecurityStorageError> {
    // Create an enhanced log context with proper privacy tags
    var context = createEnhancedLogContext(
      operation: "hash",
      identifiers: [
        "dataIdentifier": dataIdentifier
      ]
    )

    // Log operation start with privacy controls
    await logger.debug("Starting hash operation", metadata: context.metadata.toPrivacyMetadata(), source: context.source ?? "CryptoServiceFactory")

    // Perform the operation
    let result = await wrapped.hash(
      dataIdentifier: dataIdentifier,
      options: options as? SecurityCoreInterfaces.EncryptionOptions as? SecurityCoreInterfaces.EncryptionOptions
    )

    // Log the result with appropriate privacy controls
    switch result {
    case .success(let identifier):
      var resultContext = context
      resultContext.metadata = resultContext.metadata.with(key: "resultIdentifier", value: identifier, privacyLevel: .private)
      await logger.info("Hash operation completed successfully", metadata: resultContext.metadata.toPrivacyMetadata(), source: resultContext.source ?? "CryptoServiceFactory")
      return .success(identifier)
    case .failure(let error):
      var errorContext = context
      errorContext.metadata = errorContext.metadata.with(key: "error", value: error.localizedDescription, privacyLevel: .public)
      await logger.error("Hash operation failed: \(error.localizedDescription)", metadata: errorContext.metadata.toPrivacyMetadata(), source: errorContext.source ?? "CryptoServiceFactory")
      return .failure(error)
    }
  }

  /**
   Verifies a cryptographic hash against the expected value, both stored securely.
   - Parameters:
     - dataIdentifier: Identifier of the data to verify in secure storage.
     - hashIdentifier: Identifier of the expected hash in secure storage.
   - Returns: `true` if the hash matches, `false` if not, or an error.
   */
  public func verifyHash(
    dataIdentifier: String,
    hashIdentifier: String,
    options: HashingOptions?
  ) async -> Result<Bool, SecurityStorageError> {
    // Create an enhanced log context with proper privacy tags
    var context = createEnhancedLogContext(
      operation: "verifyHash",
      identifiers: [
        "dataIdentifier": dataIdentifier,
        "hashIdentifier": hashIdentifier
      ]
    )

    // Log operation start with privacy controls
    await logger.debug("Starting hash verification", metadata: context.metadata.toPrivacyMetadata(), source: context.source ?? "CryptoServiceFactory")

    // Perform the operation
    let result = await wrapped.verifyHash(
      dataIdentifier: dataIdentifier,
      hashIdentifier: hashIdentifier,
      options: options as? SecurityCoreInterfaces.EncryptionOptions as? SecurityCoreInterfaces.EncryptionOptions
    )

    // Log the result with appropriate privacy controls
    switch result {
    case .success(let verified):
      var resultContext = context
      resultContext.metadata = resultContext.metadata.with(key: "verified", value: String(verified), privacyLevel: .public)
      let status = verified ? "verified" : "failed verification"
      await logger.info("Hash verification completed: \(status)", metadata: resultContext.metadata.toPrivacyMetadata(), source: resultContext.source ?? "CryptoServiceFactory")
      return .success(verified)
    case .failure(let error):
      var errorContext = context
      errorContext.metadata = errorContext.metadata.with(key: "error", value: error.localizedDescription, privacyLevel: .public)
      await logger.error("Hash verification failed: \(error.localizedDescription)", metadata: errorContext.metadata.toPrivacyMetadata(), source: errorContext.source ?? "CryptoServiceFactory")
      return .failure(error)
    }
  }

  /**
   Generates a cryptographic key and stores it securely.
   - Parameters:
     - length: The length of the key to generate in bytes.
     - options: Optional key generation configuration.
   - Returns: Identifier for the generated key in secure storage, or an error.
   */
  public func generateKey(
    length: Int,
    options: KeyGenerationOptions?
  ) async -> Result<String, SecurityStorageError> {
    // Create an enhanced log context with proper privacy tags
    var context = createEnhancedLogContext(
      operation: "generateKey",
      identifiers: [:]
    )

    // Add key length with public privacy level
    context.metadata = context.metadata.with(key: "keyLength", value: String(length), privacyLevel: .public)

    // Log operation start with privacy controls
    await logger.debug("Starting key generation", metadata: context.metadata.toPrivacyMetadata(), source: context.source ?? "CryptoServiceFactory")

    // Perform the operation
    let result = await wrapped.generateKey(
      length: length,
      options: options as? SecurityCoreInterfaces.EncryptionOptions as? SecurityCoreInterfaces.EncryptionOptions
    )

    // Log the result with appropriate privacy controls
    switch result {
    case .success(let identifier):
      var resultContext = context
      resultContext.metadata = resultContext.metadata.with(key: "keyIdentifier", value: identifier, privacyLevel: .private)
      await logger.info("Key generation completed successfully", metadata: resultContext.metadata.toPrivacyMetadata(), source: resultContext.source ?? "CryptoServiceFactory")
      return .success(identifier)
    case .failure(let error):
      var errorContext = context
      errorContext.metadata = errorContext.metadata.with(key: "error", value: error.localizedDescription, privacyLevel: .public)
      await logger.error("Key generation failed: \(error.localizedDescription)", metadata: errorContext.metadata.toPrivacyMetadata(), source: errorContext.source ?? "CryptoServiceFactory")
      return .failure(error)
    }
  }

  /**
   Imports data into secure storage for use with cryptographic operations.
   - Parameters:
     - data: The raw data to store securely.
     - customIdentifier: Optional custom identifier for the data. If nil, a random identifier is
   generated.
   - Returns: The identifier for the data in secure storage, or an error.
   */
  public func importData(
    _ data: [UInt8],
    customIdentifier: String? = nil
  ) async -> Result<String, SecurityStorageError> {
    // Create an enhanced log context with proper privacy tags
    var context = createEnhancedLogContext(
      operation: "importData",
      identifiers: [:]
    )

    // Add data size with public privacy level
    context.metadata = context.metadata.with(key: "dataSize", value: String(data.count), privacyLevel: .public)

    if let customIdentifier = customIdentifier {
      context.metadata = context.metadata.with(key: "customIdentifier", value: customIdentifier, privacyLevel: .private)
    }

    // Log operation start with privacy controls
    await logger.debug("Starting data import", metadata: context.metadata.toPrivacyMetadata(), source: context.source ?? "CryptoServiceFactory")

    // Perform the operation
    let result = await wrapped.importData(
      data,
      customIdentifier: customIdentifier
    )

    // Log the result with appropriate privacy controls
    switch result {
    case .success(let identifier):
      var resultContext = context
      resultContext.metadata = resultContext.metadata.with(key: "resultIdentifier", value: identifier, privacyLevel: .private)
      await logger.info("Data import completed successfully", metadata: resultContext.metadata.toPrivacyMetadata(), source: resultContext.source ?? "CryptoServiceFactory")
      return .success(identifier)
    case .failure(let error):
      var errorContext = context
      errorContext.metadata = errorContext.metadata.with(key: "error", value: error.localizedDescription, privacyLevel: .public)
      await logger.error("Data import failed: \(error.localizedDescription)", metadata: errorContext.metadata.toPrivacyMetadata(), source: errorContext.source ?? "CryptoServiceFactory")
      return .failure(error)
    }
  }

  /**
   Exports data from secure storage.
   - Parameter identifier: The identifier of the data to export.
   - Returns: The raw data, or an error.
   - Warning: Use with caution as this exposes sensitive data.
   */
  func exportData(
    identifier: String
  ) async -> Result<[UInt8], SecurityStorageError> {
    // Create an enhanced log context with proper privacy tags
    var context = createEnhancedLogContext(
      operation: "exportData",
      identifiers: [
        "identifier": identifier
      ]
    )

    // Log operation start with privacy controls
    await logger.debug("Starting data export", metadata: context.metadata.toPrivacyMetadata(), source: context.source ?? "CryptoServiceFactory")

    // Log warning about data exposure
    await logger.warning(
      "Exporting data from secure storage exposes sensitive material",
      metadata: context.metadata.toPrivacyMetadata(),
      source: context.source ?? "CryptoServiceFactory"
    )

    // Perform the operation
    let result = await wrapped.exportData(
      identifier: identifier
    )

    // Log the result with appropriate privacy controls
    switch result {
    case .success(let data):
      var resultContext = context
      resultContext.metadata = resultContext.metadata.with(key: "dataSize", value: String(data.count), privacyLevel: .public)
      await logger.info("Data export completed successfully", metadata: resultContext.metadata.toPrivacyMetadata(), source: resultContext.source ?? "CryptoServiceFactory")
      return .success(data)
    case .failure(let error):
      var errorContext = context
      errorContext.metadata = errorContext.metadata.with(key: "error", value: error.localizedDescription, privacyLevel: .public)
      await logger.error("Data export failed: \(error.localizedDescription)", metadata: errorContext.metadata.toPrivacyMetadata(), source: errorContext.source ?? "CryptoServiceFactory")
      return .failure(error)
    }
  }

  // MARK: - Private Helper Methods

  /**
   Creates an enhanced log context with privacy controls for security operations

   - Parameters:
     - operation: The cryptographic operation being performed
     - identifiers: Dictionary of identifiers and their privacy levels
   - Returns: A LogContextDTO with proper privacy settings
   */
  private func createEnhancedLogContext(
    operation: String,
    identifiers: [String: String]
  ) -> EnhancedLogContext {
    var context = EnhancedLogContext(
      domainName: "CryptoServices",
      source: "CryptoServiceFactory",
      correlationID: nil
    )

    // Add operation with public privacy level
    context.metadata = context.metadata.with(key: "operation", value: operation, privacyLevel: .public)

    // Add identifiers with their specified privacy levels
    for (key, value) in identifiers {
      // Convert from PrivacyClassification to LogPrivacyLevel
      let logPrivacyLevel: LogPrivacyLevel
      switch value {
      case "public":
        logPrivacyLevel = .public
      case "private":
        logPrivacyLevel = .private
      case "sensitive":
        logPrivacyLevel = .sensitive
      case "hash":
        logPrivacyLevel = .private // Use private as fallback for hash
      case "auto":
        logPrivacyLevel = .auto
      default:
        logPrivacyLevel = .public
      }
      
      context.metadata = context.metadata.with(key: key, value: "sensitive", privacyLevel: PrivacyClassification.private)
    }

    return context
  }
}

/**
 Enhanced log context for crypto operations with privacy controls
 */
private struct EnhancedLogContext: LogContextDTO {
  var domainName: String
  var source: String?
  var correlationID: String?
  var metadata: LogMetadataDTOCollection = LogMetadataDTOCollection()

  init(domainName: String, source: String?, correlationID: String?) {
    self.domainName = domainName
    self.source = source
    self.correlationID = correlationID
  }

  mutating func withUpdatedMetadata(_ metadata: LogMetadataDTOCollection) -> EnhancedLogContext {
    self.metadata = metadata
    return self
  }
}

/**
 # SecureCryptoServiceImpl

 A CryptoServiceProtocol implementation that follows the Alpha Dot Five architecture
 by storing sensitive cryptographic material using the SecureStorageProtocol.
 */
public actor SecureCryptoServiceImpl: CryptoServiceProtocol {

  /// The wrapped implementation that does the actual cryptographic work
  private let wrapped: CryptoServiceProtocol

  /// The secure storage used for handling sensitive data
  public nonisolated var secureStorage: SecureStorageProtocol {
    wrapped.secureStorage
  }

  /// Secure logger for enhanced privacy tracking
  private let logger: LoggingProtocol

  /**
   Initialise with a wrapped implementation and logger

   - Parameters:
     - wrapped: The implementation to delegate to
     - logger: Logger for tracking operations
   */
  public init(wrapped: CryptoServiceProtocol, logger: LoggingProtocol) {
    self.wrapped = wrapped
    self.logger = logger
  }

  // MARK: - Protocol Implementation

  /// Encrypts binary data using a key from secure storage.
  /// - Parameters:
  ///   - dataIdentifier: Identifier of the data to encrypt in secure storage.
  ///   - keyIdentifier: Identifier of the encryption key in secure storage.
  ///   - options: Optional encryption configuration.
  /// - Returns: Identifier for the encrypted data in secure storage, or an error.
  public func encrypt(
    dataIdentifier: String,
    keyIdentifier: String,
    options: SecurityCoreInterfaces.EncryptionOptions?
  ) async -> Result<String, SecurityStorageError> {
    // Convert options type if needed
    let interfaceOptions: SecurityCoreInterfaces.EncryptionOptions?
    if let options = options {
      // Create equivalent SecurityCoreInterfaces options from CryptoServices options
      interfaceOptions = SecurityCoreInterfaces.EncryptionOptions(
        algorithm: .aes256GCM
      )
    } else {
      interfaceOptions = nil
    }
    
    return await wrapped.encrypt(
      dataIdentifier: dataIdentifier,
      keyIdentifier: keyIdentifier,
      options: interfaceOptions
    )
  }

  /// Decrypts binary data using a key from secure storage.
  /// - Parameters:
  ///   - encryptedDataIdentifier: Identifier of the encrypted data in secure storage.
  ///   - keyIdentifier: Identifier of the decryption key in secure storage.
  ///   - options: Optional decryption configuration.
  /// - Returns: Identifier for the decrypted data in secure storage, or an error.
  public func decrypt(
    encryptedDataIdentifier: String,
    keyIdentifier: String,
    options: SecurityCoreInterfaces.DecryptionOptions?
  ) async -> Result<String, SecurityStorageError> {
    // Convert options type if needed
    let interfaceOptions: SecurityCoreInterfaces.DecryptionOptions?
    if let options = options {
      // Create equivalent SecurityCoreInterfaces options from CryptoServices options
      interfaceOptions = SecurityCoreInterfaces.DecryptionOptions(
        algorithm: .aes256GCM
      )
    } else {
      interfaceOptions = nil
    }
    
    return await wrapped.decrypt(
      encryptedDataIdentifier: encryptedDataIdentifier,
      keyIdentifier: keyIdentifier,
      options: interfaceOptions
    )
  }

  /// Computes a cryptographic hash of data in secure storage.
  /// - Parameter dataIdentifier: Identifier of the data to hash in secure storage.
  /// - Returns: Identifier for the hash in secure storage, or an error.
  public func hash(
    dataIdentifier: String,
    options: SecurityCoreInterfaces.HashingOptions?
  ) async -> Result<String, SecurityStorageError> {
    // Convert options type if needed
    let interfaceOptions: SecurityCoreInterfaces.HashingOptions?
    if let options = options {
      // Create equivalent SecurityCoreInterfaces options from CryptoServices options
      interfaceOptions = SecurityCoreInterfaces.HashingOptions(
        algorithm: .sha256
      )
    } else {
      interfaceOptions = nil
    }
    
    return await wrapped.hash(
      dataIdentifier: dataIdentifier,
      options: interfaceOptions
    )
  }

  /// Verifies a cryptographic hash against the expected value, both stored securely.
  /// - Parameters:
  ///   - dataIdentifier: Identifier of the data to verify in secure storage.
  ///   - hashIdentifier: Identifier of the expected hash in secure storage.
  /// - Returns: `true` if the hash matches, `false` if not, or an error.
  public func verifyHash(
    dataIdentifier: String,
    hashIdentifier: String,
    options: SecurityCoreInterfaces.HashingOptions?
  ) async -> Result<Bool, SecurityStorageError> {
    // Convert options type if needed
    let interfaceOptions: SecurityCoreInterfaces.HashingOptions?
    if let options = options {
      // Create equivalent SecurityCoreInterfaces options from CryptoServices options
      interfaceOptions = SecurityCoreInterfaces.HashingOptions(
        algorithm: .sha256
      )
    } else {
      interfaceOptions = nil
    }
    
    return await wrapped.verifyHash(
      dataIdentifier: dataIdentifier,
      hashIdentifier: hashIdentifier,
      options: interfaceOptions
    )
  }

  /// Generates a cryptographic key and stores it securely.
  /// - Parameters:
  ///   - length: The length of the key to generate in bytes.
  ///   - options: Optional key generation configuration.
  /// - Returns: Identifier for the generated key in secure storage, or an error.
  public func generateKey(
    length: Int,
    options: SecurityCoreInterfaces.KeyGenerationOptions?
  ) async -> Result<String, SecurityStorageError> {
    // Convert options type if needed
    let interfaceOptions: SecurityCoreInterfaces.KeyGenerationOptions?
    if let options = options {
      // Create equivalent SecurityCoreInterfaces options from CryptoServices options
      interfaceOptions = SecurityCoreInterfaces.KeyGenerationOptions(
        persistent: true,
        keyType: .symmetric
      )
    } else {
      interfaceOptions = nil
    }
    
    return await wrapped.generateKey(
      length: length,
      options: interfaceOptions
    )
  }

  /// Imports data into secure storage for use with cryptographic operations.
  /// - Parameters:
  ///   - data: The raw data to store securely.
  ///   - customIdentifier: Optional custom identifier for the data. If nil, a random identifier is
  /// generated.
  /// - Returns: The identifier for the data in secure storage, or an error.
  public func importData(
    _ data: [UInt8],
    customIdentifier: String?
  ) async -> Result<String, SecurityStorageError> {
    return await wrapped.importData(
      data,
      customIdentifier: customIdentifier
    )
  }

  /// Exports data from secure storage.
  /// - Parameter identifier: The identifier of the data to export.
  /// - Returns: The raw data, or an error.
  /// - Warning: Use with caution as this exposes sensitive data.
  func exportData(
    identifier: String
  ) async -> Result<[UInt8], SecurityStorageError> {
    return await wrapped.exportData(
      identifier: identifier
    )
  }
}

/**
 Configuration options for the CryptoService implementation.

 allowing customisation of security parameters and algorithm choices.
 */
// This struct has been moved to CryptoServiceOptions.swift
// public struct CryptoServiceOptions: Sendable {
//   /// Default iteration count for PBKDF2 key derivation
//   public let defaultIterations: Int
// 
//   /// Preferred key size for AES encryption in bytes
//   public let preferredKeySize: Int
// 
//   /// Size of initialisation vector in bytes
//   public let ivSize: Int
// 
//   /// Creates a new CryptoServiceOptions instance with the specified parameters
//   ///
//   /// - Parameters:
//   ///   - defaultIterations: Iteration count for PBKDF2 (default: 10000)
//   ///   - preferredKeySize: Preferred key size in bytes (default: 32 for AES-256)
//   ///   - ivSize: Size of initialisation vector in bytes (default: 12)
//   public init(
//     defaultIterations: Int=10000,
//     preferredKeySize: Int=32,
//     ivSize: Int=12
//   ) {
//     self.defaultIterations=defaultIterations
//     self.preferredKeySize=preferredKeySize
//     self.ivSize=ivSize
//   }
// }

/**
 Creates a simple secure storage for internal use.
 This is a helper method to avoid circular dependencies.
 */
private static func createLocalSecureStorage(logger: LoggingProtocol) async -> SecureStorageProtocol {
  return InMemorySecureStorage(
    logger: logger,
    baseURL: URL(fileURLWithPath: NSTemporaryDirectory()).appendingPathComponent("crypto_storage")
  )
}

/**
 Creates a basic security provider for internal use.
 This is a helper method to avoid circular dependencies.
 */
private static func createBasicSecurityProvider(_ type: SecurityProviderType) async -> SecurityProviderProtocol {
  // Create a simple provider that implements the required interface
  return BasicSecurityProvider(type: type)
}

/**
 Creates a secure storage instance for storing sensitive data.
 */
private static func createSecureStorage() async -> SecureCryptoStorage {
  let secureStorage = FileSecureStorage()
  let logger = DefaultConsoleLogger()
  return SecureCryptoStorage(secureStorage: secureStorage, logger: logger)
}

/**
 Implementation of CryptoServiceProtocol that uses a security provider.
 This implementation avoids circular dependencies by being defined directly
 within the CryptoServices module rather than relying on external actors.
 */
fileprivate actor DefaultCryptoServiceWithProviderImpl: CryptoServiceProtocol {
  private let provider: SecurityProviderProtocol
  private let secureStorage: SecureStorageProtocol
  private let logger: LoggingProtocol
  
  init(
    provider: SecurityProviderProtocol,
    secureStorage: SecureStorageProtocol,
    logger: LoggingProtocol
  ) {
    self.provider = provider
    self.secureStorage = secureStorage
    self.logger = logger
  }
  
  // MARK: - CryptoServiceProtocol Implementation
  
  /**
   Implementation of encrypt method that uses the security provider.
   
   - Parameters:
     - dataIdentifier: Identifier of the data to encrypt in secure storage
     - keyIdentifier: Identifier of the encryption key in secure storage
     - options: Optional encryption configuration
   - Returns: Identifier for the encrypted data in secure storage, or an error
   */
  public func encrypt(
    dataIdentifier: String,
    keyIdentifier: String,
    options: SecurityCoreInterfaces.EncryptionOptions?
  ) async -> Result<String, SecurityStorageError> {
    // Retrieve the data to encrypt from secure storage
    let dataResult = await self.exportData(identifier: dataIdentifier)
    guard case let .success(data) = dataResult else {
      if case let .failure(error) = dataResult {
        return .failure(error)
      }
      return .failure(.keyNotFound)
    }
    
    // Retrieve the encryption key from secure storage
    let keyResult = await self.exportData(identifier: keyIdentifier)
    guard case let .success(keyData) = keyResult else {
      if case let .failure(error) = keyResult {
        return .failure(error)
      }
      return .failure(.keyNotFound)
    }
    
    // Convert options type if needed
    let interfaceOptions: SecurityCoreInterfaces.EncryptionOptions?
    if let options = options {
      // Create equivalent SecurityCoreInterfaces options from CryptoServices options
      interfaceOptions = SecurityCoreInterfaces.EncryptionOptions(
        algorithm: .aes256GCM
      )
    } else {
      interfaceOptions = nil
    }
    
    // Create config for provider
    let config = SecurityConfigDTO(
      encryptionAlgorithm: .aes256GCM,
      hashAlgorithm: .sha256,
      providerType: .basic,
      options: SecurityConfigOptions(metadata: ["keyData": "keyData", "inputData": "data"])
    )
    
    do {
      // Call provider to encrypt
      let result = try await provider.encrypt(config: config)
      
      // Store the encrypted data
      let encryptedId = "encrypted_\(UUID().uuidString)"
      let storeResult = await self.importData(result.resultData?.data?.data, customIdentifier: encryptedId)
      
      return storeResult
    } catch {
      return .failure(.operationFailed("Encryption operation failed"))
    }
  }
  
  /**
   Implementation of decrypt method that uses the security provider.
   
   - Parameters:
     - encryptedDataIdentifier: Identifier of the encrypted data in secure storage
     - keyIdentifier: Identifier of the decryption key in secure storage
     - options: Optional decryption configuration
   - Returns: Identifier for the decrypted data in secure storage, or an error
   */
  public func decrypt(
    encryptedDataIdentifier: String,
    keyIdentifier: String,
    options: SecurityCoreInterfaces.DecryptionOptions?
  ) async -> Result<String, SecurityStorageError> {
    // Retrieve the encrypted data from secure storage
    let dataResult = await self.exportData(identifier: encryptedDataIdentifier)
    guard case let .success(data) = dataResult else {
      if case let .failure(error) = dataResult {
        return .failure(error)
      }
      return .failure(.keyNotFound)
    }
    
    // Retrieve the decryption key from secure storage
    let keyResult = await self.exportData(identifier: keyIdentifier)
    guard case let .success(keyData) = keyResult else {
      if case let .failure(error) = keyResult {
        return .failure(error)
      }
      return .failure(.keyNotFound)
    }
    
    // Convert options type if needed
    let interfaceOptions: SecurityCoreInterfaces.DecryptionOptions?
    if let options = options {
      // Create equivalent SecurityCoreInterfaces options from CryptoServices options
      interfaceOptions = SecurityCoreInterfaces.DecryptionOptions(
        algorithm: .aes256GCM
      )
    } else {
      interfaceOptions = nil
    }
    
    // Create config for provider
    let config = SecurityConfigDTO(
      encryptionAlgorithm: .aes256GCM,
      hashAlgorithm: .sha256,
      providerType: .basic,
      options: SecurityConfigOptions(metadata: ["keyData": "keyData", "inputData": "data"])
    )
    
    do {
      // Call provider to decrypt
      let result = try await provider.decrypt(config: config)
      
      // Store the decrypted data
      let decryptedId = "decrypted_\(UUID().uuidString)"
      let storeResult = await self.importData(result.resultData?.data?.data, customIdentifier: decryptedId)
      
      return storeResult
    } catch {
      return .failure(.operationFailed("Decryption operation failed"))
    }
  }
  
  /**
   Computes a cryptographic hash of data in secure storage.
   
   - Parameters:
     - dataIdentifier: Identifier of the data to hash in secure storage
     - options: Optional hashing configuration
   - Returns: Identifier for the hash in secure storage, or an error
   */
  public func hash(
    dataIdentifier: String,
    options: SecurityCoreInterfaces.HashingOptions?
  ) async -> Result<String, SecurityStorageError> {
    // Retrieve the data to hash from secure storage
    let dataResult = await self.exportData(identifier: dataIdentifier)
    guard case let .success(data) = dataResult else {
      if case let .failure(error) = dataResult {
        return .failure(error)
      }
      return .failure(.keyNotFound)
    }
    
    // Convert options type if needed
    let interfaceOptions: SecurityCoreInterfaces.HashingOptions?
    if let options = options {
      // Create equivalent SecurityCoreInterfaces options from CryptoServices options
      interfaceOptions = SecurityCoreInterfaces.HashingOptions(
        algorithm: .sha256
      )
    } else {
      interfaceOptions = nil
    }
    
    // Create config for provider
    let config = SecurityConfigDTO(
      encryptionAlgorithm: .aes256CBC,
      hashAlgorithm: .sha256,
      providerType: .basic
    )
    
    do {
      // Call provider to hash
      let result = try await provider.hash(data: data, config: config)
      
      // Store the hash
      let hashId = "hash_\(UUID().uuidString)"
      let storeResult = await self.importData(result.resultData?.data?.data, customIdentifier: hashId)
      
      return storeResult
    } catch {
      return .failure(.operationFailed("Hashing operation failed"))
    }
  }
  
  /**
   Verifies a cryptographic hash against data in secure storage.
   
   - Parameters:
     - dataIdentifier: Identifier of the data to verify in secure storage
     - hashIdentifier: Identifier of the expected hash in secure storage
     - options: Optional hashing configuration
   - Returns: `true` if the hash matches, `false` if not, or an error
   */
  public func verifyHash(
    dataIdentifier: String,
    hashIdentifier: String,
    options: SecurityCoreInterfaces.HashingOptions?
  ) async -> Result<Bool, SecurityStorageError> {
    // Get the data to verify
    let dataResult = await self.exportData(identifier: dataIdentifier)
    guard case let .success(data) = dataResult else {
      if case let .failure(error) = dataResult {
        return .failure(error)
      }
      return .failure(.keyNotFound)
    }
    
    // Get the expected hash
    let hashResult = await self.exportData(identifier: hashIdentifier)
    guard case let .success(hash) = hashResult else {
      if case let .failure(error) = hashResult {
        return .failure(error)
      }
      return .failure(.keyNotFound)
    }
    
    // Convert options type if needed
    let interfaceOptions: SecurityCoreInterfaces.HashingOptions?
    if let options = options {
      // Create equivalent SecurityCoreInterfaces options from CryptoServices options
      interfaceOptions = SecurityCoreInterfaces.HashingOptions(
        algorithm: .sha256
      )
    } else {
      interfaceOptions = nil
    }
    
    // Create config for provider
    let config = SecurityConfigDTO(
      encryptionAlgorithm: .aes256CBC,
      hashAlgorithm: .sha256,
      providerType: .basic,
      options: SecurityConfigOptions(metadata: ["expectedHash": "hash"])
    )
    do {
      // Call provider to verify hash
      let result = try await provider.verifyHash(data: data, hash: hash, config: config)
      return .success(result.verified)
    } catch {
      return .failure(.operationFailed("Hash verification failed"))
    }
  }
  
  /**
   Generates a cryptographic key and stores it securely.
   
   - Parameters:
     - length: Key length in bits
     - options: Optional key generation configuration
   - Returns: Identifier for the generated key in secure storage, or an error
   */
  public func generateKey(
    length: Int,
    options: SecurityCoreInterfaces.KeyGenerationOptions?
  ) async -> Result<String, SecurityStorageError> {
    // Build configuration
    let config = SecurityConfigDTO(
      encryptionAlgorithm: .aes256GCM,
      hashAlgorithm: .sha256,
      providerType: .basic,
      options: SecurityConfigOptions(["keyLength": String(length)])
    )
    
    do {
      // Generate key using provider
      let result = try await provider.generateKey(config: config)
      let keyData = result.resultData
      
      // Store the key in secure storage
      let keyId = "key_\(UUID().uuidString)"
      let storeResult = await self.importData(result.resultData?.data?.data, customIdentifier: keyId)
      
      return storeResult
    } catch {
      return .failure(.operationFailed("Key generation failed"))
    }
  }
  
  /**
   Imports data into secure storage.
   
   - Parameters:
     - data: Data to import into secure storage
     - customIdentifier: Optional custom identifier for the data
   - Returns: Identifier for the data in secure storage, or an error
   */
  public func importData(
    _ data: [UInt8],
    customIdentifier: String? = nil
  ) async -> Result<String, SecurityStorageError> {
    // Create identifier if not provided
    let identifier = customIdentifier ?? "data_\(UUID().uuidString)"
    
    // Store data
    do {
      let result = await self.secureStorage.storeData(data, withIdentifier: identifier)
      
      switch result {
      case .success:
        return .success(identifier)
      case .failure(let error):
        return .failure(error)
      }
  }
  
  /**
   Exports data from secure storage.
   
   - Parameter identifier: Identifier of the data to export
   - Returns: The raw data bytes, or an error
   */
  func exportData(
    identifier: String
  ) async -> Result<[UInt8], SecurityStorageError> {
    // Retrieve data from secure storage
    return await self.secureStorage.retrieveData(withIdentifier: identifier)
  }
}

/**
 A basic implementation of SecurityProviderProtocol for internal use.
 */
fileprivate actor BasicSecurityProvider: SecurityProviderProtocol {
  private let providerType: SecurityProviderType
  
  init(type: SecurityProviderType) {
    self.providerType = type
  }
  
  func encrypt(config: SecurityConfigDTO) async throws -> SecurityResultDTO {
    // Basic implementation that provides a simulated encryption result
    let outputData: [UInt8] = Array("encrypted_data_\(UUID().uuidString)".utf8)
    return SecurityResultDTO.success(resultData: Data(outputData), executionTimeMs: 0.0)
  }
  
  func decrypt(config: SecurityConfigDTO) async throws -> SecurityResultDTO {
    // Basic implementation that provides a simulated decryption result
    let outputData: [UInt8] = Array("decrypted_data_\(UUID().uuidString)".utf8)
    return SecurityResultDTO.success(resultData: Data(outputData), executionTimeMs: 0.0)
  }
  
  func generateKey(config: SecurityConfigDTO) async throws -> SecurityResultDTO {
    var keyData: [UInt8]
    
    // Generate a random key based on the algorithm
    switch config.encryptionAlgorithm {
    case .aes256CBC, .aes256GCM:
      keyData = [UInt8](repeating: 0, count: 32) // 256 bits
    case .chacha20Poly1305:
      keyData = [UInt8](repeating: 0, count: 32) // 256 bits
    }
    
    return SecurityResultDTO.success(resultData: Data(keyData), executionTimeMs: 0.0)
  }
  
  func verifyHash(config: SecurityConfigDTO) async throws -> SecurityResultDTO {
    // Basic implementation that simulates hash verification
    return SecurityResultDTO.success(resultData: Data([]), executionTimeMs: 0.0)
  }
  
  func hash(config: SecurityConfigDTO) async throws -> SecurityResultDTO {
    // Basic implementation that provides a simulated hash result
    let outputData: [UInt8] = Array("hash_result_\(UUID().uuidString)".utf8)
    return SecurityResultDTO.success(resultData: Data(outputData), executionTimeMs: 0.0)
  }
}

/**
 Creates a simple secure storage for internal use.
 This is a helper method to avoid circular dependencies.
 */
private static func createLocalSecureStorage(logger: LoggingProtocol) async -> SecureStorageProtocol {
  return InMemorySecureStorage(
    logger: logger,
    baseURL: URL(fileURLWithPath: NSTemporaryDirectory()).appendingPathComponent("crypto_storage")
  )
}

/**
 Creates a basic security provider for internal use.
 This is a helper method to avoid circular dependencies.
 */
private static func createBasicSecurityProvider(_ type: SecurityProviderType) async -> SecurityProviderProtocol {
  // Create a simple provider that implements the required interface
  return BasicSecurityProvider(type: type)
}

/**
 Creates a secure storage instance for storing sensitive data.
 */
private static func createSecureStorage() async -> SecureCryptoStorage {
  // Use the default secure storage implementation
  let secureStorage = InMemorySecureStorage(
    logger: EmptyLogger(),
    baseURL: URL(fileURLWithPath: NSTemporaryDirectory()).appendingPathComponent("secure_crypto_storage")
  )
  let logger = EmptyLogger()
  return SecureCryptoStorage(secureStorage: secureStorage, logger: logger)
}

/**
 Empty logger implementation to avoid circular dependencies
 */
private struct EmptyLogger: LoggingProtocol, CoreLoggingProtocol {
  func logMessage(_ level: LogLevel, _ message: String, context: LogContext) async {}
}