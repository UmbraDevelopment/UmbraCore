import XCTest
@testable import UmbraKeychainService

final class KeychainXPCServiceTests: XCTestCase {
    var connection: KeychainXPCConnection!
    let testService = "com.umbracore.tests"
    let testAccount = "testAccount"
    let testData = "Test data string".data(using: .utf8)!
    
    override class func setUp() {
        super.setUp()
        try? XPCServiceHelper.startService()
    }
    
    override class func tearDown() {
        XPCServiceHelper.stopService()
        super.tearDown()
    }
    
    override func setUp() async throws {
        try await super.setUp()
        connection = KeychainXPCConnection()
        try await XPCServiceHelper.cleanupTestItems()
    }
    
    override func tearDown() async throws {
        try await XPCServiceHelper.cleanupTestItems()
        connection.disconnect()
        connection = nil
        try await super.tearDown()
    }
    
    func testXPCConnection() async throws {
        let proxy = try connection.connect()
        XCTAssertNotNil(proxy)
        
        // Test basic operation to ensure connection is working
        try await proxy.addItem(
            testData,
            account: testAccount,
            service: testService,
            accessGroup: nil,
            accessibility: kSecAttrAccessibleWhenUnlocked as String,
            flags: 0
        )
    }
    
    func testAddAndReadItem() async throws {
        let proxy = try connection.connect()
        
        // Add item
        try await proxy.addItem(
            testData,
            account: testAccount,
            service: testService,
            accessGroup: nil,
            accessibility: kSecAttrAccessibleWhenUnlocked as String,
            flags: 0
        )
        
        // Read item
        let retrievedData = try await proxy.readItem(
            account: testAccount,
            service: testService,
            accessGroup: nil
        )
        
        XCTAssertEqual(retrievedData, testData)
    }
    
    func testUpdateItem() async throws {
        let proxy = try connection.connect()
        
        // Add initial item
        try await proxy.addItem(
            testData,
            account: testAccount,
            service: testService,
            accessGroup: nil,
            accessibility: kSecAttrAccessibleWhenUnlocked as String,
            flags: 0
        )
        
        // Update item
        let updatedData = "Updated test data".data(using: .utf8)!
        try await proxy.updateItem(
            updatedData,
            account: testAccount,
            service: testService,
            accessGroup: nil
        )
        
        // Verify update
        let retrievedData = try await proxy.readItem(
            account: testAccount,
            service: testService,
            accessGroup: nil
        )
        
        XCTAssertEqual(retrievedData, updatedData)
    }
    
    func testDeleteItem() async throws {
        let proxy = try connection.connect()
        
        // Add item
        try await proxy.addItem(
            testData,
            account: testAccount,
            service: testService,
            accessGroup: nil,
            accessibility: kSecAttrAccessibleWhenUnlocked as String,
            flags: 0
        )
        
        // Delete item
        try await proxy.deleteItem(
            account: testAccount,
            service: testService,
            accessGroup: nil
        )
        
        // Verify deletion
        do {
            _ = try await proxy.readItem(
                account: testAccount,
                service: testService,
                accessGroup: nil
            )
            XCTFail("Expected error not thrown")
        } catch let error as KeychainError {
            XCTAssertEqual(error.errorDescription, KeychainError.itemNotFound.errorDescription)
        }
    }
    
    func testConnectionReuse() async throws {
        let proxy1 = try connection.connect()
        let proxy2 = try connection.connect()
        
        // Should return the same proxy instance
        XCTAssertTrue(proxy1 === proxy2 as AnyObject)
        
        // Verify connection is working
        try await proxy1.addItem(
            testData,
            account: testAccount,
            service: testService,
            accessGroup: nil,
            accessibility: kSecAttrAccessibleWhenUnlocked as String,
            flags: 0
        )
    }
    
    func testConnectionRecovery() async throws {
        let proxy = try connection.connect()
        
        // Add test item
        try await proxy.addItem(
            testData,
            account: testAccount,
            service: testService,
            accessGroup: nil,
            accessibility: kSecAttrAccessibleWhenUnlocked as String,
            flags: 0
        )
        
        // Simulate connection failure
        connection.disconnect()
        
        // Should be able to reconnect
        let newProxy = try connection.connect()
        XCTAssertNotNil(newProxy)
        
        // Verify connection is working
        let retrievedData = try await newProxy.readItem(
            account: testAccount,
            service: testService,
            accessGroup: nil
        )
        XCTAssertEqual(retrievedData, testData)
    }
}
