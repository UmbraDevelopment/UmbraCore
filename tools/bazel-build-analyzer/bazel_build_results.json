[
  {
    "target": "rule //packages/UmbraCoreTypes/Sources/APIInterfaces:APIInterfaces",
    "success": true,
    "start_time": "2025-04-11T17:56:58.669569+01:00",
    "end_time": "2025-04-11T17:57:01.259774+01:00",
    "duration": "2.590206833s",
    "output": "INFO: Invocation ID: 5ca1aa91-6a85-4fd3-a6a9-b31a11b94782\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraCoreTypes/Sources/APIInterfaces:APIInterfaces (4 packages loaded, 7 targets configured)\nAnalyzing: target //packages/UmbraCoreTypes/Sources/APIInterfaces:APIInterfaces (4 packages loaded, 7 targets configured)\n\nINFO: Analyzed target //packages/UmbraCoreTypes/Sources/APIInterfaces:APIInterfaces (106 packages loaded, 2810 targets configured).\nINFO: Found 1 target...\nTarget //packages/UmbraCoreTypes/Sources/APIInterfaces:APIInterfaces up-to-date:\n  bazel-bin/packages/UmbraCoreTypes/Sources/APIInterfaces/APIInterfaces.swiftdoc\n  bazel-bin/packages/UmbraCoreTypes/Sources/APIInterfaces/APIInterfaces.swiftmodule\n  bazel-bin/packages/UmbraCoreTypes/Sources/APIInterfaces/APIInterfaces.swiftsourceinfo\n  bazel-bin/packages/UmbraCoreTypes/Sources/APIInterfaces/libAPIInterfaces.a\nINFO: Elapsed time: 1.888s, Critical Path: 0.45s\nINFO: 5 processes: 59 action cache hit, 2 disk cache hit, 2 internal, 1 worker.\nINFO: Build completed successfully, 5 total actions\n"
  },
  {
    "target": "rule //packages/UmbraCoreTypes/Sources/ConfigInterfaces:ConfigInterfaces",
    "success": true,
    "start_time": "2025-04-11T17:57:01.259781+01:00",
    "end_time": "2025-04-11T17:57:02.551501+01:00",
    "duration": "1.291721875s",
    "output": "INFO: Invocation ID: fb08c525-5b04-4113-9c08-f92520292df2\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraCoreTypes/Sources/ConfigInterfaces:ConfigInterfaces (1 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraCoreTypes/Sources/ConfigInterfaces:ConfigInterfaces (1 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraCoreTypes/Sources/ConfigInterfaces:ConfigInterfaces (1 packages loaded, 6 targets configured).\nINFO: Found 1 target...\nTarget //packages/UmbraCoreTypes/Sources/ConfigInterfaces:ConfigInterfaces up-to-date:\n  bazel-bin/packages/UmbraCoreTypes/Sources/ConfigInterfaces/ConfigInterfaces.swiftdoc\n  bazel-bin/packages/UmbraCoreTypes/Sources/ConfigInterfaces/ConfigInterfaces.swiftmodule\n  bazel-bin/packages/UmbraCoreTypes/Sources/ConfigInterfaces/ConfigInterfaces.swiftsourceinfo\n  bazel-bin/packages/UmbraCoreTypes/Sources/ConfigInterfaces/libConfigInterfaces.a\nINFO: Elapsed time: 0.575s, Critical Path: 0.46s\nINFO: 3 processes: 1 action cache hit, 1 disk cache hit, 1 internal, 1 worker.\nINFO: Build completed successfully, 3 total actions\n"
  },
  {
    "target": "rule //packages/UmbraCoreTypes/Sources/CoreDTOs:CoreDTOs",
    "success": true,
    "start_time": "2025-04-11T17:57:02.551522+01:00",
    "end_time": "2025-04-11T17:57:03.358007+01:00",
    "duration": "806.485667ms",
    "output": "INFO: Invocation ID: 5bb99c1a-eb5a-4fcb-91b6-602827a375f4\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraCoreTypes/Sources/CoreDTOs:CoreDTOs (0 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraCoreTypes/Sources/CoreDTOs:CoreDTOs (0 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraCoreTypes/Sources/CoreDTOs:CoreDTOs (0 packages loaded, 0 targets configured).\nINFO: Found 1 target...\nTarget //packages/UmbraCoreTypes/Sources/CoreDTOs:CoreDTOs up-to-date:\n  bazel-bin/packages/UmbraCoreTypes/Sources/CoreDTOs/CoreDTOs.swiftdoc\n  bazel-bin/packages/UmbraCoreTypes/Sources/CoreDTOs/CoreDTOs.swiftmodule\n  bazel-bin/packages/UmbraCoreTypes/Sources/CoreDTOs/CoreDTOs.swiftsourceinfo\n  bazel-bin/packages/UmbraCoreTypes/Sources/CoreDTOs/libCoreDTOs.a\nINFO: Elapsed time: 0.100s, Critical Path: 0.00s\nINFO: 1 process: 1 action cache hit, 1 internal.\nINFO: Build completed successfully, 1 total action\n"
  },
  {
    "target": "rule //packages/UmbraCoreTypes/Sources/CoreDTOs:CoreDTOsTests",
    "success": true,
    "start_time": "2025-04-11T17:57:03.358011+01:00",
    "end_time": "2025-04-11T17:57:06.015133+01:00",
    "duration": "2.65712475s",
    "output": "INFO: Invocation ID: 18587f1c-6b85-4643-ba81-9d1df42036a4\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraCoreTypes/Sources/CoreDTOs:CoreDTOsTests (0 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraCoreTypes/Sources/CoreDTOs:CoreDTOsTests (0 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraCoreTypes/Sources/CoreDTOs:CoreDTOsTests (0 packages loaded, 1 target configured).\n[3 / 4] [Prepa] Linking packages/UmbraCoreTypes/Sources/CoreDTOs/libCoreDTOsTests.a\nINFO: Found 1 target...\nTarget //packages/UmbraCoreTypes/Sources/CoreDTOs:CoreDTOsTests up-to-date:\n  bazel-bin/packages/UmbraCoreTypes/Sources/CoreDTOs/CoreDTOsTests.swiftdoc\n  bazel-bin/packages/UmbraCoreTypes/Sources/CoreDTOs/CoreDTOsTests.swiftmodule\n  bazel-bin/packages/UmbraCoreTypes/Sources/CoreDTOs/CoreDTOsTests.swiftsourceinfo\n  bazel-bin/packages/UmbraCoreTypes/Sources/CoreDTOs/libCoreDTOsTests.a\nINFO: Elapsed time: 1.954s, Critical Path: 1.83s\nINFO: 3 processes: 1 action cache hit, 1 disk cache hit, 1 internal, 1 worker.\nINFO: Build completed successfully, 3 total actions\n"
  },
  {
    "target": "rule //packages/UmbraCoreTypes/Sources/CoreInterfaces:CoreInterfaces",
    "success": true,
    "start_time": "2025-04-11T17:57:06.015138+01:00",
    "end_time": "2025-04-11T17:57:07.267768+01:00",
    "duration": "1.252631375s",
    "output": "INFO: Invocation ID: e5876092-5e6a-4ce4-b174-13e0ea0a8600\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraCoreTypes/Sources/CoreInterfaces:CoreInterfaces (1 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraCoreTypes/Sources/CoreInterfaces:CoreInterfaces (1 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraCoreTypes/Sources/CoreInterfaces:CoreInterfaces (1 packages loaded, 8 targets configured).\nINFO: Found 1 target...\nTarget //packages/UmbraCoreTypes/Sources/CoreInterfaces:CoreInterfaces up-to-date:\n  bazel-bin/packages/UmbraCoreTypes/Sources/CoreInterfaces/CoreInterfaces.swiftdoc\n  bazel-bin/packages/UmbraCoreTypes/Sources/CoreInterfaces/CoreInterfaces.swiftmodule\n  bazel-bin/packages/UmbraCoreTypes/Sources/CoreInterfaces/CoreInterfaces.swiftsourceinfo\n  bazel-bin/packages/UmbraCoreTypes/Sources/CoreInterfaces/libCoreInterfaces.a\nINFO: Elapsed time: 0.555s, Critical Path: 0.43s\nINFO: 3 processes: 1 action cache hit, 1 disk cache hit, 1 internal, 1 worker.\nINFO: Build completed successfully, 3 total actions\n"
  },
  {
    "target": "rule //packages/UmbraCoreTypes/Sources/CoreSecurityTypes:CoreSecurityTypes",
    "success": true,
    "start_time": "2025-04-11T17:57:07.267773+01:00",
    "end_time": "2025-04-11T17:57:08.073783+01:00",
    "duration": "806.011084ms",
    "output": "INFO: Invocation ID: 71c5ce7e-be7e-4ad0-b2db-10755d0afcac\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraCoreTypes/Sources/CoreSecurityTypes:CoreSecurityTypes (0 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraCoreTypes/Sources/CoreSecurityTypes:CoreSecurityTypes (0 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraCoreTypes/Sources/CoreSecurityTypes:CoreSecurityTypes (0 packages loaded, 0 targets configured).\nINFO: Found 1 target...\nTarget //packages/UmbraCoreTypes/Sources/CoreSecurityTypes:CoreSecurityTypes up-to-date:\n  bazel-bin/packages/UmbraCoreTypes/Sources/CoreSecurityTypes/CoreSecurityTypes.swiftdoc\n  bazel-bin/packages/UmbraCoreTypes/Sources/CoreSecurityTypes/CoreSecurityTypes.swiftmodule\n  bazel-bin/packages/UmbraCoreTypes/Sources/CoreSecurityTypes/CoreSecurityTypes.swiftsourceinfo\n  bazel-bin/packages/UmbraCoreTypes/Sources/CoreSecurityTypes/libCoreSecurityTypes.a\nINFO: Elapsed time: 0.107s, Critical Path: 0.00s\nINFO: 1 process: 1 action cache hit, 1 internal.\nINFO: Build completed successfully, 1 total action\n"
  },
  {
    "target": "rule //packages/UmbraCoreTypes/Sources/CryptoInterfaces:CryptoInterfaces",
    "success": true,
    "start_time": "2025-04-11T17:57:08.073788+01:00",
    "end_time": "2025-04-11T17:57:09.384634+01:00",
    "duration": "1.310847625s",
    "output": "INFO: Invocation ID: 28c0114c-656c-435d-a695-526473fdff0e\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraCoreTypes/Sources/CryptoInterfaces:CryptoInterfaces (1 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraCoreTypes/Sources/CryptoInterfaces:CryptoInterfaces (1 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraCoreTypes/Sources/CryptoInterfaces:CryptoInterfaces (2 packages loaded, 16 targets configured).\nINFO: Found 1 target...\nTarget //packages/UmbraCoreTypes/Sources/CryptoInterfaces:CryptoInterfaces up-to-date:\n  bazel-bin/packages/UmbraCoreTypes/Sources/CryptoInterfaces/CryptoInterfaces.swiftdoc\n  bazel-bin/packages/UmbraCoreTypes/Sources/CryptoInterfaces/CryptoInterfaces.swiftmodule\n  bazel-bin/packages/UmbraCoreTypes/Sources/CryptoInterfaces/CryptoInterfaces.swiftsourceinfo\n  bazel-bin/packages/UmbraCoreTypes/Sources/CryptoInterfaces/libCryptoInterfaces.a\nINFO: Elapsed time: 0.538s, Critical Path: 0.41s\nINFO: 3 processes: 3 action cache hit, 1 disk cache hit, 1 internal, 1 worker.\nINFO: Build completed successfully, 3 total actions\n"
  },
  {
    "target": "rule //packages/UmbraCoreTypes/Sources/CryptoTypes:CryptoTypes",
    "success": true,
    "start_time": "2025-04-11T17:57:09.384639+01:00",
    "end_time": "2025-04-11T17:57:10.460435+01:00",
    "duration": "1.075797417s",
    "output": "INFO: Invocation ID: 71d08d50-ba88-4c1e-90d7-793693c6a1cb\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraCoreTypes/Sources/CryptoTypes:CryptoTypes (0 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraCoreTypes/Sources/CryptoTypes:CryptoTypes (0 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraCoreTypes/Sources/CryptoTypes:CryptoTypes (0 packages loaded, 0 targets configured).\nINFO: Found 1 target...\nTarget //packages/UmbraCoreTypes/Sources/CryptoTypes:CryptoTypes up-to-date:\n  bazel-bin/packages/UmbraCoreTypes/Sources/CryptoTypes/CryptoTypes.swiftdoc\n  bazel-bin/packages/UmbraCoreTypes/Sources/CryptoTypes/CryptoTypes.swiftmodule\n  bazel-bin/packages/UmbraCoreTypes/Sources/CryptoTypes/CryptoTypes.swiftsourceinfo\n  bazel-bin/packages/UmbraCoreTypes/Sources/CryptoTypes/libCryptoTypes.a\nINFO: Elapsed time: 0.124s, Critical Path: 0.00s\nINFO: 1 process: 1 action cache hit, 1 internal.\nINFO: Build completed successfully, 1 total action\n"
  },
  {
    "target": "rule //packages/UmbraCoreTypes/Sources/DateTimeTypes:DateTimeTypes",
    "success": true,
    "start_time": "2025-04-11T17:57:10.460439+01:00",
    "end_time": "2025-04-11T17:57:11.29817+01:00",
    "duration": "837.731958ms",
    "output": "INFO: Invocation ID: 300ff8ef-ff0c-4de8-892a-9140f0c2fb23\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraCoreTypes/Sources/DateTimeTypes:DateTimeTypes (0 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraCoreTypes/Sources/DateTimeTypes:DateTimeTypes (0 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraCoreTypes/Sources/DateTimeTypes:DateTimeTypes (0 packages loaded, 0 targets configured).\nINFO: Found 1 target...\nTarget //packages/UmbraCoreTypes/Sources/DateTimeTypes:DateTimeTypes up-to-date:\n  bazel-bin/packages/UmbraCoreTypes/Sources/DateTimeTypes/DateTimeTypes.swiftdoc\n  bazel-bin/packages/UmbraCoreTypes/Sources/DateTimeTypes/DateTimeTypes.swiftmodule\n  bazel-bin/packages/UmbraCoreTypes/Sources/DateTimeTypes/DateTimeTypes.swiftsourceinfo\n  bazel-bin/packages/UmbraCoreTypes/Sources/DateTimeTypes/libDateTimeTypes.a\nINFO: Elapsed time: 0.118s, Critical Path: 0.00s\nINFO: 1 process: 1 action cache hit, 1 internal.\nINFO: Build completed successfully, 1 total action\n"
  },
  {
    "target": "rule //packages/UmbraCoreTypes/Sources/DomainSecurityTypes:DomainSecurityTypes",
    "success": true,
    "start_time": "2025-04-11T17:57:11.298177+01:00",
    "end_time": "2025-04-11T17:57:12.136765+01:00",
    "duration": "838.588208ms",
    "output": "INFO: Invocation ID: ca4cd844-0d9d-4bfe-88d4-8c9ada0c69ac\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraCoreTypes/Sources/DomainSecurityTypes:DomainSecurityTypes (0 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraCoreTypes/Sources/DomainSecurityTypes:DomainSecurityTypes (0 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraCoreTypes/Sources/DomainSecurityTypes:DomainSecurityTypes (0 packages loaded, 0 targets configured).\nINFO: Found 1 target...\nTarget //packages/UmbraCoreTypes/Sources/DomainSecurityTypes:DomainSecurityTypes up-to-date:\n  bazel-bin/packages/UmbraCoreTypes/Sources/DomainSecurityTypes/DomainSecurityTypes.swiftdoc\n  bazel-bin/packages/UmbraCoreTypes/Sources/DomainSecurityTypes/DomainSecurityTypes.swiftmodule\n  bazel-bin/packages/UmbraCoreTypes/Sources/DomainSecurityTypes/DomainSecurityTypes.swiftsourceinfo\n  bazel-bin/packages/UmbraCoreTypes/Sources/DomainSecurityTypes/libDomainSecurityTypes.a\nINFO: Elapsed time: 0.122s, Critical Path: 0.00s\nINFO: 1 process: 1 action cache hit, 1 internal.\nINFO: Build completed successfully, 1 total action\n"
  },
  {
    "target": "rule //packages/UmbraCoreTypes/Sources/ErrorCoreTypes:ErrorCoreTypes",
    "success": true,
    "start_time": "2025-04-11T17:57:12.136771+01:00",
    "end_time": "2025-04-11T17:57:12.952616+01:00",
    "duration": "815.846083ms",
    "output": "INFO: Invocation ID: 1a86e182-fd69-4c1a-afd6-0f3f45daecb7\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraCoreTypes/Sources/ErrorCoreTypes:ErrorCoreTypes (1 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraCoreTypes/Sources/ErrorCoreTypes:ErrorCoreTypes (1 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraCoreTypes/Sources/ErrorCoreTypes:ErrorCoreTypes (1 packages loaded, 4 targets configured).\nINFO: Found 1 target...\nTarget //packages/UmbraCoreTypes/Sources/ErrorCoreTypes:ErrorCoreTypes up-to-date:\n  bazel-bin/packages/UmbraCoreTypes/Sources/ErrorCoreTypes/ErrorCoreTypes.swiftdoc\n  bazel-bin/packages/UmbraCoreTypes/Sources/ErrorCoreTypes/ErrorCoreTypes.swiftmodule\n  bazel-bin/packages/UmbraCoreTypes/Sources/ErrorCoreTypes/ErrorCoreTypes.swiftsourceinfo\n  bazel-bin/packages/UmbraCoreTypes/Sources/ErrorCoreTypes/libErrorCoreTypes.a\nINFO: Elapsed time: 0.125s, Critical Path: 0.00s\nINFO: 1 process: 3 action cache hit, 1 internal.\nINFO: Build completed successfully, 1 total action\n"
  },
  {
    "target": "rule //packages/UmbraCoreTypes/Sources/FileSystemCommonTypes:FileSystemCommonTypes",
    "success": true,
    "start_time": "2025-04-11T17:57:12.952634+01:00",
    "end_time": "2025-04-11T17:57:13.76762+01:00",
    "duration": "814.986959ms",
    "output": "INFO: Invocation ID: b60b85e3-cafb-4b5a-aff6-afe0f73af4a1\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraCoreTypes/Sources/FileSystemCommonTypes:FileSystemCommonTypes (0 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraCoreTypes/Sources/FileSystemCommonTypes:FileSystemCommonTypes (0 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraCoreTypes/Sources/FileSystemCommonTypes:FileSystemCommonTypes (0 packages loaded, 0 targets configured).\nINFO: Found 1 target...\nTarget //packages/UmbraCoreTypes/Sources/FileSystemCommonTypes:FileSystemCommonTypes up-to-date:\n  bazel-bin/packages/UmbraCoreTypes/Sources/FileSystemCommonTypes/FileSystemCommonTypes.swiftdoc\n  bazel-bin/packages/UmbraCoreTypes/Sources/FileSystemCommonTypes/FileSystemCommonTypes.swiftmodule\n  bazel-bin/packages/UmbraCoreTypes/Sources/FileSystemCommonTypes/FileSystemCommonTypes.swiftsourceinfo\n  bazel-bin/packages/UmbraCoreTypes/Sources/FileSystemCommonTypes/libFileSystemCommonTypes.a\nINFO: Elapsed time: 0.103s, Critical Path: 0.00s\nINFO: 1 process: 1 action cache hit, 1 internal.\nINFO: Build completed successfully, 1 total action\n"
  },
  {
    "target": "rule //packages/UmbraCoreTypes/Sources/FileSystemTypes:FileSystemTypes",
    "success": true,
    "start_time": "2025-04-11T17:57:13.767626+01:00",
    "end_time": "2025-04-11T17:57:14.570083+01:00",
    "duration": "802.458666ms",
    "output": "INFO: Invocation ID: 39ab97b1-9056-4d70-a6b3-5890c25cdf9d\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraCoreTypes/Sources/FileSystemTypes:FileSystemTypes (1 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraCoreTypes/Sources/FileSystemTypes:FileSystemTypes (1 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraCoreTypes/Sources/FileSystemTypes:FileSystemTypes (1 packages loaded, 9 targets configured).\nINFO: Found 1 target...\nTarget //packages/UmbraCoreTypes/Sources/FileSystemTypes:FileSystemTypes up-to-date:\n  bazel-bin/packages/UmbraCoreTypes/Sources/FileSystemTypes/FileSystemTypes.swiftdoc\n  bazel-bin/packages/UmbraCoreTypes/Sources/FileSystemTypes/FileSystemTypes.swiftmodule\n  bazel-bin/packages/UmbraCoreTypes/Sources/FileSystemTypes/FileSystemTypes.swiftsourceinfo\n  bazel-bin/packages/UmbraCoreTypes/Sources/FileSystemTypes/libFileSystemTypes.a\nINFO: Elapsed time: 0.122s, Critical Path: 0.00s\nINFO: 1 process: 3 action cache hit, 1 internal.\nINFO: Build completed successfully, 1 total action\n"
  },
  {
    "target": "rule //packages/UmbraCoreTypes/Sources/KeyManagementTypes:KeyManagementTypes",
    "success": true,
    "start_time": "2025-04-11T17:57:14.570092+01:00",
    "end_time": "2025-04-11T17:57:16.178259+01:00",
    "duration": "1.608169083s",
    "output": "INFO: Invocation ID: c2eb03bb-0dd9-4650-8135-e06a1bd29ca3\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraCoreTypes/Sources/KeyManagementTypes:KeyManagementTypes (1 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraCoreTypes/Sources/KeyManagementTypes:KeyManagementTypes (1 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraCoreTypes/Sources/KeyManagementTypes:KeyManagementTypes (3 packages loaded, 28 targets configured).\nINFO: Found 1 target...\nTarget //packages/UmbraCoreTypes/Sources/KeyManagementTypes:KeyManagementTypes up-to-date:\n  bazel-bin/packages/UmbraCoreTypes/Sources/KeyManagementTypes/KeyManagementTypes.swiftdoc\n  bazel-bin/packages/UmbraCoreTypes/Sources/KeyManagementTypes/KeyManagementTypes.swiftmodule\n  bazel-bin/packages/UmbraCoreTypes/Sources/KeyManagementTypes/KeyManagementTypes.swiftsourceinfo\n  bazel-bin/packages/UmbraCoreTypes/Sources/KeyManagementTypes/libKeyManagementTypes.a\nINFO: Elapsed time: 0.743s, Critical Path: 0.61s\nINFO: 2 processes: 6 action cache hit, 1 internal, 1 worker.\nINFO: Build completed successfully, 2 total actions\n"
  },
  {
    "target": "rule //packages/UmbraCoreTypes/Sources/KeyManagementTypes:KeyManagementTypesTests",
    "success": true,
    "start_time": "2025-04-11T17:57:16.178265+01:00",
    "end_time": "2025-04-11T17:57:17.716804+01:00",
    "duration": "1.538540959s",
    "output": "INFO: Invocation ID: 4a4f70d9-0c3c-4ba1-8da9-51159efea4a4\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraCoreTypes/Sources/KeyManagementTypes:KeyManagementTypesTests (0 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraCoreTypes/Sources/KeyManagementTypes:KeyManagementTypesTests (0 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraCoreTypes/Sources/KeyManagementTypes:KeyManagementTypesTests (0 packages loaded, 1 target configured).\nINFO: Found 1 target...\nTarget //packages/UmbraCoreTypes/Sources/KeyManagementTypes:KeyManagementTypesTests up-to-date:\n  bazel-bin/packages/UmbraCoreTypes/Sources/KeyManagementTypes/KeyManagementTypesTests.swiftdoc\n  bazel-bin/packages/UmbraCoreTypes/Sources/KeyManagementTypes/KeyManagementTypesTests.swiftmodule\n  bazel-bin/packages/UmbraCoreTypes/Sources/KeyManagementTypes/KeyManagementTypesTests.swiftsourceinfo\n  bazel-bin/packages/UmbraCoreTypes/Sources/KeyManagementTypes/libKeyManagementTypesTests.a\nINFO: Elapsed time: 0.719s, Critical Path: 0.59s\nINFO: 3 processes: 1 action cache hit, 1 disk cache hit, 1 internal, 1 worker.\nINFO: Build completed successfully, 3 total actions\n"
  },
  {
    "target": "rule //packages/UmbraCoreTypes/Sources/KeychainTypes:KeychainTypes",
    "success": true,
    "start_time": "2025-04-11T17:57:17.716819+01:00",
    "end_time": "2025-04-11T17:57:18.534428+01:00",
    "duration": "817.609667ms",
    "output": "INFO: Invocation ID: c4d847b9-8c48-4cc9-9d94-43e4157bf13c\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraCoreTypes/Sources/KeychainTypes:KeychainTypes (1 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraCoreTypes/Sources/KeychainTypes:KeychainTypes (1 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraCoreTypes/Sources/KeychainTypes:KeychainTypes (2 packages loaded, 9 targets configured).\nINFO: Found 1 target...\nTarget //packages/UmbraCoreTypes/Sources/KeychainTypes:KeychainTypes up-to-date:\n  bazel-bin/packages/UmbraCoreTypes/Sources/KeychainTypes/KeychainTypes.swiftdoc\n  bazel-bin/packages/UmbraCoreTypes/Sources/KeychainTypes/KeychainTypes.swiftmodule\n  bazel-bin/packages/UmbraCoreTypes/Sources/KeychainTypes/KeychainTypes.swiftsourceinfo\n  bazel-bin/packages/UmbraCoreTypes/Sources/KeychainTypes/libKeychainTypes.a\nINFO: Elapsed time: 0.128s, Critical Path: 0.00s\nINFO: 1 process: 5 action cache hit, 1 internal.\nINFO: Build completed successfully, 1 total action\n"
  },
  {
    "target": "rule //packages/UmbraCoreTypes/Sources/LoggingTypes:LoggingTypes",
    "success": true,
    "start_time": "2025-04-11T17:57:18.534434+01:00",
    "end_time": "2025-04-11T17:57:19.367163+01:00",
    "duration": "832.729959ms",
    "output": "INFO: Invocation ID: cccad146-e394-4577-ba71-b5eb73da2a34\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraCoreTypes/Sources/LoggingTypes:LoggingTypes (0 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraCoreTypes/Sources/LoggingTypes:LoggingTypes (0 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraCoreTypes/Sources/LoggingTypes:LoggingTypes (0 packages loaded, 0 targets configured).\nINFO: Found 1 target...\nTarget //packages/UmbraCoreTypes/Sources/LoggingTypes:LoggingTypes up-to-date:\n  bazel-bin/packages/UmbraCoreTypes/Sources/LoggingTypes/LoggingTypes.swiftdoc\n  bazel-bin/packages/UmbraCoreTypes/Sources/LoggingTypes/LoggingTypes.swiftmodule\n  bazel-bin/packages/UmbraCoreTypes/Sources/LoggingTypes/LoggingTypes.swiftsourceinfo\n  bazel-bin/packages/UmbraCoreTypes/Sources/LoggingTypes/libLoggingTypes.a\nINFO: Elapsed time: 0.119s, Critical Path: 0.00s\nINFO: 1 process: 1 action cache hit, 1 internal.\nINFO: Build completed successfully, 1 total action\n"
  },
  {
    "target": "rule //packages/UmbraCoreTypes/Sources/Notification:Notification",
    "success": true,
    "start_time": "2025-04-11T17:57:19.36717+01:00",
    "end_time": "2025-04-11T17:57:20.140465+01:00",
    "duration": "773.296375ms",
    "output": "INFO: Invocation ID: 8ba61304-2619-41c2-ae22-f514f0005248\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraCoreTypes/Sources/Notification:Notification (0 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraCoreTypes/Sources/Notification:Notification (0 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraCoreTypes/Sources/Notification:Notification (0 packages loaded, 0 targets configured).\nINFO: Found 1 target...\nTarget //packages/UmbraCoreTypes/Sources/Notification:Notification up-to-date:\n  bazel-bin/packages/UmbraCoreTypes/Sources/Notification/Notification.swiftdoc\n  bazel-bin/packages/UmbraCoreTypes/Sources/Notification/Notification.swiftmodule\n  bazel-bin/packages/UmbraCoreTypes/Sources/Notification/Notification.swiftsourceinfo\n  bazel-bin/packages/UmbraCoreTypes/Sources/Notification/libNotification.a\nINFO: Elapsed time: 0.117s, Critical Path: 0.00s\nINFO: 1 process: 1 action cache hit, 1 internal.\nINFO: Build completed successfully, 1 total action\n"
  },
  {
    "target": "rule //packages/UmbraCoreTypes/Sources/Scheduling:Scheduling",
    "success": true,
    "start_time": "2025-04-11T17:57:20.140472+01:00",
    "end_time": "2025-04-11T17:57:20.939493+01:00",
    "duration": "799.021917ms",
    "output": "INFO: Invocation ID: 9132f266-c2fc-4942-93ae-d4204a045914\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraCoreTypes/Sources/Scheduling:Scheduling (1 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraCoreTypes/Sources/Scheduling:Scheduling (1 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraCoreTypes/Sources/Scheduling:Scheduling (1 packages loaded, 5 targets configured).\nINFO: Found 1 target...\nTarget //packages/UmbraCoreTypes/Sources/Scheduling:Scheduling up-to-date:\n  bazel-bin/packages/UmbraCoreTypes/Sources/Scheduling/Scheduling.swiftdoc\n  bazel-bin/packages/UmbraCoreTypes/Sources/Scheduling/Scheduling.swiftmodule\n  bazel-bin/packages/UmbraCoreTypes/Sources/Scheduling/Scheduling.swiftsourceinfo\n  bazel-bin/packages/UmbraCoreTypes/Sources/Scheduling/libScheduling.a\nINFO: Elapsed time: 0.127s, Critical Path: 0.00s\nINFO: 1 process: 3 action cache hit, 1 internal.\nINFO: Build completed successfully, 1 total action\n"
  },
  {
    "target": "rule //packages/UmbraCoreTypes/Sources/SchedulingTypes:SchedulingTypes",
    "success": true,
    "start_time": "2025-04-11T17:57:20.9395+01:00",
    "end_time": "2025-04-11T17:57:22.050719+01:00",
    "duration": "1.11122s",
    "output": "INFO: Invocation ID: 3d0c4d61-ec7f-4690-b11c-0c5abd0d4182\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraCoreTypes/Sources/SchedulingTypes:SchedulingTypes (0 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraCoreTypes/Sources/SchedulingTypes:SchedulingTypes (0 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraCoreTypes/Sources/SchedulingTypes:SchedulingTypes (0 packages loaded, 0 targets configured).\nINFO: Found 1 target...\nTarget //packages/UmbraCoreTypes/Sources/SchedulingTypes:SchedulingTypes up-to-date:\n  bazel-bin/packages/UmbraCoreTypes/Sources/SchedulingTypes/SchedulingTypes.swiftdoc\n  bazel-bin/packages/UmbraCoreTypes/Sources/SchedulingTypes/SchedulingTypes.swiftmodule\n  bazel-bin/packages/UmbraCoreTypes/Sources/SchedulingTypes/SchedulingTypes.swiftsourceinfo\n  bazel-bin/packages/UmbraCoreTypes/Sources/SchedulingTypes/libSchedulingTypes.a\nINFO: Elapsed time: 0.119s, Critical Path: 0.00s\nINFO: 1 process: 1 action cache hit, 1 internal.\nINFO: Build completed successfully, 1 total action\n"
  },
  {
    "target": "rule //packages/UmbraCoreTypes/Sources/SecurityInterfaces:SecurityInterfaces",
    "success": true,
    "start_time": "2025-04-11T17:57:22.050725+01:00",
    "end_time": "2025-04-11T17:57:22.885698+01:00",
    "duration": "834.974375ms",
    "output": "INFO: Invocation ID: e7c393ec-8714-4c3a-b9cc-1d4f82fc7f68\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraCoreTypes/Sources/SecurityInterfaces:SecurityInterfaces (1 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraCoreTypes/Sources/SecurityInterfaces:SecurityInterfaces (1 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraCoreTypes/Sources/SecurityInterfaces:SecurityInterfaces (1 packages loaded, 2 targets configured).\nINFO: Found 1 target...\nTarget //packages/UmbraCoreTypes/Sources/SecurityInterfaces:SecurityInterfaces up-to-date:\n  bazel-bin/packages/UmbraCoreTypes/Sources/SecurityInterfaces/SecurityInterfaces.swiftdoc\n  bazel-bin/packages/UmbraCoreTypes/Sources/SecurityInterfaces/SecurityInterfaces.swiftmodule\n  bazel-bin/packages/UmbraCoreTypes/Sources/SecurityInterfaces/SecurityInterfaces.swiftsourceinfo\n  bazel-bin/packages/UmbraCoreTypes/Sources/SecurityInterfaces/libSecurityInterfaces.a\nINFO: Elapsed time: 0.126s, Critical Path: 0.00s\nINFO: 1 process: 3 action cache hit, 1 internal.\nINFO: Build completed successfully, 1 total action\n"
  },
  {
    "target": "rule //packages/UmbraCoreTypes/Sources/SecurityInterfaces/Adapters:SecurityInterfacesAdapters",
    "success": true,
    "start_time": "2025-04-11T17:57:22.885705+01:00",
    "end_time": "2025-04-11T17:57:25.111643+01:00",
    "duration": "2.225941209s",
    "output": "INFO: Invocation ID: e6b2ac91-253b-42c2-a39c-87fde84f6581\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraCoreTypes/Sources/SecurityInterfaces/Adapters:SecurityInterfacesAdapters (1 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraCoreTypes/Sources/SecurityInterfaces/Adapters:SecurityInterfacesAdapters (1 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraCoreTypes/Sources/SecurityInterfaces/Adapters:SecurityInterfacesAdapters (3 packages loaded, 17 targets configured).\n[6 / 8] [Prepa] Compiling Swift module //packages/UmbraCoreTypes/Sources/SecurityInterfaces/Adapters:SecurityInterfacesAdapters\nINFO: Found 1 target...\nTarget //packages/UmbraCoreTypes/Sources/SecurityInterfaces/Adapters:SecurityInterfacesAdapters up-to-date:\n  bazel-bin/packages/UmbraCoreTypes/Sources/SecurityInterfaces/Adapters/SecurityInterfacesAdapters.swiftdoc\n  bazel-bin/packages/UmbraCoreTypes/Sources/SecurityInterfaces/Adapters/SecurityInterfacesAdapters.swiftmodule\n  bazel-bin/packages/UmbraCoreTypes/Sources/SecurityInterfaces/Adapters/SecurityInterfacesAdapters.swiftsourceinfo\n  bazel-bin/packages/UmbraCoreTypes/Sources/SecurityInterfaces/Adapters/libSecurityInterfacesAdapters.a\nINFO: Elapsed time: 1.537s, Critical Path: 1.40s\nINFO: 5 processes: 3 action cache hit, 1 disk cache hit, 1 internal, 3 worker.\nINFO: Build completed successfully, 5 total actions\n"
  },
  {
    "target": "rule //packages/UmbraCoreTypes/Sources/SecurityInterfaces/DTOs:SecurityInterfacesDTOs",
    "success": true,
    "start_time": "2025-04-11T17:57:25.111658+01:00",
    "end_time": "2025-04-11T17:57:25.937774+01:00",
    "duration": "826.117208ms",
    "output": "INFO: Invocation ID: aa1f90ec-bfb1-4425-b9db-fcec3d24d4da\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraCoreTypes/Sources/SecurityInterfaces/DTOs:SecurityInterfacesDTOs (0 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraCoreTypes/Sources/SecurityInterfaces/DTOs:SecurityInterfacesDTOs (0 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraCoreTypes/Sources/SecurityInterfaces/DTOs:SecurityInterfacesDTOs (0 packages loaded, 0 targets configured).\nINFO: Found 1 target...\nTarget //packages/UmbraCoreTypes/Sources/SecurityInterfaces/DTOs:SecurityInterfacesDTOs up-to-date:\n  bazel-bin/packages/UmbraCoreTypes/Sources/SecurityInterfaces/DTOs/SecurityInterfacesDTOs.swiftdoc\n  bazel-bin/packages/UmbraCoreTypes/Sources/SecurityInterfaces/DTOs/SecurityInterfacesDTOs.swiftmodule\n  bazel-bin/packages/UmbraCoreTypes/Sources/SecurityInterfaces/DTOs/SecurityInterfacesDTOs.swiftsourceinfo\n  bazel-bin/packages/UmbraCoreTypes/Sources/SecurityInterfaces/DTOs/libSecurityInterfacesDTOs.a\nINFO: Elapsed time: 0.128s, Critical Path: 0.00s\nINFO: 2 processes: 1 disk cache hit, 1 internal.\nINFO: Build completed successfully, 2 total actions\n"
  },
  {
    "target": "rule //packages/UmbraCoreTypes/Sources/SecurityInterfaces/Models:SecurityInterfacesModels",
    "success": true,
    "start_time": "2025-04-11T17:57:25.937781+01:00",
    "end_time": "2025-04-11T17:57:27.344599+01:00",
    "duration": "1.4068195s",
    "output": "INFO: Invocation ID: f3f0e4d5-6ec2-4be2-bcd1-fc25cae35cde\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraCoreTypes/Sources/SecurityInterfaces/Models:SecurityInterfacesModels (1 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraCoreTypes/Sources/SecurityInterfaces/Models:SecurityInterfacesModels (1 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraCoreTypes/Sources/SecurityInterfaces/Models:SecurityInterfacesModels (1 packages loaded, 2 targets configured).\nINFO: Found 1 target...\nTarget //packages/UmbraCoreTypes/Sources/SecurityInterfaces/Models:SecurityInterfacesModels up-to-date:\n  bazel-bin/packages/UmbraCoreTypes/Sources/SecurityInterfaces/Models/SecurityInterfacesModels.swiftdoc\n  bazel-bin/packages/UmbraCoreTypes/Sources/SecurityInterfaces/Models/SecurityInterfacesModels.swiftmodule\n  bazel-bin/packages/UmbraCoreTypes/Sources/SecurityInterfaces/Models/SecurityInterfacesModels.swiftsourceinfo\n  bazel-bin/packages/UmbraCoreTypes/Sources/SecurityInterfaces/Models/libSecurityInterfacesModels.a\nINFO: Elapsed time: 0.444s, Critical Path: 0.31s\nINFO: 3 processes: 1 action cache hit, 1 disk cache hit, 1 internal, 1 worker.\nINFO: Build completed successfully, 3 total actions\n"
  },
  {
    "target": "rule //packages/UmbraCoreTypes/Sources/SecurityInterfaces/Protocols:SecurityInterfacesProtocols",
    "success": true,
    "start_time": "2025-04-11T17:57:27.344612+01:00",
    "end_time": "2025-04-11T17:57:28.302083+01:00",
    "duration": "957.471583ms",
    "output": "INFO: Invocation ID: 425ec73b-7a04-4ded-b2da-0b99323eda28\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraCoreTypes/Sources/SecurityInterfaces/Protocols:SecurityInterfacesProtocols (0 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraCoreTypes/Sources/SecurityInterfaces/Protocols:SecurityInterfacesProtocols (0 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraCoreTypes/Sources/SecurityInterfaces/Protocols:SecurityInterfacesProtocols (0 packages loaded, 0 targets configured).\nINFO: Found 1 target...\nTarget //packages/UmbraCoreTypes/Sources/SecurityInterfaces/Protocols:SecurityInterfacesProtocols up-to-date:\n  bazel-bin/packages/UmbraCoreTypes/Sources/SecurityInterfaces/Protocols/SecurityInterfacesProtocols.swiftdoc\n  bazel-bin/packages/UmbraCoreTypes/Sources/SecurityInterfaces/Protocols/SecurityInterfacesProtocols.swiftmodule\n  bazel-bin/packages/UmbraCoreTypes/Sources/SecurityInterfaces/Protocols/SecurityInterfacesProtocols.swiftsourceinfo\n  bazel-bin/packages/UmbraCoreTypes/Sources/SecurityInterfaces/Protocols/libSecurityInterfacesProtocols.a\nINFO: Elapsed time: 0.130s, Critical Path: 0.00s\nINFO: 2 processes: 1 disk cache hit, 1 internal.\nINFO: Build completed successfully, 2 total actions\n"
  },
  {
    "target": "rule //packages/UmbraCoreTypes/Sources/SecurityInterfaces/Types:SecurityInterfacesTypes",
    "success": true,
    "start_time": "2025-04-11T17:57:28.302089+01:00",
    "end_time": "2025-04-11T17:57:29.171953+01:00",
    "duration": "869.864459ms",
    "output": "INFO: Invocation ID: ad23f755-20c0-4d38-94ca-37126fc3dbc9\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraCoreTypes/Sources/SecurityInterfaces/Types:SecurityInterfacesTypes (0 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraCoreTypes/Sources/SecurityInterfaces/Types:SecurityInterfacesTypes (0 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraCoreTypes/Sources/SecurityInterfaces/Types:SecurityInterfacesTypes (0 packages loaded, 0 targets configured).\nINFO: Found 1 target...\nTarget //packages/UmbraCoreTypes/Sources/SecurityInterfaces/Types:SecurityInterfacesTypes up-to-date:\n  bazel-bin/packages/UmbraCoreTypes/Sources/SecurityInterfaces/Types/SecurityInterfacesTypes.swiftdoc\n  bazel-bin/packages/UmbraCoreTypes/Sources/SecurityInterfaces/Types/SecurityInterfacesTypes.swiftmodule\n  bazel-bin/packages/UmbraCoreTypes/Sources/SecurityInterfaces/Types/SecurityInterfacesTypes.swiftsourceinfo\n  bazel-bin/packages/UmbraCoreTypes/Sources/SecurityInterfaces/Types/libSecurityInterfacesTypes.a\nINFO: Elapsed time: 0.124s, Critical Path: 0.00s\nINFO: 1 process: 1 action cache hit, 1 internal.\nINFO: Build completed successfully, 1 total action\n"
  },
  {
    "target": "rule //packages/UmbraCoreTypes/Sources/SecurityInterfaces/XPC:SecurityInterfacesXPC",
    "success": true,
    "start_time": "2025-04-11T17:57:29.171959+01:00",
    "end_time": "2025-04-11T17:57:30.351824+01:00",
    "duration": "1.1798665s",
    "output": "INFO: Invocation ID: 50044446-5d83-4f0a-88ad-03b547e87833\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraCoreTypes/Sources/SecurityInterfaces/XPC:SecurityInterfacesXPC (1 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraCoreTypes/Sources/SecurityInterfaces/XPC:SecurityInterfacesXPC (1 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraCoreTypes/Sources/SecurityInterfaces/XPC:SecurityInterfacesXPC (1 packages loaded, 2 targets configured).\nINFO: Found 1 target...\nTarget //packages/UmbraCoreTypes/Sources/SecurityInterfaces/XPC:SecurityInterfacesXPC up-to-date:\n  bazel-bin/packages/UmbraCoreTypes/Sources/SecurityInterfaces/XPC/SecurityInterfacesXPC.swiftdoc\n  bazel-bin/packages/UmbraCoreTypes/Sources/SecurityInterfaces/XPC/SecurityInterfacesXPC.swiftmodule\n  bazel-bin/packages/UmbraCoreTypes/Sources/SecurityInterfaces/XPC/SecurityInterfacesXPC.swiftsourceinfo\n  bazel-bin/packages/UmbraCoreTypes/Sources/SecurityInterfaces/XPC/libSecurityInterfacesXPC.a\nINFO: Elapsed time: 0.461s, Critical Path: 0.34s\nINFO: 3 processes: 1 action cache hit, 1 disk cache hit, 1 internal, 1 worker.\nINFO: Build completed successfully, 3 total actions\n"
  },
  {
    "target": "rule //packages/UmbraCoreTypes/Sources/SecurityKeyTypes:SecurityKeyTypes",
    "success": true,
    "start_time": "2025-04-11T17:57:30.35183+01:00",
    "end_time": "2025-04-11T17:57:31.145754+01:00",
    "duration": "793.92425ms",
    "output": "INFO: Invocation ID: cacb1c63-6f4c-416e-8dfa-803f465c80b0\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraCoreTypes/Sources/SecurityKeyTypes:SecurityKeyTypes (1 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraCoreTypes/Sources/SecurityKeyTypes:SecurityKeyTypes (1 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraCoreTypes/Sources/SecurityKeyTypes:SecurityKeyTypes (1 packages loaded, 3 targets configured).\nINFO: Found 1 target...\nTarget //packages/UmbraCoreTypes/Sources/SecurityKeyTypes:SecurityKeyTypes up-to-date:\n  bazel-bin/packages/UmbraCoreTypes/Sources/SecurityKeyTypes/SecurityKeyTypes.swiftdoc\n  bazel-bin/packages/UmbraCoreTypes/Sources/SecurityKeyTypes/SecurityKeyTypes.swiftmodule\n  bazel-bin/packages/UmbraCoreTypes/Sources/SecurityKeyTypes/SecurityKeyTypes.swiftsourceinfo\n  bazel-bin/packages/UmbraCoreTypes/Sources/SecurityKeyTypes/libSecurityKeyTypes.a\nINFO: Elapsed time: 0.118s, Critical Path: 0.00s\nINFO: 1 process: 3 action cache hit, 1 internal.\nINFO: Build completed successfully, 1 total action\n"
  },
  {
    "target": "rule //packages/UmbraCoreTypes/Sources/UmbraErrors:UmbraErrors",
    "success": true,
    "start_time": "2025-04-11T17:57:31.145766+01:00",
    "end_time": "2025-04-11T17:57:32.032377+01:00",
    "duration": "886.611458ms",
    "output": "INFO: Invocation ID: 4a25cf1c-c21e-4875-b64c-e1c1a164012c\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraCoreTypes/Sources/UmbraErrors:UmbraErrors (0 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraCoreTypes/Sources/UmbraErrors:UmbraErrors (0 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraCoreTypes/Sources/UmbraErrors:UmbraErrors (0 packages loaded, 0 targets configured).\nINFO: Found 1 target...\nTarget //packages/UmbraCoreTypes/Sources/UmbraErrors:UmbraErrors up-to-date:\n  bazel-bin/packages/UmbraCoreTypes/Sources/UmbraErrors/UmbraErrors.swiftdoc\n  bazel-bin/packages/UmbraCoreTypes/Sources/UmbraErrors/UmbraErrors.swiftmodule\n  bazel-bin/packages/UmbraCoreTypes/Sources/UmbraErrors/UmbraErrors.swiftsourceinfo\n  bazel-bin/packages/UmbraCoreTypes/Sources/UmbraErrors/libUmbraErrors.a\nINFO: Elapsed time: 0.121s, Critical Path: 0.00s\nINFO: 1 process: 1 action cache hit, 1 internal.\nINFO: Build completed successfully, 1 total action\n"
  },
  {
    "target": "rule //packages/UmbraCoreTypes/Sources/UmbraErrors/Core:UmbraErrorsCore",
    "success": true,
    "start_time": "2025-04-11T17:57:32.032384+01:00",
    "end_time": "2025-04-11T17:57:32.834473+01:00",
    "duration": "802.089708ms",
    "output": "INFO: Invocation ID: c8277ac0-1bdc-4e45-a9ff-3dd2755b3c93\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraCoreTypes/Sources/UmbraErrors/Core:UmbraErrorsCore (0 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraCoreTypes/Sources/UmbraErrors/Core:UmbraErrorsCore (0 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraCoreTypes/Sources/UmbraErrors/Core:UmbraErrorsCore (0 packages loaded, 0 targets configured).\nINFO: Found 1 target...\nTarget //packages/UmbraCoreTypes/Sources/UmbraErrors/Core:UmbraErrorsCore up-to-date:\n  bazel-bin/packages/UmbraCoreTypes/Sources/UmbraErrors/Core/UmbraErrorsCore.swiftdoc\n  bazel-bin/packages/UmbraCoreTypes/Sources/UmbraErrors/Core/UmbraErrorsCore.swiftmodule\n  bazel-bin/packages/UmbraCoreTypes/Sources/UmbraErrors/Core/UmbraErrorsCore.swiftsourceinfo\n  bazel-bin/packages/UmbraCoreTypes/Sources/UmbraErrors/Core/libUmbraErrorsCore.a\nINFO: Elapsed time: 0.104s, Critical Path: 0.00s\nINFO: 1 process: 1 action cache hit, 1 internal.\nINFO: Build completed successfully, 1 total action\n"
  },
  {
    "target": "rule //packages/UmbraCoreTypes/Sources/UmbraErrors/DTOs:UmbraErrorsDTOs",
    "success": true,
    "start_time": "2025-04-11T17:57:32.834479+01:00",
    "end_time": "2025-04-11T17:57:33.61692+01:00",
    "duration": "782.44175ms",
    "output": "INFO: Invocation ID: e3648f71-00c9-44f9-adc1-64bad44032a0\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraCoreTypes/Sources/UmbraErrors/DTOs:UmbraErrorsDTOs (0 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraCoreTypes/Sources/UmbraErrors/DTOs:UmbraErrorsDTOs (0 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraCoreTypes/Sources/UmbraErrors/DTOs:UmbraErrorsDTOs (0 packages loaded, 0 targets configured).\nINFO: Found 1 target...\nTarget //packages/UmbraCoreTypes/Sources/UmbraErrors/DTOs:UmbraErrorsDTOs up-to-date:\n  bazel-bin/packages/UmbraCoreTypes/Sources/UmbraErrors/DTOs/UmbraErrorsDTOs.swiftdoc\n  bazel-bin/packages/UmbraCoreTypes/Sources/UmbraErrors/DTOs/UmbraErrorsDTOs.swiftmodule\n  bazel-bin/packages/UmbraCoreTypes/Sources/UmbraErrors/DTOs/UmbraErrorsDTOs.swiftsourceinfo\n  bazel-bin/packages/UmbraCoreTypes/Sources/UmbraErrors/DTOs/libUmbraErrorsDTOs.a\nINFO: Elapsed time: 0.104s, Critical Path: 0.00s\nINFO: 1 process: 1 action cache hit, 1 internal.\nINFO: Build completed successfully, 1 total action\n"
  },
  {
    "target": "rule //packages/UmbraCoreTypes/Sources/UmbraErrors/Domains:UmbraErrorsDomains",
    "success": true,
    "start_time": "2025-04-11T17:57:33.616926+01:00",
    "end_time": "2025-04-11T17:57:34.443075+01:00",
    "duration": "826.150208ms",
    "output": "INFO: Invocation ID: d2c172d9-f2dc-4531-94f9-775f564e61a5\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraCoreTypes/Sources/UmbraErrors/Domains:UmbraErrorsDomains (0 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraCoreTypes/Sources/UmbraErrors/Domains:UmbraErrorsDomains (0 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraCoreTypes/Sources/UmbraErrors/Domains:UmbraErrorsDomains (0 packages loaded, 0 targets configured).\nINFO: Found 1 target...\nTarget //packages/UmbraCoreTypes/Sources/UmbraErrors/Domains:UmbraErrorsDomains up-to-date:\n  bazel-bin/packages/UmbraCoreTypes/Sources/UmbraErrors/Domains/UmbraErrorsDomains.swiftdoc\n  bazel-bin/packages/UmbraCoreTypes/Sources/UmbraErrors/Domains/UmbraErrorsDomains.swiftmodule\n  bazel-bin/packages/UmbraCoreTypes/Sources/UmbraErrors/Domains/UmbraErrorsDomains.swiftsourceinfo\n  bazel-bin/packages/UmbraCoreTypes/Sources/UmbraErrors/Domains/libUmbraErrorsDomains.a\nINFO: Elapsed time: 0.123s, Critical Path: 0.00s\nINFO: 1 process: 1 action cache hit, 1 internal.\nINFO: Build completed successfully, 1 total action\n"
  },
  {
    "target": "rule //packages/UmbraCoreTypes/Sources/UmbraErrors/Mapping:UmbraErrorsMapping",
    "success": true,
    "start_time": "2025-04-11T17:57:34.443086+01:00",
    "end_time": "2025-04-11T17:57:36.267304+01:00",
    "duration": "1.824219833s",
    "output": "INFO: Invocation ID: e14a92b9-b7b0-4e23-a36d-6d1b441937bd\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraCoreTypes/Sources/UmbraErrors/Mapping:UmbraErrorsMapping (0 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraCoreTypes/Sources/UmbraErrors/Mapping:UmbraErrorsMapping (0 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraCoreTypes/Sources/UmbraErrors/Mapping:UmbraErrorsMapping (0 packages loaded, 0 targets configured).\nINFO: Found 1 target...\nTarget //packages/UmbraCoreTypes/Sources/UmbraErrors/Mapping:UmbraErrorsMapping up-to-date:\n  bazel-bin/packages/UmbraCoreTypes/Sources/UmbraErrors/Mapping/UmbraErrorsMapping.swiftdoc\n  bazel-bin/packages/UmbraCoreTypes/Sources/UmbraErrors/Mapping/UmbraErrorsMapping.swiftmodule\n  bazel-bin/packages/UmbraCoreTypes/Sources/UmbraErrors/Mapping/UmbraErrorsMapping.swiftsourceinfo\n  bazel-bin/packages/UmbraCoreTypes/Sources/UmbraErrors/Mapping/libUmbraErrorsMapping.a\nINFO: Elapsed time: 0.112s, Critical Path: 0.00s\nINFO: 1 process: 1 action cache hit, 1 internal.\nINFO: Build completed successfully, 1 total action\n"
  },
  {
    "target": "rule //packages/UmbraCoreTypes/Sources/UserDefaults:UserDefaults",
    "success": true,
    "start_time": "2025-04-11T17:57:36.267327+01:00",
    "end_time": "2025-04-11T17:57:37.067073+01:00",
    "duration": "799.747167ms",
    "output": "INFO: Invocation ID: 1437e293-1d42-4f50-8210-689dec1886a7\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraCoreTypes/Sources/UserDefaults:UserDefaults (0 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraCoreTypes/Sources/UserDefaults:UserDefaults (0 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraCoreTypes/Sources/UserDefaults:UserDefaults (0 packages loaded, 0 targets configured).\nINFO: Found 1 target...\nTarget //packages/UmbraCoreTypes/Sources/UserDefaults:UserDefaults up-to-date:\n  bazel-bin/packages/UmbraCoreTypes/Sources/UserDefaults/UserDefaults.swiftdoc\n  bazel-bin/packages/UmbraCoreTypes/Sources/UserDefaults/UserDefaults.swiftmodule\n  bazel-bin/packages/UmbraCoreTypes/Sources/UserDefaults/UserDefaults.swiftsourceinfo\n  bazel-bin/packages/UmbraCoreTypes/Sources/UserDefaults/libUserDefaults.a\nINFO: Elapsed time: 0.122s, Critical Path: 0.00s\nINFO: 1 process: 1 action cache hit, 1 internal.\nINFO: Build completed successfully, 1 total action\n"
  },
  {
    "target": "rule //packages/UmbraCoreTypes/Sources/UserDefaults/Adapters:UserDefaultsAdapters",
    "success": true,
    "start_time": "2025-04-11T17:57:37.06708+01:00",
    "end_time": "2025-04-11T17:57:37.995236+01:00",
    "duration": "928.157125ms",
    "output": "INFO: Invocation ID: 459fd667-40a7-4202-9277-d6f67b77956e\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraCoreTypes/Sources/UserDefaults/Adapters:UserDefaultsAdapters (0 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraCoreTypes/Sources/UserDefaults/Adapters:UserDefaultsAdapters (0 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraCoreTypes/Sources/UserDefaults/Adapters:UserDefaultsAdapters (0 packages loaded, 0 targets configured).\nINFO: Found 1 target...\nTarget //packages/UmbraCoreTypes/Sources/UserDefaults/Adapters:UserDefaultsAdapters up-to-date:\n  bazel-bin/packages/UmbraCoreTypes/Sources/UserDefaults/Adapters/UserDefaultsAdapters.swiftdoc\n  bazel-bin/packages/UmbraCoreTypes/Sources/UserDefaults/Adapters/UserDefaultsAdapters.swiftmodule\n  bazel-bin/packages/UmbraCoreTypes/Sources/UserDefaults/Adapters/UserDefaultsAdapters.swiftsourceinfo\n  bazel-bin/packages/UmbraCoreTypes/Sources/UserDefaults/Adapters/libUserDefaultsAdapters.a\nINFO: Elapsed time: 0.124s, Critical Path: 0.00s\nINFO: 1 process: 1 action cache hit, 1 internal.\nINFO: Build completed successfully, 1 total action\n"
  },
  {
    "target": "rule //packages/UmbraCoreTypes/Sources/UserDefaults/DTOs:UserDefaultsDTOs",
    "success": true,
    "start_time": "2025-04-11T17:57:37.995243+01:00",
    "end_time": "2025-04-11T17:57:38.81908+01:00",
    "duration": "823.838042ms",
    "output": "INFO: Invocation ID: 6b0e7da9-94bb-4ba7-8d2c-e97f67bd9091\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraCoreTypes/Sources/UserDefaults/DTOs:UserDefaultsDTOs (0 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraCoreTypes/Sources/UserDefaults/DTOs:UserDefaultsDTOs (0 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraCoreTypes/Sources/UserDefaults/DTOs:UserDefaultsDTOs (0 packages loaded, 0 targets configured).\nINFO: Found 1 target...\nTarget //packages/UmbraCoreTypes/Sources/UserDefaults/DTOs:UserDefaultsDTOs up-to-date:\n  bazel-bin/packages/UmbraCoreTypes/Sources/UserDefaults/DTOs/UserDefaultsDTOs.swiftdoc\n  bazel-bin/packages/UmbraCoreTypes/Sources/UserDefaults/DTOs/UserDefaultsDTOs.swiftmodule\n  bazel-bin/packages/UmbraCoreTypes/Sources/UserDefaults/DTOs/UserDefaultsDTOs.swiftsourceinfo\n  bazel-bin/packages/UmbraCoreTypes/Sources/UserDefaults/DTOs/libUserDefaultsDTOs.a\nINFO: Elapsed time: 0.121s, Critical Path: 0.00s\nINFO: 1 process: 1 action cache hit, 1 internal.\nINFO: Build completed successfully, 1 total action\n"
  },
  {
    "target": "rule //packages/UmbraImplementations/Sources/APIServices:APIServices",
    "success": false,
    "start_time": "2025-04-11T17:57:38.819086+01:00",
    "end_time": "2025-04-11T17:57:41.080055+01:00",
    "duration": "2.260971875s",
    "output": "INFO: Invocation ID: 296cc828-6e1d-4531-bf49-a3075b178bc2\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraImplementations/Sources/APIServices:APIServices (1 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraImplementations/Sources/APIServices:APIServices (1 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraImplementations/Sources/APIServices:APIServices (22 packages loaded, 273 targets configured).\nINFO: From Compiling Swift module //packages/UmbraImplementations/Sources/SecurityProviders:SecurityProviders:\npackages/UmbraImplementations/Sources/SecurityProviders/OperationsHandler.swift:450:19: warning: value 'keyIdentifier' was defined but never used; consider replacing with boolean test\n448 |       case let .success(dataIdentifier):\n449 |         // Check if key identifier is provided\n450 |         guard let keyIdentifier=config.options?.metadata?[\"keyIdentifier\"] else {\n    |                   `- warning: value 'keyIdentifier' was defined but never used; consider replacing with boolean test\n451 |           return .failure(\n452 |             errorDetails: \"Missing key identifier in configuration\",\nERROR: /Users/mpy/CascadeProjects/UmbraCore/packages/UmbraImplementations/Sources/LoggingServices/BUILD.bazel:3:20: Compiling Swift module //packages/UmbraImplementations/Sources/LoggingServices:LoggingServices failed: (Exit 1): worker failed: error executing SwiftCompile command (from target //packages/UmbraImplementations/Sources/LoggingServices:LoggingServices) \n  (cd /Users/mpy/.bazel/execroot/_main \u0026\u0026 \\\n  exec env - \\\n    APPLE_SDK_PLATFORM=MacOSX \\\n    APPLE_SDK_VERSION_OVERRIDE=15.4 \\\n    CC=clang \\\n    PATH=/Users/mpy/Library/Caches/bazelisk/downloads/sha256/ac72ad67f7a8c6b18bf605d8602425182b417de4369715bf89146daf62f7ae48/bin:/Users/mpy/.rbenv/bin:/Users/mpy/.codeium/windsurf/bin:/opt/homebrew/opt/node@18/bin:/opt/homebrew/opt/node@20/bin:/Users/mpy/.docker/bin:/opt/homebrew/opt/openjdk/bin:/Users/mpy/bin:/opt/homebrew/bin:/opt/homebrew/sbin:/usr/local/bin:/System/Cryptexes/App/usr/bin:/usr/bin:/bin:/usr/sbin:/sbin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/local/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/appleinternal/bin:/Library/Apple/usr/bin:/usr/local/go/bin:/Users/mpy/.rbenv/bin:/Users/mpy/.codeium/windsurf/bin:/opt/homebrew/opt/node@18/bin:/opt/homebrew/opt/node@20/bin:/opt/anaconda3/bin:/opt/anaconda3/condabin:/Users/mpy/.docker/bin:/opt/homebrew/opt/openjdk/bin:/Users/mpy/bin:/Users/mpy/.cargo/bin:/Users/mpy/Library/Python/3.8/bin:/Users/mpy/go/bin:/Users/mpy/.scripts:/Users/mpy/.fzf/bin:/Users/mpy/.windsurf/extensions/ms-python.debugpy-2025.6.0-darwin-arm64/bundled/scripts/noConfigScripts:/Users/mpy/Library/Python/3.8/bin:/Users/mpy/go/bin:/Users/mpy/.scripts \\\n    XCODE_VERSION_OVERRIDE=16.3.0.16E140 \\\n  bazel-out/darwin_arm64-opt-exec-ST-d57f47055a04/bin/external/rules_swift+/tools/worker/worker swiftc @bazel-out/darwin_arm64-fastbuild/bin/packages/UmbraImplementations/Sources/LoggingServices/LoggingServices.swiftmodule-0.params)\n# Configuration: 76a1bf3a80f2d50513004915454165d2f164db794b63e4666809cbd93e1abeaa\n# Execution platform: @@platforms//host:host\nerror: emit-module command failed with exit code 1 (use -v to see invocation)\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:147:17: error: invalid redeclaration of 'log(_:_:context:)'\n145 |         - context: The logging context\n146 |      */\n147 |     public func log(_ level: LogLevel, _ message: String, context: any LogContextDTO) async {\n    |                 `- error: invalid redeclaration of 'log(_:_:context:)'\n148 |         // Convert to privacy string and use privacy-aware logging\n149 |         let privacyString = PrivacyString(stringLiteral: message)\npackages/UmbraImplementations/Sources/LoggingServices/Commands/AddDestinationCommand.swift:68:31: error: cannot find 'getDestination' in scope\n 66 |         do {\n 67 |             // Check if destination already exists\n 68 |             if let existing = getDestination(id: destination.id) {\n    |                               `- error: cannot find 'getDestination' in scope\n 69 |                 if !options.overwriteExisting {\n 70 |                     throw LoggingError.destinationAlreadyExists(identifier: \"Destination with ID \\(destination.id) already exists\")\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/AddDestinationCommand.swift:82:40: error: cannot find 'validateDestination' in scope\n 80 |             // Validate destination configuration if requested\n 81 |             if options.validateConfiguration {\n 82 |                 let validationResult = validateDestination(destination, for: provider)\n    |                                        `- error: cannot find 'validateDestination' in scope\n 83 |                 \n 84 |                 if !validationResult.isValid {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/AddDestinationCommand.swift:121:13: error: expression is 'async' but is not marked with 'await'\n119 |             \n120 |             // Register the destination\n121 |             registerDestination(destination)\n    |             |- error: expression is 'async' but is not marked with 'await'\n    |             `- note: calls to instance method 'registerDestination' from outside of its actor context are implicitly asynchronous\n122 |             \n123 |             // Log success\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ArchiveLogsCommand.swift:57:84: error: type 'LogPrivacyLevel' has no member 'protected'\n 55 |             destinationId: destinationId,\n 56 |             additionalMetadata: [\n 57 |                 \"destinationPath\": (value: options.destinationPath, privacyLevel: .protected),\n    |                                                                                    `- error: type 'LogPrivacyLevel' has no member 'protected'\n 58 |                 \"compress\": (value: String(options.compress), privacyLevel: .public),\n 59 |                 \"format\": (value: options.format.rawValue, privacyLevel: .public),\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ArchiveLogsCommand.swift:70:37: error: cannot find 'getDestination' in scope\n 68 |         do {\n 69 |             // Check if destination exists\n 70 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 71 |                 throw LoggingError.destinationNotFound(\n 72 |                     \"Cannot archive logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ArchiveLogsCommand.swift:113:103: error: type 'LogPrivacyLevel' has no member 'protected'\n111 |                     context: operationContext,\n112 |                     additionalMetadata: [\n113 |                         \"archivePath\": (value: archiveResult.archivePath ?? \"unknown\", privacyLevel: .protected),\n    |                                                                                                       `- error: type 'LogPrivacyLevel' has no member 'protected'\n114 |                         \"archiveSizeBytes\": (value: String(archiveResult.archiveSizeBytes ?? 0), privacyLevel: .public),\n115 |                         \"archivedEntryCount\": (value: String(archiveResult.archivedEntryCount ?? 0), privacyLevel: .public)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ExportLogsCommand.swift:70:37: error: cannot find 'getDestination' in scope\n 68 |         do {\n 69 |             // Check if destination exists\n 70 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 71 |                 throw LoggingError.destinationNotFound(\n 72 |                     \"Cannot export logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:79:50: error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n 77 |                 key: key,\n 78 |                 value: value.value,\n 79 |                 privacyLevel: value.privacyLevel.toPrivacyClassification()\n    |                                                  `- error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n 80 |             )\n 81 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:122:54: error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n120 |                     key: key,\n121 |                     value: value.value,\n122 |                     privacyLevel: value.privacyLevel.toPrivacyClassification()\n    |                                                      `- error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n123 |                 )\n124 |             )\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:229:21: error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n227 |         \n228 |         // Process special fields first\n229 |         switch rule.field {\n    |                     `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n230 |         case \"level\":\n231 |             fieldValue = entry.level.rawValue\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:238:96: error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n236 |         default:\n237 |             // Check metadata fields\n238 |             if let metadata = entry.metadata, let metadataValue = metadata.getString(key: rule.field) {\n    |                                                                                                `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n239 |                 fieldValue = metadataValue\n240 |             } else {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:246:21: error: value of type 'UmbraLogFilterRuleDTO' has no member 'operation'\n244 |         \n245 |         // Apply the operation\n246 |         switch rule.operation {\n    |                     `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'operation'\n247 |         case .equals:\n248 |             return fieldValue == rule.value\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:248:39: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n246 |         switch rule.operation {\n247 |         case .equals:\n248 |             return fieldValue == rule.value\n    |                                       `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n249 |         case .contains:\n250 |             return fieldValue.contains(rule.value)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:250:45: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n248 |             return fieldValue == rule.value\n249 |         case .contains:\n250 |             return fieldValue.contains(rule.value)\n    |                                             `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n251 |         case .startsWith:\n252 |             return fieldValue.hasPrefix(rule.value)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:252:46: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n250 |             return fieldValue.contains(rule.value)\n251 |         case .startsWith:\n252 |             return fieldValue.hasPrefix(rule.value)\n    |                                              `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n253 |         case .endsWith:\n254 |             return fieldValue.hasSuffix(rule.value)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:254:46: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n252 |             return fieldValue.hasPrefix(rule.value)\n253 |         case .endsWith:\n254 |             return fieldValue.hasSuffix(rule.value)\n    |                                              `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n255 |         case .matches:\n256 |             if let regex = try? NSRegularExpression(pattern: rule.value) {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:256:67: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n254 |             return fieldValue.hasSuffix(rule.value)\n255 |         case .matches:\n256 |             if let regex = try? NSRegularExpression(pattern: rule.value) {\n    |                                                                   `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n257 |                 let range = NSRange(location: 0, length: fieldValue.utf16.count)\n258 |                 return regex.firstMatch(in: fieldValue, options: [], range: range) != nil\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:262:86: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n260 |             return false\n261 |         case .greaterThan:\n262 |             if let fieldNumeric = Double(fieldValue), let valueNumeric = Double(rule.value) {\n    |                                                                                      `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n263 |                 return fieldNumeric \u003e valueNumeric\n264 |             }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:267:86: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n265 |             return false\n266 |         case .lessThan:\n267 |             if let fieldNumeric = Double(fieldValue), let valueNumeric = Double(rule.value) {\n    |                                                                                      `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n268 |                 return fieldNumeric \u003c valueNumeric\n269 |             }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:293:13: warning: variable 'redactedMetadata' was never mutated; consider changing to 'let' constant\n291 |         // Create mutable copies\n292 |         var redactedMessage = entry.message\n293 |         var redactedMetadata = entry.metadata\n    |             `- warning: variable 'redactedMetadata' was never mutated; consider changing to 'let' constant\n294 |         \n295 |         for rule in rules {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:395:47: error: value of type 'String' has no member 'stringByReplacingMatches'\n393 |             if rule.targetFields.isEmpty || rule.targetFields.contains(\"message\") {\n394 |                 if let pattern = rule.pattern {\n395 |                     redactedMessage = pattern.stringByReplacingMatches(\n    |                                               `- error: value of type 'String' has no member 'stringByReplacingMatches'\n396 |                         in: redactedMessage,\n397 |                         options: [],\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:394:20: error: initializer for conditional binding must have Optional type, not 'String'\n392 |             // Apply rule to message if it matches\n393 |             if rule.targetFields.isEmpty || rule.targetFields.contains(\"message\") {\n394 |                 if let pattern = rule.pattern {\n    |                    `- error: initializer for conditional binding must have Optional type, not 'String'\n395 |                     redactedMessage = pattern.stringByReplacingMatches(\n396 |                         in: redactedMessage,\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:405:24: error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getKeys' of wrapped base type 'LogMetadataDTOCollection'\n403 |             \n404 |             // Process metadata fields\n405 |             for key in redactedMetadata.getKeys() {\n    |                        |- error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getKeys' of wrapped base type 'LogMetadataDTOCollection'\n    |                        |- note: chain the optional using '?' to access member 'getKeys' only for non-'nil' base values\n    |                        `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n406 |                 if rule.targetFields.isEmpty || rule.targetFields.contains(key) {\n407 |                     if let stringValue = redactedMetadata.getString(key: key) {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:407:42: error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getString' of wrapped base type 'LogMetadataDTOCollection'\n405 |             for key in redactedMetadata.getKeys() {\n406 |                 if rule.targetFields.isEmpty || rule.targetFields.contains(key) {\n407 |                     if let stringValue = redactedMetadata.getString(key: key) {\n    |                                          |- error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getString' of wrapped base type 'LogMetadataDTOCollection'\n    |                                          |- note: chain the optional using '?' to access member 'getString' only for non-'nil' base values\n    |                                          `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n408 |                         // Skip fields that should be preserved\n409 |                         if rule.preserveFields.contains(key) {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:468:15: error: type 'LogPrivacyLevel' has no member 'never'\n466 |         case .auto:\n467 |             return .auto\n468 |         case .never:\n    |               `- error: type 'LogPrivacyLevel' has no member 'never'\n469 |             return .public // Map 'never' to public classification\n470 |         case .protected:\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:470:15: error: type 'LogPrivacyLevel' has no member 'protected'\n468 |         case .never:\n469 |             return .public // Map 'never' to public classification\n470 |         case .protected:\n    |               `- error: type 'LogPrivacyLevel' has no member 'protected'\n471 |             return .private // Map 'protected' to private classification\n472 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:58:84: error: type 'LogPrivacyLevel' has no member 'protected'\n 56 |             additionalMetadata: [\n 57 |                 \"createBackup\": (value: String(options.createBackup), privacyLevel: .public),\n 58 |                 \"backupPath\": (value: options.backupPath ?? \"none\", privacyLevel: .protected),\n    |                                                                                    `- error: type 'LogPrivacyLevel' has no member 'protected'\n 59 |                 \"dryRun\": (value: String(options.dryRun), privacyLevel: .public),\n 60 |                 \"hasFilterCriteria\": (value: String(options.filterCriteria != nil), privacyLevel: .public),\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:184:34: error: cannot find 'getDestination' in scope\n182 |         if let destinationId = destinationId {\n183 |             // Use specific destination\n184 |             if let destination = getDestination(id: destinationId) {\n    |                                  `- error: cannot find 'getDestination' in scope\n185 |                 return [destination]\n186 |             } else {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:196:38: error: cannot find 'getDestination' in scope\n194 |             \n195 |             for id in options.destinationIds {\n196 |                 if let destination = getDestination(id: id) {\n    |                                      `- error: cannot find 'getDestination' in scope\n197 |                     result.append(destination)\n198 |                 } else {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:208:20: error: cannot find 'getAllDestinations' in scope\n206 |         } else {\n207 |             // Use all registered destinations\n208 |             return getAllDestinations()\n    |                    `- error: cannot find 'getAllDestinations' in scope\n209 |         }\n210 |     }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/QueryLogsCommand.swift:71:37: error: cannot find 'getDestination' in scope\n 69 |         do {\n 70 |             // Check if destination exists\n 71 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 72 |                 throw LoggingError.destinationNotFound(\n 73 |                     \"Cannot query logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RedactionRule.swift:123:72: error: missing argument for parameter 'privacyLevel' in call\n121 |                 if value != redactedValue {\n122 |                     // Only update if actually changed\n123 |                     result = result.with(key: key, value: redactedValue)\n    |                                                                        `- error: missing argument for parameter 'privacyLevel' in call\n124 |                 }\n125 |             }\n\n/Users/mpy/.bazel/execroot/_main/packages/UmbraCoreTypes/Sources/LoggingTypes/LogMetadataDTOCollection.swift:78:15: note: 'with(key:value:privacyLevel:)' declared here\n 76 |   ///   - privacyLevel: The privacy classification for this entry\n 77 |   /// - Returns: The updated collection\n 78 |   public func with(\n    |               `- note: 'with(key:value:privacyLevel:)' declared here\n 79 |     key: String,\n 80 |     value: String,\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RedactionRule.swift:101:26: warning: no calls to throwing functions occur within 'try' expression\n 99 |     public func redact(metadata: LogMetadataDTOCollection) -\u003e LogMetadataDTOCollection {\n100 |         // No redaction needed for empty metadata\n101 |         guard let keys = try? metadata.getKeys() else {\n    |                          `- warning: no calls to throwing functions occur within 'try' expression\n102 |             return metadata\n103 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RedactionRule.swift:119:28: warning: no calls to throwing functions occur within 'try' expression\n117 |             \n118 |             // Get string value and apply redaction\n119 |             if let value = try? metadata.getString(key: key) {\n    |                            `- warning: no calls to throwing functions occur within 'try' expression\n120 |                 let redactedValue = redact(value)\n121 |                 if value != redactedValue {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RemoveDestinationCommand.swift:67:37: error: cannot find 'getDestination' in scope\n 65 |         do {\n 66 |             // Check if destination exists\n 67 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 68 |                 throw LoggingError.destinationNotFound(\n 69 |                     \"Cannot remove destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RemoveDestinationCommand.swift:128:13: error: expression is 'async' but is not marked with 'await'\n126 |             \n127 |             // Unregister the destination\n128 |             unregisterDestination(id: destinationId)\n    |             |- error: expression is 'async' but is not marked with 'await'\n    |             `- note: calls to instance method 'unregisterDestination(id:)' from outside of its actor context are implicitly asynchronous\n129 |             \n130 |             // Log success\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RotateLogsCommand.swift:67:37: error: cannot find 'getDestination' in scope\n 65 |         do {\n 66 |             // Check if destination exists\n 67 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 68 |                 throw LoggingError.destinationNotFound(\n 69 |                     \"Cannot rotate logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RotateLogsCommand.swift:74:37: error: cannot infer contextual base in reference to member 'file'\n 72 |             \n 73 |             // Check if the destination type supports rotation\n 74 |             if destination.type != .file {\n    |                                     `- error: cannot infer contextual base in reference to member 'file'\n 75 |                 throw LoggingError.invalidDestinationConfig(\n 76 |                     \"Log rotation is only supported for file destinations\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RotateLogsCommand.swift:92:112: error: type 'LogPrivacyLevel' has no member 'protected'\n 90 |                     context: operationContext,\n 91 |                     additionalMetadata: [\n 92 |                         \"rotatedFilePath\": (value: rotationResult.rotatedFilePath ?? \"unknown\", privacyLevel: .protected),\n    |                                                                                                                `- error: type 'LogPrivacyLevel' has no member 'protected'\n 93 |                         \"rotatedSizeBytes\": (value: String(rotationResult.rotatedSizeBytes ?? 0), privacyLevel: .public),\n 94 |                         \"rotatedEntryCount\": (value: String(rotationResult.rotatedEntryCount ?? 0), privacyLevel: .public)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/WriteLogCommand.swift:159:20: error: cannot find 'getAllDestinations' in scope\n157 |         if destinationIds.isEmpty {\n158 |             // Use all registered destinations\n159 |             return getAllDestinations().filter { $0.isEnabled }\n    |                    `- error: cannot find 'getAllDestinations' in scope\n160 |         } else {\n161 |             // Use specific destinations\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/WriteLogCommand.swift:165:38: error: cannot find 'getDestination' in scope\n163 |             \n164 |             for destinationId in destinationIds {\n165 |                 if let destination = getDestination(id: destinationId) {\n    |                                      `- error: cannot find 'getDestination' in scope\n166 |                     if destination.isEnabled {\n167 |                         result.append(destination)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/WriteLogCommand.swift:193:16: error: cannot find 'applyFilterRules' in scope\n191 |         \n192 |         // Apply filter rules if they exist\n193 |         return applyFilterRules(\n    |                `- error: cannot find 'applyFilterRules' in scope\n194 |             to: entry,\n195 |             rules: destination.configuration.filterRules\n\npackages/UmbraImplementations/Sources/LoggingServices/DefaultLoggingServiceImpl.swift:39:36: warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 37 |     let contextDTO=BaseLogContextDTO(\n 38 |       domainName: \"Legacy\",\n 39 |       operation: context.operation ?? \"unknown\",\n    |                                    `- warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 40 |       category: context.category ?? \"General\",\n 41 |       source: context.source ?? \"Unknown\",\n\npackages/UmbraImplementations/Sources/LoggingServices/DefaultLoggingServiceImpl.swift:40:34: warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 38 |       domainName: \"Legacy\",\n 39 |       operation: context.operation ?? \"unknown\",\n 40 |       category: context.category ?? \"General\",\n    |                                  `- warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 41 |       source: context.source ?? \"Unknown\",\n 42 |       metadata: context.metadata\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:147:17: error: invalid redeclaration of 'log(_:_:context:)'\n145 |         - context: The logging context\n146 |      */\n147 |     public func log(_ level: LogLevel, _ message: String, context: any LogContextDTO) async {\n    |                 `- error: invalid redeclaration of 'log(_:_:context:)'\n148 |         // Convert to privacy string and use privacy-aware logging\n149 |         let privacyString = PrivacyString(stringLiteral: message)\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:92:48: error: value of type 'any LoggingProviderProtocol' has no member 'writeLogEntry'\n 90 |                     do {\n 91 |                         // Write log entry to destination\n 92 |                         _ = try await provider.writeLogEntry(entry, to: destination)\n    |                                                `- error: value of type 'any LoggingProviderProtocol' has no member 'writeLogEntry'\n 93 |                     } catch {\n 94 |                         // Silently ignore provider errors for now\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:122:28: error: value of type 'PrivacyString' has no member 'privacy'\n120 |         enrichedMetadata = enrichedMetadata.withPrivate(\n121 |             key: \"__privacy_annotation\", \n122 |             value: message.privacy.description\n    |                            `- error: value of type 'PrivacyString' has no member 'privacy'\n123 |         )\n124 |         \n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:136:34: error: value of type 'PrivacyString' has no member 'content'\n134 |         \n135 |         // Log the message using the standard log method\n136 |         await log(level, message.content, context: privacyContext)\n    |                                  `- error: value of type 'PrivacyString' has no member 'content'\n137 |     }\n138 |     \n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:167:71: error: value of type 'PrivacyAnnotatedString' has no member 'stringValue'\n165 |     ) async {\n166 |         let annotatedString = privacyScope()\n167 |         await log(level, PrivacyString(stringLiteral: annotatedString.stringValue), context: context) \n    |                                                                       `- error: value of type 'PrivacyAnnotatedString' has no member 'stringValue'\n168 |     }\n169 |     \n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:190:29: error: for-in loop requires 'LogMetadata' to conform to 'Sequence'\n188 |         // Create a metadata collection with sensitive values\n189 |         var metadataCollection = context.metadata\n190 |         for (key, value) in sensitiveValues {\n    |                             `- error: for-in loop requires 'LogMetadata' to conform to 'Sequence'\n191 |             metadataCollection = metadataCollection.withSensitive(key: key, value: String(describing: value))\n192 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:228:9: error: switch must be exhaustive\n226 |         \n227 |         // Add error information to metadata with appropriate privacy level\n228 |         switch privacyLevel {\n    |         |- error: switch must be exhaustive\n    |         `- note: add missing case: '.auto'\n229 |         case .public:\n230 |             metadataCollection = metadataCollection.withPublic(key: \"error_description\", value: error.localizedDescription)\npackages/UmbraImplementations/Sources/LoggingServices/PrivacyAwareLogDTO.swift:217:24: error: value of type 'LogMetadataDTOCollection' has no member 'set'\n215 |     for key in self.metadata.getKeys() {\n216 |       if let value = self.metadata.getString(key: key) {\n217 |         mergedMetadata.set(key: key, value: value)\n    |                        `- error: value of type 'LogMetadataDTOCollection' has no member 'set'\n218 |       }\n219 |     }\n\npackages/UmbraImplementations/Sources/LoggingServices/PrivacyAwareLogDTO.swift:224:24: error: value of type 'LogMetadataDTOCollection' has no member 'set'\n222 |     for key in additionalMetadata.getKeys() {\n223 |       if let value = additionalMetadata.getString(key: key) {\n224 |         mergedMetadata.set(key: key, value: value)\n    |                        `- error: value of type 'LogMetadataDTOCollection' has no member 'set'\n225 |       }\n226 |     }\n\npackages/UmbraImplementations/Sources/LoggingServices/PrivacyAwareLogDTO.swift:235:17: error: cannot convert value of type 'LogMetadataDTOCollection' to expected argument type '[String : (value: Any, privacy: LogPrivacyLevel)]'\n233 |       category: category,\n234 |       correlationID: correlationID,\n235 |       metadata: mergedMetadata,\n    |                 `- error: cannot convert value of type 'LogMetadataDTOCollection' to expected argument type '[String : (value: Any, privacy: LogPrivacyLevel)]'\n236 |       environment: environment\n237 |     )\nTarget //packages/UmbraImplementations/Sources/APIServices:APIServices failed to build\nINFO: Elapsed time: 1.546s, Critical Path: 1.38s\nINFO: 6 processes: 34 action cache hit, 2 internal, 4 worker.\nERROR: Build did NOT complete successfully\n"
  },
  {
    "target": "rule //packages/UmbraImplementations/Sources/BackupCoordinator:BackupCoordinator",
    "success": false,
    "start_time": "2025-04-11T17:57:41.080078+01:00",
    "end_time": "2025-04-11T17:57:43.008159+01:00",
    "duration": "1.928082792s",
    "output": "INFO: Invocation ID: 655a40d3-1d18-442d-9fe4-fa3860b68065\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraImplementations/Sources/BackupCoordinator:BackupCoordinator (1 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraImplementations/Sources/BackupCoordinator:BackupCoordinator (1 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraImplementations/Sources/BackupCoordinator:BackupCoordinator (11 packages loaded, 165 targets configured).\nERROR: /Users/mpy/CascadeProjects/UmbraCore/packages/UmbraImplementations/Sources/LoggingServices/BUILD.bazel:3:20: Compiling Swift module //packages/UmbraImplementations/Sources/LoggingServices:LoggingServices failed: (Exit 1): worker failed: error executing SwiftCompile command (from target //packages/UmbraImplementations/Sources/LoggingServices:LoggingServices) \n  (cd /Users/mpy/.bazel/execroot/_main \u0026\u0026 \\\n  exec env - \\\n    APPLE_SDK_PLATFORM=MacOSX \\\n    APPLE_SDK_VERSION_OVERRIDE=15.4 \\\n    CC=clang \\\n    PATH=/Users/mpy/Library/Caches/bazelisk/downloads/sha256/ac72ad67f7a8c6b18bf605d8602425182b417de4369715bf89146daf62f7ae48/bin:/Users/mpy/.rbenv/bin:/Users/mpy/.codeium/windsurf/bin:/opt/homebrew/opt/node@18/bin:/opt/homebrew/opt/node@20/bin:/Users/mpy/.docker/bin:/opt/homebrew/opt/openjdk/bin:/Users/mpy/bin:/opt/homebrew/bin:/opt/homebrew/sbin:/usr/local/bin:/System/Cryptexes/App/usr/bin:/usr/bin:/bin:/usr/sbin:/sbin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/local/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/appleinternal/bin:/Library/Apple/usr/bin:/usr/local/go/bin:/Users/mpy/.rbenv/bin:/Users/mpy/.codeium/windsurf/bin:/opt/homebrew/opt/node@18/bin:/opt/homebrew/opt/node@20/bin:/opt/anaconda3/bin:/opt/anaconda3/condabin:/Users/mpy/.docker/bin:/opt/homebrew/opt/openjdk/bin:/Users/mpy/bin:/Users/mpy/.cargo/bin:/Users/mpy/Library/Python/3.8/bin:/Users/mpy/go/bin:/Users/mpy/.scripts:/Users/mpy/.fzf/bin:/Users/mpy/.windsurf/extensions/ms-python.debugpy-2025.6.0-darwin-arm64/bundled/scripts/noConfigScripts:/Users/mpy/Library/Python/3.8/bin:/Users/mpy/go/bin:/Users/mpy/.scripts \\\n    XCODE_VERSION_OVERRIDE=16.3.0.16E140 \\\n  bazel-out/darwin_arm64-opt-exec-ST-d57f47055a04/bin/external/rules_swift+/tools/worker/worker swiftc @bazel-out/darwin_arm64-fastbuild/bin/packages/UmbraImplementations/Sources/LoggingServices/LoggingServices.swiftmodule-0.params)\n# Configuration: 76a1bf3a80f2d50513004915454165d2f164db794b63e4666809cbd93e1abeaa\n# Execution platform: @@platforms//host:host\nerror: emit-module command failed with exit code 1 (use -v to see invocation)\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:147:17: error: invalid redeclaration of 'log(_:_:context:)'\n145 |         - context: The logging context\n146 |      */\n147 |     public func log(_ level: LogLevel, _ message: String, context: any LogContextDTO) async {\n    |                 `- error: invalid redeclaration of 'log(_:_:context:)'\n148 |         // Convert to privacy string and use privacy-aware logging\n149 |         let privacyString = PrivacyString(stringLiteral: message)\npackages/UmbraImplementations/Sources/LoggingServices/Commands/AddDestinationCommand.swift:68:31: error: cannot find 'getDestination' in scope\n 66 |         do {\n 67 |             // Check if destination already exists\n 68 |             if let existing = getDestination(id: destination.id) {\n    |                               `- error: cannot find 'getDestination' in scope\n 69 |                 if !options.overwriteExisting {\n 70 |                     throw LoggingError.destinationAlreadyExists(identifier: \"Destination with ID \\(destination.id) already exists\")\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/AddDestinationCommand.swift:82:40: error: cannot find 'validateDestination' in scope\n 80 |             // Validate destination configuration if requested\n 81 |             if options.validateConfiguration {\n 82 |                 let validationResult = validateDestination(destination, for: provider)\n    |                                        `- error: cannot find 'validateDestination' in scope\n 83 |                 \n 84 |                 if !validationResult.isValid {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/AddDestinationCommand.swift:121:13: error: expression is 'async' but is not marked with 'await'\n119 |             \n120 |             // Register the destination\n121 |             registerDestination(destination)\n    |             |- error: expression is 'async' but is not marked with 'await'\n    |             `- note: calls to instance method 'registerDestination' from outside of its actor context are implicitly asynchronous\n122 |             \n123 |             // Log success\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ArchiveLogsCommand.swift:57:84: error: type 'LogPrivacyLevel' has no member 'protected'\n 55 |             destinationId: destinationId,\n 56 |             additionalMetadata: [\n 57 |                 \"destinationPath\": (value: options.destinationPath, privacyLevel: .protected),\n    |                                                                                    `- error: type 'LogPrivacyLevel' has no member 'protected'\n 58 |                 \"compress\": (value: String(options.compress), privacyLevel: .public),\n 59 |                 \"format\": (value: options.format.rawValue, privacyLevel: .public),\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ArchiveLogsCommand.swift:70:37: error: cannot find 'getDestination' in scope\n 68 |         do {\n 69 |             // Check if destination exists\n 70 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 71 |                 throw LoggingError.destinationNotFound(\n 72 |                     \"Cannot archive logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ArchiveLogsCommand.swift:113:103: error: type 'LogPrivacyLevel' has no member 'protected'\n111 |                     context: operationContext,\n112 |                     additionalMetadata: [\n113 |                         \"archivePath\": (value: archiveResult.archivePath ?? \"unknown\", privacyLevel: .protected),\n    |                                                                                                       `- error: type 'LogPrivacyLevel' has no member 'protected'\n114 |                         \"archiveSizeBytes\": (value: String(archiveResult.archiveSizeBytes ?? 0), privacyLevel: .public),\n115 |                         \"archivedEntryCount\": (value: String(archiveResult.archivedEntryCount ?? 0), privacyLevel: .public)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ExportLogsCommand.swift:70:37: error: cannot find 'getDestination' in scope\n 68 |         do {\n 69 |             // Check if destination exists\n 70 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 71 |                 throw LoggingError.destinationNotFound(\n 72 |                     \"Cannot export logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:79:50: error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n 77 |                 key: key,\n 78 |                 value: value.value,\n 79 |                 privacyLevel: value.privacyLevel.toPrivacyClassification()\n    |                                                  `- error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n 80 |             )\n 81 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:122:54: error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n120 |                     key: key,\n121 |                     value: value.value,\n122 |                     privacyLevel: value.privacyLevel.toPrivacyClassification()\n    |                                                      `- error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n123 |                 )\n124 |             )\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:229:21: error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n227 |         \n228 |         // Process special fields first\n229 |         switch rule.field {\n    |                     `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n230 |         case \"level\":\n231 |             fieldValue = entry.level.rawValue\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:238:96: error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n236 |         default:\n237 |             // Check metadata fields\n238 |             if let metadata = entry.metadata, let metadataValue = metadata.getString(key: rule.field) {\n    |                                                                                                `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n239 |                 fieldValue = metadataValue\n240 |             } else {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:246:21: error: value of type 'UmbraLogFilterRuleDTO' has no member 'operation'\n244 |         \n245 |         // Apply the operation\n246 |         switch rule.operation {\n    |                     `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'operation'\n247 |         case .equals:\n248 |             return fieldValue == rule.value\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:248:39: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n246 |         switch rule.operation {\n247 |         case .equals:\n248 |             return fieldValue == rule.value\n    |                                       `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n249 |         case .contains:\n250 |             return fieldValue.contains(rule.value)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:250:45: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n248 |             return fieldValue == rule.value\n249 |         case .contains:\n250 |             return fieldValue.contains(rule.value)\n    |                                             `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n251 |         case .startsWith:\n252 |             return fieldValue.hasPrefix(rule.value)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:252:46: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n250 |             return fieldValue.contains(rule.value)\n251 |         case .startsWith:\n252 |             return fieldValue.hasPrefix(rule.value)\n    |                                              `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n253 |         case .endsWith:\n254 |             return fieldValue.hasSuffix(rule.value)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:254:46: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n252 |             return fieldValue.hasPrefix(rule.value)\n253 |         case .endsWith:\n254 |             return fieldValue.hasSuffix(rule.value)\n    |                                              `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n255 |         case .matches:\n256 |             if let regex = try? NSRegularExpression(pattern: rule.value) {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:256:67: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n254 |             return fieldValue.hasSuffix(rule.value)\n255 |         case .matches:\n256 |             if let regex = try? NSRegularExpression(pattern: rule.value) {\n    |                                                                   `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n257 |                 let range = NSRange(location: 0, length: fieldValue.utf16.count)\n258 |                 return regex.firstMatch(in: fieldValue, options: [], range: range) != nil\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:262:86: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n260 |             return false\n261 |         case .greaterThan:\n262 |             if let fieldNumeric = Double(fieldValue), let valueNumeric = Double(rule.value) {\n    |                                                                                      `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n263 |                 return fieldNumeric \u003e valueNumeric\n264 |             }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:267:86: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n265 |             return false\n266 |         case .lessThan:\n267 |             if let fieldNumeric = Double(fieldValue), let valueNumeric = Double(rule.value) {\n    |                                                                                      `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n268 |                 return fieldNumeric \u003c valueNumeric\n269 |             }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:293:13: warning: variable 'redactedMetadata' was never mutated; consider changing to 'let' constant\n291 |         // Create mutable copies\n292 |         var redactedMessage = entry.message\n293 |         var redactedMetadata = entry.metadata\n    |             `- warning: variable 'redactedMetadata' was never mutated; consider changing to 'let' constant\n294 |         \n295 |         for rule in rules {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:395:47: error: value of type 'String' has no member 'stringByReplacingMatches'\n393 |             if rule.targetFields.isEmpty || rule.targetFields.contains(\"message\") {\n394 |                 if let pattern = rule.pattern {\n395 |                     redactedMessage = pattern.stringByReplacingMatches(\n    |                                               `- error: value of type 'String' has no member 'stringByReplacingMatches'\n396 |                         in: redactedMessage,\n397 |                         options: [],\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:394:20: error: initializer for conditional binding must have Optional type, not 'String'\n392 |             // Apply rule to message if it matches\n393 |             if rule.targetFields.isEmpty || rule.targetFields.contains(\"message\") {\n394 |                 if let pattern = rule.pattern {\n    |                    `- error: initializer for conditional binding must have Optional type, not 'String'\n395 |                     redactedMessage = pattern.stringByReplacingMatches(\n396 |                         in: redactedMessage,\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:405:24: error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getKeys' of wrapped base type 'LogMetadataDTOCollection'\n403 |             \n404 |             // Process metadata fields\n405 |             for key in redactedMetadata.getKeys() {\n    |                        |- error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getKeys' of wrapped base type 'LogMetadataDTOCollection'\n    |                        |- note: chain the optional using '?' to access member 'getKeys' only for non-'nil' base values\n    |                        `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n406 |                 if rule.targetFields.isEmpty || rule.targetFields.contains(key) {\n407 |                     if let stringValue = redactedMetadata.getString(key: key) {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:407:42: error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getString' of wrapped base type 'LogMetadataDTOCollection'\n405 |             for key in redactedMetadata.getKeys() {\n406 |                 if rule.targetFields.isEmpty || rule.targetFields.contains(key) {\n407 |                     if let stringValue = redactedMetadata.getString(key: key) {\n    |                                          |- error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getString' of wrapped base type 'LogMetadataDTOCollection'\n    |                                          |- note: chain the optional using '?' to access member 'getString' only for non-'nil' base values\n    |                                          `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n408 |                         // Skip fields that should be preserved\n409 |                         if rule.preserveFields.contains(key) {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:468:15: error: type 'LogPrivacyLevel' has no member 'never'\n466 |         case .auto:\n467 |             return .auto\n468 |         case .never:\n    |               `- error: type 'LogPrivacyLevel' has no member 'never'\n469 |             return .public // Map 'never' to public classification\n470 |         case .protected:\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:470:15: error: type 'LogPrivacyLevel' has no member 'protected'\n468 |         case .never:\n469 |             return .public // Map 'never' to public classification\n470 |         case .protected:\n    |               `- error: type 'LogPrivacyLevel' has no member 'protected'\n471 |             return .private // Map 'protected' to private classification\n472 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:58:84: error: type 'LogPrivacyLevel' has no member 'protected'\n 56 |             additionalMetadata: [\n 57 |                 \"createBackup\": (value: String(options.createBackup), privacyLevel: .public),\n 58 |                 \"backupPath\": (value: options.backupPath ?? \"none\", privacyLevel: .protected),\n    |                                                                                    `- error: type 'LogPrivacyLevel' has no member 'protected'\n 59 |                 \"dryRun\": (value: String(options.dryRun), privacyLevel: .public),\n 60 |                 \"hasFilterCriteria\": (value: String(options.filterCriteria != nil), privacyLevel: .public),\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:184:34: error: cannot find 'getDestination' in scope\n182 |         if let destinationId = destinationId {\n183 |             // Use specific destination\n184 |             if let destination = getDestination(id: destinationId) {\n    |                                  `- error: cannot find 'getDestination' in scope\n185 |                 return [destination]\n186 |             } else {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:196:38: error: cannot find 'getDestination' in scope\n194 |             \n195 |             for id in options.destinationIds {\n196 |                 if let destination = getDestination(id: id) {\n    |                                      `- error: cannot find 'getDestination' in scope\n197 |                     result.append(destination)\n198 |                 } else {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:208:20: error: cannot find 'getAllDestinations' in scope\n206 |         } else {\n207 |             // Use all registered destinations\n208 |             return getAllDestinations()\n    |                    `- error: cannot find 'getAllDestinations' in scope\n209 |         }\n210 |     }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/QueryLogsCommand.swift:71:37: error: cannot find 'getDestination' in scope\n 69 |         do {\n 70 |             // Check if destination exists\n 71 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 72 |                 throw LoggingError.destinationNotFound(\n 73 |                     \"Cannot query logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RedactionRule.swift:123:72: error: missing argument for parameter 'privacyLevel' in call\n121 |                 if value != redactedValue {\n122 |                     // Only update if actually changed\n123 |                     result = result.with(key: key, value: redactedValue)\n    |                                                                        `- error: missing argument for parameter 'privacyLevel' in call\n124 |                 }\n125 |             }\n\n/Users/mpy/.bazel/execroot/_main/packages/UmbraCoreTypes/Sources/LoggingTypes/LogMetadataDTOCollection.swift:78:15: note: 'with(key:value:privacyLevel:)' declared here\n 76 |   ///   - privacyLevel: The privacy classification for this entry\n 77 |   /// - Returns: The updated collection\n 78 |   public func with(\n    |               `- note: 'with(key:value:privacyLevel:)' declared here\n 79 |     key: String,\n 80 |     value: String,\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RedactionRule.swift:101:26: warning: no calls to throwing functions occur within 'try' expression\n 99 |     public func redact(metadata: LogMetadataDTOCollection) -\u003e LogMetadataDTOCollection {\n100 |         // No redaction needed for empty metadata\n101 |         guard let keys = try? metadata.getKeys() else {\n    |                          `- warning: no calls to throwing functions occur within 'try' expression\n102 |             return metadata\n103 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RedactionRule.swift:119:28: warning: no calls to throwing functions occur within 'try' expression\n117 |             \n118 |             // Get string value and apply redaction\n119 |             if let value = try? metadata.getString(key: key) {\n    |                            `- warning: no calls to throwing functions occur within 'try' expression\n120 |                 let redactedValue = redact(value)\n121 |                 if value != redactedValue {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RemoveDestinationCommand.swift:67:37: error: cannot find 'getDestination' in scope\n 65 |         do {\n 66 |             // Check if destination exists\n 67 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 68 |                 throw LoggingError.destinationNotFound(\n 69 |                     \"Cannot remove destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RemoveDestinationCommand.swift:128:13: error: expression is 'async' but is not marked with 'await'\n126 |             \n127 |             // Unregister the destination\n128 |             unregisterDestination(id: destinationId)\n    |             |- error: expression is 'async' but is not marked with 'await'\n    |             `- note: calls to instance method 'unregisterDestination(id:)' from outside of its actor context are implicitly asynchronous\n129 |             \n130 |             // Log success\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RotateLogsCommand.swift:67:37: error: cannot find 'getDestination' in scope\n 65 |         do {\n 66 |             // Check if destination exists\n 67 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 68 |                 throw LoggingError.destinationNotFound(\n 69 |                     \"Cannot rotate logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RotateLogsCommand.swift:74:37: error: cannot infer contextual base in reference to member 'file'\n 72 |             \n 73 |             // Check if the destination type supports rotation\n 74 |             if destination.type != .file {\n    |                                     `- error: cannot infer contextual base in reference to member 'file'\n 75 |                 throw LoggingError.invalidDestinationConfig(\n 76 |                     \"Log rotation is only supported for file destinations\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RotateLogsCommand.swift:92:112: error: type 'LogPrivacyLevel' has no member 'protected'\n 90 |                     context: operationContext,\n 91 |                     additionalMetadata: [\n 92 |                         \"rotatedFilePath\": (value: rotationResult.rotatedFilePath ?? \"unknown\", privacyLevel: .protected),\n    |                                                                                                                `- error: type 'LogPrivacyLevel' has no member 'protected'\n 93 |                         \"rotatedSizeBytes\": (value: String(rotationResult.rotatedSizeBytes ?? 0), privacyLevel: .public),\n 94 |                         \"rotatedEntryCount\": (value: String(rotationResult.rotatedEntryCount ?? 0), privacyLevel: .public)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/WriteLogCommand.swift:159:20: error: cannot find 'getAllDestinations' in scope\n157 |         if destinationIds.isEmpty {\n158 |             // Use all registered destinations\n159 |             return getAllDestinations().filter { $0.isEnabled }\n    |                    `- error: cannot find 'getAllDestinations' in scope\n160 |         } else {\n161 |             // Use specific destinations\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/WriteLogCommand.swift:165:38: error: cannot find 'getDestination' in scope\n163 |             \n164 |             for destinationId in destinationIds {\n165 |                 if let destination = getDestination(id: destinationId) {\n    |                                      `- error: cannot find 'getDestination' in scope\n166 |                     if destination.isEnabled {\n167 |                         result.append(destination)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/WriteLogCommand.swift:193:16: error: cannot find 'applyFilterRules' in scope\n191 |         \n192 |         // Apply filter rules if they exist\n193 |         return applyFilterRules(\n    |                `- error: cannot find 'applyFilterRules' in scope\n194 |             to: entry,\n195 |             rules: destination.configuration.filterRules\n\npackages/UmbraImplementations/Sources/LoggingServices/DefaultLoggingServiceImpl.swift:39:36: warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 37 |     let contextDTO=BaseLogContextDTO(\n 38 |       domainName: \"Legacy\",\n 39 |       operation: context.operation ?? \"unknown\",\n    |                                    `- warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 40 |       category: context.category ?? \"General\",\n 41 |       source: context.source ?? \"Unknown\",\n\npackages/UmbraImplementations/Sources/LoggingServices/DefaultLoggingServiceImpl.swift:40:34: warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 38 |       domainName: \"Legacy\",\n 39 |       operation: context.operation ?? \"unknown\",\n 40 |       category: context.category ?? \"General\",\n    |                                  `- warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 41 |       source: context.source ?? \"Unknown\",\n 42 |       metadata: context.metadata\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:147:17: error: invalid redeclaration of 'log(_:_:context:)'\n145 |         - context: The logging context\n146 |      */\n147 |     public func log(_ level: LogLevel, _ message: String, context: any LogContextDTO) async {\n    |                 `- error: invalid redeclaration of 'log(_:_:context:)'\n148 |         // Convert to privacy string and use privacy-aware logging\n149 |         let privacyString = PrivacyString(stringLiteral: message)\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:92:48: error: value of type 'any LoggingProviderProtocol' has no member 'writeLogEntry'\n 90 |                     do {\n 91 |                         // Write log entry to destination\n 92 |                         _ = try await provider.writeLogEntry(entry, to: destination)\n    |                                                `- error: value of type 'any LoggingProviderProtocol' has no member 'writeLogEntry'\n 93 |                     } catch {\n 94 |                         // Silently ignore provider errors for now\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:122:28: error: value of type 'PrivacyString' has no member 'privacy'\n120 |         enrichedMetadata = enrichedMetadata.withPrivate(\n121 |             key: \"__privacy_annotation\", \n122 |             value: message.privacy.description\n    |                            `- error: value of type 'PrivacyString' has no member 'privacy'\n123 |         )\n124 |         \n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:136:34: error: value of type 'PrivacyString' has no member 'content'\n134 |         \n135 |         // Log the message using the standard log method\n136 |         await log(level, message.content, context: privacyContext)\n    |                                  `- error: value of type 'PrivacyString' has no member 'content'\n137 |     }\n138 |     \n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:167:71: error: value of type 'PrivacyAnnotatedString' has no member 'stringValue'\n165 |     ) async {\n166 |         let annotatedString = privacyScope()\n167 |         await log(level, PrivacyString(stringLiteral: annotatedString.stringValue), context: context) \n    |                                                                       `- error: value of type 'PrivacyAnnotatedString' has no member 'stringValue'\n168 |     }\n169 |     \n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:190:29: error: for-in loop requires 'LogMetadata' to conform to 'Sequence'\n188 |         // Create a metadata collection with sensitive values\n189 |         var metadataCollection = context.metadata\n190 |         for (key, value) in sensitiveValues {\n    |                             `- error: for-in loop requires 'LogMetadata' to conform to 'Sequence'\n191 |             metadataCollection = metadataCollection.withSensitive(key: key, value: String(describing: value))\n192 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:228:9: error: switch must be exhaustive\n226 |         \n227 |         // Add error information to metadata with appropriate privacy level\n228 |         switch privacyLevel {\n    |         |- error: switch must be exhaustive\n    |         `- note: add missing case: '.auto'\n229 |         case .public:\n230 |             metadataCollection = metadataCollection.withPublic(key: \"error_description\", value: error.localizedDescription)\npackages/UmbraImplementations/Sources/LoggingServices/PrivacyAwareLogDTO.swift:217:24: error: value of type 'LogMetadataDTOCollection' has no member 'set'\n215 |     for key in self.metadata.getKeys() {\n216 |       if let value = self.metadata.getString(key: key) {\n217 |         mergedMetadata.set(key: key, value: value)\n    |                        `- error: value of type 'LogMetadataDTOCollection' has no member 'set'\n218 |       }\n219 |     }\n\npackages/UmbraImplementations/Sources/LoggingServices/PrivacyAwareLogDTO.swift:224:24: error: value of type 'LogMetadataDTOCollection' has no member 'set'\n222 |     for key in additionalMetadata.getKeys() {\n223 |       if let value = additionalMetadata.getString(key: key) {\n224 |         mergedMetadata.set(key: key, value: value)\n    |                        `- error: value of type 'LogMetadataDTOCollection' has no member 'set'\n225 |       }\n226 |     }\n\npackages/UmbraImplementations/Sources/LoggingServices/PrivacyAwareLogDTO.swift:235:17: error: cannot convert value of type 'LogMetadataDTOCollection' to expected argument type '[String : (value: Any, privacy: LogPrivacyLevel)]'\n233 |       category: category,\n234 |       correlationID: correlationID,\n235 |       metadata: mergedMetadata,\n    |                 `- error: cannot convert value of type 'LogMetadataDTOCollection' to expected argument type '[String : (value: Any, privacy: LogPrivacyLevel)]'\n236 |       environment: environment\n237 |     )\nTarget //packages/UmbraImplementations/Sources/BackupCoordinator:BackupCoordinator failed to build\nINFO: Elapsed time: 1.208s, Critical Path: 1.05s\nINFO: 6 processes: 12 action cache hit, 3 internal, 3 worker.\nERROR: Build did NOT complete successfully\n"
  },
  {
    "target": "rule //packages/UmbraImplementations/Sources/BackupServices:BackupServices",
    "success": false,
    "start_time": "2025-04-11T17:57:43.008171+01:00",
    "end_time": "2025-04-11T17:57:44.980837+01:00",
    "duration": "1.972667875s",
    "output": "INFO: Invocation ID: 073c261c-2756-4a68-b1de-350c83f3da0f\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraImplementations/Sources/BackupServices:BackupServices (0 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraImplementations/Sources/BackupServices:BackupServices (0 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraImplementations/Sources/BackupServices:BackupServices (0 packages loaded, 0 targets configured).\nERROR: /Users/mpy/CascadeProjects/UmbraCore/packages/UmbraImplementations/Sources/LoggingServices/BUILD.bazel:3:20: Compiling Swift module //packages/UmbraImplementations/Sources/LoggingServices:LoggingServices failed: (Exit 1): worker failed: error executing SwiftCompile command (from target //packages/UmbraImplementations/Sources/LoggingServices:LoggingServices) \n  (cd /Users/mpy/.bazel/execroot/_main \u0026\u0026 \\\n  exec env - \\\n    APPLE_SDK_PLATFORM=MacOSX \\\n    APPLE_SDK_VERSION_OVERRIDE=15.4 \\\n    CC=clang \\\n    PATH=/Users/mpy/Library/Caches/bazelisk/downloads/sha256/ac72ad67f7a8c6b18bf605d8602425182b417de4369715bf89146daf62f7ae48/bin:/Users/mpy/.rbenv/bin:/Users/mpy/.codeium/windsurf/bin:/opt/homebrew/opt/node@18/bin:/opt/homebrew/opt/node@20/bin:/Users/mpy/.docker/bin:/opt/homebrew/opt/openjdk/bin:/Users/mpy/bin:/opt/homebrew/bin:/opt/homebrew/sbin:/usr/local/bin:/System/Cryptexes/App/usr/bin:/usr/bin:/bin:/usr/sbin:/sbin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/local/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/appleinternal/bin:/Library/Apple/usr/bin:/usr/local/go/bin:/Users/mpy/.rbenv/bin:/Users/mpy/.codeium/windsurf/bin:/opt/homebrew/opt/node@18/bin:/opt/homebrew/opt/node@20/bin:/opt/anaconda3/bin:/opt/anaconda3/condabin:/Users/mpy/.docker/bin:/opt/homebrew/opt/openjdk/bin:/Users/mpy/bin:/Users/mpy/.cargo/bin:/Users/mpy/Library/Python/3.8/bin:/Users/mpy/go/bin:/Users/mpy/.scripts:/Users/mpy/.fzf/bin:/Users/mpy/.windsurf/extensions/ms-python.debugpy-2025.6.0-darwin-arm64/bundled/scripts/noConfigScripts:/Users/mpy/Library/Python/3.8/bin:/Users/mpy/go/bin:/Users/mpy/.scripts \\\n    XCODE_VERSION_OVERRIDE=16.3.0.16E140 \\\n  bazel-out/darwin_arm64-opt-exec-ST-d57f47055a04/bin/external/rules_swift+/tools/worker/worker swiftc @bazel-out/darwin_arm64-fastbuild/bin/packages/UmbraImplementations/Sources/LoggingServices/LoggingServices.swiftmodule-0.params)\n# Configuration: 76a1bf3a80f2d50513004915454165d2f164db794b63e4666809cbd93e1abeaa\n# Execution platform: @@platforms//host:host\nerror: emit-module command failed with exit code 1 (use -v to see invocation)\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:147:17: error: invalid redeclaration of 'log(_:_:context:)'\n145 |         - context: The logging context\n146 |      */\n147 |     public func log(_ level: LogLevel, _ message: String, context: any LogContextDTO) async {\n    |                 `- error: invalid redeclaration of 'log(_:_:context:)'\n148 |         // Convert to privacy string and use privacy-aware logging\n149 |         let privacyString = PrivacyString(stringLiteral: message)\npackages/UmbraImplementations/Sources/LoggingServices/Commands/AddDestinationCommand.swift:68:31: error: cannot find 'getDestination' in scope\n 66 |         do {\n 67 |             // Check if destination already exists\n 68 |             if let existing = getDestination(id: destination.id) {\n    |                               `- error: cannot find 'getDestination' in scope\n 69 |                 if !options.overwriteExisting {\n 70 |                     throw LoggingError.destinationAlreadyExists(identifier: \"Destination with ID \\(destination.id) already exists\")\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/AddDestinationCommand.swift:82:40: error: cannot find 'validateDestination' in scope\n 80 |             // Validate destination configuration if requested\n 81 |             if options.validateConfiguration {\n 82 |                 let validationResult = validateDestination(destination, for: provider)\n    |                                        `- error: cannot find 'validateDestination' in scope\n 83 |                 \n 84 |                 if !validationResult.isValid {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/AddDestinationCommand.swift:121:13: error: expression is 'async' but is not marked with 'await'\n119 |             \n120 |             // Register the destination\n121 |             registerDestination(destination)\n    |             |- error: expression is 'async' but is not marked with 'await'\n    |             `- note: calls to instance method 'registerDestination' from outside of its actor context are implicitly asynchronous\n122 |             \n123 |             // Log success\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ArchiveLogsCommand.swift:57:84: error: type 'LogPrivacyLevel' has no member 'protected'\n 55 |             destinationId: destinationId,\n 56 |             additionalMetadata: [\n 57 |                 \"destinationPath\": (value: options.destinationPath, privacyLevel: .protected),\n    |                                                                                    `- error: type 'LogPrivacyLevel' has no member 'protected'\n 58 |                 \"compress\": (value: String(options.compress), privacyLevel: .public),\n 59 |                 \"format\": (value: options.format.rawValue, privacyLevel: .public),\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ArchiveLogsCommand.swift:70:37: error: cannot find 'getDestination' in scope\n 68 |         do {\n 69 |             // Check if destination exists\n 70 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 71 |                 throw LoggingError.destinationNotFound(\n 72 |                     \"Cannot archive logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ArchiveLogsCommand.swift:113:103: error: type 'LogPrivacyLevel' has no member 'protected'\n111 |                     context: operationContext,\n112 |                     additionalMetadata: [\n113 |                         \"archivePath\": (value: archiveResult.archivePath ?? \"unknown\", privacyLevel: .protected),\n    |                                                                                                       `- error: type 'LogPrivacyLevel' has no member 'protected'\n114 |                         \"archiveSizeBytes\": (value: String(archiveResult.archiveSizeBytes ?? 0), privacyLevel: .public),\n115 |                         \"archivedEntryCount\": (value: String(archiveResult.archivedEntryCount ?? 0), privacyLevel: .public)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ExportLogsCommand.swift:70:37: error: cannot find 'getDestination' in scope\n 68 |         do {\n 69 |             // Check if destination exists\n 70 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 71 |                 throw LoggingError.destinationNotFound(\n 72 |                     \"Cannot export logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:79:50: error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n 77 |                 key: key,\n 78 |                 value: value.value,\n 79 |                 privacyLevel: value.privacyLevel.toPrivacyClassification()\n    |                                                  `- error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n 80 |             )\n 81 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:122:54: error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n120 |                     key: key,\n121 |                     value: value.value,\n122 |                     privacyLevel: value.privacyLevel.toPrivacyClassification()\n    |                                                      `- error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n123 |                 )\n124 |             )\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:229:21: error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n227 |         \n228 |         // Process special fields first\n229 |         switch rule.field {\n    |                     `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n230 |         case \"level\":\n231 |             fieldValue = entry.level.rawValue\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:238:96: error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n236 |         default:\n237 |             // Check metadata fields\n238 |             if let metadata = entry.metadata, let metadataValue = metadata.getString(key: rule.field) {\n    |                                                                                                `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n239 |                 fieldValue = metadataValue\n240 |             } else {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:246:21: error: value of type 'UmbraLogFilterRuleDTO' has no member 'operation'\n244 |         \n245 |         // Apply the operation\n246 |         switch rule.operation {\n    |                     `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'operation'\n247 |         case .equals:\n248 |             return fieldValue == rule.value\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:248:39: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n246 |         switch rule.operation {\n247 |         case .equals:\n248 |             return fieldValue == rule.value\n    |                                       `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n249 |         case .contains:\n250 |             return fieldValue.contains(rule.value)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:250:45: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n248 |             return fieldValue == rule.value\n249 |         case .contains:\n250 |             return fieldValue.contains(rule.value)\n    |                                             `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n251 |         case .startsWith:\n252 |             return fieldValue.hasPrefix(rule.value)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:252:46: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n250 |             return fieldValue.contains(rule.value)\n251 |         case .startsWith:\n252 |             return fieldValue.hasPrefix(rule.value)\n    |                                              `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n253 |         case .endsWith:\n254 |             return fieldValue.hasSuffix(rule.value)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:254:46: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n252 |             return fieldValue.hasPrefix(rule.value)\n253 |         case .endsWith:\n254 |             return fieldValue.hasSuffix(rule.value)\n    |                                              `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n255 |         case .matches:\n256 |             if let regex = try? NSRegularExpression(pattern: rule.value) {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:256:67: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n254 |             return fieldValue.hasSuffix(rule.value)\n255 |         case .matches:\n256 |             if let regex = try? NSRegularExpression(pattern: rule.value) {\n    |                                                                   `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n257 |                 let range = NSRange(location: 0, length: fieldValue.utf16.count)\n258 |                 return regex.firstMatch(in: fieldValue, options: [], range: range) != nil\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:262:86: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n260 |             return false\n261 |         case .greaterThan:\n262 |             if let fieldNumeric = Double(fieldValue), let valueNumeric = Double(rule.value) {\n    |                                                                                      `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n263 |                 return fieldNumeric \u003e valueNumeric\n264 |             }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:267:86: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n265 |             return false\n266 |         case .lessThan:\n267 |             if let fieldNumeric = Double(fieldValue), let valueNumeric = Double(rule.value) {\n    |                                                                                      `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n268 |                 return fieldNumeric \u003c valueNumeric\n269 |             }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:293:13: warning: variable 'redactedMetadata' was never mutated; consider changing to 'let' constant\n291 |         // Create mutable copies\n292 |         var redactedMessage = entry.message\n293 |         var redactedMetadata = entry.metadata\n    |             `- warning: variable 'redactedMetadata' was never mutated; consider changing to 'let' constant\n294 |         \n295 |         for rule in rules {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:395:47: error: value of type 'String' has no member 'stringByReplacingMatches'\n393 |             if rule.targetFields.isEmpty || rule.targetFields.contains(\"message\") {\n394 |                 if let pattern = rule.pattern {\n395 |                     redactedMessage = pattern.stringByReplacingMatches(\n    |                                               `- error: value of type 'String' has no member 'stringByReplacingMatches'\n396 |                         in: redactedMessage,\n397 |                         options: [],\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:394:20: error: initializer for conditional binding must have Optional type, not 'String'\n392 |             // Apply rule to message if it matches\n393 |             if rule.targetFields.isEmpty || rule.targetFields.contains(\"message\") {\n394 |                 if let pattern = rule.pattern {\n    |                    `- error: initializer for conditional binding must have Optional type, not 'String'\n395 |                     redactedMessage = pattern.stringByReplacingMatches(\n396 |                         in: redactedMessage,\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:405:24: error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getKeys' of wrapped base type 'LogMetadataDTOCollection'\n403 |             \n404 |             // Process metadata fields\n405 |             for key in redactedMetadata.getKeys() {\n    |                        |- error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getKeys' of wrapped base type 'LogMetadataDTOCollection'\n    |                        |- note: chain the optional using '?' to access member 'getKeys' only for non-'nil' base values\n    |                        `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n406 |                 if rule.targetFields.isEmpty || rule.targetFields.contains(key) {\n407 |                     if let stringValue = redactedMetadata.getString(key: key) {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:407:42: error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getString' of wrapped base type 'LogMetadataDTOCollection'\n405 |             for key in redactedMetadata.getKeys() {\n406 |                 if rule.targetFields.isEmpty || rule.targetFields.contains(key) {\n407 |                     if let stringValue = redactedMetadata.getString(key: key) {\n    |                                          |- error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getString' of wrapped base type 'LogMetadataDTOCollection'\n    |                                          |- note: chain the optional using '?' to access member 'getString' only for non-'nil' base values\n    |                                          `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n408 |                         // Skip fields that should be preserved\n409 |                         if rule.preserveFields.contains(key) {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:468:15: error: type 'LogPrivacyLevel' has no member 'never'\n466 |         case .auto:\n467 |             return .auto\n468 |         case .never:\n    |               `- error: type 'LogPrivacyLevel' has no member 'never'\n469 |             return .public // Map 'never' to public classification\n470 |         case .protected:\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:470:15: error: type 'LogPrivacyLevel' has no member 'protected'\n468 |         case .never:\n469 |             return .public // Map 'never' to public classification\n470 |         case .protected:\n    |               `- error: type 'LogPrivacyLevel' has no member 'protected'\n471 |             return .private // Map 'protected' to private classification\n472 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:58:84: error: type 'LogPrivacyLevel' has no member 'protected'\n 56 |             additionalMetadata: [\n 57 |                 \"createBackup\": (value: String(options.createBackup), privacyLevel: .public),\n 58 |                 \"backupPath\": (value: options.backupPath ?? \"none\", privacyLevel: .protected),\n    |                                                                                    `- error: type 'LogPrivacyLevel' has no member 'protected'\n 59 |                 \"dryRun\": (value: String(options.dryRun), privacyLevel: .public),\n 60 |                 \"hasFilterCriteria\": (value: String(options.filterCriteria != nil), privacyLevel: .public),\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:184:34: error: cannot find 'getDestination' in scope\n182 |         if let destinationId = destinationId {\n183 |             // Use specific destination\n184 |             if let destination = getDestination(id: destinationId) {\n    |                                  `- error: cannot find 'getDestination' in scope\n185 |                 return [destination]\n186 |             } else {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:196:38: error: cannot find 'getDestination' in scope\n194 |             \n195 |             for id in options.destinationIds {\n196 |                 if let destination = getDestination(id: id) {\n    |                                      `- error: cannot find 'getDestination' in scope\n197 |                     result.append(destination)\n198 |                 } else {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:208:20: error: cannot find 'getAllDestinations' in scope\n206 |         } else {\n207 |             // Use all registered destinations\n208 |             return getAllDestinations()\n    |                    `- error: cannot find 'getAllDestinations' in scope\n209 |         }\n210 |     }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/QueryLogsCommand.swift:71:37: error: cannot find 'getDestination' in scope\n 69 |         do {\n 70 |             // Check if destination exists\n 71 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 72 |                 throw LoggingError.destinationNotFound(\n 73 |                     \"Cannot query logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RedactionRule.swift:123:72: error: missing argument for parameter 'privacyLevel' in call\n121 |                 if value != redactedValue {\n122 |                     // Only update if actually changed\n123 |                     result = result.with(key: key, value: redactedValue)\n    |                                                                        `- error: missing argument for parameter 'privacyLevel' in call\n124 |                 }\n125 |             }\n\n/Users/mpy/.bazel/execroot/_main/packages/UmbraCoreTypes/Sources/LoggingTypes/LogMetadataDTOCollection.swift:78:15: note: 'with(key:value:privacyLevel:)' declared here\n 76 |   ///   - privacyLevel: The privacy classification for this entry\n 77 |   /// - Returns: The updated collection\n 78 |   public func with(\n    |               `- note: 'with(key:value:privacyLevel:)' declared here\n 79 |     key: String,\n 80 |     value: String,\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RedactionRule.swift:101:26: warning: no calls to throwing functions occur within 'try' expression\n 99 |     public func redact(metadata: LogMetadataDTOCollection) -\u003e LogMetadataDTOCollection {\n100 |         // No redaction needed for empty metadata\n101 |         guard let keys = try? metadata.getKeys() else {\n    |                          `- warning: no calls to throwing functions occur within 'try' expression\n102 |             return metadata\n103 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RedactionRule.swift:119:28: warning: no calls to throwing functions occur within 'try' expression\n117 |             \n118 |             // Get string value and apply redaction\n119 |             if let value = try? metadata.getString(key: key) {\n    |                            `- warning: no calls to throwing functions occur within 'try' expression\n120 |                 let redactedValue = redact(value)\n121 |                 if value != redactedValue {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RemoveDestinationCommand.swift:67:37: error: cannot find 'getDestination' in scope\n 65 |         do {\n 66 |             // Check if destination exists\n 67 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 68 |                 throw LoggingError.destinationNotFound(\n 69 |                     \"Cannot remove destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RemoveDestinationCommand.swift:128:13: error: expression is 'async' but is not marked with 'await'\n126 |             \n127 |             // Unregister the destination\n128 |             unregisterDestination(id: destinationId)\n    |             |- error: expression is 'async' but is not marked with 'await'\n    |             `- note: calls to instance method 'unregisterDestination(id:)' from outside of its actor context are implicitly asynchronous\n129 |             \n130 |             // Log success\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RotateLogsCommand.swift:67:37: error: cannot find 'getDestination' in scope\n 65 |         do {\n 66 |             // Check if destination exists\n 67 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 68 |                 throw LoggingError.destinationNotFound(\n 69 |                     \"Cannot rotate logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RotateLogsCommand.swift:74:37: error: cannot infer contextual base in reference to member 'file'\n 72 |             \n 73 |             // Check if the destination type supports rotation\n 74 |             if destination.type != .file {\n    |                                     `- error: cannot infer contextual base in reference to member 'file'\n 75 |                 throw LoggingError.invalidDestinationConfig(\n 76 |                     \"Log rotation is only supported for file destinations\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RotateLogsCommand.swift:92:112: error: type 'LogPrivacyLevel' has no member 'protected'\n 90 |                     context: operationContext,\n 91 |                     additionalMetadata: [\n 92 |                         \"rotatedFilePath\": (value: rotationResult.rotatedFilePath ?? \"unknown\", privacyLevel: .protected),\n    |                                                                                                                `- error: type 'LogPrivacyLevel' has no member 'protected'\n 93 |                         \"rotatedSizeBytes\": (value: String(rotationResult.rotatedSizeBytes ?? 0), privacyLevel: .public),\n 94 |                         \"rotatedEntryCount\": (value: String(rotationResult.rotatedEntryCount ?? 0), privacyLevel: .public)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/WriteLogCommand.swift:159:20: error: cannot find 'getAllDestinations' in scope\n157 |         if destinationIds.isEmpty {\n158 |             // Use all registered destinations\n159 |             return getAllDestinations().filter { $0.isEnabled }\n    |                    `- error: cannot find 'getAllDestinations' in scope\n160 |         } else {\n161 |             // Use specific destinations\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/WriteLogCommand.swift:165:38: error: cannot find 'getDestination' in scope\n163 |             \n164 |             for destinationId in destinationIds {\n165 |                 if let destination = getDestination(id: destinationId) {\n    |                                      `- error: cannot find 'getDestination' in scope\n166 |                     if destination.isEnabled {\n167 |                         result.append(destination)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/WriteLogCommand.swift:193:16: error: cannot find 'applyFilterRules' in scope\n191 |         \n192 |         // Apply filter rules if they exist\n193 |         return applyFilterRules(\n    |                `- error: cannot find 'applyFilterRules' in scope\n194 |             to: entry,\n195 |             rules: destination.configuration.filterRules\n\npackages/UmbraImplementations/Sources/LoggingServices/DefaultLoggingServiceImpl.swift:39:36: warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 37 |     let contextDTO=BaseLogContextDTO(\n 38 |       domainName: \"Legacy\",\n 39 |       operation: context.operation ?? \"unknown\",\n    |                                    `- warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 40 |       category: context.category ?? \"General\",\n 41 |       source: context.source ?? \"Unknown\",\n\npackages/UmbraImplementations/Sources/LoggingServices/DefaultLoggingServiceImpl.swift:40:34: warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 38 |       domainName: \"Legacy\",\n 39 |       operation: context.operation ?? \"unknown\",\n 40 |       category: context.category ?? \"General\",\n    |                                  `- warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 41 |       source: context.source ?? \"Unknown\",\n 42 |       metadata: context.metadata\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:147:17: error: invalid redeclaration of 'log(_:_:context:)'\n145 |         - context: The logging context\n146 |      */\n147 |     public func log(_ level: LogLevel, _ message: String, context: any LogContextDTO) async {\n    |                 `- error: invalid redeclaration of 'log(_:_:context:)'\n148 |         // Convert to privacy string and use privacy-aware logging\n149 |         let privacyString = PrivacyString(stringLiteral: message)\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:92:48: error: value of type 'any LoggingProviderProtocol' has no member 'writeLogEntry'\n 90 |                     do {\n 91 |                         // Write log entry to destination\n 92 |                         _ = try await provider.writeLogEntry(entry, to: destination)\n    |                                                `- error: value of type 'any LoggingProviderProtocol' has no member 'writeLogEntry'\n 93 |                     } catch {\n 94 |                         // Silently ignore provider errors for now\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:122:28: error: value of type 'PrivacyString' has no member 'privacy'\n120 |         enrichedMetadata = enrichedMetadata.withPrivate(\n121 |             key: \"__privacy_annotation\", \n122 |             value: message.privacy.description\n    |                            `- error: value of type 'PrivacyString' has no member 'privacy'\n123 |         )\n124 |         \n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:136:34: error: value of type 'PrivacyString' has no member 'content'\n134 |         \n135 |         // Log the message using the standard log method\n136 |         await log(level, message.content, context: privacyContext)\n    |                                  `- error: value of type 'PrivacyString' has no member 'content'\n137 |     }\n138 |     \n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:167:71: error: value of type 'PrivacyAnnotatedString' has no member 'stringValue'\n165 |     ) async {\n166 |         let annotatedString = privacyScope()\n167 |         await log(level, PrivacyString(stringLiteral: annotatedString.stringValue), context: context) \n    |                                                                       `- error: value of type 'PrivacyAnnotatedString' has no member 'stringValue'\n168 |     }\n169 |     \n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:190:29: error: for-in loop requires 'LogMetadata' to conform to 'Sequence'\n188 |         // Create a metadata collection with sensitive values\n189 |         var metadataCollection = context.metadata\n190 |         for (key, value) in sensitiveValues {\n    |                             `- error: for-in loop requires 'LogMetadata' to conform to 'Sequence'\n191 |             metadataCollection = metadataCollection.withSensitive(key: key, value: String(describing: value))\n192 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:228:9: error: switch must be exhaustive\n226 |         \n227 |         // Add error information to metadata with appropriate privacy level\n228 |         switch privacyLevel {\n    |         |- error: switch must be exhaustive\n    |         `- note: add missing case: '.auto'\n229 |         case .public:\n230 |             metadataCollection = metadataCollection.withPublic(key: \"error_description\", value: error.localizedDescription)\npackages/UmbraImplementations/Sources/LoggingServices/PrivacyAwareLogDTO.swift:217:24: error: value of type 'LogMetadataDTOCollection' has no member 'set'\n215 |     for key in self.metadata.getKeys() {\n216 |       if let value = self.metadata.getString(key: key) {\n217 |         mergedMetadata.set(key: key, value: value)\n    |                        `- error: value of type 'LogMetadataDTOCollection' has no member 'set'\n218 |       }\n219 |     }\n\npackages/UmbraImplementations/Sources/LoggingServices/PrivacyAwareLogDTO.swift:224:24: error: value of type 'LogMetadataDTOCollection' has no member 'set'\n222 |     for key in additionalMetadata.getKeys() {\n223 |       if let value = additionalMetadata.getString(key: key) {\n224 |         mergedMetadata.set(key: key, value: value)\n    |                        `- error: value of type 'LogMetadataDTOCollection' has no member 'set'\n225 |       }\n226 |     }\n\npackages/UmbraImplementations/Sources/LoggingServices/PrivacyAwareLogDTO.swift:235:17: error: cannot convert value of type 'LogMetadataDTOCollection' to expected argument type '[String : (value: Any, privacy: LogPrivacyLevel)]'\n233 |       category: category,\n234 |       correlationID: correlationID,\n235 |       metadata: mergedMetadata,\n    |                 `- error: cannot convert value of type 'LogMetadataDTOCollection' to expected argument type '[String : (value: Any, privacy: LogPrivacyLevel)]'\n236 |       environment: environment\n237 |     )\nTarget //packages/UmbraImplementations/Sources/BackupServices:BackupServices failed to build\nINFO: Elapsed time: 1.142s, Critical Path: 1.02s\nINFO: 3 processes: 3 internal.\nERROR: Build did NOT complete successfully\n"
  },
  {
    "target": "rule //packages/UmbraImplementations/Sources/BookmarkServices:BookmarkServices",
    "success": false,
    "start_time": "2025-04-11T17:57:44.980848+01:00",
    "end_time": "2025-04-11T17:57:47.007395+01:00",
    "duration": "2.026548917s",
    "output": "INFO: Invocation ID: 232ed64d-2a68-4bbf-a065-34a7c17afecf\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraImplementations/Sources/BookmarkServices:BookmarkServices (1 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraImplementations/Sources/BookmarkServices:BookmarkServices (1 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraImplementations/Sources/BookmarkServices:BookmarkServices (4 packages loaded, 34 targets configured).\nERROR: /Users/mpy/CascadeProjects/UmbraCore/packages/UmbraImplementations/Sources/LoggingServices/BUILD.bazel:3:20: Compiling Swift module //packages/UmbraImplementations/Sources/LoggingServices:LoggingServices failed: (Exit 1): worker failed: error executing SwiftCompile command (from target //packages/UmbraImplementations/Sources/LoggingServices:LoggingServices) \n  (cd /Users/mpy/.bazel/execroot/_main \u0026\u0026 \\\n  exec env - \\\n    APPLE_SDK_PLATFORM=MacOSX \\\n    APPLE_SDK_VERSION_OVERRIDE=15.4 \\\n    CC=clang \\\n    PATH=/Users/mpy/Library/Caches/bazelisk/downloads/sha256/ac72ad67f7a8c6b18bf605d8602425182b417de4369715bf89146daf62f7ae48/bin:/Users/mpy/.rbenv/bin:/Users/mpy/.codeium/windsurf/bin:/opt/homebrew/opt/node@18/bin:/opt/homebrew/opt/node@20/bin:/Users/mpy/.docker/bin:/opt/homebrew/opt/openjdk/bin:/Users/mpy/bin:/opt/homebrew/bin:/opt/homebrew/sbin:/usr/local/bin:/System/Cryptexes/App/usr/bin:/usr/bin:/bin:/usr/sbin:/sbin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/local/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/appleinternal/bin:/Library/Apple/usr/bin:/usr/local/go/bin:/Users/mpy/.rbenv/bin:/Users/mpy/.codeium/windsurf/bin:/opt/homebrew/opt/node@18/bin:/opt/homebrew/opt/node@20/bin:/opt/anaconda3/bin:/opt/anaconda3/condabin:/Users/mpy/.docker/bin:/opt/homebrew/opt/openjdk/bin:/Users/mpy/bin:/Users/mpy/.cargo/bin:/Users/mpy/Library/Python/3.8/bin:/Users/mpy/go/bin:/Users/mpy/.scripts:/Users/mpy/.fzf/bin:/Users/mpy/.windsurf/extensions/ms-python.debugpy-2025.6.0-darwin-arm64/bundled/scripts/noConfigScripts:/Users/mpy/Library/Python/3.8/bin:/Users/mpy/go/bin:/Users/mpy/.scripts \\\n    XCODE_VERSION_OVERRIDE=16.3.0.16E140 \\\n  bazel-out/darwin_arm64-opt-exec-ST-d57f47055a04/bin/external/rules_swift+/tools/worker/worker swiftc @bazel-out/darwin_arm64-fastbuild/bin/packages/UmbraImplementations/Sources/LoggingServices/LoggingServices.swiftmodule-0.params)\n# Configuration: 76a1bf3a80f2d50513004915454165d2f164db794b63e4666809cbd93e1abeaa\n# Execution platform: @@platforms//host:host\nerror: emit-module command failed with exit code 1 (use -v to see invocation)\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:147:17: error: invalid redeclaration of 'log(_:_:context:)'\n145 |         - context: The logging context\n146 |      */\n147 |     public func log(_ level: LogLevel, _ message: String, context: any LogContextDTO) async {\n    |                 `- error: invalid redeclaration of 'log(_:_:context:)'\n148 |         // Convert to privacy string and use privacy-aware logging\n149 |         let privacyString = PrivacyString(stringLiteral: message)\npackages/UmbraImplementations/Sources/LoggingServices/Commands/AddDestinationCommand.swift:68:31: error: cannot find 'getDestination' in scope\n 66 |         do {\n 67 |             // Check if destination already exists\n 68 |             if let existing = getDestination(id: destination.id) {\n    |                               `- error: cannot find 'getDestination' in scope\n 69 |                 if !options.overwriteExisting {\n 70 |                     throw LoggingError.destinationAlreadyExists(identifier: \"Destination with ID \\(destination.id) already exists\")\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/AddDestinationCommand.swift:82:40: error: cannot find 'validateDestination' in scope\n 80 |             // Validate destination configuration if requested\n 81 |             if options.validateConfiguration {\n 82 |                 let validationResult = validateDestination(destination, for: provider)\n    |                                        `- error: cannot find 'validateDestination' in scope\n 83 |                 \n 84 |                 if !validationResult.isValid {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/AddDestinationCommand.swift:121:13: error: expression is 'async' but is not marked with 'await'\n119 |             \n120 |             // Register the destination\n121 |             registerDestination(destination)\n    |             |- error: expression is 'async' but is not marked with 'await'\n    |             `- note: calls to instance method 'registerDestination' from outside of its actor context are implicitly asynchronous\n122 |             \n123 |             // Log success\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ArchiveLogsCommand.swift:57:84: error: type 'LogPrivacyLevel' has no member 'protected'\n 55 |             destinationId: destinationId,\n 56 |             additionalMetadata: [\n 57 |                 \"destinationPath\": (value: options.destinationPath, privacyLevel: .protected),\n    |                                                                                    `- error: type 'LogPrivacyLevel' has no member 'protected'\n 58 |                 \"compress\": (value: String(options.compress), privacyLevel: .public),\n 59 |                 \"format\": (value: options.format.rawValue, privacyLevel: .public),\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ArchiveLogsCommand.swift:70:37: error: cannot find 'getDestination' in scope\n 68 |         do {\n 69 |             // Check if destination exists\n 70 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 71 |                 throw LoggingError.destinationNotFound(\n 72 |                     \"Cannot archive logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ArchiveLogsCommand.swift:113:103: error: type 'LogPrivacyLevel' has no member 'protected'\n111 |                     context: operationContext,\n112 |                     additionalMetadata: [\n113 |                         \"archivePath\": (value: archiveResult.archivePath ?? \"unknown\", privacyLevel: .protected),\n    |                                                                                                       `- error: type 'LogPrivacyLevel' has no member 'protected'\n114 |                         \"archiveSizeBytes\": (value: String(archiveResult.archiveSizeBytes ?? 0), privacyLevel: .public),\n115 |                         \"archivedEntryCount\": (value: String(archiveResult.archivedEntryCount ?? 0), privacyLevel: .public)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ExportLogsCommand.swift:70:37: error: cannot find 'getDestination' in scope\n 68 |         do {\n 69 |             // Check if destination exists\n 70 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 71 |                 throw LoggingError.destinationNotFound(\n 72 |                     \"Cannot export logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:79:50: error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n 77 |                 key: key,\n 78 |                 value: value.value,\n 79 |                 privacyLevel: value.privacyLevel.toPrivacyClassification()\n    |                                                  `- error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n 80 |             )\n 81 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:122:54: error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n120 |                     key: key,\n121 |                     value: value.value,\n122 |                     privacyLevel: value.privacyLevel.toPrivacyClassification()\n    |                                                      `- error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n123 |                 )\n124 |             )\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:229:21: error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n227 |         \n228 |         // Process special fields first\n229 |         switch rule.field {\n    |                     `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n230 |         case \"level\":\n231 |             fieldValue = entry.level.rawValue\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:238:96: error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n236 |         default:\n237 |             // Check metadata fields\n238 |             if let metadata = entry.metadata, let metadataValue = metadata.getString(key: rule.field) {\n    |                                                                                                `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n239 |                 fieldValue = metadataValue\n240 |             } else {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:246:21: error: value of type 'UmbraLogFilterRuleDTO' has no member 'operation'\n244 |         \n245 |         // Apply the operation\n246 |         switch rule.operation {\n    |                     `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'operation'\n247 |         case .equals:\n248 |             return fieldValue == rule.value\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:248:39: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n246 |         switch rule.operation {\n247 |         case .equals:\n248 |             return fieldValue == rule.value\n    |                                       `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n249 |         case .contains:\n250 |             return fieldValue.contains(rule.value)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:250:45: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n248 |             return fieldValue == rule.value\n249 |         case .contains:\n250 |             return fieldValue.contains(rule.value)\n    |                                             `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n251 |         case .startsWith:\n252 |             return fieldValue.hasPrefix(rule.value)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:252:46: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n250 |             return fieldValue.contains(rule.value)\n251 |         case .startsWith:\n252 |             return fieldValue.hasPrefix(rule.value)\n    |                                              `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n253 |         case .endsWith:\n254 |             return fieldValue.hasSuffix(rule.value)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:254:46: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n252 |             return fieldValue.hasPrefix(rule.value)\n253 |         case .endsWith:\n254 |             return fieldValue.hasSuffix(rule.value)\n    |                                              `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n255 |         case .matches:\n256 |             if let regex = try? NSRegularExpression(pattern: rule.value) {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:256:67: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n254 |             return fieldValue.hasSuffix(rule.value)\n255 |         case .matches:\n256 |             if let regex = try? NSRegularExpression(pattern: rule.value) {\n    |                                                                   `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n257 |                 let range = NSRange(location: 0, length: fieldValue.utf16.count)\n258 |                 return regex.firstMatch(in: fieldValue, options: [], range: range) != nil\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:262:86: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n260 |             return false\n261 |         case .greaterThan:\n262 |             if let fieldNumeric = Double(fieldValue), let valueNumeric = Double(rule.value) {\n    |                                                                                      `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n263 |                 return fieldNumeric \u003e valueNumeric\n264 |             }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:267:86: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n265 |             return false\n266 |         case .lessThan:\n267 |             if let fieldNumeric = Double(fieldValue), let valueNumeric = Double(rule.value) {\n    |                                                                                      `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n268 |                 return fieldNumeric \u003c valueNumeric\n269 |             }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:293:13: warning: variable 'redactedMetadata' was never mutated; consider changing to 'let' constant\n291 |         // Create mutable copies\n292 |         var redactedMessage = entry.message\n293 |         var redactedMetadata = entry.metadata\n    |             `- warning: variable 'redactedMetadata' was never mutated; consider changing to 'let' constant\n294 |         \n295 |         for rule in rules {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:395:47: error: value of type 'String' has no member 'stringByReplacingMatches'\n393 |             if rule.targetFields.isEmpty || rule.targetFields.contains(\"message\") {\n394 |                 if let pattern = rule.pattern {\n395 |                     redactedMessage = pattern.stringByReplacingMatches(\n    |                                               `- error: value of type 'String' has no member 'stringByReplacingMatches'\n396 |                         in: redactedMessage,\n397 |                         options: [],\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:394:20: error: initializer for conditional binding must have Optional type, not 'String'\n392 |             // Apply rule to message if it matches\n393 |             if rule.targetFields.isEmpty || rule.targetFields.contains(\"message\") {\n394 |                 if let pattern = rule.pattern {\n    |                    `- error: initializer for conditional binding must have Optional type, not 'String'\n395 |                     redactedMessage = pattern.stringByReplacingMatches(\n396 |                         in: redactedMessage,\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:405:24: error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getKeys' of wrapped base type 'LogMetadataDTOCollection'\n403 |             \n404 |             // Process metadata fields\n405 |             for key in redactedMetadata.getKeys() {\n    |                        |- error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getKeys' of wrapped base type 'LogMetadataDTOCollection'\n    |                        |- note: chain the optional using '?' to access member 'getKeys' only for non-'nil' base values\n    |                        `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n406 |                 if rule.targetFields.isEmpty || rule.targetFields.contains(key) {\n407 |                     if let stringValue = redactedMetadata.getString(key: key) {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:407:42: error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getString' of wrapped base type 'LogMetadataDTOCollection'\n405 |             for key in redactedMetadata.getKeys() {\n406 |                 if rule.targetFields.isEmpty || rule.targetFields.contains(key) {\n407 |                     if let stringValue = redactedMetadata.getString(key: key) {\n    |                                          |- error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getString' of wrapped base type 'LogMetadataDTOCollection'\n    |                                          |- note: chain the optional using '?' to access member 'getString' only for non-'nil' base values\n    |                                          `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n408 |                         // Skip fields that should be preserved\n409 |                         if rule.preserveFields.contains(key) {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:468:15: error: type 'LogPrivacyLevel' has no member 'never'\n466 |         case .auto:\n467 |             return .auto\n468 |         case .never:\n    |               `- error: type 'LogPrivacyLevel' has no member 'never'\n469 |             return .public // Map 'never' to public classification\n470 |         case .protected:\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:470:15: error: type 'LogPrivacyLevel' has no member 'protected'\n468 |         case .never:\n469 |             return .public // Map 'never' to public classification\n470 |         case .protected:\n    |               `- error: type 'LogPrivacyLevel' has no member 'protected'\n471 |             return .private // Map 'protected' to private classification\n472 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:58:84: error: type 'LogPrivacyLevel' has no member 'protected'\n 56 |             additionalMetadata: [\n 57 |                 \"createBackup\": (value: String(options.createBackup), privacyLevel: .public),\n 58 |                 \"backupPath\": (value: options.backupPath ?? \"none\", privacyLevel: .protected),\n    |                                                                                    `- error: type 'LogPrivacyLevel' has no member 'protected'\n 59 |                 \"dryRun\": (value: String(options.dryRun), privacyLevel: .public),\n 60 |                 \"hasFilterCriteria\": (value: String(options.filterCriteria != nil), privacyLevel: .public),\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:184:34: error: cannot find 'getDestination' in scope\n182 |         if let destinationId = destinationId {\n183 |             // Use specific destination\n184 |             if let destination = getDestination(id: destinationId) {\n    |                                  `- error: cannot find 'getDestination' in scope\n185 |                 return [destination]\n186 |             } else {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:196:38: error: cannot find 'getDestination' in scope\n194 |             \n195 |             for id in options.destinationIds {\n196 |                 if let destination = getDestination(id: id) {\n    |                                      `- error: cannot find 'getDestination' in scope\n197 |                     result.append(destination)\n198 |                 } else {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:208:20: error: cannot find 'getAllDestinations' in scope\n206 |         } else {\n207 |             // Use all registered destinations\n208 |             return getAllDestinations()\n    |                    `- error: cannot find 'getAllDestinations' in scope\n209 |         }\n210 |     }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/QueryLogsCommand.swift:71:37: error: cannot find 'getDestination' in scope\n 69 |         do {\n 70 |             // Check if destination exists\n 71 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 72 |                 throw LoggingError.destinationNotFound(\n 73 |                     \"Cannot query logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RedactionRule.swift:123:72: error: missing argument for parameter 'privacyLevel' in call\n121 |                 if value != redactedValue {\n122 |                     // Only update if actually changed\n123 |                     result = result.with(key: key, value: redactedValue)\n    |                                                                        `- error: missing argument for parameter 'privacyLevel' in call\n124 |                 }\n125 |             }\n\n/Users/mpy/.bazel/execroot/_main/packages/UmbraCoreTypes/Sources/LoggingTypes/LogMetadataDTOCollection.swift:78:15: note: 'with(key:value:privacyLevel:)' declared here\n 76 |   ///   - privacyLevel: The privacy classification for this entry\n 77 |   /// - Returns: The updated collection\n 78 |   public func with(\n    |               `- note: 'with(key:value:privacyLevel:)' declared here\n 79 |     key: String,\n 80 |     value: String,\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RedactionRule.swift:101:26: warning: no calls to throwing functions occur within 'try' expression\n 99 |     public func redact(metadata: LogMetadataDTOCollection) -\u003e LogMetadataDTOCollection {\n100 |         // No redaction needed for empty metadata\n101 |         guard let keys = try? metadata.getKeys() else {\n    |                          `- warning: no calls to throwing functions occur within 'try' expression\n102 |             return metadata\n103 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RedactionRule.swift:119:28: warning: no calls to throwing functions occur within 'try' expression\n117 |             \n118 |             // Get string value and apply redaction\n119 |             if let value = try? metadata.getString(key: key) {\n    |                            `- warning: no calls to throwing functions occur within 'try' expression\n120 |                 let redactedValue = redact(value)\n121 |                 if value != redactedValue {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RemoveDestinationCommand.swift:67:37: error: cannot find 'getDestination' in scope\n 65 |         do {\n 66 |             // Check if destination exists\n 67 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 68 |                 throw LoggingError.destinationNotFound(\n 69 |                     \"Cannot remove destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RemoveDestinationCommand.swift:128:13: error: expression is 'async' but is not marked with 'await'\n126 |             \n127 |             // Unregister the destination\n128 |             unregisterDestination(id: destinationId)\n    |             |- error: expression is 'async' but is not marked with 'await'\n    |             `- note: calls to instance method 'unregisterDestination(id:)' from outside of its actor context are implicitly asynchronous\n129 |             \n130 |             // Log success\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RotateLogsCommand.swift:67:37: error: cannot find 'getDestination' in scope\n 65 |         do {\n 66 |             // Check if destination exists\n 67 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 68 |                 throw LoggingError.destinationNotFound(\n 69 |                     \"Cannot rotate logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RotateLogsCommand.swift:74:37: error: cannot infer contextual base in reference to member 'file'\n 72 |             \n 73 |             // Check if the destination type supports rotation\n 74 |             if destination.type != .file {\n    |                                     `- error: cannot infer contextual base in reference to member 'file'\n 75 |                 throw LoggingError.invalidDestinationConfig(\n 76 |                     \"Log rotation is only supported for file destinations\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RotateLogsCommand.swift:92:112: error: type 'LogPrivacyLevel' has no member 'protected'\n 90 |                     context: operationContext,\n 91 |                     additionalMetadata: [\n 92 |                         \"rotatedFilePath\": (value: rotationResult.rotatedFilePath ?? \"unknown\", privacyLevel: .protected),\n    |                                                                                                                `- error: type 'LogPrivacyLevel' has no member 'protected'\n 93 |                         \"rotatedSizeBytes\": (value: String(rotationResult.rotatedSizeBytes ?? 0), privacyLevel: .public),\n 94 |                         \"rotatedEntryCount\": (value: String(rotationResult.rotatedEntryCount ?? 0), privacyLevel: .public)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/WriteLogCommand.swift:159:20: error: cannot find 'getAllDestinations' in scope\n157 |         if destinationIds.isEmpty {\n158 |             // Use all registered destinations\n159 |             return getAllDestinations().filter { $0.isEnabled }\n    |                    `- error: cannot find 'getAllDestinations' in scope\n160 |         } else {\n161 |             // Use specific destinations\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/WriteLogCommand.swift:165:38: error: cannot find 'getDestination' in scope\n163 |             \n164 |             for destinationId in destinationIds {\n165 |                 if let destination = getDestination(id: destinationId) {\n    |                                      `- error: cannot find 'getDestination' in scope\n166 |                     if destination.isEnabled {\n167 |                         result.append(destination)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/WriteLogCommand.swift:193:16: error: cannot find 'applyFilterRules' in scope\n191 |         \n192 |         // Apply filter rules if they exist\n193 |         return applyFilterRules(\n    |                `- error: cannot find 'applyFilterRules' in scope\n194 |             to: entry,\n195 |             rules: destination.configuration.filterRules\n\npackages/UmbraImplementations/Sources/LoggingServices/DefaultLoggingServiceImpl.swift:39:36: warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 37 |     let contextDTO=BaseLogContextDTO(\n 38 |       domainName: \"Legacy\",\n 39 |       operation: context.operation ?? \"unknown\",\n    |                                    `- warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 40 |       category: context.category ?? \"General\",\n 41 |       source: context.source ?? \"Unknown\",\n\npackages/UmbraImplementations/Sources/LoggingServices/DefaultLoggingServiceImpl.swift:40:34: warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 38 |       domainName: \"Legacy\",\n 39 |       operation: context.operation ?? \"unknown\",\n 40 |       category: context.category ?? \"General\",\n    |                                  `- warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 41 |       source: context.source ?? \"Unknown\",\n 42 |       metadata: context.metadata\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:147:17: error: invalid redeclaration of 'log(_:_:context:)'\n145 |         - context: The logging context\n146 |      */\n147 |     public func log(_ level: LogLevel, _ message: String, context: any LogContextDTO) async {\n    |                 `- error: invalid redeclaration of 'log(_:_:context:)'\n148 |         // Convert to privacy string and use privacy-aware logging\n149 |         let privacyString = PrivacyString(stringLiteral: message)\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:92:48: error: value of type 'any LoggingProviderProtocol' has no member 'writeLogEntry'\n 90 |                     do {\n 91 |                         // Write log entry to destination\n 92 |                         _ = try await provider.writeLogEntry(entry, to: destination)\n    |                                                `- error: value of type 'any LoggingProviderProtocol' has no member 'writeLogEntry'\n 93 |                     } catch {\n 94 |                         // Silently ignore provider errors for now\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:122:28: error: value of type 'PrivacyString' has no member 'privacy'\n120 |         enrichedMetadata = enrichedMetadata.withPrivate(\n121 |             key: \"__privacy_annotation\", \n122 |             value: message.privacy.description\n    |                            `- error: value of type 'PrivacyString' has no member 'privacy'\n123 |         )\n124 |         \n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:136:34: error: value of type 'PrivacyString' has no member 'content'\n134 |         \n135 |         // Log the message using the standard log method\n136 |         await log(level, message.content, context: privacyContext)\n    |                                  `- error: value of type 'PrivacyString' has no member 'content'\n137 |     }\n138 |     \n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:167:71: error: value of type 'PrivacyAnnotatedString' has no member 'stringValue'\n165 |     ) async {\n166 |         let annotatedString = privacyScope()\n167 |         await log(level, PrivacyString(stringLiteral: annotatedString.stringValue), context: context) \n    |                                                                       `- error: value of type 'PrivacyAnnotatedString' has no member 'stringValue'\n168 |     }\n169 |     \n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:190:29: error: for-in loop requires 'LogMetadata' to conform to 'Sequence'\n188 |         // Create a metadata collection with sensitive values\n189 |         var metadataCollection = context.metadata\n190 |         for (key, value) in sensitiveValues {\n    |                             `- error: for-in loop requires 'LogMetadata' to conform to 'Sequence'\n191 |             metadataCollection = metadataCollection.withSensitive(key: key, value: String(describing: value))\n192 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:228:9: error: switch must be exhaustive\n226 |         \n227 |         // Add error information to metadata with appropriate privacy level\n228 |         switch privacyLevel {\n    |         |- error: switch must be exhaustive\n    |         `- note: add missing case: '.auto'\n229 |         case .public:\n230 |             metadataCollection = metadataCollection.withPublic(key: \"error_description\", value: error.localizedDescription)\npackages/UmbraImplementations/Sources/LoggingServices/PrivacyAwareLogDTO.swift:217:24: error: value of type 'LogMetadataDTOCollection' has no member 'set'\n215 |     for key in self.metadata.getKeys() {\n216 |       if let value = self.metadata.getString(key: key) {\n217 |         mergedMetadata.set(key: key, value: value)\n    |                        `- error: value of type 'LogMetadataDTOCollection' has no member 'set'\n218 |       }\n219 |     }\n\npackages/UmbraImplementations/Sources/LoggingServices/PrivacyAwareLogDTO.swift:224:24: error: value of type 'LogMetadataDTOCollection' has no member 'set'\n222 |     for key in additionalMetadata.getKeys() {\n223 |       if let value = additionalMetadata.getString(key: key) {\n224 |         mergedMetadata.set(key: key, value: value)\n    |                        `- error: value of type 'LogMetadataDTOCollection' has no member 'set'\n225 |       }\n226 |     }\n\npackages/UmbraImplementations/Sources/LoggingServices/PrivacyAwareLogDTO.swift:235:17: error: cannot convert value of type 'LogMetadataDTOCollection' to expected argument type '[String : (value: Any, privacy: LogPrivacyLevel)]'\n233 |       category: category,\n234 |       correlationID: correlationID,\n235 |       metadata: mergedMetadata,\n    |                 `- error: cannot convert value of type 'LogMetadataDTOCollection' to expected argument type '[String : (value: Any, privacy: LogPrivacyLevel)]'\n236 |       environment: environment\n237 |     )\nTarget //packages/UmbraImplementations/Sources/BookmarkServices:BookmarkServices failed to build\nINFO: Elapsed time: 1.157s, Critical Path: 1.02s\nINFO: 4 processes: 4 action cache hit, 3 internal, 1 worker.\nERROR: Build did NOT complete successfully\n"
  },
  {
    "target": "rule //packages/UmbraImplementations/Sources/BookmarkServices/Logging:BookmarkLogger",
    "success": false,
    "start_time": "2025-04-11T17:57:47.007404+01:00",
    "end_time": "2025-04-11T17:57:48.818912+01:00",
    "duration": "1.811509917s",
    "output": "INFO: Invocation ID: 2e8843f4-89d3-4ec3-8ee4-773a93e72d9c\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraImplementations/Sources/BookmarkServices/Logging:BookmarkLogger (0 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraImplementations/Sources/BookmarkServices/Logging:BookmarkLogger (0 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraImplementations/Sources/BookmarkServices/Logging:BookmarkLogger (0 packages loaded, 0 targets configured).\nERROR: /Users/mpy/CascadeProjects/UmbraCore/packages/UmbraImplementations/Sources/LoggingServices/BUILD.bazel:3:20: Compiling Swift module //packages/UmbraImplementations/Sources/LoggingServices:LoggingServices failed: (Exit 1): worker failed: error executing SwiftCompile command (from target //packages/UmbraImplementations/Sources/LoggingServices:LoggingServices) \n  (cd /Users/mpy/.bazel/execroot/_main \u0026\u0026 \\\n  exec env - \\\n    APPLE_SDK_PLATFORM=MacOSX \\\n    APPLE_SDK_VERSION_OVERRIDE=15.4 \\\n    CC=clang \\\n    PATH=/Users/mpy/Library/Caches/bazelisk/downloads/sha256/ac72ad67f7a8c6b18bf605d8602425182b417de4369715bf89146daf62f7ae48/bin:/Users/mpy/.rbenv/bin:/Users/mpy/.codeium/windsurf/bin:/opt/homebrew/opt/node@18/bin:/opt/homebrew/opt/node@20/bin:/Users/mpy/.docker/bin:/opt/homebrew/opt/openjdk/bin:/Users/mpy/bin:/opt/homebrew/bin:/opt/homebrew/sbin:/usr/local/bin:/System/Cryptexes/App/usr/bin:/usr/bin:/bin:/usr/sbin:/sbin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/local/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/appleinternal/bin:/Library/Apple/usr/bin:/usr/local/go/bin:/Users/mpy/.rbenv/bin:/Users/mpy/.codeium/windsurf/bin:/opt/homebrew/opt/node@18/bin:/opt/homebrew/opt/node@20/bin:/opt/anaconda3/bin:/opt/anaconda3/condabin:/Users/mpy/.docker/bin:/opt/homebrew/opt/openjdk/bin:/Users/mpy/bin:/Users/mpy/.cargo/bin:/Users/mpy/Library/Python/3.8/bin:/Users/mpy/go/bin:/Users/mpy/.scripts:/Users/mpy/.fzf/bin:/Users/mpy/.windsurf/extensions/ms-python.debugpy-2025.6.0-darwin-arm64/bundled/scripts/noConfigScripts:/Users/mpy/Library/Python/3.8/bin:/Users/mpy/go/bin:/Users/mpy/.scripts \\\n    XCODE_VERSION_OVERRIDE=16.3.0.16E140 \\\n  bazel-out/darwin_arm64-opt-exec-ST-d57f47055a04/bin/external/rules_swift+/tools/worker/worker swiftc @bazel-out/darwin_arm64-fastbuild/bin/packages/UmbraImplementations/Sources/LoggingServices/LoggingServices.swiftmodule-0.params)\n# Configuration: 76a1bf3a80f2d50513004915454165d2f164db794b63e4666809cbd93e1abeaa\n# Execution platform: @@platforms//host:host\nerror: emit-module command failed with exit code 1 (use -v to see invocation)\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:147:17: error: invalid redeclaration of 'log(_:_:context:)'\n145 |         - context: The logging context\n146 |      */\n147 |     public func log(_ level: LogLevel, _ message: String, context: any LogContextDTO) async {\n    |                 `- error: invalid redeclaration of 'log(_:_:context:)'\n148 |         // Convert to privacy string and use privacy-aware logging\n149 |         let privacyString = PrivacyString(stringLiteral: message)\npackages/UmbraImplementations/Sources/LoggingServices/Commands/AddDestinationCommand.swift:68:31: error: cannot find 'getDestination' in scope\n 66 |         do {\n 67 |             // Check if destination already exists\n 68 |             if let existing = getDestination(id: destination.id) {\n    |                               `- error: cannot find 'getDestination' in scope\n 69 |                 if !options.overwriteExisting {\n 70 |                     throw LoggingError.destinationAlreadyExists(identifier: \"Destination with ID \\(destination.id) already exists\")\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/AddDestinationCommand.swift:82:40: error: cannot find 'validateDestination' in scope\n 80 |             // Validate destination configuration if requested\n 81 |             if options.validateConfiguration {\n 82 |                 let validationResult = validateDestination(destination, for: provider)\n    |                                        `- error: cannot find 'validateDestination' in scope\n 83 |                 \n 84 |                 if !validationResult.isValid {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/AddDestinationCommand.swift:121:13: error: expression is 'async' but is not marked with 'await'\n119 |             \n120 |             // Register the destination\n121 |             registerDestination(destination)\n    |             |- error: expression is 'async' but is not marked with 'await'\n    |             `- note: calls to instance method 'registerDestination' from outside of its actor context are implicitly asynchronous\n122 |             \n123 |             // Log success\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ArchiveLogsCommand.swift:57:84: error: type 'LogPrivacyLevel' has no member 'protected'\n 55 |             destinationId: destinationId,\n 56 |             additionalMetadata: [\n 57 |                 \"destinationPath\": (value: options.destinationPath, privacyLevel: .protected),\n    |                                                                                    `- error: type 'LogPrivacyLevel' has no member 'protected'\n 58 |                 \"compress\": (value: String(options.compress), privacyLevel: .public),\n 59 |                 \"format\": (value: options.format.rawValue, privacyLevel: .public),\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ArchiveLogsCommand.swift:70:37: error: cannot find 'getDestination' in scope\n 68 |         do {\n 69 |             // Check if destination exists\n 70 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 71 |                 throw LoggingError.destinationNotFound(\n 72 |                     \"Cannot archive logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ArchiveLogsCommand.swift:113:103: error: type 'LogPrivacyLevel' has no member 'protected'\n111 |                     context: operationContext,\n112 |                     additionalMetadata: [\n113 |                         \"archivePath\": (value: archiveResult.archivePath ?? \"unknown\", privacyLevel: .protected),\n    |                                                                                                       `- error: type 'LogPrivacyLevel' has no member 'protected'\n114 |                         \"archiveSizeBytes\": (value: String(archiveResult.archiveSizeBytes ?? 0), privacyLevel: .public),\n115 |                         \"archivedEntryCount\": (value: String(archiveResult.archivedEntryCount ?? 0), privacyLevel: .public)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ExportLogsCommand.swift:70:37: error: cannot find 'getDestination' in scope\n 68 |         do {\n 69 |             // Check if destination exists\n 70 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 71 |                 throw LoggingError.destinationNotFound(\n 72 |                     \"Cannot export logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:79:50: error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n 77 |                 key: key,\n 78 |                 value: value.value,\n 79 |                 privacyLevel: value.privacyLevel.toPrivacyClassification()\n    |                                                  `- error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n 80 |             )\n 81 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:122:54: error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n120 |                     key: key,\n121 |                     value: value.value,\n122 |                     privacyLevel: value.privacyLevel.toPrivacyClassification()\n    |                                                      `- error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n123 |                 )\n124 |             )\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:229:21: error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n227 |         \n228 |         // Process special fields first\n229 |         switch rule.field {\n    |                     `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n230 |         case \"level\":\n231 |             fieldValue = entry.level.rawValue\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:238:96: error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n236 |         default:\n237 |             // Check metadata fields\n238 |             if let metadata = entry.metadata, let metadataValue = metadata.getString(key: rule.field) {\n    |                                                                                                `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n239 |                 fieldValue = metadataValue\n240 |             } else {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:246:21: error: value of type 'UmbraLogFilterRuleDTO' has no member 'operation'\n244 |         \n245 |         // Apply the operation\n246 |         switch rule.operation {\n    |                     `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'operation'\n247 |         case .equals:\n248 |             return fieldValue == rule.value\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:248:39: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n246 |         switch rule.operation {\n247 |         case .equals:\n248 |             return fieldValue == rule.value\n    |                                       `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n249 |         case .contains:\n250 |             return fieldValue.contains(rule.value)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:250:45: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n248 |             return fieldValue == rule.value\n249 |         case .contains:\n250 |             return fieldValue.contains(rule.value)\n    |                                             `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n251 |         case .startsWith:\n252 |             return fieldValue.hasPrefix(rule.value)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:252:46: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n250 |             return fieldValue.contains(rule.value)\n251 |         case .startsWith:\n252 |             return fieldValue.hasPrefix(rule.value)\n    |                                              `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n253 |         case .endsWith:\n254 |             return fieldValue.hasSuffix(rule.value)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:254:46: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n252 |             return fieldValue.hasPrefix(rule.value)\n253 |         case .endsWith:\n254 |             return fieldValue.hasSuffix(rule.value)\n    |                                              `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n255 |         case .matches:\n256 |             if let regex = try? NSRegularExpression(pattern: rule.value) {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:256:67: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n254 |             return fieldValue.hasSuffix(rule.value)\n255 |         case .matches:\n256 |             if let regex = try? NSRegularExpression(pattern: rule.value) {\n    |                                                                   `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n257 |                 let range = NSRange(location: 0, length: fieldValue.utf16.count)\n258 |                 return regex.firstMatch(in: fieldValue, options: [], range: range) != nil\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:262:86: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n260 |             return false\n261 |         case .greaterThan:\n262 |             if let fieldNumeric = Double(fieldValue), let valueNumeric = Double(rule.value) {\n    |                                                                                      `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n263 |                 return fieldNumeric \u003e valueNumeric\n264 |             }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:267:86: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n265 |             return false\n266 |         case .lessThan:\n267 |             if let fieldNumeric = Double(fieldValue), let valueNumeric = Double(rule.value) {\n    |                                                                                      `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n268 |                 return fieldNumeric \u003c valueNumeric\n269 |             }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:293:13: warning: variable 'redactedMetadata' was never mutated; consider changing to 'let' constant\n291 |         // Create mutable copies\n292 |         var redactedMessage = entry.message\n293 |         var redactedMetadata = entry.metadata\n    |             `- warning: variable 'redactedMetadata' was never mutated; consider changing to 'let' constant\n294 |         \n295 |         for rule in rules {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:395:47: error: value of type 'String' has no member 'stringByReplacingMatches'\n393 |             if rule.targetFields.isEmpty || rule.targetFields.contains(\"message\") {\n394 |                 if let pattern = rule.pattern {\n395 |                     redactedMessage = pattern.stringByReplacingMatches(\n    |                                               `- error: value of type 'String' has no member 'stringByReplacingMatches'\n396 |                         in: redactedMessage,\n397 |                         options: [],\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:394:20: error: initializer for conditional binding must have Optional type, not 'String'\n392 |             // Apply rule to message if it matches\n393 |             if rule.targetFields.isEmpty || rule.targetFields.contains(\"message\") {\n394 |                 if let pattern = rule.pattern {\n    |                    `- error: initializer for conditional binding must have Optional type, not 'String'\n395 |                     redactedMessage = pattern.stringByReplacingMatches(\n396 |                         in: redactedMessage,\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:405:24: error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getKeys' of wrapped base type 'LogMetadataDTOCollection'\n403 |             \n404 |             // Process metadata fields\n405 |             for key in redactedMetadata.getKeys() {\n    |                        |- error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getKeys' of wrapped base type 'LogMetadataDTOCollection'\n    |                        |- note: chain the optional using '?' to access member 'getKeys' only for non-'nil' base values\n    |                        `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n406 |                 if rule.targetFields.isEmpty || rule.targetFields.contains(key) {\n407 |                     if let stringValue = redactedMetadata.getString(key: key) {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:407:42: error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getString' of wrapped base type 'LogMetadataDTOCollection'\n405 |             for key in redactedMetadata.getKeys() {\n406 |                 if rule.targetFields.isEmpty || rule.targetFields.contains(key) {\n407 |                     if let stringValue = redactedMetadata.getString(key: key) {\n    |                                          |- error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getString' of wrapped base type 'LogMetadataDTOCollection'\n    |                                          |- note: chain the optional using '?' to access member 'getString' only for non-'nil' base values\n    |                                          `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n408 |                         // Skip fields that should be preserved\n409 |                         if rule.preserveFields.contains(key) {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:468:15: error: type 'LogPrivacyLevel' has no member 'never'\n466 |         case .auto:\n467 |             return .auto\n468 |         case .never:\n    |               `- error: type 'LogPrivacyLevel' has no member 'never'\n469 |             return .public // Map 'never' to public classification\n470 |         case .protected:\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:470:15: error: type 'LogPrivacyLevel' has no member 'protected'\n468 |         case .never:\n469 |             return .public // Map 'never' to public classification\n470 |         case .protected:\n    |               `- error: type 'LogPrivacyLevel' has no member 'protected'\n471 |             return .private // Map 'protected' to private classification\n472 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:58:84: error: type 'LogPrivacyLevel' has no member 'protected'\n 56 |             additionalMetadata: [\n 57 |                 \"createBackup\": (value: String(options.createBackup), privacyLevel: .public),\n 58 |                 \"backupPath\": (value: options.backupPath ?? \"none\", privacyLevel: .protected),\n    |                                                                                    `- error: type 'LogPrivacyLevel' has no member 'protected'\n 59 |                 \"dryRun\": (value: String(options.dryRun), privacyLevel: .public),\n 60 |                 \"hasFilterCriteria\": (value: String(options.filterCriteria != nil), privacyLevel: .public),\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:184:34: error: cannot find 'getDestination' in scope\n182 |         if let destinationId = destinationId {\n183 |             // Use specific destination\n184 |             if let destination = getDestination(id: destinationId) {\n    |                                  `- error: cannot find 'getDestination' in scope\n185 |                 return [destination]\n186 |             } else {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:196:38: error: cannot find 'getDestination' in scope\n194 |             \n195 |             for id in options.destinationIds {\n196 |                 if let destination = getDestination(id: id) {\n    |                                      `- error: cannot find 'getDestination' in scope\n197 |                     result.append(destination)\n198 |                 } else {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:208:20: error: cannot find 'getAllDestinations' in scope\n206 |         } else {\n207 |             // Use all registered destinations\n208 |             return getAllDestinations()\n    |                    `- error: cannot find 'getAllDestinations' in scope\n209 |         }\n210 |     }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/QueryLogsCommand.swift:71:37: error: cannot find 'getDestination' in scope\n 69 |         do {\n 70 |             // Check if destination exists\n 71 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 72 |                 throw LoggingError.destinationNotFound(\n 73 |                     \"Cannot query logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RedactionRule.swift:123:72: error: missing argument for parameter 'privacyLevel' in call\n121 |                 if value != redactedValue {\n122 |                     // Only update if actually changed\n123 |                     result = result.with(key: key, value: redactedValue)\n    |                                                                        `- error: missing argument for parameter 'privacyLevel' in call\n124 |                 }\n125 |             }\n\n/Users/mpy/.bazel/execroot/_main/packages/UmbraCoreTypes/Sources/LoggingTypes/LogMetadataDTOCollection.swift:78:15: note: 'with(key:value:privacyLevel:)' declared here\n 76 |   ///   - privacyLevel: The privacy classification for this entry\n 77 |   /// - Returns: The updated collection\n 78 |   public func with(\n    |               `- note: 'with(key:value:privacyLevel:)' declared here\n 79 |     key: String,\n 80 |     value: String,\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RedactionRule.swift:101:26: warning: no calls to throwing functions occur within 'try' expression\n 99 |     public func redact(metadata: LogMetadataDTOCollection) -\u003e LogMetadataDTOCollection {\n100 |         // No redaction needed for empty metadata\n101 |         guard let keys = try? metadata.getKeys() else {\n    |                          `- warning: no calls to throwing functions occur within 'try' expression\n102 |             return metadata\n103 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RedactionRule.swift:119:28: warning: no calls to throwing functions occur within 'try' expression\n117 |             \n118 |             // Get string value and apply redaction\n119 |             if let value = try? metadata.getString(key: key) {\n    |                            `- warning: no calls to throwing functions occur within 'try' expression\n120 |                 let redactedValue = redact(value)\n121 |                 if value != redactedValue {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RemoveDestinationCommand.swift:67:37: error: cannot find 'getDestination' in scope\n 65 |         do {\n 66 |             // Check if destination exists\n 67 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 68 |                 throw LoggingError.destinationNotFound(\n 69 |                     \"Cannot remove destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RemoveDestinationCommand.swift:128:13: error: expression is 'async' but is not marked with 'await'\n126 |             \n127 |             // Unregister the destination\n128 |             unregisterDestination(id: destinationId)\n    |             |- error: expression is 'async' but is not marked with 'await'\n    |             `- note: calls to instance method 'unregisterDestination(id:)' from outside of its actor context are implicitly asynchronous\n129 |             \n130 |             // Log success\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RotateLogsCommand.swift:67:37: error: cannot find 'getDestination' in scope\n 65 |         do {\n 66 |             // Check if destination exists\n 67 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 68 |                 throw LoggingError.destinationNotFound(\n 69 |                     \"Cannot rotate logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RotateLogsCommand.swift:74:37: error: cannot infer contextual base in reference to member 'file'\n 72 |             \n 73 |             // Check if the destination type supports rotation\n 74 |             if destination.type != .file {\n    |                                     `- error: cannot infer contextual base in reference to member 'file'\n 75 |                 throw LoggingError.invalidDestinationConfig(\n 76 |                     \"Log rotation is only supported for file destinations\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RotateLogsCommand.swift:92:112: error: type 'LogPrivacyLevel' has no member 'protected'\n 90 |                     context: operationContext,\n 91 |                     additionalMetadata: [\n 92 |                         \"rotatedFilePath\": (value: rotationResult.rotatedFilePath ?? \"unknown\", privacyLevel: .protected),\n    |                                                                                                                `- error: type 'LogPrivacyLevel' has no member 'protected'\n 93 |                         \"rotatedSizeBytes\": (value: String(rotationResult.rotatedSizeBytes ?? 0), privacyLevel: .public),\n 94 |                         \"rotatedEntryCount\": (value: String(rotationResult.rotatedEntryCount ?? 0), privacyLevel: .public)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/WriteLogCommand.swift:159:20: error: cannot find 'getAllDestinations' in scope\n157 |         if destinationIds.isEmpty {\n158 |             // Use all registered destinations\n159 |             return getAllDestinations().filter { $0.isEnabled }\n    |                    `- error: cannot find 'getAllDestinations' in scope\n160 |         } else {\n161 |             // Use specific destinations\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/WriteLogCommand.swift:165:38: error: cannot find 'getDestination' in scope\n163 |             \n164 |             for destinationId in destinationIds {\n165 |                 if let destination = getDestination(id: destinationId) {\n    |                                      `- error: cannot find 'getDestination' in scope\n166 |                     if destination.isEnabled {\n167 |                         result.append(destination)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/WriteLogCommand.swift:193:16: error: cannot find 'applyFilterRules' in scope\n191 |         \n192 |         // Apply filter rules if they exist\n193 |         return applyFilterRules(\n    |                `- error: cannot find 'applyFilterRules' in scope\n194 |             to: entry,\n195 |             rules: destination.configuration.filterRules\n\npackages/UmbraImplementations/Sources/LoggingServices/DefaultLoggingServiceImpl.swift:39:36: warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 37 |     let contextDTO=BaseLogContextDTO(\n 38 |       domainName: \"Legacy\",\n 39 |       operation: context.operation ?? \"unknown\",\n    |                                    `- warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 40 |       category: context.category ?? \"General\",\n 41 |       source: context.source ?? \"Unknown\",\n\npackages/UmbraImplementations/Sources/LoggingServices/DefaultLoggingServiceImpl.swift:40:34: warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 38 |       domainName: \"Legacy\",\n 39 |       operation: context.operation ?? \"unknown\",\n 40 |       category: context.category ?? \"General\",\n    |                                  `- warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 41 |       source: context.source ?? \"Unknown\",\n 42 |       metadata: context.metadata\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:147:17: error: invalid redeclaration of 'log(_:_:context:)'\n145 |         - context: The logging context\n146 |      */\n147 |     public func log(_ level: LogLevel, _ message: String, context: any LogContextDTO) async {\n    |                 `- error: invalid redeclaration of 'log(_:_:context:)'\n148 |         // Convert to privacy string and use privacy-aware logging\n149 |         let privacyString = PrivacyString(stringLiteral: message)\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:92:48: error: value of type 'any LoggingProviderProtocol' has no member 'writeLogEntry'\n 90 |                     do {\n 91 |                         // Write log entry to destination\n 92 |                         _ = try await provider.writeLogEntry(entry, to: destination)\n    |                                                `- error: value of type 'any LoggingProviderProtocol' has no member 'writeLogEntry'\n 93 |                     } catch {\n 94 |                         // Silently ignore provider errors for now\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:122:28: error: value of type 'PrivacyString' has no member 'privacy'\n120 |         enrichedMetadata = enrichedMetadata.withPrivate(\n121 |             key: \"__privacy_annotation\", \n122 |             value: message.privacy.description\n    |                            `- error: value of type 'PrivacyString' has no member 'privacy'\n123 |         )\n124 |         \n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:136:34: error: value of type 'PrivacyString' has no member 'content'\n134 |         \n135 |         // Log the message using the standard log method\n136 |         await log(level, message.content, context: privacyContext)\n    |                                  `- error: value of type 'PrivacyString' has no member 'content'\n137 |     }\n138 |     \n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:167:71: error: value of type 'PrivacyAnnotatedString' has no member 'stringValue'\n165 |     ) async {\n166 |         let annotatedString = privacyScope()\n167 |         await log(level, PrivacyString(stringLiteral: annotatedString.stringValue), context: context) \n    |                                                                       `- error: value of type 'PrivacyAnnotatedString' has no member 'stringValue'\n168 |     }\n169 |     \n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:190:29: error: for-in loop requires 'LogMetadata' to conform to 'Sequence'\n188 |         // Create a metadata collection with sensitive values\n189 |         var metadataCollection = context.metadata\n190 |         for (key, value) in sensitiveValues {\n    |                             `- error: for-in loop requires 'LogMetadata' to conform to 'Sequence'\n191 |             metadataCollection = metadataCollection.withSensitive(key: key, value: String(describing: value))\n192 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:228:9: error: switch must be exhaustive\n226 |         \n227 |         // Add error information to metadata with appropriate privacy level\n228 |         switch privacyLevel {\n    |         |- error: switch must be exhaustive\n    |         `- note: add missing case: '.auto'\n229 |         case .public:\n230 |             metadataCollection = metadataCollection.withPublic(key: \"error_description\", value: error.localizedDescription)\npackages/UmbraImplementations/Sources/LoggingServices/PrivacyAwareLogDTO.swift:217:24: error: value of type 'LogMetadataDTOCollection' has no member 'set'\n215 |     for key in self.metadata.getKeys() {\n216 |       if let value = self.metadata.getString(key: key) {\n217 |         mergedMetadata.set(key: key, value: value)\n    |                        `- error: value of type 'LogMetadataDTOCollection' has no member 'set'\n218 |       }\n219 |     }\n\npackages/UmbraImplementations/Sources/LoggingServices/PrivacyAwareLogDTO.swift:224:24: error: value of type 'LogMetadataDTOCollection' has no member 'set'\n222 |     for key in additionalMetadata.getKeys() {\n223 |       if let value = additionalMetadata.getString(key: key) {\n224 |         mergedMetadata.set(key: key, value: value)\n    |                        `- error: value of type 'LogMetadataDTOCollection' has no member 'set'\n225 |       }\n226 |     }\n\npackages/UmbraImplementations/Sources/LoggingServices/PrivacyAwareLogDTO.swift:235:17: error: cannot convert value of type 'LogMetadataDTOCollection' to expected argument type '[String : (value: Any, privacy: LogPrivacyLevel)]'\n233 |       category: category,\n234 |       correlationID: correlationID,\n235 |       metadata: mergedMetadata,\n    |                 `- error: cannot convert value of type 'LogMetadataDTOCollection' to expected argument type '[String : (value: Any, privacy: LogPrivacyLevel)]'\n236 |       environment: environment\n237 |     )\nTarget //packages/UmbraImplementations/Sources/BookmarkServices/Logging:BookmarkLogger failed to build\nINFO: Elapsed time: 1.140s, Critical Path: 1.01s\nINFO: 2 processes: 2 internal.\nERROR: Build did NOT complete successfully\n"
  },
  {
    "target": "rule //packages/UmbraImplementations/Sources/BookmarkServices/Model:BookmarkModel",
    "success": true,
    "start_time": "2025-04-11T17:57:48.818925+01:00",
    "end_time": "2025-04-11T17:57:49.640756+01:00",
    "duration": "821.832375ms",
    "output": "INFO: Invocation ID: 2bbd7447-2d23-40a4-8b62-9aedb289eff9\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraImplementations/Sources/BookmarkServices/Model:BookmarkModel (0 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraImplementations/Sources/BookmarkServices/Model:BookmarkModel (0 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraImplementations/Sources/BookmarkServices/Model:BookmarkModel (0 packages loaded, 0 targets configured).\nINFO: Found 1 target...\nTarget //packages/UmbraImplementations/Sources/BookmarkServices/Model:BookmarkModel up-to-date:\n  bazel-bin/packages/UmbraImplementations/Sources/BookmarkServices/Model/BookmarkModel.swiftdoc\n  bazel-bin/packages/UmbraImplementations/Sources/BookmarkServices/Model/BookmarkModel.swiftmodule\n  bazel-bin/packages/UmbraImplementations/Sources/BookmarkServices/Model/BookmarkModel.swiftsourceinfo\n  bazel-bin/packages/UmbraImplementations/Sources/BookmarkServices/Model/libBookmarkModel.a\nINFO: Elapsed time: 0.125s, Critical Path: 0.00s\nINFO: 2 processes: 1 disk cache hit, 1 internal.\nINFO: Build completed successfully, 2 total actions\n"
  },
  {
    "target": "rule //packages/UmbraImplementations/Sources/ConfigServices:ConfigServices",
    "success": false,
    "start_time": "2025-04-11T17:57:49.640776+01:00",
    "end_time": "2025-04-11T17:57:51.734752+01:00",
    "duration": "2.093978417s",
    "output": "INFO: Invocation ID: 344b8011-dda0-46ae-b201-ba260be93a18\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraImplementations/Sources/ConfigServices:ConfigServices (1 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraImplementations/Sources/ConfigServices:ConfigServices (1 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraImplementations/Sources/ConfigServices:ConfigServices (1 packages loaded, 3 targets configured).\nERROR: /Users/mpy/CascadeProjects/UmbraCore/packages/UmbraImplementations/Sources/LoggingServices/BUILD.bazel:3:20: Compiling Swift module //packages/UmbraImplementations/Sources/LoggingServices:LoggingServices failed: (Exit 1): worker failed: error executing SwiftCompile command (from target //packages/UmbraImplementations/Sources/LoggingServices:LoggingServices) \n  (cd /Users/mpy/.bazel/execroot/_main \u0026\u0026 \\\n  exec env - \\\n    APPLE_SDK_PLATFORM=MacOSX \\\n    APPLE_SDK_VERSION_OVERRIDE=15.4 \\\n    CC=clang \\\n    PATH=/Users/mpy/Library/Caches/bazelisk/downloads/sha256/ac72ad67f7a8c6b18bf605d8602425182b417de4369715bf89146daf62f7ae48/bin:/Users/mpy/.rbenv/bin:/Users/mpy/.codeium/windsurf/bin:/opt/homebrew/opt/node@18/bin:/opt/homebrew/opt/node@20/bin:/Users/mpy/.docker/bin:/opt/homebrew/opt/openjdk/bin:/Users/mpy/bin:/opt/homebrew/bin:/opt/homebrew/sbin:/usr/local/bin:/System/Cryptexes/App/usr/bin:/usr/bin:/bin:/usr/sbin:/sbin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/local/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/appleinternal/bin:/Library/Apple/usr/bin:/usr/local/go/bin:/Users/mpy/.rbenv/bin:/Users/mpy/.codeium/windsurf/bin:/opt/homebrew/opt/node@18/bin:/opt/homebrew/opt/node@20/bin:/opt/anaconda3/bin:/opt/anaconda3/condabin:/Users/mpy/.docker/bin:/opt/homebrew/opt/openjdk/bin:/Users/mpy/bin:/Users/mpy/.cargo/bin:/Users/mpy/Library/Python/3.8/bin:/Users/mpy/go/bin:/Users/mpy/.scripts:/Users/mpy/.fzf/bin:/Users/mpy/.windsurf/extensions/ms-python.debugpy-2025.6.0-darwin-arm64/bundled/scripts/noConfigScripts:/Users/mpy/Library/Python/3.8/bin:/Users/mpy/go/bin:/Users/mpy/.scripts \\\n    XCODE_VERSION_OVERRIDE=16.3.0.16E140 \\\n  bazel-out/darwin_arm64-opt-exec-ST-d57f47055a04/bin/external/rules_swift+/tools/worker/worker swiftc @bazel-out/darwin_arm64-fastbuild/bin/packages/UmbraImplementations/Sources/LoggingServices/LoggingServices.swiftmodule-0.params)\n# Configuration: 76a1bf3a80f2d50513004915454165d2f164db794b63e4666809cbd93e1abeaa\n# Execution platform: @@platforms//host:host\nerror: emit-module command failed with exit code 1 (use -v to see invocation)\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:147:17: error: invalid redeclaration of 'log(_:_:context:)'\n145 |         - context: The logging context\n146 |      */\n147 |     public func log(_ level: LogLevel, _ message: String, context: any LogContextDTO) async {\n    |                 `- error: invalid redeclaration of 'log(_:_:context:)'\n148 |         // Convert to privacy string and use privacy-aware logging\n149 |         let privacyString = PrivacyString(stringLiteral: message)\npackages/UmbraImplementations/Sources/LoggingServices/Commands/AddDestinationCommand.swift:68:31: error: cannot find 'getDestination' in scope\n 66 |         do {\n 67 |             // Check if destination already exists\n 68 |             if let existing = getDestination(id: destination.id) {\n    |                               `- error: cannot find 'getDestination' in scope\n 69 |                 if !options.overwriteExisting {\n 70 |                     throw LoggingError.destinationAlreadyExists(identifier: \"Destination with ID \\(destination.id) already exists\")\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/AddDestinationCommand.swift:82:40: error: cannot find 'validateDestination' in scope\n 80 |             // Validate destination configuration if requested\n 81 |             if options.validateConfiguration {\n 82 |                 let validationResult = validateDestination(destination, for: provider)\n    |                                        `- error: cannot find 'validateDestination' in scope\n 83 |                 \n 84 |                 if !validationResult.isValid {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/AddDestinationCommand.swift:121:13: error: expression is 'async' but is not marked with 'await'\n119 |             \n120 |             // Register the destination\n121 |             registerDestination(destination)\n    |             |- error: expression is 'async' but is not marked with 'await'\n    |             `- note: calls to instance method 'registerDestination' from outside of its actor context are implicitly asynchronous\n122 |             \n123 |             // Log success\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ArchiveLogsCommand.swift:57:84: error: type 'LogPrivacyLevel' has no member 'protected'\n 55 |             destinationId: destinationId,\n 56 |             additionalMetadata: [\n 57 |                 \"destinationPath\": (value: options.destinationPath, privacyLevel: .protected),\n    |                                                                                    `- error: type 'LogPrivacyLevel' has no member 'protected'\n 58 |                 \"compress\": (value: String(options.compress), privacyLevel: .public),\n 59 |                 \"format\": (value: options.format.rawValue, privacyLevel: .public),\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ArchiveLogsCommand.swift:70:37: error: cannot find 'getDestination' in scope\n 68 |         do {\n 69 |             // Check if destination exists\n 70 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 71 |                 throw LoggingError.destinationNotFound(\n 72 |                     \"Cannot archive logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ArchiveLogsCommand.swift:113:103: error: type 'LogPrivacyLevel' has no member 'protected'\n111 |                     context: operationContext,\n112 |                     additionalMetadata: [\n113 |                         \"archivePath\": (value: archiveResult.archivePath ?? \"unknown\", privacyLevel: .protected),\n    |                                                                                                       `- error: type 'LogPrivacyLevel' has no member 'protected'\n114 |                         \"archiveSizeBytes\": (value: String(archiveResult.archiveSizeBytes ?? 0), privacyLevel: .public),\n115 |                         \"archivedEntryCount\": (value: String(archiveResult.archivedEntryCount ?? 0), privacyLevel: .public)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ExportLogsCommand.swift:70:37: error: cannot find 'getDestination' in scope\n 68 |         do {\n 69 |             // Check if destination exists\n 70 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 71 |                 throw LoggingError.destinationNotFound(\n 72 |                     \"Cannot export logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:79:50: error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n 77 |                 key: key,\n 78 |                 value: value.value,\n 79 |                 privacyLevel: value.privacyLevel.toPrivacyClassification()\n    |                                                  `- error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n 80 |             )\n 81 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:122:54: error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n120 |                     key: key,\n121 |                     value: value.value,\n122 |                     privacyLevel: value.privacyLevel.toPrivacyClassification()\n    |                                                      `- error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n123 |                 )\n124 |             )\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:229:21: error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n227 |         \n228 |         // Process special fields first\n229 |         switch rule.field {\n    |                     `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n230 |         case \"level\":\n231 |             fieldValue = entry.level.rawValue\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:238:96: error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n236 |         default:\n237 |             // Check metadata fields\n238 |             if let metadata = entry.metadata, let metadataValue = metadata.getString(key: rule.field) {\n    |                                                                                                `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n239 |                 fieldValue = metadataValue\n240 |             } else {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:246:21: error: value of type 'UmbraLogFilterRuleDTO' has no member 'operation'\n244 |         \n245 |         // Apply the operation\n246 |         switch rule.operation {\n    |                     `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'operation'\n247 |         case .equals:\n248 |             return fieldValue == rule.value\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:248:39: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n246 |         switch rule.operation {\n247 |         case .equals:\n248 |             return fieldValue == rule.value\n    |                                       `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n249 |         case .contains:\n250 |             return fieldValue.contains(rule.value)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:250:45: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n248 |             return fieldValue == rule.value\n249 |         case .contains:\n250 |             return fieldValue.contains(rule.value)\n    |                                             `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n251 |         case .startsWith:\n252 |             return fieldValue.hasPrefix(rule.value)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:252:46: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n250 |             return fieldValue.contains(rule.value)\n251 |         case .startsWith:\n252 |             return fieldValue.hasPrefix(rule.value)\n    |                                              `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n253 |         case .endsWith:\n254 |             return fieldValue.hasSuffix(rule.value)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:254:46: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n252 |             return fieldValue.hasPrefix(rule.value)\n253 |         case .endsWith:\n254 |             return fieldValue.hasSuffix(rule.value)\n    |                                              `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n255 |         case .matches:\n256 |             if let regex = try? NSRegularExpression(pattern: rule.value) {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:256:67: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n254 |             return fieldValue.hasSuffix(rule.value)\n255 |         case .matches:\n256 |             if let regex = try? NSRegularExpression(pattern: rule.value) {\n    |                                                                   `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n257 |                 let range = NSRange(location: 0, length: fieldValue.utf16.count)\n258 |                 return regex.firstMatch(in: fieldValue, options: [], range: range) != nil\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:262:86: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n260 |             return false\n261 |         case .greaterThan:\n262 |             if let fieldNumeric = Double(fieldValue), let valueNumeric = Double(rule.value) {\n    |                                                                                      `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n263 |                 return fieldNumeric \u003e valueNumeric\n264 |             }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:267:86: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n265 |             return false\n266 |         case .lessThan:\n267 |             if let fieldNumeric = Double(fieldValue), let valueNumeric = Double(rule.value) {\n    |                                                                                      `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n268 |                 return fieldNumeric \u003c valueNumeric\n269 |             }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:293:13: warning: variable 'redactedMetadata' was never mutated; consider changing to 'let' constant\n291 |         // Create mutable copies\n292 |         var redactedMessage = entry.message\n293 |         var redactedMetadata = entry.metadata\n    |             `- warning: variable 'redactedMetadata' was never mutated; consider changing to 'let' constant\n294 |         \n295 |         for rule in rules {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:395:47: error: value of type 'String' has no member 'stringByReplacingMatches'\n393 |             if rule.targetFields.isEmpty || rule.targetFields.contains(\"message\") {\n394 |                 if let pattern = rule.pattern {\n395 |                     redactedMessage = pattern.stringByReplacingMatches(\n    |                                               `- error: value of type 'String' has no member 'stringByReplacingMatches'\n396 |                         in: redactedMessage,\n397 |                         options: [],\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:394:20: error: initializer for conditional binding must have Optional type, not 'String'\n392 |             // Apply rule to message if it matches\n393 |             if rule.targetFields.isEmpty || rule.targetFields.contains(\"message\") {\n394 |                 if let pattern = rule.pattern {\n    |                    `- error: initializer for conditional binding must have Optional type, not 'String'\n395 |                     redactedMessage = pattern.stringByReplacingMatches(\n396 |                         in: redactedMessage,\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:405:24: error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getKeys' of wrapped base type 'LogMetadataDTOCollection'\n403 |             \n404 |             // Process metadata fields\n405 |             for key in redactedMetadata.getKeys() {\n    |                        |- error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getKeys' of wrapped base type 'LogMetadataDTOCollection'\n    |                        |- note: chain the optional using '?' to access member 'getKeys' only for non-'nil' base values\n    |                        `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n406 |                 if rule.targetFields.isEmpty || rule.targetFields.contains(key) {\n407 |                     if let stringValue = redactedMetadata.getString(key: key) {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:407:42: error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getString' of wrapped base type 'LogMetadataDTOCollection'\n405 |             for key in redactedMetadata.getKeys() {\n406 |                 if rule.targetFields.isEmpty || rule.targetFields.contains(key) {\n407 |                     if let stringValue = redactedMetadata.getString(key: key) {\n    |                                          |- error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getString' of wrapped base type 'LogMetadataDTOCollection'\n    |                                          |- note: chain the optional using '?' to access member 'getString' only for non-'nil' base values\n    |                                          `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n408 |                         // Skip fields that should be preserved\n409 |                         if rule.preserveFields.contains(key) {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:468:15: error: type 'LogPrivacyLevel' has no member 'never'\n466 |         case .auto:\n467 |             return .auto\n468 |         case .never:\n    |               `- error: type 'LogPrivacyLevel' has no member 'never'\n469 |             return .public // Map 'never' to public classification\n470 |         case .protected:\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:470:15: error: type 'LogPrivacyLevel' has no member 'protected'\n468 |         case .never:\n469 |             return .public // Map 'never' to public classification\n470 |         case .protected:\n    |               `- error: type 'LogPrivacyLevel' has no member 'protected'\n471 |             return .private // Map 'protected' to private classification\n472 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:58:84: error: type 'LogPrivacyLevel' has no member 'protected'\n 56 |             additionalMetadata: [\n 57 |                 \"createBackup\": (value: String(options.createBackup), privacyLevel: .public),\n 58 |                 \"backupPath\": (value: options.backupPath ?? \"none\", privacyLevel: .protected),\n    |                                                                                    `- error: type 'LogPrivacyLevel' has no member 'protected'\n 59 |                 \"dryRun\": (value: String(options.dryRun), privacyLevel: .public),\n 60 |                 \"hasFilterCriteria\": (value: String(options.filterCriteria != nil), privacyLevel: .public),\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:184:34: error: cannot find 'getDestination' in scope\n182 |         if let destinationId = destinationId {\n183 |             // Use specific destination\n184 |             if let destination = getDestination(id: destinationId) {\n    |                                  `- error: cannot find 'getDestination' in scope\n185 |                 return [destination]\n186 |             } else {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:196:38: error: cannot find 'getDestination' in scope\n194 |             \n195 |             for id in options.destinationIds {\n196 |                 if let destination = getDestination(id: id) {\n    |                                      `- error: cannot find 'getDestination' in scope\n197 |                     result.append(destination)\n198 |                 } else {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:208:20: error: cannot find 'getAllDestinations' in scope\n206 |         } else {\n207 |             // Use all registered destinations\n208 |             return getAllDestinations()\n    |                    `- error: cannot find 'getAllDestinations' in scope\n209 |         }\n210 |     }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/QueryLogsCommand.swift:71:37: error: cannot find 'getDestination' in scope\n 69 |         do {\n 70 |             // Check if destination exists\n 71 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 72 |                 throw LoggingError.destinationNotFound(\n 73 |                     \"Cannot query logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RedactionRule.swift:123:72: error: missing argument for parameter 'privacyLevel' in call\n121 |                 if value != redactedValue {\n122 |                     // Only update if actually changed\n123 |                     result = result.with(key: key, value: redactedValue)\n    |                                                                        `- error: missing argument for parameter 'privacyLevel' in call\n124 |                 }\n125 |             }\n\n/Users/mpy/.bazel/execroot/_main/packages/UmbraCoreTypes/Sources/LoggingTypes/LogMetadataDTOCollection.swift:78:15: note: 'with(key:value:privacyLevel:)' declared here\n 76 |   ///   - privacyLevel: The privacy classification for this entry\n 77 |   /// - Returns: The updated collection\n 78 |   public func with(\n    |               `- note: 'with(key:value:privacyLevel:)' declared here\n 79 |     key: String,\n 80 |     value: String,\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RedactionRule.swift:101:26: warning: no calls to throwing functions occur within 'try' expression\n 99 |     public func redact(metadata: LogMetadataDTOCollection) -\u003e LogMetadataDTOCollection {\n100 |         // No redaction needed for empty metadata\n101 |         guard let keys = try? metadata.getKeys() else {\n    |                          `- warning: no calls to throwing functions occur within 'try' expression\n102 |             return metadata\n103 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RedactionRule.swift:119:28: warning: no calls to throwing functions occur within 'try' expression\n117 |             \n118 |             // Get string value and apply redaction\n119 |             if let value = try? metadata.getString(key: key) {\n    |                            `- warning: no calls to throwing functions occur within 'try' expression\n120 |                 let redactedValue = redact(value)\n121 |                 if value != redactedValue {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RemoveDestinationCommand.swift:67:37: error: cannot find 'getDestination' in scope\n 65 |         do {\n 66 |             // Check if destination exists\n 67 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 68 |                 throw LoggingError.destinationNotFound(\n 69 |                     \"Cannot remove destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RemoveDestinationCommand.swift:128:13: error: expression is 'async' but is not marked with 'await'\n126 |             \n127 |             // Unregister the destination\n128 |             unregisterDestination(id: destinationId)\n    |             |- error: expression is 'async' but is not marked with 'await'\n    |             `- note: calls to instance method 'unregisterDestination(id:)' from outside of its actor context are implicitly asynchronous\n129 |             \n130 |             // Log success\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RotateLogsCommand.swift:67:37: error: cannot find 'getDestination' in scope\n 65 |         do {\n 66 |             // Check if destination exists\n 67 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 68 |                 throw LoggingError.destinationNotFound(\n 69 |                     \"Cannot rotate logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RotateLogsCommand.swift:74:37: error: cannot infer contextual base in reference to member 'file'\n 72 |             \n 73 |             // Check if the destination type supports rotation\n 74 |             if destination.type != .file {\n    |                                     `- error: cannot infer contextual base in reference to member 'file'\n 75 |                 throw LoggingError.invalidDestinationConfig(\n 76 |                     \"Log rotation is only supported for file destinations\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RotateLogsCommand.swift:92:112: error: type 'LogPrivacyLevel' has no member 'protected'\n 90 |                     context: operationContext,\n 91 |                     additionalMetadata: [\n 92 |                         \"rotatedFilePath\": (value: rotationResult.rotatedFilePath ?? \"unknown\", privacyLevel: .protected),\n    |                                                                                                                `- error: type 'LogPrivacyLevel' has no member 'protected'\n 93 |                         \"rotatedSizeBytes\": (value: String(rotationResult.rotatedSizeBytes ?? 0), privacyLevel: .public),\n 94 |                         \"rotatedEntryCount\": (value: String(rotationResult.rotatedEntryCount ?? 0), privacyLevel: .public)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/WriteLogCommand.swift:159:20: error: cannot find 'getAllDestinations' in scope\n157 |         if destinationIds.isEmpty {\n158 |             // Use all registered destinations\n159 |             return getAllDestinations().filter { $0.isEnabled }\n    |                    `- error: cannot find 'getAllDestinations' in scope\n160 |         } else {\n161 |             // Use specific destinations\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/WriteLogCommand.swift:165:38: error: cannot find 'getDestination' in scope\n163 |             \n164 |             for destinationId in destinationIds {\n165 |                 if let destination = getDestination(id: destinationId) {\n    |                                      `- error: cannot find 'getDestination' in scope\n166 |                     if destination.isEnabled {\n167 |                         result.append(destination)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/WriteLogCommand.swift:193:16: error: cannot find 'applyFilterRules' in scope\n191 |         \n192 |         // Apply filter rules if they exist\n193 |         return applyFilterRules(\n    |                `- error: cannot find 'applyFilterRules' in scope\n194 |             to: entry,\n195 |             rules: destination.configuration.filterRules\n\npackages/UmbraImplementations/Sources/LoggingServices/DefaultLoggingServiceImpl.swift:39:36: warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 37 |     let contextDTO=BaseLogContextDTO(\n 38 |       domainName: \"Legacy\",\n 39 |       operation: context.operation ?? \"unknown\",\n    |                                    `- warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 40 |       category: context.category ?? \"General\",\n 41 |       source: context.source ?? \"Unknown\",\n\npackages/UmbraImplementations/Sources/LoggingServices/DefaultLoggingServiceImpl.swift:40:34: warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 38 |       domainName: \"Legacy\",\n 39 |       operation: context.operation ?? \"unknown\",\n 40 |       category: context.category ?? \"General\",\n    |                                  `- warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 41 |       source: context.source ?? \"Unknown\",\n 42 |       metadata: context.metadata\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:147:17: error: invalid redeclaration of 'log(_:_:context:)'\n145 |         - context: The logging context\n146 |      */\n147 |     public func log(_ level: LogLevel, _ message: String, context: any LogContextDTO) async {\n    |                 `- error: invalid redeclaration of 'log(_:_:context:)'\n148 |         // Convert to privacy string and use privacy-aware logging\n149 |         let privacyString = PrivacyString(stringLiteral: message)\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:92:48: error: value of type 'any LoggingProviderProtocol' has no member 'writeLogEntry'\n 90 |                     do {\n 91 |                         // Write log entry to destination\n 92 |                         _ = try await provider.writeLogEntry(entry, to: destination)\n    |                                                `- error: value of type 'any LoggingProviderProtocol' has no member 'writeLogEntry'\n 93 |                     } catch {\n 94 |                         // Silently ignore provider errors for now\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:122:28: error: value of type 'PrivacyString' has no member 'privacy'\n120 |         enrichedMetadata = enrichedMetadata.withPrivate(\n121 |             key: \"__privacy_annotation\", \n122 |             value: message.privacy.description\n    |                            `- error: value of type 'PrivacyString' has no member 'privacy'\n123 |         )\n124 |         \n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:136:34: error: value of type 'PrivacyString' has no member 'content'\n134 |         \n135 |         // Log the message using the standard log method\n136 |         await log(level, message.content, context: privacyContext)\n    |                                  `- error: value of type 'PrivacyString' has no member 'content'\n137 |     }\n138 |     \n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:167:71: error: value of type 'PrivacyAnnotatedString' has no member 'stringValue'\n165 |     ) async {\n166 |         let annotatedString = privacyScope()\n167 |         await log(level, PrivacyString(stringLiteral: annotatedString.stringValue), context: context) \n    |                                                                       `- error: value of type 'PrivacyAnnotatedString' has no member 'stringValue'\n168 |     }\n169 |     \n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:190:29: error: for-in loop requires 'LogMetadata' to conform to 'Sequence'\n188 |         // Create a metadata collection with sensitive values\n189 |         var metadataCollection = context.metadata\n190 |         for (key, value) in sensitiveValues {\n    |                             `- error: for-in loop requires 'LogMetadata' to conform to 'Sequence'\n191 |             metadataCollection = metadataCollection.withSensitive(key: key, value: String(describing: value))\n192 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:228:9: error: switch must be exhaustive\n226 |         \n227 |         // Add error information to metadata with appropriate privacy level\n228 |         switch privacyLevel {\n    |         |- error: switch must be exhaustive\n    |         `- note: add missing case: '.auto'\n229 |         case .public:\n230 |             metadataCollection = metadataCollection.withPublic(key: \"error_description\", value: error.localizedDescription)\npackages/UmbraImplementations/Sources/LoggingServices/PrivacyAwareLogDTO.swift:217:24: error: value of type 'LogMetadataDTOCollection' has no member 'set'\n215 |     for key in self.metadata.getKeys() {\n216 |       if let value = self.metadata.getString(key: key) {\n217 |         mergedMetadata.set(key: key, value: value)\n    |                        `- error: value of type 'LogMetadataDTOCollection' has no member 'set'\n218 |       }\n219 |     }\n\npackages/UmbraImplementations/Sources/LoggingServices/PrivacyAwareLogDTO.swift:224:24: error: value of type 'LogMetadataDTOCollection' has no member 'set'\n222 |     for key in additionalMetadata.getKeys() {\n223 |       if let value = additionalMetadata.getString(key: key) {\n224 |         mergedMetadata.set(key: key, value: value)\n    |                        `- error: value of type 'LogMetadataDTOCollection' has no member 'set'\n225 |       }\n226 |     }\n\npackages/UmbraImplementations/Sources/LoggingServices/PrivacyAwareLogDTO.swift:235:17: error: cannot convert value of type 'LogMetadataDTOCollection' to expected argument type '[String : (value: Any, privacy: LogPrivacyLevel)]'\n233 |       category: category,\n234 |       correlationID: correlationID,\n235 |       metadata: mergedMetadata,\n    |                 `- error: cannot convert value of type 'LogMetadataDTOCollection' to expected argument type '[String : (value: Any, privacy: LogPrivacyLevel)]'\n236 |       environment: environment\n237 |     )\nTarget //packages/UmbraImplementations/Sources/ConfigServices:ConfigServices failed to build\nINFO: Elapsed time: 1.141s, Critical Path: 1.01s\nINFO: 2 processes: 1 action cache hit, 2 internal.\nERROR: Build did NOT complete successfully\n"
  },
  {
    "target": "rule //packages/UmbraImplementations/Sources/CoreFileOperations:CoreFileOperations",
    "success": false,
    "start_time": "2025-04-11T17:57:51.734765+01:00",
    "end_time": "2025-04-11T17:57:54.017857+01:00",
    "duration": "2.283094084s",
    "output": "INFO: Invocation ID: 66e29480-0adb-4e5d-ac88-3eb9ffa482ee\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraImplementations/Sources/CoreFileOperations:CoreFileOperations (1 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraImplementations/Sources/CoreFileOperations:CoreFileOperations (1 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraImplementations/Sources/CoreFileOperations:CoreFileOperations (1 packages loaded, 3 targets configured).\nINFO: From Compiling Swift module //packages/UmbraInterfaces/Sources/FileSystemInterfaces:FileSystemInterfaces:\npackages/UmbraInterfaces/Sources/FileSystemInterfaces/Models/FileMetadataDTO.swift:57:14: warning: stored property 'resourceValues' of 'Sendable'-conforming struct 'FileMetadataDTO' has non-sendable type '[URLResourceKey : Any]?'; this is an error in the Swift 6 language mode\n 55 | \n 56 |   /// File resource values\n 57 |   public let resourceValues: [URLResourceKey: Any]?\n    |              `- warning: stored property 'resourceValues' of 'Sendable'-conforming struct 'FileMetadataDTO' has non-sendable type '[URLResourceKey : Any]?'; this is an error in the Swift 6 language mode\n 58 | \n 59 |   /// Creates a new file metadata object\n\npackages/UmbraInterfaces/Sources/FileSystemInterfaces/Models/FileSystemOptions.swift:17:14: warning: stored property 'attributes' of 'Sendable'-conforming struct 'FileCreationOptions' has non-sendable type '[FileAttributeKey : Any]?'; this is an error in the Swift 6 language mode\n 15 | public struct FileCreationOptions: Sendable {\n 16 |   /// File attributes to set when creating the file\n 17 |   public let attributes: [FileAttributeKey: Any]?\n    |              `- warning: stored property 'attributes' of 'Sendable'-conforming struct 'FileCreationOptions' has non-sendable type '[FileAttributeKey : Any]?'; this is an error in the Swift 6 language mode\n 18 | \n 19 |   /// Whether to overwrite an existing file at the path\n\npackages/UmbraInterfaces/Sources/FileSystemInterfaces/Models/FileSystemOptions.swift:106:14: warning: stored property 'attributes' of 'Sendable'-conforming struct 'FileWriteOptions' has non-sendable type '[FileAttributeKey : Any]?'; this is an error in the Swift 6 language mode\n104 | \n105 |   /// File attributes to set when writing the file\n106 |   public let attributes: [FileAttributeKey: Any]?\n    |              `- warning: stored property 'attributes' of 'Sendable'-conforming struct 'FileWriteOptions' has non-sendable type '[FileAttributeKey : Any]?'; this is an error in the Swift 6 language mode\n107 | \n108 |   /// Creates new file write options\n\npackages/UmbraInterfaces/Sources/FileSystemInterfaces/Models/FileSystemOptions.swift:202:14: warning: stored property 'attributes' of 'Sendable'-conforming struct 'DirectoryCreationOptions' has non-sendable type '[FileAttributeKey : Any]?'; this is an error in the Swift 6 language mode\n200 | \n201 |   /// Directory attributes to set when creating the directory\n202 |   public let attributes: [FileAttributeKey: Any]?\n    |              `- warning: stored property 'attributes' of 'Sendable'-conforming struct 'DirectoryCreationOptions' has non-sendable type '[FileAttributeKey : Any]?'; this is an error in the Swift 6 language mode\n203 | \n204 |   /// Creates new directory creation options\npackages/UmbraInterfaces/Sources/FileSystemInterfaces/Models/FileMetadataDTO.swift:57:14: warning: stored property 'resourceValues' of 'Sendable'-conforming struct 'FileMetadataDTO' has non-sendable type '[URLResourceKey : Any]?'; this is an error in the Swift 6 language mode\n 55 | \n 56 |   /// File resource values\n 57 |   public let resourceValues: [URLResourceKey: Any]?\n    |              `- warning: stored property 'resourceValues' of 'Sendable'-conforming struct 'FileMetadataDTO' has non-sendable type '[URLResourceKey : Any]?'; this is an error in the Swift 6 language mode\n 58 | \n 59 |   /// Creates a new file metadata object\n\npackages/UmbraInterfaces/Sources/FileSystemInterfaces/Models/FileSystemError.swift:160:26: warning: conditional cast from 'any Error' to 'NSError' always succeeds\n158 | \n159 |     // For NSError, try to create a more specific error based on the error code\n160 |     if let nsError=error as? NSError {\n    |                          `- warning: conditional cast from 'any Error' to 'NSError' always succeeds\n161 |       switch nsError.domain {\n162 |         case NSCocoaErrorDomain:\n\npackages/UmbraInterfaces/Sources/FileSystemInterfaces/Models/FileSystemOptions.swift:17:14: warning: stored property 'attributes' of 'Sendable'-conforming struct 'FileCreationOptions' has non-sendable type '[FileAttributeKey : Any]?'; this is an error in the Swift 6 language mode\n 15 | public struct FileCreationOptions: Sendable {\n 16 |   /// File attributes to set when creating the file\n 17 |   public let attributes: [FileAttributeKey: Any]?\n    |              `- warning: stored property 'attributes' of 'Sendable'-conforming struct 'FileCreationOptions' has non-sendable type '[FileAttributeKey : Any]?'; this is an error in the Swift 6 language mode\n 18 | \n 19 |   /// Whether to overwrite an existing file at the path\n\npackages/UmbraInterfaces/Sources/FileSystemInterfaces/Models/FileSystemOptions.swift:106:14: warning: stored property 'attributes' of 'Sendable'-conforming struct 'FileWriteOptions' has non-sendable type '[FileAttributeKey : Any]?'; this is an error in the Swift 6 language mode\n104 | \n105 |   /// File attributes to set when writing the file\n106 |   public let attributes: [FileAttributeKey: Any]?\n    |              `- warning: stored property 'attributes' of 'Sendable'-conforming struct 'FileWriteOptions' has non-sendable type '[FileAttributeKey : Any]?'; this is an error in the Swift 6 language mode\n107 | \n108 |   /// Creates new file write options\n\npackages/UmbraInterfaces/Sources/FileSystemInterfaces/Models/FileSystemOptions.swift:202:14: warning: stored property 'attributes' of 'Sendable'-conforming struct 'DirectoryCreationOptions' has non-sendable type '[FileAttributeKey : Any]?'; this is an error in the Swift 6 language mode\n200 | \n201 |   /// Directory attributes to set when creating the directory\n202 |   public let attributes: [FileAttributeKey: Any]?\n    |              `- warning: stored property 'attributes' of 'Sendable'-conforming struct 'DirectoryCreationOptions' has non-sendable type '[FileAttributeKey : Any]?'; this is an error in the Swift 6 language mode\n203 | \n204 |   /// Creates new directory creation options\n[3 / 5] [Prepa] Compiling Swift module //packages/UmbraImplementations/Sources/CoreFileOperations:CoreFileOperations\nERROR: /Users/mpy/CascadeProjects/UmbraCore/packages/UmbraImplementations/Sources/CoreFileOperations/BUILD.bazel:3:14: Compiling Swift module //packages/UmbraImplementations/Sources/CoreFileOperations:CoreFileOperations failed: (Exit 1): worker failed: error executing SwiftCompile command (from target //packages/UmbraImplementations/Sources/CoreFileOperations:CoreFileOperations) \n  (cd /Users/mpy/.bazel/execroot/_main \u0026\u0026 \\\n  exec env - \\\n    APPLE_SDK_PLATFORM=MacOSX \\\n    APPLE_SDK_VERSION_OVERRIDE=15.4 \\\n    CC=clang \\\n    PATH=/Users/mpy/Library/Caches/bazelisk/downloads/sha256/ac72ad67f7a8c6b18bf605d8602425182b417de4369715bf89146daf62f7ae48/bin:/Users/mpy/.rbenv/bin:/Users/mpy/.codeium/windsurf/bin:/opt/homebrew/opt/node@18/bin:/opt/homebrew/opt/node@20/bin:/Users/mpy/.docker/bin:/opt/homebrew/opt/openjdk/bin:/Users/mpy/bin:/opt/homebrew/bin:/opt/homebrew/sbin:/usr/local/bin:/System/Cryptexes/App/usr/bin:/usr/bin:/bin:/usr/sbin:/sbin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/local/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/appleinternal/bin:/Library/Apple/usr/bin:/usr/local/go/bin:/Users/mpy/.rbenv/bin:/Users/mpy/.codeium/windsurf/bin:/opt/homebrew/opt/node@18/bin:/opt/homebrew/opt/node@20/bin:/opt/anaconda3/bin:/opt/anaconda3/condabin:/Users/mpy/.docker/bin:/opt/homebrew/opt/openjdk/bin:/Users/mpy/bin:/Users/mpy/.cargo/bin:/Users/mpy/Library/Python/3.8/bin:/Users/mpy/go/bin:/Users/mpy/.scripts:/Users/mpy/.fzf/bin:/Users/mpy/.windsurf/extensions/ms-python.debugpy-2025.6.0-darwin-arm64/bundled/scripts/noConfigScripts:/Users/mpy/Library/Python/3.8/bin:/Users/mpy/go/bin:/Users/mpy/.scripts \\\n    XCODE_VERSION_OVERRIDE=16.3.0.16E140 \\\n  bazel-out/darwin_arm64-opt-exec-ST-d57f47055a04/bin/external/rules_swift+/tools/worker/worker swiftc @bazel-out/darwin_arm64-fastbuild/bin/packages/UmbraImplementations/Sources/CoreFileOperations/CoreFileOperations.swiftmodule-0.params)\n# Configuration: 76a1bf3a80f2d50513004915454165d2f164db794b63e4666809cbd93e1abeaa\n# Execution platform: @@platforms//host:host\npackages/UmbraImplementations/Sources/CoreFileOperations/Implementation/CoreFileOperationsImpl.swift:55:29: error: missing arguments for parameters 'operation', 'category' in call\n  53 |     }\n  54 | \n  55 |     return BaseLogContextDTO(\n     |                             `- error: missing arguments for parameters 'operation', 'category' in call\n  56 |       domainName: \"CoreFileOperations\",\n  57 |       source: \"CoreFileOperationsImpl\",\n\n/Users/mpy/.bazel/execroot/_main/packages/UmbraCoreTypes/Sources/LoggingTypes/LogContextDTO.swift:60:10: note: 'init(domainName:operation:category:source:metadata:correlationID:)' declared here\n58 |   ///   - metadata: Privacy metadata as a LogMetadataDTOCollection instance\n59 |   ///   - correlationID: Optional correlation ID\n60 |   public init(\n   |          `- note: 'init(domainName:operation:category:source:metadata:correlationID:)' declared here\n61 |     domainName: String,\n62 |     operation: String,\nTarget //packages/UmbraImplementations/Sources/CoreFileOperations:CoreFileOperations failed to build\nINFO: Elapsed time: 1.551s, Critical Path: 1.43s\nINFO: 3 processes: 1 action cache hit, 2 internal, 1 worker.\nERROR: Build did NOT complete successfully\n"
  },
  {
    "target": "rule //packages/UmbraImplementations/Sources/CoreServices:CoreServices",
    "success": false,
    "start_time": "2025-04-11T17:57:54.017868+01:00",
    "end_time": "2025-04-11T17:57:55.838074+01:00",
    "duration": "1.820207542s",
    "output": "INFO: Invocation ID: ff78240e-296b-4cbd-8488-3886986081ed\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraImplementations/Sources/CoreServices:CoreServices (1 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraImplementations/Sources/CoreServices:CoreServices (1 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraImplementations/Sources/CoreServices:CoreServices (1 packages loaded, 8 targets configured).\nERROR: /Users/mpy/CascadeProjects/UmbraCore/packages/UmbraImplementations/Sources/LoggingServices/BUILD.bazel:3:20: Compiling Swift module //packages/UmbraImplementations/Sources/LoggingServices:LoggingServices failed: (Exit 1): worker failed: error executing SwiftCompile command (from target //packages/UmbraImplementations/Sources/LoggingServices:LoggingServices) \n  (cd /Users/mpy/.bazel/execroot/_main \u0026\u0026 \\\n  exec env - \\\n    APPLE_SDK_PLATFORM=MacOSX \\\n    APPLE_SDK_VERSION_OVERRIDE=15.4 \\\n    CC=clang \\\n    PATH=/Users/mpy/Library/Caches/bazelisk/downloads/sha256/ac72ad67f7a8c6b18bf605d8602425182b417de4369715bf89146daf62f7ae48/bin:/Users/mpy/.rbenv/bin:/Users/mpy/.codeium/windsurf/bin:/opt/homebrew/opt/node@18/bin:/opt/homebrew/opt/node@20/bin:/Users/mpy/.docker/bin:/opt/homebrew/opt/openjdk/bin:/Users/mpy/bin:/opt/homebrew/bin:/opt/homebrew/sbin:/usr/local/bin:/System/Cryptexes/App/usr/bin:/usr/bin:/bin:/usr/sbin:/sbin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/local/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/appleinternal/bin:/Library/Apple/usr/bin:/usr/local/go/bin:/Users/mpy/.rbenv/bin:/Users/mpy/.codeium/windsurf/bin:/opt/homebrew/opt/node@18/bin:/opt/homebrew/opt/node@20/bin:/opt/anaconda3/bin:/opt/anaconda3/condabin:/Users/mpy/.docker/bin:/opt/homebrew/opt/openjdk/bin:/Users/mpy/bin:/Users/mpy/.cargo/bin:/Users/mpy/Library/Python/3.8/bin:/Users/mpy/go/bin:/Users/mpy/.scripts:/Users/mpy/.fzf/bin:/Users/mpy/.windsurf/extensions/ms-python.debugpy-2025.6.0-darwin-arm64/bundled/scripts/noConfigScripts:/Users/mpy/Library/Python/3.8/bin:/Users/mpy/go/bin:/Users/mpy/.scripts \\\n    XCODE_VERSION_OVERRIDE=16.3.0.16E140 \\\n  bazel-out/darwin_arm64-opt-exec-ST-d57f47055a04/bin/external/rules_swift+/tools/worker/worker swiftc @bazel-out/darwin_arm64-fastbuild/bin/packages/UmbraImplementations/Sources/LoggingServices/LoggingServices.swiftmodule-0.params)\n# Configuration: 76a1bf3a80f2d50513004915454165d2f164db794b63e4666809cbd93e1abeaa\n# Execution platform: @@platforms//host:host\nerror: emit-module command failed with exit code 1 (use -v to see invocation)\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:147:17: error: invalid redeclaration of 'log(_:_:context:)'\n145 |         - context: The logging context\n146 |      */\n147 |     public func log(_ level: LogLevel, _ message: String, context: any LogContextDTO) async {\n    |                 `- error: invalid redeclaration of 'log(_:_:context:)'\n148 |         // Convert to privacy string and use privacy-aware logging\n149 |         let privacyString = PrivacyString(stringLiteral: message)\npackages/UmbraImplementations/Sources/LoggingServices/Commands/AddDestinationCommand.swift:68:31: error: cannot find 'getDestination' in scope\n 66 |         do {\n 67 |             // Check if destination already exists\n 68 |             if let existing = getDestination(id: destination.id) {\n    |                               `- error: cannot find 'getDestination' in scope\n 69 |                 if !options.overwriteExisting {\n 70 |                     throw LoggingError.destinationAlreadyExists(identifier: \"Destination with ID \\(destination.id) already exists\")\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/AddDestinationCommand.swift:82:40: error: cannot find 'validateDestination' in scope\n 80 |             // Validate destination configuration if requested\n 81 |             if options.validateConfiguration {\n 82 |                 let validationResult = validateDestination(destination, for: provider)\n    |                                        `- error: cannot find 'validateDestination' in scope\n 83 |                 \n 84 |                 if !validationResult.isValid {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/AddDestinationCommand.swift:121:13: error: expression is 'async' but is not marked with 'await'\n119 |             \n120 |             // Register the destination\n121 |             registerDestination(destination)\n    |             |- error: expression is 'async' but is not marked with 'await'\n    |             `- note: calls to instance method 'registerDestination' from outside of its actor context are implicitly asynchronous\n122 |             \n123 |             // Log success\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ArchiveLogsCommand.swift:57:84: error: type 'LogPrivacyLevel' has no member 'protected'\n 55 |             destinationId: destinationId,\n 56 |             additionalMetadata: [\n 57 |                 \"destinationPath\": (value: options.destinationPath, privacyLevel: .protected),\n    |                                                                                    `- error: type 'LogPrivacyLevel' has no member 'protected'\n 58 |                 \"compress\": (value: String(options.compress), privacyLevel: .public),\n 59 |                 \"format\": (value: options.format.rawValue, privacyLevel: .public),\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ArchiveLogsCommand.swift:70:37: error: cannot find 'getDestination' in scope\n 68 |         do {\n 69 |             // Check if destination exists\n 70 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 71 |                 throw LoggingError.destinationNotFound(\n 72 |                     \"Cannot archive logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ArchiveLogsCommand.swift:113:103: error: type 'LogPrivacyLevel' has no member 'protected'\n111 |                     context: operationContext,\n112 |                     additionalMetadata: [\n113 |                         \"archivePath\": (value: archiveResult.archivePath ?? \"unknown\", privacyLevel: .protected),\n    |                                                                                                       `- error: type 'LogPrivacyLevel' has no member 'protected'\n114 |                         \"archiveSizeBytes\": (value: String(archiveResult.archiveSizeBytes ?? 0), privacyLevel: .public),\n115 |                         \"archivedEntryCount\": (value: String(archiveResult.archivedEntryCount ?? 0), privacyLevel: .public)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ExportLogsCommand.swift:70:37: error: cannot find 'getDestination' in scope\n 68 |         do {\n 69 |             // Check if destination exists\n 70 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 71 |                 throw LoggingError.destinationNotFound(\n 72 |                     \"Cannot export logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:79:50: error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n 77 |                 key: key,\n 78 |                 value: value.value,\n 79 |                 privacyLevel: value.privacyLevel.toPrivacyClassification()\n    |                                                  `- error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n 80 |             )\n 81 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:122:54: error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n120 |                     key: key,\n121 |                     value: value.value,\n122 |                     privacyLevel: value.privacyLevel.toPrivacyClassification()\n    |                                                      `- error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n123 |                 )\n124 |             )\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:229:21: error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n227 |         \n228 |         // Process special fields first\n229 |         switch rule.field {\n    |                     `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n230 |         case \"level\":\n231 |             fieldValue = entry.level.rawValue\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:238:96: error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n236 |         default:\n237 |             // Check metadata fields\n238 |             if let metadata = entry.metadata, let metadataValue = metadata.getString(key: rule.field) {\n    |                                                                                                `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n239 |                 fieldValue = metadataValue\n240 |             } else {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:246:21: error: value of type 'UmbraLogFilterRuleDTO' has no member 'operation'\n244 |         \n245 |         // Apply the operation\n246 |         switch rule.operation {\n    |                     `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'operation'\n247 |         case .equals:\n248 |             return fieldValue == rule.value\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:248:39: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n246 |         switch rule.operation {\n247 |         case .equals:\n248 |             return fieldValue == rule.value\n    |                                       `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n249 |         case .contains:\n250 |             return fieldValue.contains(rule.value)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:250:45: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n248 |             return fieldValue == rule.value\n249 |         case .contains:\n250 |             return fieldValue.contains(rule.value)\n    |                                             `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n251 |         case .startsWith:\n252 |             return fieldValue.hasPrefix(rule.value)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:252:46: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n250 |             return fieldValue.contains(rule.value)\n251 |         case .startsWith:\n252 |             return fieldValue.hasPrefix(rule.value)\n    |                                              `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n253 |         case .endsWith:\n254 |             return fieldValue.hasSuffix(rule.value)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:254:46: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n252 |             return fieldValue.hasPrefix(rule.value)\n253 |         case .endsWith:\n254 |             return fieldValue.hasSuffix(rule.value)\n    |                                              `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n255 |         case .matches:\n256 |             if let regex = try? NSRegularExpression(pattern: rule.value) {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:256:67: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n254 |             return fieldValue.hasSuffix(rule.value)\n255 |         case .matches:\n256 |             if let regex = try? NSRegularExpression(pattern: rule.value) {\n    |                                                                   `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n257 |                 let range = NSRange(location: 0, length: fieldValue.utf16.count)\n258 |                 return regex.firstMatch(in: fieldValue, options: [], range: range) != nil\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:262:86: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n260 |             return false\n261 |         case .greaterThan:\n262 |             if let fieldNumeric = Double(fieldValue), let valueNumeric = Double(rule.value) {\n    |                                                                                      `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n263 |                 return fieldNumeric \u003e valueNumeric\n264 |             }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:267:86: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n265 |             return false\n266 |         case .lessThan:\n267 |             if let fieldNumeric = Double(fieldValue), let valueNumeric = Double(rule.value) {\n    |                                                                                      `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n268 |                 return fieldNumeric \u003c valueNumeric\n269 |             }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:293:13: warning: variable 'redactedMetadata' was never mutated; consider changing to 'let' constant\n291 |         // Create mutable copies\n292 |         var redactedMessage = entry.message\n293 |         var redactedMetadata = entry.metadata\n    |             `- warning: variable 'redactedMetadata' was never mutated; consider changing to 'let' constant\n294 |         \n295 |         for rule in rules {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:395:47: error: value of type 'String' has no member 'stringByReplacingMatches'\n393 |             if rule.targetFields.isEmpty || rule.targetFields.contains(\"message\") {\n394 |                 if let pattern = rule.pattern {\n395 |                     redactedMessage = pattern.stringByReplacingMatches(\n    |                                               `- error: value of type 'String' has no member 'stringByReplacingMatches'\n396 |                         in: redactedMessage,\n397 |                         options: [],\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:394:20: error: initializer for conditional binding must have Optional type, not 'String'\n392 |             // Apply rule to message if it matches\n393 |             if rule.targetFields.isEmpty || rule.targetFields.contains(\"message\") {\n394 |                 if let pattern = rule.pattern {\n    |                    `- error: initializer for conditional binding must have Optional type, not 'String'\n395 |                     redactedMessage = pattern.stringByReplacingMatches(\n396 |                         in: redactedMessage,\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:405:24: error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getKeys' of wrapped base type 'LogMetadataDTOCollection'\n403 |             \n404 |             // Process metadata fields\n405 |             for key in redactedMetadata.getKeys() {\n    |                        |- error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getKeys' of wrapped base type 'LogMetadataDTOCollection'\n    |                        |- note: chain the optional using '?' to access member 'getKeys' only for non-'nil' base values\n    |                        `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n406 |                 if rule.targetFields.isEmpty || rule.targetFields.contains(key) {\n407 |                     if let stringValue = redactedMetadata.getString(key: key) {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:407:42: error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getString' of wrapped base type 'LogMetadataDTOCollection'\n405 |             for key in redactedMetadata.getKeys() {\n406 |                 if rule.targetFields.isEmpty || rule.targetFields.contains(key) {\n407 |                     if let stringValue = redactedMetadata.getString(key: key) {\n    |                                          |- error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getString' of wrapped base type 'LogMetadataDTOCollection'\n    |                                          |- note: chain the optional using '?' to access member 'getString' only for non-'nil' base values\n    |                                          `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n408 |                         // Skip fields that should be preserved\n409 |                         if rule.preserveFields.contains(key) {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:468:15: error: type 'LogPrivacyLevel' has no member 'never'\n466 |         case .auto:\n467 |             return .auto\n468 |         case .never:\n    |               `- error: type 'LogPrivacyLevel' has no member 'never'\n469 |             return .public // Map 'never' to public classification\n470 |         case .protected:\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:470:15: error: type 'LogPrivacyLevel' has no member 'protected'\n468 |         case .never:\n469 |             return .public // Map 'never' to public classification\n470 |         case .protected:\n    |               `- error: type 'LogPrivacyLevel' has no member 'protected'\n471 |             return .private // Map 'protected' to private classification\n472 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:58:84: error: type 'LogPrivacyLevel' has no member 'protected'\n 56 |             additionalMetadata: [\n 57 |                 \"createBackup\": (value: String(options.createBackup), privacyLevel: .public),\n 58 |                 \"backupPath\": (value: options.backupPath ?? \"none\", privacyLevel: .protected),\n    |                                                                                    `- error: type 'LogPrivacyLevel' has no member 'protected'\n 59 |                 \"dryRun\": (value: String(options.dryRun), privacyLevel: .public),\n 60 |                 \"hasFilterCriteria\": (value: String(options.filterCriteria != nil), privacyLevel: .public),\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:184:34: error: cannot find 'getDestination' in scope\n182 |         if let destinationId = destinationId {\n183 |             // Use specific destination\n184 |             if let destination = getDestination(id: destinationId) {\n    |                                  `- error: cannot find 'getDestination' in scope\n185 |                 return [destination]\n186 |             } else {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:196:38: error: cannot find 'getDestination' in scope\n194 |             \n195 |             for id in options.destinationIds {\n196 |                 if let destination = getDestination(id: id) {\n    |                                      `- error: cannot find 'getDestination' in scope\n197 |                     result.append(destination)\n198 |                 } else {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:208:20: error: cannot find 'getAllDestinations' in scope\n206 |         } else {\n207 |             // Use all registered destinations\n208 |             return getAllDestinations()\n    |                    `- error: cannot find 'getAllDestinations' in scope\n209 |         }\n210 |     }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/QueryLogsCommand.swift:71:37: error: cannot find 'getDestination' in scope\n 69 |         do {\n 70 |             // Check if destination exists\n 71 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 72 |                 throw LoggingError.destinationNotFound(\n 73 |                     \"Cannot query logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RedactionRule.swift:123:72: error: missing argument for parameter 'privacyLevel' in call\n121 |                 if value != redactedValue {\n122 |                     // Only update if actually changed\n123 |                     result = result.with(key: key, value: redactedValue)\n    |                                                                        `- error: missing argument for parameter 'privacyLevel' in call\n124 |                 }\n125 |             }\n\n/Users/mpy/.bazel/execroot/_main/packages/UmbraCoreTypes/Sources/LoggingTypes/LogMetadataDTOCollection.swift:78:15: note: 'with(key:value:privacyLevel:)' declared here\n 76 |   ///   - privacyLevel: The privacy classification for this entry\n 77 |   /// - Returns: The updated collection\n 78 |   public func with(\n    |               `- note: 'with(key:value:privacyLevel:)' declared here\n 79 |     key: String,\n 80 |     value: String,\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RedactionRule.swift:101:26: warning: no calls to throwing functions occur within 'try' expression\n 99 |     public func redact(metadata: LogMetadataDTOCollection) -\u003e LogMetadataDTOCollection {\n100 |         // No redaction needed for empty metadata\n101 |         guard let keys = try? metadata.getKeys() else {\n    |                          `- warning: no calls to throwing functions occur within 'try' expression\n102 |             return metadata\n103 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RedactionRule.swift:119:28: warning: no calls to throwing functions occur within 'try' expression\n117 |             \n118 |             // Get string value and apply redaction\n119 |             if let value = try? metadata.getString(key: key) {\n    |                            `- warning: no calls to throwing functions occur within 'try' expression\n120 |                 let redactedValue = redact(value)\n121 |                 if value != redactedValue {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RemoveDestinationCommand.swift:67:37: error: cannot find 'getDestination' in scope\n 65 |         do {\n 66 |             // Check if destination exists\n 67 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 68 |                 throw LoggingError.destinationNotFound(\n 69 |                     \"Cannot remove destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RemoveDestinationCommand.swift:128:13: error: expression is 'async' but is not marked with 'await'\n126 |             \n127 |             // Unregister the destination\n128 |             unregisterDestination(id: destinationId)\n    |             |- error: expression is 'async' but is not marked with 'await'\n    |             `- note: calls to instance method 'unregisterDestination(id:)' from outside of its actor context are implicitly asynchronous\n129 |             \n130 |             // Log success\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RotateLogsCommand.swift:67:37: error: cannot find 'getDestination' in scope\n 65 |         do {\n 66 |             // Check if destination exists\n 67 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 68 |                 throw LoggingError.destinationNotFound(\n 69 |                     \"Cannot rotate logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RotateLogsCommand.swift:74:37: error: cannot infer contextual base in reference to member 'file'\n 72 |             \n 73 |             // Check if the destination type supports rotation\n 74 |             if destination.type != .file {\n    |                                     `- error: cannot infer contextual base in reference to member 'file'\n 75 |                 throw LoggingError.invalidDestinationConfig(\n 76 |                     \"Log rotation is only supported for file destinations\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RotateLogsCommand.swift:92:112: error: type 'LogPrivacyLevel' has no member 'protected'\n 90 |                     context: operationContext,\n 91 |                     additionalMetadata: [\n 92 |                         \"rotatedFilePath\": (value: rotationResult.rotatedFilePath ?? \"unknown\", privacyLevel: .protected),\n    |                                                                                                                `- error: type 'LogPrivacyLevel' has no member 'protected'\n 93 |                         \"rotatedSizeBytes\": (value: String(rotationResult.rotatedSizeBytes ?? 0), privacyLevel: .public),\n 94 |                         \"rotatedEntryCount\": (value: String(rotationResult.rotatedEntryCount ?? 0), privacyLevel: .public)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/WriteLogCommand.swift:159:20: error: cannot find 'getAllDestinations' in scope\n157 |         if destinationIds.isEmpty {\n158 |             // Use all registered destinations\n159 |             return getAllDestinations().filter { $0.isEnabled }\n    |                    `- error: cannot find 'getAllDestinations' in scope\n160 |         } else {\n161 |             // Use specific destinations\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/WriteLogCommand.swift:165:38: error: cannot find 'getDestination' in scope\n163 |             \n164 |             for destinationId in destinationIds {\n165 |                 if let destination = getDestination(id: destinationId) {\n    |                                      `- error: cannot find 'getDestination' in scope\n166 |                     if destination.isEnabled {\n167 |                         result.append(destination)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/WriteLogCommand.swift:193:16: error: cannot find 'applyFilterRules' in scope\n191 |         \n192 |         // Apply filter rules if they exist\n193 |         return applyFilterRules(\n    |                `- error: cannot find 'applyFilterRules' in scope\n194 |             to: entry,\n195 |             rules: destination.configuration.filterRules\n\npackages/UmbraImplementations/Sources/LoggingServices/DefaultLoggingServiceImpl.swift:39:36: warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 37 |     let contextDTO=BaseLogContextDTO(\n 38 |       domainName: \"Legacy\",\n 39 |       operation: context.operation ?? \"unknown\",\n    |                                    `- warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 40 |       category: context.category ?? \"General\",\n 41 |       source: context.source ?? \"Unknown\",\n\npackages/UmbraImplementations/Sources/LoggingServices/DefaultLoggingServiceImpl.swift:40:34: warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 38 |       domainName: \"Legacy\",\n 39 |       operation: context.operation ?? \"unknown\",\n 40 |       category: context.category ?? \"General\",\n    |                                  `- warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 41 |       source: context.source ?? \"Unknown\",\n 42 |       metadata: context.metadata\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:147:17: error: invalid redeclaration of 'log(_:_:context:)'\n145 |         - context: The logging context\n146 |      */\n147 |     public func log(_ level: LogLevel, _ message: String, context: any LogContextDTO) async {\n    |                 `- error: invalid redeclaration of 'log(_:_:context:)'\n148 |         // Convert to privacy string and use privacy-aware logging\n149 |         let privacyString = PrivacyString(stringLiteral: message)\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:92:48: error: value of type 'any LoggingProviderProtocol' has no member 'writeLogEntry'\n 90 |                     do {\n 91 |                         // Write log entry to destination\n 92 |                         _ = try await provider.writeLogEntry(entry, to: destination)\n    |                                                `- error: value of type 'any LoggingProviderProtocol' has no member 'writeLogEntry'\n 93 |                     } catch {\n 94 |                         // Silently ignore provider errors for now\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:122:28: error: value of type 'PrivacyString' has no member 'privacy'\n120 |         enrichedMetadata = enrichedMetadata.withPrivate(\n121 |             key: \"__privacy_annotation\", \n122 |             value: message.privacy.description\n    |                            `- error: value of type 'PrivacyString' has no member 'privacy'\n123 |         )\n124 |         \n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:136:34: error: value of type 'PrivacyString' has no member 'content'\n134 |         \n135 |         // Log the message using the standard log method\n136 |         await log(level, message.content, context: privacyContext)\n    |                                  `- error: value of type 'PrivacyString' has no member 'content'\n137 |     }\n138 |     \n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:167:71: error: value of type 'PrivacyAnnotatedString' has no member 'stringValue'\n165 |     ) async {\n166 |         let annotatedString = privacyScope()\n167 |         await log(level, PrivacyString(stringLiteral: annotatedString.stringValue), context: context) \n    |                                                                       `- error: value of type 'PrivacyAnnotatedString' has no member 'stringValue'\n168 |     }\n169 |     \n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:190:29: error: for-in loop requires 'LogMetadata' to conform to 'Sequence'\n188 |         // Create a metadata collection with sensitive values\n189 |         var metadataCollection = context.metadata\n190 |         for (key, value) in sensitiveValues {\n    |                             `- error: for-in loop requires 'LogMetadata' to conform to 'Sequence'\n191 |             metadataCollection = metadataCollection.withSensitive(key: key, value: String(describing: value))\n192 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:228:9: error: switch must be exhaustive\n226 |         \n227 |         // Add error information to metadata with appropriate privacy level\n228 |         switch privacyLevel {\n    |         |- error: switch must be exhaustive\n    |         `- note: add missing case: '.auto'\n229 |         case .public:\n230 |             metadataCollection = metadataCollection.withPublic(key: \"error_description\", value: error.localizedDescription)\npackages/UmbraImplementations/Sources/LoggingServices/PrivacyAwareLogDTO.swift:217:24: error: value of type 'LogMetadataDTOCollection' has no member 'set'\n215 |     for key in self.metadata.getKeys() {\n216 |       if let value = self.metadata.getString(key: key) {\n217 |         mergedMetadata.set(key: key, value: value)\n    |                        `- error: value of type 'LogMetadataDTOCollection' has no member 'set'\n218 |       }\n219 |     }\n\npackages/UmbraImplementations/Sources/LoggingServices/PrivacyAwareLogDTO.swift:224:24: error: value of type 'LogMetadataDTOCollection' has no member 'set'\n222 |     for key in additionalMetadata.getKeys() {\n223 |       if let value = additionalMetadata.getString(key: key) {\n224 |         mergedMetadata.set(key: key, value: value)\n    |                        `- error: value of type 'LogMetadataDTOCollection' has no member 'set'\n225 |       }\n226 |     }\n\npackages/UmbraImplementations/Sources/LoggingServices/PrivacyAwareLogDTO.swift:235:17: error: cannot convert value of type 'LogMetadataDTOCollection' to expected argument type '[String : (value: Any, privacy: LogPrivacyLevel)]'\n233 |       category: category,\n234 |       correlationID: correlationID,\n235 |       metadata: mergedMetadata,\n    |                 `- error: cannot convert value of type 'LogMetadataDTOCollection' to expected argument type '[String : (value: Any, privacy: LogPrivacyLevel)]'\n236 |       environment: environment\n237 |     )\nTarget //packages/UmbraImplementations/Sources/CoreServices:CoreServices failed to build\nINFO: Elapsed time: 1.148s, Critical Path: 1.01s\nINFO: 2 processes: 1 action cache hit, 2 internal.\nERROR: Build did NOT complete successfully\n"
  },
  {
    "target": "rule //packages/UmbraImplementations/Sources/CryptoServices:CryptoServices",
    "success": false,
    "start_time": "2025-04-11T17:57:55.838124+01:00",
    "end_time": "2025-04-11T17:57:57.708787+01:00",
    "duration": "1.870665583s",
    "output": "INFO: Invocation ID: 0468b45d-8b90-499e-9208-2d949a0da48e\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraImplementations/Sources/CryptoServices:CryptoServices (0 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraImplementations/Sources/CryptoServices:CryptoServices (0 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraImplementations/Sources/CryptoServices:CryptoServices (0 packages loaded, 0 targets configured).\nERROR: /Users/mpy/CascadeProjects/UmbraCore/packages/UmbraImplementations/Sources/LoggingServices/BUILD.bazel:3:20: Compiling Swift module //packages/UmbraImplementations/Sources/LoggingServices:LoggingServices failed: (Exit 1): worker failed: error executing SwiftCompile command (from target //packages/UmbraImplementations/Sources/LoggingServices:LoggingServices) \n  (cd /Users/mpy/.bazel/execroot/_main \u0026\u0026 \\\n  exec env - \\\n    APPLE_SDK_PLATFORM=MacOSX \\\n    APPLE_SDK_VERSION_OVERRIDE=15.4 \\\n    CC=clang \\\n    PATH=/Users/mpy/Library/Caches/bazelisk/downloads/sha256/ac72ad67f7a8c6b18bf605d8602425182b417de4369715bf89146daf62f7ae48/bin:/Users/mpy/.rbenv/bin:/Users/mpy/.codeium/windsurf/bin:/opt/homebrew/opt/node@18/bin:/opt/homebrew/opt/node@20/bin:/Users/mpy/.docker/bin:/opt/homebrew/opt/openjdk/bin:/Users/mpy/bin:/opt/homebrew/bin:/opt/homebrew/sbin:/usr/local/bin:/System/Cryptexes/App/usr/bin:/usr/bin:/bin:/usr/sbin:/sbin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/local/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/appleinternal/bin:/Library/Apple/usr/bin:/usr/local/go/bin:/Users/mpy/.rbenv/bin:/Users/mpy/.codeium/windsurf/bin:/opt/homebrew/opt/node@18/bin:/opt/homebrew/opt/node@20/bin:/opt/anaconda3/bin:/opt/anaconda3/condabin:/Users/mpy/.docker/bin:/opt/homebrew/opt/openjdk/bin:/Users/mpy/bin:/Users/mpy/.cargo/bin:/Users/mpy/Library/Python/3.8/bin:/Users/mpy/go/bin:/Users/mpy/.scripts:/Users/mpy/.fzf/bin:/Users/mpy/.windsurf/extensions/ms-python.debugpy-2025.6.0-darwin-arm64/bundled/scripts/noConfigScripts:/Users/mpy/Library/Python/3.8/bin:/Users/mpy/go/bin:/Users/mpy/.scripts \\\n    XCODE_VERSION_OVERRIDE=16.3.0.16E140 \\\n  bazel-out/darwin_arm64-opt-exec-ST-d57f47055a04/bin/external/rules_swift+/tools/worker/worker swiftc @bazel-out/darwin_arm64-fastbuild/bin/packages/UmbraImplementations/Sources/LoggingServices/LoggingServices.swiftmodule-0.params)\n# Configuration: 76a1bf3a80f2d50513004915454165d2f164db794b63e4666809cbd93e1abeaa\n# Execution platform: @@platforms//host:host\nerror: emit-module command failed with exit code 1 (use -v to see invocation)\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:147:17: error: invalid redeclaration of 'log(_:_:context:)'\n145 |         - context: The logging context\n146 |      */\n147 |     public func log(_ level: LogLevel, _ message: String, context: any LogContextDTO) async {\n    |                 `- error: invalid redeclaration of 'log(_:_:context:)'\n148 |         // Convert to privacy string and use privacy-aware logging\n149 |         let privacyString = PrivacyString(stringLiteral: message)\npackages/UmbraImplementations/Sources/LoggingServices/Commands/AddDestinationCommand.swift:68:31: error: cannot find 'getDestination' in scope\n 66 |         do {\n 67 |             // Check if destination already exists\n 68 |             if let existing = getDestination(id: destination.id) {\n    |                               `- error: cannot find 'getDestination' in scope\n 69 |                 if !options.overwriteExisting {\n 70 |                     throw LoggingError.destinationAlreadyExists(identifier: \"Destination with ID \\(destination.id) already exists\")\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/AddDestinationCommand.swift:82:40: error: cannot find 'validateDestination' in scope\n 80 |             // Validate destination configuration if requested\n 81 |             if options.validateConfiguration {\n 82 |                 let validationResult = validateDestination(destination, for: provider)\n    |                                        `- error: cannot find 'validateDestination' in scope\n 83 |                 \n 84 |                 if !validationResult.isValid {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/AddDestinationCommand.swift:121:13: error: expression is 'async' but is not marked with 'await'\n119 |             \n120 |             // Register the destination\n121 |             registerDestination(destination)\n    |             |- error: expression is 'async' but is not marked with 'await'\n    |             `- note: calls to instance method 'registerDestination' from outside of its actor context are implicitly asynchronous\n122 |             \n123 |             // Log success\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ArchiveLogsCommand.swift:57:84: error: type 'LogPrivacyLevel' has no member 'protected'\n 55 |             destinationId: destinationId,\n 56 |             additionalMetadata: [\n 57 |                 \"destinationPath\": (value: options.destinationPath, privacyLevel: .protected),\n    |                                                                                    `- error: type 'LogPrivacyLevel' has no member 'protected'\n 58 |                 \"compress\": (value: String(options.compress), privacyLevel: .public),\n 59 |                 \"format\": (value: options.format.rawValue, privacyLevel: .public),\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ArchiveLogsCommand.swift:70:37: error: cannot find 'getDestination' in scope\n 68 |         do {\n 69 |             // Check if destination exists\n 70 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 71 |                 throw LoggingError.destinationNotFound(\n 72 |                     \"Cannot archive logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ArchiveLogsCommand.swift:113:103: error: type 'LogPrivacyLevel' has no member 'protected'\n111 |                     context: operationContext,\n112 |                     additionalMetadata: [\n113 |                         \"archivePath\": (value: archiveResult.archivePath ?? \"unknown\", privacyLevel: .protected),\n    |                                                                                                       `- error: type 'LogPrivacyLevel' has no member 'protected'\n114 |                         \"archiveSizeBytes\": (value: String(archiveResult.archiveSizeBytes ?? 0), privacyLevel: .public),\n115 |                         \"archivedEntryCount\": (value: String(archiveResult.archivedEntryCount ?? 0), privacyLevel: .public)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ExportLogsCommand.swift:70:37: error: cannot find 'getDestination' in scope\n 68 |         do {\n 69 |             // Check if destination exists\n 70 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 71 |                 throw LoggingError.destinationNotFound(\n 72 |                     \"Cannot export logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:79:50: error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n 77 |                 key: key,\n 78 |                 value: value.value,\n 79 |                 privacyLevel: value.privacyLevel.toPrivacyClassification()\n    |                                                  `- error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n 80 |             )\n 81 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:122:54: error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n120 |                     key: key,\n121 |                     value: value.value,\n122 |                     privacyLevel: value.privacyLevel.toPrivacyClassification()\n    |                                                      `- error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n123 |                 )\n124 |             )\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:229:21: error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n227 |         \n228 |         // Process special fields first\n229 |         switch rule.field {\n    |                     `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n230 |         case \"level\":\n231 |             fieldValue = entry.level.rawValue\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:238:96: error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n236 |         default:\n237 |             // Check metadata fields\n238 |             if let metadata = entry.metadata, let metadataValue = metadata.getString(key: rule.field) {\n    |                                                                                                `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n239 |                 fieldValue = metadataValue\n240 |             } else {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:246:21: error: value of type 'UmbraLogFilterRuleDTO' has no member 'operation'\n244 |         \n245 |         // Apply the operation\n246 |         switch rule.operation {\n    |                     `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'operation'\n247 |         case .equals:\n248 |             return fieldValue == rule.value\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:248:39: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n246 |         switch rule.operation {\n247 |         case .equals:\n248 |             return fieldValue == rule.value\n    |                                       `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n249 |         case .contains:\n250 |             return fieldValue.contains(rule.value)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:250:45: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n248 |             return fieldValue == rule.value\n249 |         case .contains:\n250 |             return fieldValue.contains(rule.value)\n    |                                             `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n251 |         case .startsWith:\n252 |             return fieldValue.hasPrefix(rule.value)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:252:46: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n250 |             return fieldValue.contains(rule.value)\n251 |         case .startsWith:\n252 |             return fieldValue.hasPrefix(rule.value)\n    |                                              `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n253 |         case .endsWith:\n254 |             return fieldValue.hasSuffix(rule.value)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:254:46: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n252 |             return fieldValue.hasPrefix(rule.value)\n253 |         case .endsWith:\n254 |             return fieldValue.hasSuffix(rule.value)\n    |                                              `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n255 |         case .matches:\n256 |             if let regex = try? NSRegularExpression(pattern: rule.value) {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:256:67: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n254 |             return fieldValue.hasSuffix(rule.value)\n255 |         case .matches:\n256 |             if let regex = try? NSRegularExpression(pattern: rule.value) {\n    |                                                                   `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n257 |                 let range = NSRange(location: 0, length: fieldValue.utf16.count)\n258 |                 return regex.firstMatch(in: fieldValue, options: [], range: range) != nil\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:262:86: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n260 |             return false\n261 |         case .greaterThan:\n262 |             if let fieldNumeric = Double(fieldValue), let valueNumeric = Double(rule.value) {\n    |                                                                                      `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n263 |                 return fieldNumeric \u003e valueNumeric\n264 |             }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:267:86: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n265 |             return false\n266 |         case .lessThan:\n267 |             if let fieldNumeric = Double(fieldValue), let valueNumeric = Double(rule.value) {\n    |                                                                                      `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n268 |                 return fieldNumeric \u003c valueNumeric\n269 |             }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:293:13: warning: variable 'redactedMetadata' was never mutated; consider changing to 'let' constant\n291 |         // Create mutable copies\n292 |         var redactedMessage = entry.message\n293 |         var redactedMetadata = entry.metadata\n    |             `- warning: variable 'redactedMetadata' was never mutated; consider changing to 'let' constant\n294 |         \n295 |         for rule in rules {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:395:47: error: value of type 'String' has no member 'stringByReplacingMatches'\n393 |             if rule.targetFields.isEmpty || rule.targetFields.contains(\"message\") {\n394 |                 if let pattern = rule.pattern {\n395 |                     redactedMessage = pattern.stringByReplacingMatches(\n    |                                               `- error: value of type 'String' has no member 'stringByReplacingMatches'\n396 |                         in: redactedMessage,\n397 |                         options: [],\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:394:20: error: initializer for conditional binding must have Optional type, not 'String'\n392 |             // Apply rule to message if it matches\n393 |             if rule.targetFields.isEmpty || rule.targetFields.contains(\"message\") {\n394 |                 if let pattern = rule.pattern {\n    |                    `- error: initializer for conditional binding must have Optional type, not 'String'\n395 |                     redactedMessage = pattern.stringByReplacingMatches(\n396 |                         in: redactedMessage,\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:405:24: error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getKeys' of wrapped base type 'LogMetadataDTOCollection'\n403 |             \n404 |             // Process metadata fields\n405 |             for key in redactedMetadata.getKeys() {\n    |                        |- error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getKeys' of wrapped base type 'LogMetadataDTOCollection'\n    |                        |- note: chain the optional using '?' to access member 'getKeys' only for non-'nil' base values\n    |                        `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n406 |                 if rule.targetFields.isEmpty || rule.targetFields.contains(key) {\n407 |                     if let stringValue = redactedMetadata.getString(key: key) {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:407:42: error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getString' of wrapped base type 'LogMetadataDTOCollection'\n405 |             for key in redactedMetadata.getKeys() {\n406 |                 if rule.targetFields.isEmpty || rule.targetFields.contains(key) {\n407 |                     if let stringValue = redactedMetadata.getString(key: key) {\n    |                                          |- error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getString' of wrapped base type 'LogMetadataDTOCollection'\n    |                                          |- note: chain the optional using '?' to access member 'getString' only for non-'nil' base values\n    |                                          `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n408 |                         // Skip fields that should be preserved\n409 |                         if rule.preserveFields.contains(key) {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:468:15: error: type 'LogPrivacyLevel' has no member 'never'\n466 |         case .auto:\n467 |             return .auto\n468 |         case .never:\n    |               `- error: type 'LogPrivacyLevel' has no member 'never'\n469 |             return .public // Map 'never' to public classification\n470 |         case .protected:\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:470:15: error: type 'LogPrivacyLevel' has no member 'protected'\n468 |         case .never:\n469 |             return .public // Map 'never' to public classification\n470 |         case .protected:\n    |               `- error: type 'LogPrivacyLevel' has no member 'protected'\n471 |             return .private // Map 'protected' to private classification\n472 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:58:84: error: type 'LogPrivacyLevel' has no member 'protected'\n 56 |             additionalMetadata: [\n 57 |                 \"createBackup\": (value: String(options.createBackup), privacyLevel: .public),\n 58 |                 \"backupPath\": (value: options.backupPath ?? \"none\", privacyLevel: .protected),\n    |                                                                                    `- error: type 'LogPrivacyLevel' has no member 'protected'\n 59 |                 \"dryRun\": (value: String(options.dryRun), privacyLevel: .public),\n 60 |                 \"hasFilterCriteria\": (value: String(options.filterCriteria != nil), privacyLevel: .public),\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:184:34: error: cannot find 'getDestination' in scope\n182 |         if let destinationId = destinationId {\n183 |             // Use specific destination\n184 |             if let destination = getDestination(id: destinationId) {\n    |                                  `- error: cannot find 'getDestination' in scope\n185 |                 return [destination]\n186 |             } else {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:196:38: error: cannot find 'getDestination' in scope\n194 |             \n195 |             for id in options.destinationIds {\n196 |                 if let destination = getDestination(id: id) {\n    |                                      `- error: cannot find 'getDestination' in scope\n197 |                     result.append(destination)\n198 |                 } else {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:208:20: error: cannot find 'getAllDestinations' in scope\n206 |         } else {\n207 |             // Use all registered destinations\n208 |             return getAllDestinations()\n    |                    `- error: cannot find 'getAllDestinations' in scope\n209 |         }\n210 |     }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/QueryLogsCommand.swift:71:37: error: cannot find 'getDestination' in scope\n 69 |         do {\n 70 |             // Check if destination exists\n 71 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 72 |                 throw LoggingError.destinationNotFound(\n 73 |                     \"Cannot query logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RedactionRule.swift:123:72: error: missing argument for parameter 'privacyLevel' in call\n121 |                 if value != redactedValue {\n122 |                     // Only update if actually changed\n123 |                     result = result.with(key: key, value: redactedValue)\n    |                                                                        `- error: missing argument for parameter 'privacyLevel' in call\n124 |                 }\n125 |             }\n\n/Users/mpy/.bazel/execroot/_main/packages/UmbraCoreTypes/Sources/LoggingTypes/LogMetadataDTOCollection.swift:78:15: note: 'with(key:value:privacyLevel:)' declared here\n 76 |   ///   - privacyLevel: The privacy classification for this entry\n 77 |   /// - Returns: The updated collection\n 78 |   public func with(\n    |               `- note: 'with(key:value:privacyLevel:)' declared here\n 79 |     key: String,\n 80 |     value: String,\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RedactionRule.swift:101:26: warning: no calls to throwing functions occur within 'try' expression\n 99 |     public func redact(metadata: LogMetadataDTOCollection) -\u003e LogMetadataDTOCollection {\n100 |         // No redaction needed for empty metadata\n101 |         guard let keys = try? metadata.getKeys() else {\n    |                          `- warning: no calls to throwing functions occur within 'try' expression\n102 |             return metadata\n103 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RedactionRule.swift:119:28: warning: no calls to throwing functions occur within 'try' expression\n117 |             \n118 |             // Get string value and apply redaction\n119 |             if let value = try? metadata.getString(key: key) {\n    |                            `- warning: no calls to throwing functions occur within 'try' expression\n120 |                 let redactedValue = redact(value)\n121 |                 if value != redactedValue {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RemoveDestinationCommand.swift:67:37: error: cannot find 'getDestination' in scope\n 65 |         do {\n 66 |             // Check if destination exists\n 67 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 68 |                 throw LoggingError.destinationNotFound(\n 69 |                     \"Cannot remove destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RemoveDestinationCommand.swift:128:13: error: expression is 'async' but is not marked with 'await'\n126 |             \n127 |             // Unregister the destination\n128 |             unregisterDestination(id: destinationId)\n    |             |- error: expression is 'async' but is not marked with 'await'\n    |             `- note: calls to instance method 'unregisterDestination(id:)' from outside of its actor context are implicitly asynchronous\n129 |             \n130 |             // Log success\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RotateLogsCommand.swift:67:37: error: cannot find 'getDestination' in scope\n 65 |         do {\n 66 |             // Check if destination exists\n 67 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 68 |                 throw LoggingError.destinationNotFound(\n 69 |                     \"Cannot rotate logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RotateLogsCommand.swift:74:37: error: cannot infer contextual base in reference to member 'file'\n 72 |             \n 73 |             // Check if the destination type supports rotation\n 74 |             if destination.type != .file {\n    |                                     `- error: cannot infer contextual base in reference to member 'file'\n 75 |                 throw LoggingError.invalidDestinationConfig(\n 76 |                     \"Log rotation is only supported for file destinations\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RotateLogsCommand.swift:92:112: error: type 'LogPrivacyLevel' has no member 'protected'\n 90 |                     context: operationContext,\n 91 |                     additionalMetadata: [\n 92 |                         \"rotatedFilePath\": (value: rotationResult.rotatedFilePath ?? \"unknown\", privacyLevel: .protected),\n    |                                                                                                                `- error: type 'LogPrivacyLevel' has no member 'protected'\n 93 |                         \"rotatedSizeBytes\": (value: String(rotationResult.rotatedSizeBytes ?? 0), privacyLevel: .public),\n 94 |                         \"rotatedEntryCount\": (value: String(rotationResult.rotatedEntryCount ?? 0), privacyLevel: .public)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/WriteLogCommand.swift:159:20: error: cannot find 'getAllDestinations' in scope\n157 |         if destinationIds.isEmpty {\n158 |             // Use all registered destinations\n159 |             return getAllDestinations().filter { $0.isEnabled }\n    |                    `- error: cannot find 'getAllDestinations' in scope\n160 |         } else {\n161 |             // Use specific destinations\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/WriteLogCommand.swift:165:38: error: cannot find 'getDestination' in scope\n163 |             \n164 |             for destinationId in destinationIds {\n165 |                 if let destination = getDestination(id: destinationId) {\n    |                                      `- error: cannot find 'getDestination' in scope\n166 |                     if destination.isEnabled {\n167 |                         result.append(destination)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/WriteLogCommand.swift:193:16: error: cannot find 'applyFilterRules' in scope\n191 |         \n192 |         // Apply filter rules if they exist\n193 |         return applyFilterRules(\n    |                `- error: cannot find 'applyFilterRules' in scope\n194 |             to: entry,\n195 |             rules: destination.configuration.filterRules\n\npackages/UmbraImplementations/Sources/LoggingServices/DefaultLoggingServiceImpl.swift:39:36: warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 37 |     let contextDTO=BaseLogContextDTO(\n 38 |       domainName: \"Legacy\",\n 39 |       operation: context.operation ?? \"unknown\",\n    |                                    `- warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 40 |       category: context.category ?? \"General\",\n 41 |       source: context.source ?? \"Unknown\",\n\npackages/UmbraImplementations/Sources/LoggingServices/DefaultLoggingServiceImpl.swift:40:34: warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 38 |       domainName: \"Legacy\",\n 39 |       operation: context.operation ?? \"unknown\",\n 40 |       category: context.category ?? \"General\",\n    |                                  `- warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 41 |       source: context.source ?? \"Unknown\",\n 42 |       metadata: context.metadata\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:147:17: error: invalid redeclaration of 'log(_:_:context:)'\n145 |         - context: The logging context\n146 |      */\n147 |     public func log(_ level: LogLevel, _ message: String, context: any LogContextDTO) async {\n    |                 `- error: invalid redeclaration of 'log(_:_:context:)'\n148 |         // Convert to privacy string and use privacy-aware logging\n149 |         let privacyString = PrivacyString(stringLiteral: message)\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:92:48: error: value of type 'any LoggingProviderProtocol' has no member 'writeLogEntry'\n 90 |                     do {\n 91 |                         // Write log entry to destination\n 92 |                         _ = try await provider.writeLogEntry(entry, to: destination)\n    |                                                `- error: value of type 'any LoggingProviderProtocol' has no member 'writeLogEntry'\n 93 |                     } catch {\n 94 |                         // Silently ignore provider errors for now\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:122:28: error: value of type 'PrivacyString' has no member 'privacy'\n120 |         enrichedMetadata = enrichedMetadata.withPrivate(\n121 |             key: \"__privacy_annotation\", \n122 |             value: message.privacy.description\n    |                            `- error: value of type 'PrivacyString' has no member 'privacy'\n123 |         )\n124 |         \n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:136:34: error: value of type 'PrivacyString' has no member 'content'\n134 |         \n135 |         // Log the message using the standard log method\n136 |         await log(level, message.content, context: privacyContext)\n    |                                  `- error: value of type 'PrivacyString' has no member 'content'\n137 |     }\n138 |     \n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:167:71: error: value of type 'PrivacyAnnotatedString' has no member 'stringValue'\n165 |     ) async {\n166 |         let annotatedString = privacyScope()\n167 |         await log(level, PrivacyString(stringLiteral: annotatedString.stringValue), context: context) \n    |                                                                       `- error: value of type 'PrivacyAnnotatedString' has no member 'stringValue'\n168 |     }\n169 |     \n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:190:29: error: for-in loop requires 'LogMetadata' to conform to 'Sequence'\n188 |         // Create a metadata collection with sensitive values\n189 |         var metadataCollection = context.metadata\n190 |         for (key, value) in sensitiveValues {\n    |                             `- error: for-in loop requires 'LogMetadata' to conform to 'Sequence'\n191 |             metadataCollection = metadataCollection.withSensitive(key: key, value: String(describing: value))\n192 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:228:9: error: switch must be exhaustive\n226 |         \n227 |         // Add error information to metadata with appropriate privacy level\n228 |         switch privacyLevel {\n    |         |- error: switch must be exhaustive\n    |         `- note: add missing case: '.auto'\n229 |         case .public:\n230 |             metadataCollection = metadataCollection.withPublic(key: \"error_description\", value: error.localizedDescription)\npackages/UmbraImplementations/Sources/LoggingServices/PrivacyAwareLogDTO.swift:217:24: error: value of type 'LogMetadataDTOCollection' has no member 'set'\n215 |     for key in self.metadata.getKeys() {\n216 |       if let value = self.metadata.getString(key: key) {\n217 |         mergedMetadata.set(key: key, value: value)\n    |                        `- error: value of type 'LogMetadataDTOCollection' has no member 'set'\n218 |       }\n219 |     }\n\npackages/UmbraImplementations/Sources/LoggingServices/PrivacyAwareLogDTO.swift:224:24: error: value of type 'LogMetadataDTOCollection' has no member 'set'\n222 |     for key in additionalMetadata.getKeys() {\n223 |       if let value = additionalMetadata.getString(key: key) {\n224 |         mergedMetadata.set(key: key, value: value)\n    |                        `- error: value of type 'LogMetadataDTOCollection' has no member 'set'\n225 |       }\n226 |     }\n\npackages/UmbraImplementations/Sources/LoggingServices/PrivacyAwareLogDTO.swift:235:17: error: cannot convert value of type 'LogMetadataDTOCollection' to expected argument type '[String : (value: Any, privacy: LogPrivacyLevel)]'\n233 |       category: category,\n234 |       correlationID: correlationID,\n235 |       metadata: mergedMetadata,\n    |                 `- error: cannot convert value of type 'LogMetadataDTOCollection' to expected argument type '[String : (value: Any, privacy: LogPrivacyLevel)]'\n236 |       environment: environment\n237 |     )\nTarget //packages/UmbraImplementations/Sources/CryptoServices:CryptoServices failed to build\nINFO: Elapsed time: 1.134s, Critical Path: 1.00s\nINFO: 2 processes: 2 internal.\nERROR: Build did NOT complete successfully\n"
  },
  {
    "target": "rule //packages/UmbraImplementations/Sources/CryptoServices/Logging:CryptoLogger",
    "success": true,
    "start_time": "2025-04-11T17:57:57.708799+01:00",
    "end_time": "2025-04-11T17:57:58.968854+01:00",
    "duration": "1.260055792s",
    "output": "INFO: Invocation ID: e52c9b95-a09d-4ad7-a7fd-85c4f471c6b2\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraImplementations/Sources/CryptoServices/Logging:CryptoLogger (0 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraImplementations/Sources/CryptoServices/Logging:CryptoLogger (0 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraImplementations/Sources/CryptoServices/Logging:CryptoLogger (0 packages loaded, 0 targets configured).\nINFO: Found 1 target...\nTarget //packages/UmbraImplementations/Sources/CryptoServices/Logging:CryptoLogger up-to-date:\n  bazel-bin/packages/UmbraImplementations/Sources/CryptoServices/Logging/CryptoLogger.swiftdoc\n  bazel-bin/packages/UmbraImplementations/Sources/CryptoServices/Logging/CryptoLogger.swiftmodule\n  bazel-bin/packages/UmbraImplementations/Sources/CryptoServices/Logging/CryptoLogger.swiftsourceinfo\n  bazel-bin/packages/UmbraImplementations/Sources/CryptoServices/Logging/libCryptoLogger.a\nINFO: Elapsed time: 0.530s, Critical Path: 0.41s\nINFO: 2 processes: 1 internal, 1 local.\nINFO: Build completed successfully, 2 total actions\n"
  },
  {
    "target": "rule //packages/UmbraImplementations/Sources/CryptoXPCServices:CryptoXPCServices",
    "success": true,
    "start_time": "2025-04-11T17:57:58.968863+01:00",
    "end_time": "2025-04-11T17:58:00.269016+01:00",
    "duration": "1.300154s",
    "output": "INFO: Invocation ID: 2b840751-212a-4d90-8d30-a0f3f4ccd5df\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraImplementations/Sources/CryptoXPCServices:CryptoXPCServices (1 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraImplementations/Sources/CryptoXPCServices:CryptoXPCServices (1 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraImplementations/Sources/CryptoXPCServices:CryptoXPCServices (1 packages loaded, 4 targets configured).\nINFO: Found 1 target...\nTarget //packages/UmbraImplementations/Sources/CryptoXPCServices:CryptoXPCServices up-to-date:\n  bazel-bin/packages/UmbraImplementations/Sources/CryptoXPCServices/CryptoXPCServices.swiftdoc\n  bazel-bin/packages/UmbraImplementations/Sources/CryptoXPCServices/CryptoXPCServices.swiftmodule\n  bazel-bin/packages/UmbraImplementations/Sources/CryptoXPCServices/CryptoXPCServices.swiftsourceinfo\n  bazel-bin/packages/UmbraImplementations/Sources/CryptoXPCServices/libCryptoXPCServices.a\nINFO: Elapsed time: 0.633s, Critical Path: 0.51s\nINFO: 3 processes: 1 action cache hit, 1 disk cache hit, 1 internal, 1 worker.\nINFO: Build completed successfully, 3 total actions\n"
  },
  {
    "target": "rule //packages/UmbraImplementations/Sources/DateTimeServices:DateTimeServices",
    "success": true,
    "start_time": "2025-04-11T17:58:00.269021+01:00",
    "end_time": "2025-04-11T17:58:01.920865+01:00",
    "duration": "1.651845583s",
    "output": "INFO: Invocation ID: 47f903b4-ca5e-47c1-a15c-a1f8eab34b4a\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraImplementations/Sources/DateTimeServices:DateTimeServices (1 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraImplementations/Sources/DateTimeServices:DateTimeServices (1 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraImplementations/Sources/DateTimeServices:DateTimeServices (2 packages loaded, 8 targets configured).\nINFO: Found 1 target...\nTarget //packages/UmbraImplementations/Sources/DateTimeServices:DateTimeServices up-to-date:\n  bazel-bin/packages/UmbraImplementations/Sources/DateTimeServices/DateTimeServices.swiftdoc\n  bazel-bin/packages/UmbraImplementations/Sources/DateTimeServices/DateTimeServices.swiftmodule\n  bazel-bin/packages/UmbraImplementations/Sources/DateTimeServices/DateTimeServices.swiftsourceinfo\n  bazel-bin/packages/UmbraImplementations/Sources/DateTimeServices/libDateTimeServices.a\nINFO: Elapsed time: 0.937s, Critical Path: 0.80s\nINFO: 4 processes: 2 action cache hit, 1 disk cache hit, 1 internal, 2 worker.\nINFO: Build completed successfully, 4 total actions\n"
  },
  {
    "target": "rule //packages/UmbraImplementations/Sources/ErrorDomainsImpl:ErrorDomainsImpl",
    "success": true,
    "start_time": "2025-04-11T17:58:01.920871+01:00",
    "end_time": "2025-04-11T17:58:02.711448+01:00",
    "duration": "790.577958ms",
    "output": "INFO: Invocation ID: 6c31f63d-d35d-4057-9a6d-819219e7fc1e\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraImplementations/Sources/ErrorDomainsImpl:ErrorDomainsImpl (0 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraImplementations/Sources/ErrorDomainsImpl:ErrorDomainsImpl (0 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraImplementations/Sources/ErrorDomainsImpl:ErrorDomainsImpl (0 packages loaded, 0 targets configured).\nINFO: Found 1 target...\nTarget //packages/UmbraImplementations/Sources/ErrorDomainsImpl:ErrorDomainsImpl up-to-date:\n  bazel-bin/packages/UmbraImplementations/Sources/ErrorDomainsImpl/ErrorDomainsImpl.swiftdoc\n  bazel-bin/packages/UmbraImplementations/Sources/ErrorDomainsImpl/ErrorDomainsImpl.swiftmodule\n  bazel-bin/packages/UmbraImplementations/Sources/ErrorDomainsImpl/ErrorDomainsImpl.swiftsourceinfo\n  bazel-bin/packages/UmbraImplementations/Sources/ErrorDomainsImpl/libErrorDomainsImpl.a\nINFO: Elapsed time: 0.124s, Critical Path: 0.00s\nINFO: 1 process: 1 action cache hit, 1 internal.\nINFO: Build completed successfully, 1 total action\n"
  },
  {
    "target": "rule //packages/UmbraImplementations/Sources/ErrorHandlingImpl:ErrorHandlingImpl",
    "success": false,
    "start_time": "2025-04-11T17:58:02.711453+01:00",
    "end_time": "2025-04-11T17:58:04.542544+01:00",
    "duration": "1.831092542s",
    "output": "INFO: Invocation ID: 446838e3-4675-4b92-aca1-0fbfe0d0f075\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraImplementations/Sources/ErrorHandlingImpl:ErrorHandlingImpl (1 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraImplementations/Sources/ErrorHandlingImpl:ErrorHandlingImpl (1 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraImplementations/Sources/ErrorHandlingImpl:ErrorHandlingImpl (1 packages loaded, 4 targets configured).\nERROR: /Users/mpy/CascadeProjects/UmbraCore/packages/UmbraImplementations/Sources/LoggingServices/BUILD.bazel:3:20: Compiling Swift module //packages/UmbraImplementations/Sources/LoggingServices:LoggingServices failed: (Exit 1): worker failed: error executing SwiftCompile command (from target //packages/UmbraImplementations/Sources/LoggingServices:LoggingServices) \n  (cd /Users/mpy/.bazel/execroot/_main \u0026\u0026 \\\n  exec env - \\\n    APPLE_SDK_PLATFORM=MacOSX \\\n    APPLE_SDK_VERSION_OVERRIDE=15.4 \\\n    CC=clang \\\n    PATH=/Users/mpy/Library/Caches/bazelisk/downloads/sha256/ac72ad67f7a8c6b18bf605d8602425182b417de4369715bf89146daf62f7ae48/bin:/Users/mpy/.rbenv/bin:/Users/mpy/.codeium/windsurf/bin:/opt/homebrew/opt/node@18/bin:/opt/homebrew/opt/node@20/bin:/Users/mpy/.docker/bin:/opt/homebrew/opt/openjdk/bin:/Users/mpy/bin:/opt/homebrew/bin:/opt/homebrew/sbin:/usr/local/bin:/System/Cryptexes/App/usr/bin:/usr/bin:/bin:/usr/sbin:/sbin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/local/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/appleinternal/bin:/Library/Apple/usr/bin:/usr/local/go/bin:/Users/mpy/.rbenv/bin:/Users/mpy/.codeium/windsurf/bin:/opt/homebrew/opt/node@18/bin:/opt/homebrew/opt/node@20/bin:/opt/anaconda3/bin:/opt/anaconda3/condabin:/Users/mpy/.docker/bin:/opt/homebrew/opt/openjdk/bin:/Users/mpy/bin:/Users/mpy/.cargo/bin:/Users/mpy/Library/Python/3.8/bin:/Users/mpy/go/bin:/Users/mpy/.scripts:/Users/mpy/.fzf/bin:/Users/mpy/.windsurf/extensions/ms-python.debugpy-2025.6.0-darwin-arm64/bundled/scripts/noConfigScripts:/Users/mpy/Library/Python/3.8/bin:/Users/mpy/go/bin:/Users/mpy/.scripts \\\n    XCODE_VERSION_OVERRIDE=16.3.0.16E140 \\\n  bazel-out/darwin_arm64-opt-exec-ST-d57f47055a04/bin/external/rules_swift+/tools/worker/worker swiftc @bazel-out/darwin_arm64-fastbuild/bin/packages/UmbraImplementations/Sources/LoggingServices/LoggingServices.swiftmodule-0.params)\n# Configuration: 76a1bf3a80f2d50513004915454165d2f164db794b63e4666809cbd93e1abeaa\n# Execution platform: @@platforms//host:host\nerror: emit-module command failed with exit code 1 (use -v to see invocation)\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:147:17: error: invalid redeclaration of 'log(_:_:context:)'\n145 |         - context: The logging context\n146 |      */\n147 |     public func log(_ level: LogLevel, _ message: String, context: any LogContextDTO) async {\n    |                 `- error: invalid redeclaration of 'log(_:_:context:)'\n148 |         // Convert to privacy string and use privacy-aware logging\n149 |         let privacyString = PrivacyString(stringLiteral: message)\npackages/UmbraImplementations/Sources/LoggingServices/Commands/AddDestinationCommand.swift:68:31: error: cannot find 'getDestination' in scope\n 66 |         do {\n 67 |             // Check if destination already exists\n 68 |             if let existing = getDestination(id: destination.id) {\n    |                               `- error: cannot find 'getDestination' in scope\n 69 |                 if !options.overwriteExisting {\n 70 |                     throw LoggingError.destinationAlreadyExists(identifier: \"Destination with ID \\(destination.id) already exists\")\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/AddDestinationCommand.swift:82:40: error: cannot find 'validateDestination' in scope\n 80 |             // Validate destination configuration if requested\n 81 |             if options.validateConfiguration {\n 82 |                 let validationResult = validateDestination(destination, for: provider)\n    |                                        `- error: cannot find 'validateDestination' in scope\n 83 |                 \n 84 |                 if !validationResult.isValid {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/AddDestinationCommand.swift:121:13: error: expression is 'async' but is not marked with 'await'\n119 |             \n120 |             // Register the destination\n121 |             registerDestination(destination)\n    |             |- error: expression is 'async' but is not marked with 'await'\n    |             `- note: calls to instance method 'registerDestination' from outside of its actor context are implicitly asynchronous\n122 |             \n123 |             // Log success\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ArchiveLogsCommand.swift:57:84: error: type 'LogPrivacyLevel' has no member 'protected'\n 55 |             destinationId: destinationId,\n 56 |             additionalMetadata: [\n 57 |                 \"destinationPath\": (value: options.destinationPath, privacyLevel: .protected),\n    |                                                                                    `- error: type 'LogPrivacyLevel' has no member 'protected'\n 58 |                 \"compress\": (value: String(options.compress), privacyLevel: .public),\n 59 |                 \"format\": (value: options.format.rawValue, privacyLevel: .public),\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ArchiveLogsCommand.swift:70:37: error: cannot find 'getDestination' in scope\n 68 |         do {\n 69 |             // Check if destination exists\n 70 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 71 |                 throw LoggingError.destinationNotFound(\n 72 |                     \"Cannot archive logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ArchiveLogsCommand.swift:113:103: error: type 'LogPrivacyLevel' has no member 'protected'\n111 |                     context: operationContext,\n112 |                     additionalMetadata: [\n113 |                         \"archivePath\": (value: archiveResult.archivePath ?? \"unknown\", privacyLevel: .protected),\n    |                                                                                                       `- error: type 'LogPrivacyLevel' has no member 'protected'\n114 |                         \"archiveSizeBytes\": (value: String(archiveResult.archiveSizeBytes ?? 0), privacyLevel: .public),\n115 |                         \"archivedEntryCount\": (value: String(archiveResult.archivedEntryCount ?? 0), privacyLevel: .public)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ExportLogsCommand.swift:70:37: error: cannot find 'getDestination' in scope\n 68 |         do {\n 69 |             // Check if destination exists\n 70 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 71 |                 throw LoggingError.destinationNotFound(\n 72 |                     \"Cannot export logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:79:50: error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n 77 |                 key: key,\n 78 |                 value: value.value,\n 79 |                 privacyLevel: value.privacyLevel.toPrivacyClassification()\n    |                                                  `- error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n 80 |             )\n 81 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:122:54: error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n120 |                     key: key,\n121 |                     value: value.value,\n122 |                     privacyLevel: value.privacyLevel.toPrivacyClassification()\n    |                                                      `- error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n123 |                 )\n124 |             )\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:229:21: error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n227 |         \n228 |         // Process special fields first\n229 |         switch rule.field {\n    |                     `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n230 |         case \"level\":\n231 |             fieldValue = entry.level.rawValue\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:238:96: error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n236 |         default:\n237 |             // Check metadata fields\n238 |             if let metadata = entry.metadata, let metadataValue = metadata.getString(key: rule.field) {\n    |                                                                                                `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n239 |                 fieldValue = metadataValue\n240 |             } else {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:246:21: error: value of type 'UmbraLogFilterRuleDTO' has no member 'operation'\n244 |         \n245 |         // Apply the operation\n246 |         switch rule.operation {\n    |                     `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'operation'\n247 |         case .equals:\n248 |             return fieldValue == rule.value\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:248:39: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n246 |         switch rule.operation {\n247 |         case .equals:\n248 |             return fieldValue == rule.value\n    |                                       `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n249 |         case .contains:\n250 |             return fieldValue.contains(rule.value)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:250:45: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n248 |             return fieldValue == rule.value\n249 |         case .contains:\n250 |             return fieldValue.contains(rule.value)\n    |                                             `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n251 |         case .startsWith:\n252 |             return fieldValue.hasPrefix(rule.value)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:252:46: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n250 |             return fieldValue.contains(rule.value)\n251 |         case .startsWith:\n252 |             return fieldValue.hasPrefix(rule.value)\n    |                                              `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n253 |         case .endsWith:\n254 |             return fieldValue.hasSuffix(rule.value)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:254:46: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n252 |             return fieldValue.hasPrefix(rule.value)\n253 |         case .endsWith:\n254 |             return fieldValue.hasSuffix(rule.value)\n    |                                              `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n255 |         case .matches:\n256 |             if let regex = try? NSRegularExpression(pattern: rule.value) {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:256:67: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n254 |             return fieldValue.hasSuffix(rule.value)\n255 |         case .matches:\n256 |             if let regex = try? NSRegularExpression(pattern: rule.value) {\n    |                                                                   `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n257 |                 let range = NSRange(location: 0, length: fieldValue.utf16.count)\n258 |                 return regex.firstMatch(in: fieldValue, options: [], range: range) != nil\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:262:86: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n260 |             return false\n261 |         case .greaterThan:\n262 |             if let fieldNumeric = Double(fieldValue), let valueNumeric = Double(rule.value) {\n    |                                                                                      `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n263 |                 return fieldNumeric \u003e valueNumeric\n264 |             }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:267:86: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n265 |             return false\n266 |         case .lessThan:\n267 |             if let fieldNumeric = Double(fieldValue), let valueNumeric = Double(rule.value) {\n    |                                                                                      `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n268 |                 return fieldNumeric \u003c valueNumeric\n269 |             }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:293:13: warning: variable 'redactedMetadata' was never mutated; consider changing to 'let' constant\n291 |         // Create mutable copies\n292 |         var redactedMessage = entry.message\n293 |         var redactedMetadata = entry.metadata\n    |             `- warning: variable 'redactedMetadata' was never mutated; consider changing to 'let' constant\n294 |         \n295 |         for rule in rules {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:395:47: error: value of type 'String' has no member 'stringByReplacingMatches'\n393 |             if rule.targetFields.isEmpty || rule.targetFields.contains(\"message\") {\n394 |                 if let pattern = rule.pattern {\n395 |                     redactedMessage = pattern.stringByReplacingMatches(\n    |                                               `- error: value of type 'String' has no member 'stringByReplacingMatches'\n396 |                         in: redactedMessage,\n397 |                         options: [],\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:394:20: error: initializer for conditional binding must have Optional type, not 'String'\n392 |             // Apply rule to message if it matches\n393 |             if rule.targetFields.isEmpty || rule.targetFields.contains(\"message\") {\n394 |                 if let pattern = rule.pattern {\n    |                    `- error: initializer for conditional binding must have Optional type, not 'String'\n395 |                     redactedMessage = pattern.stringByReplacingMatches(\n396 |                         in: redactedMessage,\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:405:24: error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getKeys' of wrapped base type 'LogMetadataDTOCollection'\n403 |             \n404 |             // Process metadata fields\n405 |             for key in redactedMetadata.getKeys() {\n    |                        |- error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getKeys' of wrapped base type 'LogMetadataDTOCollection'\n    |                        |- note: chain the optional using '?' to access member 'getKeys' only for non-'nil' base values\n    |                        `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n406 |                 if rule.targetFields.isEmpty || rule.targetFields.contains(key) {\n407 |                     if let stringValue = redactedMetadata.getString(key: key) {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:407:42: error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getString' of wrapped base type 'LogMetadataDTOCollection'\n405 |             for key in redactedMetadata.getKeys() {\n406 |                 if rule.targetFields.isEmpty || rule.targetFields.contains(key) {\n407 |                     if let stringValue = redactedMetadata.getString(key: key) {\n    |                                          |- error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getString' of wrapped base type 'LogMetadataDTOCollection'\n    |                                          |- note: chain the optional using '?' to access member 'getString' only for non-'nil' base values\n    |                                          `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n408 |                         // Skip fields that should be preserved\n409 |                         if rule.preserveFields.contains(key) {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:468:15: error: type 'LogPrivacyLevel' has no member 'never'\n466 |         case .auto:\n467 |             return .auto\n468 |         case .never:\n    |               `- error: type 'LogPrivacyLevel' has no member 'never'\n469 |             return .public // Map 'never' to public classification\n470 |         case .protected:\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:470:15: error: type 'LogPrivacyLevel' has no member 'protected'\n468 |         case .never:\n469 |             return .public // Map 'never' to public classification\n470 |         case .protected:\n    |               `- error: type 'LogPrivacyLevel' has no member 'protected'\n471 |             return .private // Map 'protected' to private classification\n472 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:58:84: error: type 'LogPrivacyLevel' has no member 'protected'\n 56 |             additionalMetadata: [\n 57 |                 \"createBackup\": (value: String(options.createBackup), privacyLevel: .public),\n 58 |                 \"backupPath\": (value: options.backupPath ?? \"none\", privacyLevel: .protected),\n    |                                                                                    `- error: type 'LogPrivacyLevel' has no member 'protected'\n 59 |                 \"dryRun\": (value: String(options.dryRun), privacyLevel: .public),\n 60 |                 \"hasFilterCriteria\": (value: String(options.filterCriteria != nil), privacyLevel: .public),\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:184:34: error: cannot find 'getDestination' in scope\n182 |         if let destinationId = destinationId {\n183 |             // Use specific destination\n184 |             if let destination = getDestination(id: destinationId) {\n    |                                  `- error: cannot find 'getDestination' in scope\n185 |                 return [destination]\n186 |             } else {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:196:38: error: cannot find 'getDestination' in scope\n194 |             \n195 |             for id in options.destinationIds {\n196 |                 if let destination = getDestination(id: id) {\n    |                                      `- error: cannot find 'getDestination' in scope\n197 |                     result.append(destination)\n198 |                 } else {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:208:20: error: cannot find 'getAllDestinations' in scope\n206 |         } else {\n207 |             // Use all registered destinations\n208 |             return getAllDestinations()\n    |                    `- error: cannot find 'getAllDestinations' in scope\n209 |         }\n210 |     }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/QueryLogsCommand.swift:71:37: error: cannot find 'getDestination' in scope\n 69 |         do {\n 70 |             // Check if destination exists\n 71 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 72 |                 throw LoggingError.destinationNotFound(\n 73 |                     \"Cannot query logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RedactionRule.swift:123:72: error: missing argument for parameter 'privacyLevel' in call\n121 |                 if value != redactedValue {\n122 |                     // Only update if actually changed\n123 |                     result = result.with(key: key, value: redactedValue)\n    |                                                                        `- error: missing argument for parameter 'privacyLevel' in call\n124 |                 }\n125 |             }\n\n/Users/mpy/.bazel/execroot/_main/packages/UmbraCoreTypes/Sources/LoggingTypes/LogMetadataDTOCollection.swift:78:15: note: 'with(key:value:privacyLevel:)' declared here\n 76 |   ///   - privacyLevel: The privacy classification for this entry\n 77 |   /// - Returns: The updated collection\n 78 |   public func with(\n    |               `- note: 'with(key:value:privacyLevel:)' declared here\n 79 |     key: String,\n 80 |     value: String,\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RedactionRule.swift:101:26: warning: no calls to throwing functions occur within 'try' expression\n 99 |     public func redact(metadata: LogMetadataDTOCollection) -\u003e LogMetadataDTOCollection {\n100 |         // No redaction needed for empty metadata\n101 |         guard let keys = try? metadata.getKeys() else {\n    |                          `- warning: no calls to throwing functions occur within 'try' expression\n102 |             return metadata\n103 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RedactionRule.swift:119:28: warning: no calls to throwing functions occur within 'try' expression\n117 |             \n118 |             // Get string value and apply redaction\n119 |             if let value = try? metadata.getString(key: key) {\n    |                            `- warning: no calls to throwing functions occur within 'try' expression\n120 |                 let redactedValue = redact(value)\n121 |                 if value != redactedValue {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RemoveDestinationCommand.swift:67:37: error: cannot find 'getDestination' in scope\n 65 |         do {\n 66 |             // Check if destination exists\n 67 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 68 |                 throw LoggingError.destinationNotFound(\n 69 |                     \"Cannot remove destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RemoveDestinationCommand.swift:128:13: error: expression is 'async' but is not marked with 'await'\n126 |             \n127 |             // Unregister the destination\n128 |             unregisterDestination(id: destinationId)\n    |             |- error: expression is 'async' but is not marked with 'await'\n    |             `- note: calls to instance method 'unregisterDestination(id:)' from outside of its actor context are implicitly asynchronous\n129 |             \n130 |             // Log success\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RotateLogsCommand.swift:67:37: error: cannot find 'getDestination' in scope\n 65 |         do {\n 66 |             // Check if destination exists\n 67 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 68 |                 throw LoggingError.destinationNotFound(\n 69 |                     \"Cannot rotate logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RotateLogsCommand.swift:74:37: error: cannot infer contextual base in reference to member 'file'\n 72 |             \n 73 |             // Check if the destination type supports rotation\n 74 |             if destination.type != .file {\n    |                                     `- error: cannot infer contextual base in reference to member 'file'\n 75 |                 throw LoggingError.invalidDestinationConfig(\n 76 |                     \"Log rotation is only supported for file destinations\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RotateLogsCommand.swift:92:112: error: type 'LogPrivacyLevel' has no member 'protected'\n 90 |                     context: operationContext,\n 91 |                     additionalMetadata: [\n 92 |                         \"rotatedFilePath\": (value: rotationResult.rotatedFilePath ?? \"unknown\", privacyLevel: .protected),\n    |                                                                                                                `- error: type 'LogPrivacyLevel' has no member 'protected'\n 93 |                         \"rotatedSizeBytes\": (value: String(rotationResult.rotatedSizeBytes ?? 0), privacyLevel: .public),\n 94 |                         \"rotatedEntryCount\": (value: String(rotationResult.rotatedEntryCount ?? 0), privacyLevel: .public)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/WriteLogCommand.swift:159:20: error: cannot find 'getAllDestinations' in scope\n157 |         if destinationIds.isEmpty {\n158 |             // Use all registered destinations\n159 |             return getAllDestinations().filter { $0.isEnabled }\n    |                    `- error: cannot find 'getAllDestinations' in scope\n160 |         } else {\n161 |             // Use specific destinations\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/WriteLogCommand.swift:165:38: error: cannot find 'getDestination' in scope\n163 |             \n164 |             for destinationId in destinationIds {\n165 |                 if let destination = getDestination(id: destinationId) {\n    |                                      `- error: cannot find 'getDestination' in scope\n166 |                     if destination.isEnabled {\n167 |                         result.append(destination)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/WriteLogCommand.swift:193:16: error: cannot find 'applyFilterRules' in scope\n191 |         \n192 |         // Apply filter rules if they exist\n193 |         return applyFilterRules(\n    |                `- error: cannot find 'applyFilterRules' in scope\n194 |             to: entry,\n195 |             rules: destination.configuration.filterRules\n\npackages/UmbraImplementations/Sources/LoggingServices/DefaultLoggingServiceImpl.swift:39:36: warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 37 |     let contextDTO=BaseLogContextDTO(\n 38 |       domainName: \"Legacy\",\n 39 |       operation: context.operation ?? \"unknown\",\n    |                                    `- warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 40 |       category: context.category ?? \"General\",\n 41 |       source: context.source ?? \"Unknown\",\n\npackages/UmbraImplementations/Sources/LoggingServices/DefaultLoggingServiceImpl.swift:40:34: warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 38 |       domainName: \"Legacy\",\n 39 |       operation: context.operation ?? \"unknown\",\n 40 |       category: context.category ?? \"General\",\n    |                                  `- warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 41 |       source: context.source ?? \"Unknown\",\n 42 |       metadata: context.metadata\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:147:17: error: invalid redeclaration of 'log(_:_:context:)'\n145 |         - context: The logging context\n146 |      */\n147 |     public func log(_ level: LogLevel, _ message: String, context: any LogContextDTO) async {\n    |                 `- error: invalid redeclaration of 'log(_:_:context:)'\n148 |         // Convert to privacy string and use privacy-aware logging\n149 |         let privacyString = PrivacyString(stringLiteral: message)\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:92:48: error: value of type 'any LoggingProviderProtocol' has no member 'writeLogEntry'\n 90 |                     do {\n 91 |                         // Write log entry to destination\n 92 |                         _ = try await provider.writeLogEntry(entry, to: destination)\n    |                                                `- error: value of type 'any LoggingProviderProtocol' has no member 'writeLogEntry'\n 93 |                     } catch {\n 94 |                         // Silently ignore provider errors for now\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:122:28: error: value of type 'PrivacyString' has no member 'privacy'\n120 |         enrichedMetadata = enrichedMetadata.withPrivate(\n121 |             key: \"__privacy_annotation\", \n122 |             value: message.privacy.description\n    |                            `- error: value of type 'PrivacyString' has no member 'privacy'\n123 |         )\n124 |         \n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:136:34: error: value of type 'PrivacyString' has no member 'content'\n134 |         \n135 |         // Log the message using the standard log method\n136 |         await log(level, message.content, context: privacyContext)\n    |                                  `- error: value of type 'PrivacyString' has no member 'content'\n137 |     }\n138 |     \n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:167:71: error: value of type 'PrivacyAnnotatedString' has no member 'stringValue'\n165 |     ) async {\n166 |         let annotatedString = privacyScope()\n167 |         await log(level, PrivacyString(stringLiteral: annotatedString.stringValue), context: context) \n    |                                                                       `- error: value of type 'PrivacyAnnotatedString' has no member 'stringValue'\n168 |     }\n169 |     \n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:190:29: error: for-in loop requires 'LogMetadata' to conform to 'Sequence'\n188 |         // Create a metadata collection with sensitive values\n189 |         var metadataCollection = context.metadata\n190 |         for (key, value) in sensitiveValues {\n    |                             `- error: for-in loop requires 'LogMetadata' to conform to 'Sequence'\n191 |             metadataCollection = metadataCollection.withSensitive(key: key, value: String(describing: value))\n192 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:228:9: error: switch must be exhaustive\n226 |         \n227 |         // Add error information to metadata with appropriate privacy level\n228 |         switch privacyLevel {\n    |         |- error: switch must be exhaustive\n    |         `- note: add missing case: '.auto'\n229 |         case .public:\n230 |             metadataCollection = metadataCollection.withPublic(key: \"error_description\", value: error.localizedDescription)\npackages/UmbraImplementations/Sources/LoggingServices/PrivacyAwareLogDTO.swift:217:24: error: value of type 'LogMetadataDTOCollection' has no member 'set'\n215 |     for key in self.metadata.getKeys() {\n216 |       if let value = self.metadata.getString(key: key) {\n217 |         mergedMetadata.set(key: key, value: value)\n    |                        `- error: value of type 'LogMetadataDTOCollection' has no member 'set'\n218 |       }\n219 |     }\n\npackages/UmbraImplementations/Sources/LoggingServices/PrivacyAwareLogDTO.swift:224:24: error: value of type 'LogMetadataDTOCollection' has no member 'set'\n222 |     for key in additionalMetadata.getKeys() {\n223 |       if let value = additionalMetadata.getString(key: key) {\n224 |         mergedMetadata.set(key: key, value: value)\n    |                        `- error: value of type 'LogMetadataDTOCollection' has no member 'set'\n225 |       }\n226 |     }\n\npackages/UmbraImplementations/Sources/LoggingServices/PrivacyAwareLogDTO.swift:235:17: error: cannot convert value of type 'LogMetadataDTOCollection' to expected argument type '[String : (value: Any, privacy: LogPrivacyLevel)]'\n233 |       category: category,\n234 |       correlationID: correlationID,\n235 |       metadata: mergedMetadata,\n    |                 `- error: cannot convert value of type 'LogMetadataDTOCollection' to expected argument type '[String : (value: Any, privacy: LogPrivacyLevel)]'\n236 |       environment: environment\n237 |     )\nTarget //packages/UmbraImplementations/Sources/ErrorHandlingImpl:ErrorHandlingImpl failed to build\nINFO: Elapsed time: 1.122s, Critical Path: 1.01s\nINFO: 2 processes: 1 action cache hit, 2 internal.\nERROR: Build did NOT complete successfully\n"
  },
  {
    "target": "rule //packages/UmbraImplementations/Sources/ErrorLoggingServices:ErrorLoggingServices",
    "success": false,
    "start_time": "2025-04-11T17:58:04.542558+01:00",
    "end_time": "2025-04-11T17:58:06.368069+01:00",
    "duration": "1.82551275s",
    "output": "INFO: Invocation ID: 48cf5290-3854-40e0-bf5e-bdb69afc5c1f\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraImplementations/Sources/ErrorLoggingServices:ErrorLoggingServices (1 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraImplementations/Sources/ErrorLoggingServices:ErrorLoggingServices (1 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraImplementations/Sources/ErrorLoggingServices:ErrorLoggingServices (2 packages loaded, 8 targets configured).\nERROR: /Users/mpy/CascadeProjects/UmbraCore/packages/UmbraImplementations/Sources/LoggingServices/BUILD.bazel:3:20: Compiling Swift module //packages/UmbraImplementations/Sources/LoggingServices:LoggingServices failed: (Exit 1): worker failed: error executing SwiftCompile command (from target //packages/UmbraImplementations/Sources/LoggingServices:LoggingServices) \n  (cd /Users/mpy/.bazel/execroot/_main \u0026\u0026 \\\n  exec env - \\\n    APPLE_SDK_PLATFORM=MacOSX \\\n    APPLE_SDK_VERSION_OVERRIDE=15.4 \\\n    CC=clang \\\n    PATH=/Users/mpy/Library/Caches/bazelisk/downloads/sha256/ac72ad67f7a8c6b18bf605d8602425182b417de4369715bf89146daf62f7ae48/bin:/Users/mpy/.rbenv/bin:/Users/mpy/.codeium/windsurf/bin:/opt/homebrew/opt/node@18/bin:/opt/homebrew/opt/node@20/bin:/Users/mpy/.docker/bin:/opt/homebrew/opt/openjdk/bin:/Users/mpy/bin:/opt/homebrew/bin:/opt/homebrew/sbin:/usr/local/bin:/System/Cryptexes/App/usr/bin:/usr/bin:/bin:/usr/sbin:/sbin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/local/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/appleinternal/bin:/Library/Apple/usr/bin:/usr/local/go/bin:/Users/mpy/.rbenv/bin:/Users/mpy/.codeium/windsurf/bin:/opt/homebrew/opt/node@18/bin:/opt/homebrew/opt/node@20/bin:/opt/anaconda3/bin:/opt/anaconda3/condabin:/Users/mpy/.docker/bin:/opt/homebrew/opt/openjdk/bin:/Users/mpy/bin:/Users/mpy/.cargo/bin:/Users/mpy/Library/Python/3.8/bin:/Users/mpy/go/bin:/Users/mpy/.scripts:/Users/mpy/.fzf/bin:/Users/mpy/.windsurf/extensions/ms-python.debugpy-2025.6.0-darwin-arm64/bundled/scripts/noConfigScripts:/Users/mpy/Library/Python/3.8/bin:/Users/mpy/go/bin:/Users/mpy/.scripts \\\n    XCODE_VERSION_OVERRIDE=16.3.0.16E140 \\\n  bazel-out/darwin_arm64-opt-exec-ST-d57f47055a04/bin/external/rules_swift+/tools/worker/worker swiftc @bazel-out/darwin_arm64-fastbuild/bin/packages/UmbraImplementations/Sources/LoggingServices/LoggingServices.swiftmodule-0.params)\n# Configuration: 76a1bf3a80f2d50513004915454165d2f164db794b63e4666809cbd93e1abeaa\n# Execution platform: @@platforms//host:host\nerror: emit-module command failed with exit code 1 (use -v to see invocation)\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:147:17: error: invalid redeclaration of 'log(_:_:context:)'\n145 |         - context: The logging context\n146 |      */\n147 |     public func log(_ level: LogLevel, _ message: String, context: any LogContextDTO) async {\n    |                 `- error: invalid redeclaration of 'log(_:_:context:)'\n148 |         // Convert to privacy string and use privacy-aware logging\n149 |         let privacyString = PrivacyString(stringLiteral: message)\npackages/UmbraImplementations/Sources/LoggingServices/Commands/AddDestinationCommand.swift:68:31: error: cannot find 'getDestination' in scope\n 66 |         do {\n 67 |             // Check if destination already exists\n 68 |             if let existing = getDestination(id: destination.id) {\n    |                               `- error: cannot find 'getDestination' in scope\n 69 |                 if !options.overwriteExisting {\n 70 |                     throw LoggingError.destinationAlreadyExists(identifier: \"Destination with ID \\(destination.id) already exists\")\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/AddDestinationCommand.swift:82:40: error: cannot find 'validateDestination' in scope\n 80 |             // Validate destination configuration if requested\n 81 |             if options.validateConfiguration {\n 82 |                 let validationResult = validateDestination(destination, for: provider)\n    |                                        `- error: cannot find 'validateDestination' in scope\n 83 |                 \n 84 |                 if !validationResult.isValid {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/AddDestinationCommand.swift:121:13: error: expression is 'async' but is not marked with 'await'\n119 |             \n120 |             // Register the destination\n121 |             registerDestination(destination)\n    |             |- error: expression is 'async' but is not marked with 'await'\n    |             `- note: calls to instance method 'registerDestination' from outside of its actor context are implicitly asynchronous\n122 |             \n123 |             // Log success\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ArchiveLogsCommand.swift:57:84: error: type 'LogPrivacyLevel' has no member 'protected'\n 55 |             destinationId: destinationId,\n 56 |             additionalMetadata: [\n 57 |                 \"destinationPath\": (value: options.destinationPath, privacyLevel: .protected),\n    |                                                                                    `- error: type 'LogPrivacyLevel' has no member 'protected'\n 58 |                 \"compress\": (value: String(options.compress), privacyLevel: .public),\n 59 |                 \"format\": (value: options.format.rawValue, privacyLevel: .public),\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ArchiveLogsCommand.swift:70:37: error: cannot find 'getDestination' in scope\n 68 |         do {\n 69 |             // Check if destination exists\n 70 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 71 |                 throw LoggingError.destinationNotFound(\n 72 |                     \"Cannot archive logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ArchiveLogsCommand.swift:113:103: error: type 'LogPrivacyLevel' has no member 'protected'\n111 |                     context: operationContext,\n112 |                     additionalMetadata: [\n113 |                         \"archivePath\": (value: archiveResult.archivePath ?? \"unknown\", privacyLevel: .protected),\n    |                                                                                                       `- error: type 'LogPrivacyLevel' has no member 'protected'\n114 |                         \"archiveSizeBytes\": (value: String(archiveResult.archiveSizeBytes ?? 0), privacyLevel: .public),\n115 |                         \"archivedEntryCount\": (value: String(archiveResult.archivedEntryCount ?? 0), privacyLevel: .public)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ExportLogsCommand.swift:70:37: error: cannot find 'getDestination' in scope\n 68 |         do {\n 69 |             // Check if destination exists\n 70 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 71 |                 throw LoggingError.destinationNotFound(\n 72 |                     \"Cannot export logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:79:50: error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n 77 |                 key: key,\n 78 |                 value: value.value,\n 79 |                 privacyLevel: value.privacyLevel.toPrivacyClassification()\n    |                                                  `- error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n 80 |             )\n 81 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:122:54: error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n120 |                     key: key,\n121 |                     value: value.value,\n122 |                     privacyLevel: value.privacyLevel.toPrivacyClassification()\n    |                                                      `- error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n123 |                 )\n124 |             )\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:229:21: error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n227 |         \n228 |         // Process special fields first\n229 |         switch rule.field {\n    |                     `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n230 |         case \"level\":\n231 |             fieldValue = entry.level.rawValue\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:238:96: error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n236 |         default:\n237 |             // Check metadata fields\n238 |             if let metadata = entry.metadata, let metadataValue = metadata.getString(key: rule.field) {\n    |                                                                                                `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n239 |                 fieldValue = metadataValue\n240 |             } else {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:246:21: error: value of type 'UmbraLogFilterRuleDTO' has no member 'operation'\n244 |         \n245 |         // Apply the operation\n246 |         switch rule.operation {\n    |                     `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'operation'\n247 |         case .equals:\n248 |             return fieldValue == rule.value\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:248:39: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n246 |         switch rule.operation {\n247 |         case .equals:\n248 |             return fieldValue == rule.value\n    |                                       `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n249 |         case .contains:\n250 |             return fieldValue.contains(rule.value)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:250:45: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n248 |             return fieldValue == rule.value\n249 |         case .contains:\n250 |             return fieldValue.contains(rule.value)\n    |                                             `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n251 |         case .startsWith:\n252 |             return fieldValue.hasPrefix(rule.value)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:252:46: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n250 |             return fieldValue.contains(rule.value)\n251 |         case .startsWith:\n252 |             return fieldValue.hasPrefix(rule.value)\n    |                                              `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n253 |         case .endsWith:\n254 |             return fieldValue.hasSuffix(rule.value)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:254:46: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n252 |             return fieldValue.hasPrefix(rule.value)\n253 |         case .endsWith:\n254 |             return fieldValue.hasSuffix(rule.value)\n    |                                              `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n255 |         case .matches:\n256 |             if let regex = try? NSRegularExpression(pattern: rule.value) {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:256:67: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n254 |             return fieldValue.hasSuffix(rule.value)\n255 |         case .matches:\n256 |             if let regex = try? NSRegularExpression(pattern: rule.value) {\n    |                                                                   `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n257 |                 let range = NSRange(location: 0, length: fieldValue.utf16.count)\n258 |                 return regex.firstMatch(in: fieldValue, options: [], range: range) != nil\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:262:86: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n260 |             return false\n261 |         case .greaterThan:\n262 |             if let fieldNumeric = Double(fieldValue), let valueNumeric = Double(rule.value) {\n    |                                                                                      `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n263 |                 return fieldNumeric \u003e valueNumeric\n264 |             }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:267:86: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n265 |             return false\n266 |         case .lessThan:\n267 |             if let fieldNumeric = Double(fieldValue), let valueNumeric = Double(rule.value) {\n    |                                                                                      `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n268 |                 return fieldNumeric \u003c valueNumeric\n269 |             }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:293:13: warning: variable 'redactedMetadata' was never mutated; consider changing to 'let' constant\n291 |         // Create mutable copies\n292 |         var redactedMessage = entry.message\n293 |         var redactedMetadata = entry.metadata\n    |             `- warning: variable 'redactedMetadata' was never mutated; consider changing to 'let' constant\n294 |         \n295 |         for rule in rules {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:395:47: error: value of type 'String' has no member 'stringByReplacingMatches'\n393 |             if rule.targetFields.isEmpty || rule.targetFields.contains(\"message\") {\n394 |                 if let pattern = rule.pattern {\n395 |                     redactedMessage = pattern.stringByReplacingMatches(\n    |                                               `- error: value of type 'String' has no member 'stringByReplacingMatches'\n396 |                         in: redactedMessage,\n397 |                         options: [],\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:394:20: error: initializer for conditional binding must have Optional type, not 'String'\n392 |             // Apply rule to message if it matches\n393 |             if rule.targetFields.isEmpty || rule.targetFields.contains(\"message\") {\n394 |                 if let pattern = rule.pattern {\n    |                    `- error: initializer for conditional binding must have Optional type, not 'String'\n395 |                     redactedMessage = pattern.stringByReplacingMatches(\n396 |                         in: redactedMessage,\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:405:24: error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getKeys' of wrapped base type 'LogMetadataDTOCollection'\n403 |             \n404 |             // Process metadata fields\n405 |             for key in redactedMetadata.getKeys() {\n    |                        |- error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getKeys' of wrapped base type 'LogMetadataDTOCollection'\n    |                        |- note: chain the optional using '?' to access member 'getKeys' only for non-'nil' base values\n    |                        `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n406 |                 if rule.targetFields.isEmpty || rule.targetFields.contains(key) {\n407 |                     if let stringValue = redactedMetadata.getString(key: key) {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:407:42: error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getString' of wrapped base type 'LogMetadataDTOCollection'\n405 |             for key in redactedMetadata.getKeys() {\n406 |                 if rule.targetFields.isEmpty || rule.targetFields.contains(key) {\n407 |                     if let stringValue = redactedMetadata.getString(key: key) {\n    |                                          |- error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getString' of wrapped base type 'LogMetadataDTOCollection'\n    |                                          |- note: chain the optional using '?' to access member 'getString' only for non-'nil' base values\n    |                                          `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n408 |                         // Skip fields that should be preserved\n409 |                         if rule.preserveFields.contains(key) {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:468:15: error: type 'LogPrivacyLevel' has no member 'never'\n466 |         case .auto:\n467 |             return .auto\n468 |         case .never:\n    |               `- error: type 'LogPrivacyLevel' has no member 'never'\n469 |             return .public // Map 'never' to public classification\n470 |         case .protected:\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:470:15: error: type 'LogPrivacyLevel' has no member 'protected'\n468 |         case .never:\n469 |             return .public // Map 'never' to public classification\n470 |         case .protected:\n    |               `- error: type 'LogPrivacyLevel' has no member 'protected'\n471 |             return .private // Map 'protected' to private classification\n472 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:58:84: error: type 'LogPrivacyLevel' has no member 'protected'\n 56 |             additionalMetadata: [\n 57 |                 \"createBackup\": (value: String(options.createBackup), privacyLevel: .public),\n 58 |                 \"backupPath\": (value: options.backupPath ?? \"none\", privacyLevel: .protected),\n    |                                                                                    `- error: type 'LogPrivacyLevel' has no member 'protected'\n 59 |                 \"dryRun\": (value: String(options.dryRun), privacyLevel: .public),\n 60 |                 \"hasFilterCriteria\": (value: String(options.filterCriteria != nil), privacyLevel: .public),\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:184:34: error: cannot find 'getDestination' in scope\n182 |         if let destinationId = destinationId {\n183 |             // Use specific destination\n184 |             if let destination = getDestination(id: destinationId) {\n    |                                  `- error: cannot find 'getDestination' in scope\n185 |                 return [destination]\n186 |             } else {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:196:38: error: cannot find 'getDestination' in scope\n194 |             \n195 |             for id in options.destinationIds {\n196 |                 if let destination = getDestination(id: id) {\n    |                                      `- error: cannot find 'getDestination' in scope\n197 |                     result.append(destination)\n198 |                 } else {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:208:20: error: cannot find 'getAllDestinations' in scope\n206 |         } else {\n207 |             // Use all registered destinations\n208 |             return getAllDestinations()\n    |                    `- error: cannot find 'getAllDestinations' in scope\n209 |         }\n210 |     }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/QueryLogsCommand.swift:71:37: error: cannot find 'getDestination' in scope\n 69 |         do {\n 70 |             // Check if destination exists\n 71 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 72 |                 throw LoggingError.destinationNotFound(\n 73 |                     \"Cannot query logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RedactionRule.swift:123:72: error: missing argument for parameter 'privacyLevel' in call\n121 |                 if value != redactedValue {\n122 |                     // Only update if actually changed\n123 |                     result = result.with(key: key, value: redactedValue)\n    |                                                                        `- error: missing argument for parameter 'privacyLevel' in call\n124 |                 }\n125 |             }\n\n/Users/mpy/.bazel/execroot/_main/packages/UmbraCoreTypes/Sources/LoggingTypes/LogMetadataDTOCollection.swift:78:15: note: 'with(key:value:privacyLevel:)' declared here\n 76 |   ///   - privacyLevel: The privacy classification for this entry\n 77 |   /// - Returns: The updated collection\n 78 |   public func with(\n    |               `- note: 'with(key:value:privacyLevel:)' declared here\n 79 |     key: String,\n 80 |     value: String,\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RedactionRule.swift:101:26: warning: no calls to throwing functions occur within 'try' expression\n 99 |     public func redact(metadata: LogMetadataDTOCollection) -\u003e LogMetadataDTOCollection {\n100 |         // No redaction needed for empty metadata\n101 |         guard let keys = try? metadata.getKeys() else {\n    |                          `- warning: no calls to throwing functions occur within 'try' expression\n102 |             return metadata\n103 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RedactionRule.swift:119:28: warning: no calls to throwing functions occur within 'try' expression\n117 |             \n118 |             // Get string value and apply redaction\n119 |             if let value = try? metadata.getString(key: key) {\n    |                            `- warning: no calls to throwing functions occur within 'try' expression\n120 |                 let redactedValue = redact(value)\n121 |                 if value != redactedValue {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RemoveDestinationCommand.swift:67:37: error: cannot find 'getDestination' in scope\n 65 |         do {\n 66 |             // Check if destination exists\n 67 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 68 |                 throw LoggingError.destinationNotFound(\n 69 |                     \"Cannot remove destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RemoveDestinationCommand.swift:128:13: error: expression is 'async' but is not marked with 'await'\n126 |             \n127 |             // Unregister the destination\n128 |             unregisterDestination(id: destinationId)\n    |             |- error: expression is 'async' but is not marked with 'await'\n    |             `- note: calls to instance method 'unregisterDestination(id:)' from outside of its actor context are implicitly asynchronous\n129 |             \n130 |             // Log success\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RotateLogsCommand.swift:67:37: error: cannot find 'getDestination' in scope\n 65 |         do {\n 66 |             // Check if destination exists\n 67 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 68 |                 throw LoggingError.destinationNotFound(\n 69 |                     \"Cannot rotate logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RotateLogsCommand.swift:74:37: error: cannot infer contextual base in reference to member 'file'\n 72 |             \n 73 |             // Check if the destination type supports rotation\n 74 |             if destination.type != .file {\n    |                                     `- error: cannot infer contextual base in reference to member 'file'\n 75 |                 throw LoggingError.invalidDestinationConfig(\n 76 |                     \"Log rotation is only supported for file destinations\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RotateLogsCommand.swift:92:112: error: type 'LogPrivacyLevel' has no member 'protected'\n 90 |                     context: operationContext,\n 91 |                     additionalMetadata: [\n 92 |                         \"rotatedFilePath\": (value: rotationResult.rotatedFilePath ?? \"unknown\", privacyLevel: .protected),\n    |                                                                                                                `- error: type 'LogPrivacyLevel' has no member 'protected'\n 93 |                         \"rotatedSizeBytes\": (value: String(rotationResult.rotatedSizeBytes ?? 0), privacyLevel: .public),\n 94 |                         \"rotatedEntryCount\": (value: String(rotationResult.rotatedEntryCount ?? 0), privacyLevel: .public)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/WriteLogCommand.swift:159:20: error: cannot find 'getAllDestinations' in scope\n157 |         if destinationIds.isEmpty {\n158 |             // Use all registered destinations\n159 |             return getAllDestinations().filter { $0.isEnabled }\n    |                    `- error: cannot find 'getAllDestinations' in scope\n160 |         } else {\n161 |             // Use specific destinations\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/WriteLogCommand.swift:165:38: error: cannot find 'getDestination' in scope\n163 |             \n164 |             for destinationId in destinationIds {\n165 |                 if let destination = getDestination(id: destinationId) {\n    |                                      `- error: cannot find 'getDestination' in scope\n166 |                     if destination.isEnabled {\n167 |                         result.append(destination)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/WriteLogCommand.swift:193:16: error: cannot find 'applyFilterRules' in scope\n191 |         \n192 |         // Apply filter rules if they exist\n193 |         return applyFilterRules(\n    |                `- error: cannot find 'applyFilterRules' in scope\n194 |             to: entry,\n195 |             rules: destination.configuration.filterRules\n\npackages/UmbraImplementations/Sources/LoggingServices/DefaultLoggingServiceImpl.swift:39:36: warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 37 |     let contextDTO=BaseLogContextDTO(\n 38 |       domainName: \"Legacy\",\n 39 |       operation: context.operation ?? \"unknown\",\n    |                                    `- warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 40 |       category: context.category ?? \"General\",\n 41 |       source: context.source ?? \"Unknown\",\n\npackages/UmbraImplementations/Sources/LoggingServices/DefaultLoggingServiceImpl.swift:40:34: warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 38 |       domainName: \"Legacy\",\n 39 |       operation: context.operation ?? \"unknown\",\n 40 |       category: context.category ?? \"General\",\n    |                                  `- warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 41 |       source: context.source ?? \"Unknown\",\n 42 |       metadata: context.metadata\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:147:17: error: invalid redeclaration of 'log(_:_:context:)'\n145 |         - context: The logging context\n146 |      */\n147 |     public func log(_ level: LogLevel, _ message: String, context: any LogContextDTO) async {\n    |                 `- error: invalid redeclaration of 'log(_:_:context:)'\n148 |         // Convert to privacy string and use privacy-aware logging\n149 |         let privacyString = PrivacyString(stringLiteral: message)\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:92:48: error: value of type 'any LoggingProviderProtocol' has no member 'writeLogEntry'\n 90 |                     do {\n 91 |                         // Write log entry to destination\n 92 |                         _ = try await provider.writeLogEntry(entry, to: destination)\n    |                                                `- error: value of type 'any LoggingProviderProtocol' has no member 'writeLogEntry'\n 93 |                     } catch {\n 94 |                         // Silently ignore provider errors for now\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:122:28: error: value of type 'PrivacyString' has no member 'privacy'\n120 |         enrichedMetadata = enrichedMetadata.withPrivate(\n121 |             key: \"__privacy_annotation\", \n122 |             value: message.privacy.description\n    |                            `- error: value of type 'PrivacyString' has no member 'privacy'\n123 |         )\n124 |         \n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:136:34: error: value of type 'PrivacyString' has no member 'content'\n134 |         \n135 |         // Log the message using the standard log method\n136 |         await log(level, message.content, context: privacyContext)\n    |                                  `- error: value of type 'PrivacyString' has no member 'content'\n137 |     }\n138 |     \n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:167:71: error: value of type 'PrivacyAnnotatedString' has no member 'stringValue'\n165 |     ) async {\n166 |         let annotatedString = privacyScope()\n167 |         await log(level, PrivacyString(stringLiteral: annotatedString.stringValue), context: context) \n    |                                                                       `- error: value of type 'PrivacyAnnotatedString' has no member 'stringValue'\n168 |     }\n169 |     \n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:190:29: error: for-in loop requires 'LogMetadata' to conform to 'Sequence'\n188 |         // Create a metadata collection with sensitive values\n189 |         var metadataCollection = context.metadata\n190 |         for (key, value) in sensitiveValues {\n    |                             `- error: for-in loop requires 'LogMetadata' to conform to 'Sequence'\n191 |             metadataCollection = metadataCollection.withSensitive(key: key, value: String(describing: value))\n192 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:228:9: error: switch must be exhaustive\n226 |         \n227 |         // Add error information to metadata with appropriate privacy level\n228 |         switch privacyLevel {\n    |         |- error: switch must be exhaustive\n    |         `- note: add missing case: '.auto'\n229 |         case .public:\n230 |             metadataCollection = metadataCollection.withPublic(key: \"error_description\", value: error.localizedDescription)\npackages/UmbraImplementations/Sources/LoggingServices/PrivacyAwareLogDTO.swift:217:24: error: value of type 'LogMetadataDTOCollection' has no member 'set'\n215 |     for key in self.metadata.getKeys() {\n216 |       if let value = self.metadata.getString(key: key) {\n217 |         mergedMetadata.set(key: key, value: value)\n    |                        `- error: value of type 'LogMetadataDTOCollection' has no member 'set'\n218 |       }\n219 |     }\n\npackages/UmbraImplementations/Sources/LoggingServices/PrivacyAwareLogDTO.swift:224:24: error: value of type 'LogMetadataDTOCollection' has no member 'set'\n222 |     for key in additionalMetadata.getKeys() {\n223 |       if let value = additionalMetadata.getString(key: key) {\n224 |         mergedMetadata.set(key: key, value: value)\n    |                        `- error: value of type 'LogMetadataDTOCollection' has no member 'set'\n225 |       }\n226 |     }\n\npackages/UmbraImplementations/Sources/LoggingServices/PrivacyAwareLogDTO.swift:235:17: error: cannot convert value of type 'LogMetadataDTOCollection' to expected argument type '[String : (value: Any, privacy: LogPrivacyLevel)]'\n233 |       category: category,\n234 |       correlationID: correlationID,\n235 |       metadata: mergedMetadata,\n    |                 `- error: cannot convert value of type 'LogMetadataDTOCollection' to expected argument type '[String : (value: Any, privacy: LogPrivacyLevel)]'\n236 |       environment: environment\n237 |     )\nTarget //packages/UmbraImplementations/Sources/ErrorLoggingServices:ErrorLoggingServices failed to build\nINFO: Elapsed time: 1.136s, Critical Path: 1.01s\nINFO: 2 processes: 3 action cache hit, 2 internal.\nERROR: Build did NOT complete successfully\n"
  },
  {
    "target": "rule //packages/UmbraImplementations/Sources/FileMetadataOperations:FileMetadataOperations",
    "success": true,
    "start_time": "2025-04-11T17:58:06.368088+01:00",
    "end_time": "2025-04-11T17:58:08.137023+01:00",
    "duration": "1.7689375s",
    "output": "INFO: Invocation ID: e47e1eba-0473-4ff4-ac0b-e65ac191bf47\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraImplementations/Sources/FileMetadataOperations:FileMetadataOperations (1 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraImplementations/Sources/FileMetadataOperations:FileMetadataOperations (1 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraImplementations/Sources/FileMetadataOperations:FileMetadataOperations (1 packages loaded, 3 targets configured).\nINFO: Found 1 target...\nTarget //packages/UmbraImplementations/Sources/FileMetadataOperations:FileMetadataOperations up-to-date:\n  bazel-bin/packages/UmbraImplementations/Sources/FileMetadataOperations/FileMetadataOperations.swiftdoc\n  bazel-bin/packages/UmbraImplementations/Sources/FileMetadataOperations/FileMetadataOperations.swiftmodule\n  bazel-bin/packages/UmbraImplementations/Sources/FileMetadataOperations/FileMetadataOperations.swiftsourceinfo\n  bazel-bin/packages/UmbraImplementations/Sources/FileMetadataOperations/libFileMetadataOperations.a\nINFO: Elapsed time: 1.074s, Critical Path: 0.94s\nINFO: 3 processes: 1 action cache hit, 1 internal, 1 local, 1 worker.\nINFO: Build completed successfully, 3 total actions\n"
  },
  {
    "target": "rule //packages/UmbraImplementations/Sources/FileSandboxing:FileSandboxing",
    "success": false,
    "start_time": "2025-04-11T17:58:08.137042+01:00",
    "end_time": "2025-04-11T17:58:09.360136+01:00",
    "duration": "1.223095583s",
    "output": "INFO: Invocation ID: e0cf28b4-2b49-40c5-82f6-d672be92e7eb\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraImplementations/Sources/FileSandboxing:FileSandboxing (1 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraImplementations/Sources/FileSandboxing:FileSandboxing (1 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraImplementations/Sources/FileSandboxing:FileSandboxing (1 packages loaded, 3 targets configured).\nERROR: /Users/mpy/CascadeProjects/UmbraCore/packages/UmbraImplementations/Sources/FileSandboxing/BUILD.bazel:3:14: Compiling Swift module //packages/UmbraImplementations/Sources/FileSandboxing:FileSandboxing failed: (Exit 1): worker failed: error executing SwiftCompile command (from target //packages/UmbraImplementations/Sources/FileSandboxing:FileSandboxing) \n  (cd /Users/mpy/.bazel/execroot/_main \u0026\u0026 \\\n  exec env - \\\n    APPLE_SDK_PLATFORM=MacOSX \\\n    APPLE_SDK_VERSION_OVERRIDE=15.4 \\\n    CC=clang \\\n    PATH=/Users/mpy/Library/Caches/bazelisk/downloads/sha256/ac72ad67f7a8c6b18bf605d8602425182b417de4369715bf89146daf62f7ae48/bin:/Users/mpy/.rbenv/bin:/Users/mpy/.codeium/windsurf/bin:/opt/homebrew/opt/node@18/bin:/opt/homebrew/opt/node@20/bin:/Users/mpy/.docker/bin:/opt/homebrew/opt/openjdk/bin:/Users/mpy/bin:/opt/homebrew/bin:/opt/homebrew/sbin:/usr/local/bin:/System/Cryptexes/App/usr/bin:/usr/bin:/bin:/usr/sbin:/sbin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/local/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/appleinternal/bin:/Library/Apple/usr/bin:/usr/local/go/bin:/Users/mpy/.rbenv/bin:/Users/mpy/.codeium/windsurf/bin:/opt/homebrew/opt/node@18/bin:/opt/homebrew/opt/node@20/bin:/opt/anaconda3/bin:/opt/anaconda3/condabin:/Users/mpy/.docker/bin:/opt/homebrew/opt/openjdk/bin:/Users/mpy/bin:/Users/mpy/.cargo/bin:/Users/mpy/Library/Python/3.8/bin:/Users/mpy/go/bin:/Users/mpy/.scripts:/Users/mpy/.fzf/bin:/Users/mpy/.windsurf/extensions/ms-python.debugpy-2025.6.0-darwin-arm64/bundled/scripts/noConfigScripts:/Users/mpy/Library/Python/3.8/bin:/Users/mpy/go/bin:/Users/mpy/.scripts \\\n    XCODE_VERSION_OVERRIDE=16.3.0.16E140 \\\n  bazel-out/darwin_arm64-opt-exec-ST-d57f47055a04/bin/external/rules_swift+/tools/worker/worker swiftc @bazel-out/darwin_arm64-fastbuild/bin/packages/UmbraImplementations/Sources/FileSandboxing/FileSandboxing.swiftmodule-0.params)\n# Configuration: 76a1bf3a80f2d50513004915454165d2f164db794b63e4666809cbd93e1abeaa\n# Execution platform: @@platforms//host:host\npackages/UmbraImplementations/Sources/FileSandboxing/Implementation/FileSandboxingImpl.swift:831:29: error: missing arguments for parameters 'operation', 'category' in call\n 829 |     }\n 830 | \n 831 |     return BaseLogContextDTO(\n     |                             `- error: missing arguments for parameters 'operation', 'category' in call\n 832 |       domainName: \"FileSandboxing\",\n 833 |       source: \"FileSandboxingImpl\",\n\n/Users/mpy/.bazel/execroot/_main/packages/UmbraCoreTypes/Sources/LoggingTypes/LogContextDTO.swift:60:10: note: 'init(domainName:operation:category:source:metadata:correlationID:)' declared here\n58 |   ///   - metadata: Privacy metadata as a LogMetadataDTOCollection instance\n59 |   ///   - correlationID: Optional correlation ID\n60 |   public init(\n   |          `- note: 'init(domainName:operation:category:source:metadata:correlationID:)' declared here\n61 |     domainName: String,\n62 |     operation: String,\n\npackages/UmbraImplementations/Sources/FileSandboxing/Implementation/FileSandboxingImpl.swift:888:29: error: missing arguments for parameters 'operation', 'category' in call\n 886 |     }\n 887 | \n 888 |     return BaseLogContextDTO(\n     |                             `- error: missing arguments for parameters 'operation', 'category' in call\n 889 |       domainName: \"FileSandboxing\",\n 890 |       source: \"SandboxedFileOperations\",\n\n/Users/mpy/.bazel/execroot/_main/packages/UmbraCoreTypes/Sources/LoggingTypes/LogContextDTO.swift:60:10: note: 'init(domainName:operation:category:source:metadata:correlationID:)' declared here\n58 |   ///   - metadata: Privacy metadata as a LogMetadataDTOCollection instance\n59 |   ///   - correlationID: Optional correlation ID\n60 |   public init(\n   |          `- note: 'init(domainName:operation:category:source:metadata:correlationID:)' declared here\n61 |     domainName: String,\n62 |     operation: String,\nTarget //packages/UmbraImplementations/Sources/FileSandboxing:FileSandboxing failed to build\nINFO: Elapsed time: 0.531s, Critical Path: 0.40s\nINFO: 2 processes: 1 action cache hit, 2 internal.\nERROR: Build did NOT complete successfully\n"
  },
  {
    "target": "rule //packages/UmbraImplementations/Sources/FileSystemServices:FileSystemServices",
    "success": false,
    "start_time": "2025-04-11T17:58:09.360148+01:00",
    "end_time": "2025-04-11T17:58:10.627985+01:00",
    "duration": "1.267838833s",
    "output": "INFO: Invocation ID: 808cf8de-c41e-417f-8804-047fab65be11\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraImplementations/Sources/FileSystemServices:FileSystemServices (1 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraImplementations/Sources/FileSystemServices:FileSystemServices (1 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraImplementations/Sources/FileSystemServices:FileSystemServices (2 packages loaded, 10 targets configured).\nERROR: /Users/mpy/CascadeProjects/UmbraCore/packages/UmbraImplementations/Sources/CoreFileOperations/BUILD.bazel:3:14: Compiling Swift module //packages/UmbraImplementations/Sources/CoreFileOperations:CoreFileOperations failed: (Exit 1): worker failed: error executing SwiftCompile command (from target //packages/UmbraImplementations/Sources/CoreFileOperations:CoreFileOperations) \n  (cd /Users/mpy/.bazel/execroot/_main \u0026\u0026 \\\n  exec env - \\\n    APPLE_SDK_PLATFORM=MacOSX \\\n    APPLE_SDK_VERSION_OVERRIDE=15.4 \\\n    CC=clang \\\n    PATH=/Users/mpy/Library/Caches/bazelisk/downloads/sha256/ac72ad67f7a8c6b18bf605d8602425182b417de4369715bf89146daf62f7ae48/bin:/Users/mpy/.rbenv/bin:/Users/mpy/.codeium/windsurf/bin:/opt/homebrew/opt/node@18/bin:/opt/homebrew/opt/node@20/bin:/Users/mpy/.docker/bin:/opt/homebrew/opt/openjdk/bin:/Users/mpy/bin:/opt/homebrew/bin:/opt/homebrew/sbin:/usr/local/bin:/System/Cryptexes/App/usr/bin:/usr/bin:/bin:/usr/sbin:/sbin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/local/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/appleinternal/bin:/Library/Apple/usr/bin:/usr/local/go/bin:/Users/mpy/.rbenv/bin:/Users/mpy/.codeium/windsurf/bin:/opt/homebrew/opt/node@18/bin:/opt/homebrew/opt/node@20/bin:/opt/anaconda3/bin:/opt/anaconda3/condabin:/Users/mpy/.docker/bin:/opt/homebrew/opt/openjdk/bin:/Users/mpy/bin:/Users/mpy/.cargo/bin:/Users/mpy/Library/Python/3.8/bin:/Users/mpy/go/bin:/Users/mpy/.scripts:/Users/mpy/.fzf/bin:/Users/mpy/.windsurf/extensions/ms-python.debugpy-2025.6.0-darwin-arm64/bundled/scripts/noConfigScripts:/Users/mpy/Library/Python/3.8/bin:/Users/mpy/go/bin:/Users/mpy/.scripts \\\n    XCODE_VERSION_OVERRIDE=16.3.0.16E140 \\\n  bazel-out/darwin_arm64-opt-exec-ST-d57f47055a04/bin/external/rules_swift+/tools/worker/worker swiftc @bazel-out/darwin_arm64-fastbuild/bin/packages/UmbraImplementations/Sources/CoreFileOperations/CoreFileOperations.swiftmodule-0.params)\n# Configuration: 76a1bf3a80f2d50513004915454165d2f164db794b63e4666809cbd93e1abeaa\n# Execution platform: @@platforms//host:host\npackages/UmbraImplementations/Sources/CoreFileOperations/Implementation/CoreFileOperationsImpl.swift:55:29: error: missing arguments for parameters 'operation', 'category' in call\n  53 |     }\n  54 | \n  55 |     return BaseLogContextDTO(\n     |                             `- error: missing arguments for parameters 'operation', 'category' in call\n  56 |       domainName: \"CoreFileOperations\",\n  57 |       source: \"CoreFileOperationsImpl\",\n\n/Users/mpy/.bazel/execroot/_main/packages/UmbraCoreTypes/Sources/LoggingTypes/LogContextDTO.swift:60:10: note: 'init(domainName:operation:category:source:metadata:correlationID:)' declared here\n58 |   ///   - metadata: Privacy metadata as a LogMetadataDTOCollection instance\n59 |   ///   - correlationID: Optional correlation ID\n60 |   public init(\n   |          `- note: 'init(domainName:operation:category:source:metadata:correlationID:)' declared here\n61 |     domainName: String,\n62 |     operation: String,\nTarget //packages/UmbraImplementations/Sources/FileSystemServices:FileSystemServices failed to build\nINFO: Elapsed time: 0.567s, Critical Path: 0.43s\nINFO: 4 processes: 2 action cache hit, 4 internal.\nERROR: Build did NOT complete successfully\n"
  },
  {
    "target": "rule //packages/UmbraImplementations/Sources/KeychainServices:KeychainServices",
    "success": false,
    "start_time": "2025-04-11T17:58:10.628001+01:00",
    "end_time": "2025-04-11T17:58:12.45856+01:00",
    "duration": "1.830561125s",
    "output": "INFO: Invocation ID: 8cdd2a10-f1af-4035-9049-92d97bb506c3\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraImplementations/Sources/KeychainServices:KeychainServices (0 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraImplementations/Sources/KeychainServices:KeychainServices (0 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraImplementations/Sources/KeychainServices:KeychainServices (0 packages loaded, 0 targets configured).\nERROR: /Users/mpy/CascadeProjects/UmbraCore/packages/UmbraImplementations/Sources/LoggingServices/BUILD.bazel:3:20: Compiling Swift module //packages/UmbraImplementations/Sources/LoggingServices:LoggingServices failed: (Exit 1): worker failed: error executing SwiftCompile command (from target //packages/UmbraImplementations/Sources/LoggingServices:LoggingServices) \n  (cd /Users/mpy/.bazel/execroot/_main \u0026\u0026 \\\n  exec env - \\\n    APPLE_SDK_PLATFORM=MacOSX \\\n    APPLE_SDK_VERSION_OVERRIDE=15.4 \\\n    CC=clang \\\n    PATH=/Users/mpy/Library/Caches/bazelisk/downloads/sha256/ac72ad67f7a8c6b18bf605d8602425182b417de4369715bf89146daf62f7ae48/bin:/Users/mpy/.rbenv/bin:/Users/mpy/.codeium/windsurf/bin:/opt/homebrew/opt/node@18/bin:/opt/homebrew/opt/node@20/bin:/Users/mpy/.docker/bin:/opt/homebrew/opt/openjdk/bin:/Users/mpy/bin:/opt/homebrew/bin:/opt/homebrew/sbin:/usr/local/bin:/System/Cryptexes/App/usr/bin:/usr/bin:/bin:/usr/sbin:/sbin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/local/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/appleinternal/bin:/Library/Apple/usr/bin:/usr/local/go/bin:/Users/mpy/.rbenv/bin:/Users/mpy/.codeium/windsurf/bin:/opt/homebrew/opt/node@18/bin:/opt/homebrew/opt/node@20/bin:/opt/anaconda3/bin:/opt/anaconda3/condabin:/Users/mpy/.docker/bin:/opt/homebrew/opt/openjdk/bin:/Users/mpy/bin:/Users/mpy/.cargo/bin:/Users/mpy/Library/Python/3.8/bin:/Users/mpy/go/bin:/Users/mpy/.scripts:/Users/mpy/.fzf/bin:/Users/mpy/.windsurf/extensions/ms-python.debugpy-2025.6.0-darwin-arm64/bundled/scripts/noConfigScripts:/Users/mpy/Library/Python/3.8/bin:/Users/mpy/go/bin:/Users/mpy/.scripts \\\n    XCODE_VERSION_OVERRIDE=16.3.0.16E140 \\\n  bazel-out/darwin_arm64-opt-exec-ST-d57f47055a04/bin/external/rules_swift+/tools/worker/worker swiftc @bazel-out/darwin_arm64-fastbuild/bin/packages/UmbraImplementations/Sources/LoggingServices/LoggingServices.swiftmodule-0.params)\n# Configuration: 76a1bf3a80f2d50513004915454165d2f164db794b63e4666809cbd93e1abeaa\n# Execution platform: @@platforms//host:host\nerror: emit-module command failed with exit code 1 (use -v to see invocation)\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:147:17: error: invalid redeclaration of 'log(_:_:context:)'\n145 |         - context: The logging context\n146 |      */\n147 |     public func log(_ level: LogLevel, _ message: String, context: any LogContextDTO) async {\n    |                 `- error: invalid redeclaration of 'log(_:_:context:)'\n148 |         // Convert to privacy string and use privacy-aware logging\n149 |         let privacyString = PrivacyString(stringLiteral: message)\npackages/UmbraImplementations/Sources/LoggingServices/Commands/AddDestinationCommand.swift:68:31: error: cannot find 'getDestination' in scope\n 66 |         do {\n 67 |             // Check if destination already exists\n 68 |             if let existing = getDestination(id: destination.id) {\n    |                               `- error: cannot find 'getDestination' in scope\n 69 |                 if !options.overwriteExisting {\n 70 |                     throw LoggingError.destinationAlreadyExists(identifier: \"Destination with ID \\(destination.id) already exists\")\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/AddDestinationCommand.swift:82:40: error: cannot find 'validateDestination' in scope\n 80 |             // Validate destination configuration if requested\n 81 |             if options.validateConfiguration {\n 82 |                 let validationResult = validateDestination(destination, for: provider)\n    |                                        `- error: cannot find 'validateDestination' in scope\n 83 |                 \n 84 |                 if !validationResult.isValid {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/AddDestinationCommand.swift:121:13: error: expression is 'async' but is not marked with 'await'\n119 |             \n120 |             // Register the destination\n121 |             registerDestination(destination)\n    |             |- error: expression is 'async' but is not marked with 'await'\n    |             `- note: calls to instance method 'registerDestination' from outside of its actor context are implicitly asynchronous\n122 |             \n123 |             // Log success\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ArchiveLogsCommand.swift:57:84: error: type 'LogPrivacyLevel' has no member 'protected'\n 55 |             destinationId: destinationId,\n 56 |             additionalMetadata: [\n 57 |                 \"destinationPath\": (value: options.destinationPath, privacyLevel: .protected),\n    |                                                                                    `- error: type 'LogPrivacyLevel' has no member 'protected'\n 58 |                 \"compress\": (value: String(options.compress), privacyLevel: .public),\n 59 |                 \"format\": (value: options.format.rawValue, privacyLevel: .public),\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ArchiveLogsCommand.swift:70:37: error: cannot find 'getDestination' in scope\n 68 |         do {\n 69 |             // Check if destination exists\n 70 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 71 |                 throw LoggingError.destinationNotFound(\n 72 |                     \"Cannot archive logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ArchiveLogsCommand.swift:113:103: error: type 'LogPrivacyLevel' has no member 'protected'\n111 |                     context: operationContext,\n112 |                     additionalMetadata: [\n113 |                         \"archivePath\": (value: archiveResult.archivePath ?? \"unknown\", privacyLevel: .protected),\n    |                                                                                                       `- error: type 'LogPrivacyLevel' has no member 'protected'\n114 |                         \"archiveSizeBytes\": (value: String(archiveResult.archiveSizeBytes ?? 0), privacyLevel: .public),\n115 |                         \"archivedEntryCount\": (value: String(archiveResult.archivedEntryCount ?? 0), privacyLevel: .public)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ExportLogsCommand.swift:70:37: error: cannot find 'getDestination' in scope\n 68 |         do {\n 69 |             // Check if destination exists\n 70 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 71 |                 throw LoggingError.destinationNotFound(\n 72 |                     \"Cannot export logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:79:50: error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n 77 |                 key: key,\n 78 |                 value: value.value,\n 79 |                 privacyLevel: value.privacyLevel.toPrivacyClassification()\n    |                                                  `- error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n 80 |             )\n 81 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:122:54: error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n120 |                     key: key,\n121 |                     value: value.value,\n122 |                     privacyLevel: value.privacyLevel.toPrivacyClassification()\n    |                                                      `- error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n123 |                 )\n124 |             )\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:229:21: error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n227 |         \n228 |         // Process special fields first\n229 |         switch rule.field {\n    |                     `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n230 |         case \"level\":\n231 |             fieldValue = entry.level.rawValue\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:238:96: error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n236 |         default:\n237 |             // Check metadata fields\n238 |             if let metadata = entry.metadata, let metadataValue = metadata.getString(key: rule.field) {\n    |                                                                                                `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n239 |                 fieldValue = metadataValue\n240 |             } else {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:246:21: error: value of type 'UmbraLogFilterRuleDTO' has no member 'operation'\n244 |         \n245 |         // Apply the operation\n246 |         switch rule.operation {\n    |                     `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'operation'\n247 |         case .equals:\n248 |             return fieldValue == rule.value\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:248:39: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n246 |         switch rule.operation {\n247 |         case .equals:\n248 |             return fieldValue == rule.value\n    |                                       `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n249 |         case .contains:\n250 |             return fieldValue.contains(rule.value)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:250:45: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n248 |             return fieldValue == rule.value\n249 |         case .contains:\n250 |             return fieldValue.contains(rule.value)\n    |                                             `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n251 |         case .startsWith:\n252 |             return fieldValue.hasPrefix(rule.value)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:252:46: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n250 |             return fieldValue.contains(rule.value)\n251 |         case .startsWith:\n252 |             return fieldValue.hasPrefix(rule.value)\n    |                                              `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n253 |         case .endsWith:\n254 |             return fieldValue.hasSuffix(rule.value)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:254:46: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n252 |             return fieldValue.hasPrefix(rule.value)\n253 |         case .endsWith:\n254 |             return fieldValue.hasSuffix(rule.value)\n    |                                              `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n255 |         case .matches:\n256 |             if let regex = try? NSRegularExpression(pattern: rule.value) {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:256:67: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n254 |             return fieldValue.hasSuffix(rule.value)\n255 |         case .matches:\n256 |             if let regex = try? NSRegularExpression(pattern: rule.value) {\n    |                                                                   `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n257 |                 let range = NSRange(location: 0, length: fieldValue.utf16.count)\n258 |                 return regex.firstMatch(in: fieldValue, options: [], range: range) != nil\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:262:86: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n260 |             return false\n261 |         case .greaterThan:\n262 |             if let fieldNumeric = Double(fieldValue), let valueNumeric = Double(rule.value) {\n    |                                                                                      `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n263 |                 return fieldNumeric \u003e valueNumeric\n264 |             }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:267:86: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n265 |             return false\n266 |         case .lessThan:\n267 |             if let fieldNumeric = Double(fieldValue), let valueNumeric = Double(rule.value) {\n    |                                                                                      `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n268 |                 return fieldNumeric \u003c valueNumeric\n269 |             }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:293:13: warning: variable 'redactedMetadata' was never mutated; consider changing to 'let' constant\n291 |         // Create mutable copies\n292 |         var redactedMessage = entry.message\n293 |         var redactedMetadata = entry.metadata\n    |             `- warning: variable 'redactedMetadata' was never mutated; consider changing to 'let' constant\n294 |         \n295 |         for rule in rules {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:395:47: error: value of type 'String' has no member 'stringByReplacingMatches'\n393 |             if rule.targetFields.isEmpty || rule.targetFields.contains(\"message\") {\n394 |                 if let pattern = rule.pattern {\n395 |                     redactedMessage = pattern.stringByReplacingMatches(\n    |                                               `- error: value of type 'String' has no member 'stringByReplacingMatches'\n396 |                         in: redactedMessage,\n397 |                         options: [],\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:394:20: error: initializer for conditional binding must have Optional type, not 'String'\n392 |             // Apply rule to message if it matches\n393 |             if rule.targetFields.isEmpty || rule.targetFields.contains(\"message\") {\n394 |                 if let pattern = rule.pattern {\n    |                    `- error: initializer for conditional binding must have Optional type, not 'String'\n395 |                     redactedMessage = pattern.stringByReplacingMatches(\n396 |                         in: redactedMessage,\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:405:24: error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getKeys' of wrapped base type 'LogMetadataDTOCollection'\n403 |             \n404 |             // Process metadata fields\n405 |             for key in redactedMetadata.getKeys() {\n    |                        |- error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getKeys' of wrapped base type 'LogMetadataDTOCollection'\n    |                        |- note: chain the optional using '?' to access member 'getKeys' only for non-'nil' base values\n    |                        `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n406 |                 if rule.targetFields.isEmpty || rule.targetFields.contains(key) {\n407 |                     if let stringValue = redactedMetadata.getString(key: key) {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:407:42: error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getString' of wrapped base type 'LogMetadataDTOCollection'\n405 |             for key in redactedMetadata.getKeys() {\n406 |                 if rule.targetFields.isEmpty || rule.targetFields.contains(key) {\n407 |                     if let stringValue = redactedMetadata.getString(key: key) {\n    |                                          |- error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getString' of wrapped base type 'LogMetadataDTOCollection'\n    |                                          |- note: chain the optional using '?' to access member 'getString' only for non-'nil' base values\n    |                                          `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n408 |                         // Skip fields that should be preserved\n409 |                         if rule.preserveFields.contains(key) {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:468:15: error: type 'LogPrivacyLevel' has no member 'never'\n466 |         case .auto:\n467 |             return .auto\n468 |         case .never:\n    |               `- error: type 'LogPrivacyLevel' has no member 'never'\n469 |             return .public // Map 'never' to public classification\n470 |         case .protected:\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:470:15: error: type 'LogPrivacyLevel' has no member 'protected'\n468 |         case .never:\n469 |             return .public // Map 'never' to public classification\n470 |         case .protected:\n    |               `- error: type 'LogPrivacyLevel' has no member 'protected'\n471 |             return .private // Map 'protected' to private classification\n472 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:58:84: error: type 'LogPrivacyLevel' has no member 'protected'\n 56 |             additionalMetadata: [\n 57 |                 \"createBackup\": (value: String(options.createBackup), privacyLevel: .public),\n 58 |                 \"backupPath\": (value: options.backupPath ?? \"none\", privacyLevel: .protected),\n    |                                                                                    `- error: type 'LogPrivacyLevel' has no member 'protected'\n 59 |                 \"dryRun\": (value: String(options.dryRun), privacyLevel: .public),\n 60 |                 \"hasFilterCriteria\": (value: String(options.filterCriteria != nil), privacyLevel: .public),\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:184:34: error: cannot find 'getDestination' in scope\n182 |         if let destinationId = destinationId {\n183 |             // Use specific destination\n184 |             if let destination = getDestination(id: destinationId) {\n    |                                  `- error: cannot find 'getDestination' in scope\n185 |                 return [destination]\n186 |             } else {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:196:38: error: cannot find 'getDestination' in scope\n194 |             \n195 |             for id in options.destinationIds {\n196 |                 if let destination = getDestination(id: id) {\n    |                                      `- error: cannot find 'getDestination' in scope\n197 |                     result.append(destination)\n198 |                 } else {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:208:20: error: cannot find 'getAllDestinations' in scope\n206 |         } else {\n207 |             // Use all registered destinations\n208 |             return getAllDestinations()\n    |                    `- error: cannot find 'getAllDestinations' in scope\n209 |         }\n210 |     }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/QueryLogsCommand.swift:71:37: error: cannot find 'getDestination' in scope\n 69 |         do {\n 70 |             // Check if destination exists\n 71 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 72 |                 throw LoggingError.destinationNotFound(\n 73 |                     \"Cannot query logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RedactionRule.swift:123:72: error: missing argument for parameter 'privacyLevel' in call\n121 |                 if value != redactedValue {\n122 |                     // Only update if actually changed\n123 |                     result = result.with(key: key, value: redactedValue)\n    |                                                                        `- error: missing argument for parameter 'privacyLevel' in call\n124 |                 }\n125 |             }\n\n/Users/mpy/.bazel/execroot/_main/packages/UmbraCoreTypes/Sources/LoggingTypes/LogMetadataDTOCollection.swift:78:15: note: 'with(key:value:privacyLevel:)' declared here\n 76 |   ///   - privacyLevel: The privacy classification for this entry\n 77 |   /// - Returns: The updated collection\n 78 |   public func with(\n    |               `- note: 'with(key:value:privacyLevel:)' declared here\n 79 |     key: String,\n 80 |     value: String,\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RedactionRule.swift:101:26: warning: no calls to throwing functions occur within 'try' expression\n 99 |     public func redact(metadata: LogMetadataDTOCollection) -\u003e LogMetadataDTOCollection {\n100 |         // No redaction needed for empty metadata\n101 |         guard let keys = try? metadata.getKeys() else {\n    |                          `- warning: no calls to throwing functions occur within 'try' expression\n102 |             return metadata\n103 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RedactionRule.swift:119:28: warning: no calls to throwing functions occur within 'try' expression\n117 |             \n118 |             // Get string value and apply redaction\n119 |             if let value = try? metadata.getString(key: key) {\n    |                            `- warning: no calls to throwing functions occur within 'try' expression\n120 |                 let redactedValue = redact(value)\n121 |                 if value != redactedValue {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RemoveDestinationCommand.swift:67:37: error: cannot find 'getDestination' in scope\n 65 |         do {\n 66 |             // Check if destination exists\n 67 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 68 |                 throw LoggingError.destinationNotFound(\n 69 |                     \"Cannot remove destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RemoveDestinationCommand.swift:128:13: error: expression is 'async' but is not marked with 'await'\n126 |             \n127 |             // Unregister the destination\n128 |             unregisterDestination(id: destinationId)\n    |             |- error: expression is 'async' but is not marked with 'await'\n    |             `- note: calls to instance method 'unregisterDestination(id:)' from outside of its actor context are implicitly asynchronous\n129 |             \n130 |             // Log success\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RotateLogsCommand.swift:67:37: error: cannot find 'getDestination' in scope\n 65 |         do {\n 66 |             // Check if destination exists\n 67 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 68 |                 throw LoggingError.destinationNotFound(\n 69 |                     \"Cannot rotate logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RotateLogsCommand.swift:74:37: error: cannot infer contextual base in reference to member 'file'\n 72 |             \n 73 |             // Check if the destination type supports rotation\n 74 |             if destination.type != .file {\n    |                                     `- error: cannot infer contextual base in reference to member 'file'\n 75 |                 throw LoggingError.invalidDestinationConfig(\n 76 |                     \"Log rotation is only supported for file destinations\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RotateLogsCommand.swift:92:112: error: type 'LogPrivacyLevel' has no member 'protected'\n 90 |                     context: operationContext,\n 91 |                     additionalMetadata: [\n 92 |                         \"rotatedFilePath\": (value: rotationResult.rotatedFilePath ?? \"unknown\", privacyLevel: .protected),\n    |                                                                                                                `- error: type 'LogPrivacyLevel' has no member 'protected'\n 93 |                         \"rotatedSizeBytes\": (value: String(rotationResult.rotatedSizeBytes ?? 0), privacyLevel: .public),\n 94 |                         \"rotatedEntryCount\": (value: String(rotationResult.rotatedEntryCount ?? 0), privacyLevel: .public)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/WriteLogCommand.swift:159:20: error: cannot find 'getAllDestinations' in scope\n157 |         if destinationIds.isEmpty {\n158 |             // Use all registered destinations\n159 |             return getAllDestinations().filter { $0.isEnabled }\n    |                    `- error: cannot find 'getAllDestinations' in scope\n160 |         } else {\n161 |             // Use specific destinations\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/WriteLogCommand.swift:165:38: error: cannot find 'getDestination' in scope\n163 |             \n164 |             for destinationId in destinationIds {\n165 |                 if let destination = getDestination(id: destinationId) {\n    |                                      `- error: cannot find 'getDestination' in scope\n166 |                     if destination.isEnabled {\n167 |                         result.append(destination)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/WriteLogCommand.swift:193:16: error: cannot find 'applyFilterRules' in scope\n191 |         \n192 |         // Apply filter rules if they exist\n193 |         return applyFilterRules(\n    |                `- error: cannot find 'applyFilterRules' in scope\n194 |             to: entry,\n195 |             rules: destination.configuration.filterRules\n\npackages/UmbraImplementations/Sources/LoggingServices/DefaultLoggingServiceImpl.swift:39:36: warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 37 |     let contextDTO=BaseLogContextDTO(\n 38 |       domainName: \"Legacy\",\n 39 |       operation: context.operation ?? \"unknown\",\n    |                                    `- warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 40 |       category: context.category ?? \"General\",\n 41 |       source: context.source ?? \"Unknown\",\n\npackages/UmbraImplementations/Sources/LoggingServices/DefaultLoggingServiceImpl.swift:40:34: warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 38 |       domainName: \"Legacy\",\n 39 |       operation: context.operation ?? \"unknown\",\n 40 |       category: context.category ?? \"General\",\n    |                                  `- warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 41 |       source: context.source ?? \"Unknown\",\n 42 |       metadata: context.metadata\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:147:17: error: invalid redeclaration of 'log(_:_:context:)'\n145 |         - context: The logging context\n146 |      */\n147 |     public func log(_ level: LogLevel, _ message: String, context: any LogContextDTO) async {\n    |                 `- error: invalid redeclaration of 'log(_:_:context:)'\n148 |         // Convert to privacy string and use privacy-aware logging\n149 |         let privacyString = PrivacyString(stringLiteral: message)\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:92:48: error: value of type 'any LoggingProviderProtocol' has no member 'writeLogEntry'\n 90 |                     do {\n 91 |                         // Write log entry to destination\n 92 |                         _ = try await provider.writeLogEntry(entry, to: destination)\n    |                                                `- error: value of type 'any LoggingProviderProtocol' has no member 'writeLogEntry'\n 93 |                     } catch {\n 94 |                         // Silently ignore provider errors for now\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:122:28: error: value of type 'PrivacyString' has no member 'privacy'\n120 |         enrichedMetadata = enrichedMetadata.withPrivate(\n121 |             key: \"__privacy_annotation\", \n122 |             value: message.privacy.description\n    |                            `- error: value of type 'PrivacyString' has no member 'privacy'\n123 |         )\n124 |         \n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:136:34: error: value of type 'PrivacyString' has no member 'content'\n134 |         \n135 |         // Log the message using the standard log method\n136 |         await log(level, message.content, context: privacyContext)\n    |                                  `- error: value of type 'PrivacyString' has no member 'content'\n137 |     }\n138 |     \n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:167:71: error: value of type 'PrivacyAnnotatedString' has no member 'stringValue'\n165 |     ) async {\n166 |         let annotatedString = privacyScope()\n167 |         await log(level, PrivacyString(stringLiteral: annotatedString.stringValue), context: context) \n    |                                                                       `- error: value of type 'PrivacyAnnotatedString' has no member 'stringValue'\n168 |     }\n169 |     \n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:190:29: error: for-in loop requires 'LogMetadata' to conform to 'Sequence'\n188 |         // Create a metadata collection with sensitive values\n189 |         var metadataCollection = context.metadata\n190 |         for (key, value) in sensitiveValues {\n    |                             `- error: for-in loop requires 'LogMetadata' to conform to 'Sequence'\n191 |             metadataCollection = metadataCollection.withSensitive(key: key, value: String(describing: value))\n192 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:228:9: error: switch must be exhaustive\n226 |         \n227 |         // Add error information to metadata with appropriate privacy level\n228 |         switch privacyLevel {\n    |         |- error: switch must be exhaustive\n    |         `- note: add missing case: '.auto'\n229 |         case .public:\n230 |             metadataCollection = metadataCollection.withPublic(key: \"error_description\", value: error.localizedDescription)\npackages/UmbraImplementations/Sources/LoggingServices/PrivacyAwareLogDTO.swift:217:24: error: value of type 'LogMetadataDTOCollection' has no member 'set'\n215 |     for key in self.metadata.getKeys() {\n216 |       if let value = self.metadata.getString(key: key) {\n217 |         mergedMetadata.set(key: key, value: value)\n    |                        `- error: value of type 'LogMetadataDTOCollection' has no member 'set'\n218 |       }\n219 |     }\n\npackages/UmbraImplementations/Sources/LoggingServices/PrivacyAwareLogDTO.swift:224:24: error: value of type 'LogMetadataDTOCollection' has no member 'set'\n222 |     for key in additionalMetadata.getKeys() {\n223 |       if let value = additionalMetadata.getString(key: key) {\n224 |         mergedMetadata.set(key: key, value: value)\n    |                        `- error: value of type 'LogMetadataDTOCollection' has no member 'set'\n225 |       }\n226 |     }\n\npackages/UmbraImplementations/Sources/LoggingServices/PrivacyAwareLogDTO.swift:235:17: error: cannot convert value of type 'LogMetadataDTOCollection' to expected argument type '[String : (value: Any, privacy: LogPrivacyLevel)]'\n233 |       category: category,\n234 |       correlationID: correlationID,\n235 |       metadata: mergedMetadata,\n    |                 `- error: cannot convert value of type 'LogMetadataDTOCollection' to expected argument type '[String : (value: Any, privacy: LogPrivacyLevel)]'\n236 |       environment: environment\n237 |     )\nTarget //packages/UmbraImplementations/Sources/KeychainServices:KeychainServices failed to build\nINFO: Elapsed time: 1.131s, Critical Path: 1.01s\nINFO: 2 processes: 2 internal.\nERROR: Build did NOT complete successfully\n"
  },
  {
    "target": "rule //packages/UmbraImplementations/Sources/KeychainServices/Actor:KeychainSecurityActor",
    "success": true,
    "start_time": "2025-04-11T17:58:12.458591+01:00",
    "end_time": "2025-04-11T17:58:13.274887+01:00",
    "duration": "816.296958ms",
    "output": "INFO: Invocation ID: 01c5bf80-56a9-446b-8369-77920f6a0b91\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraImplementations/Sources/KeychainServices/Actor:KeychainSecurityActor (1 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraImplementations/Sources/KeychainServices/Actor:KeychainSecurityActor (1 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraImplementations/Sources/KeychainServices/Actor:KeychainSecurityActor (1 packages loaded, 2 targets configured).\nINFO: Found 1 target...\nTarget //packages/UmbraImplementations/Sources/KeychainServices/Actor:KeychainSecurityActor up-to-date:\n  bazel-bin/packages/UmbraImplementations/Sources/KeychainServices/Actor/KeychainSecurityActor.swiftdoc\n  bazel-bin/packages/UmbraImplementations/Sources/KeychainServices/Actor/KeychainSecurityActor.swiftmodule\n  bazel-bin/packages/UmbraImplementations/Sources/KeychainServices/Actor/KeychainSecurityActor.swiftsourceinfo\n  bazel-bin/packages/UmbraImplementations/Sources/KeychainServices/Actor/libKeychainSecurityActor.a\nINFO: Elapsed time: 0.128s, Critical Path: 0.00s\nINFO: 1 process: 3 action cache hit, 1 internal.\nINFO: Build completed successfully, 1 total action\n"
  },
  {
    "target": "rule //packages/UmbraImplementations/Sources/KeychainServices/ActorTypes:KeychainSecurityActor",
    "success": false,
    "start_time": "2025-04-11T17:58:13.274914+01:00",
    "end_time": "2025-04-11T17:58:15.060344+01:00",
    "duration": "1.785431792s",
    "output": "INFO: Invocation ID: 35164bcd-ba84-471b-b7e4-36573e2a3af1\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraImplementations/Sources/KeychainServices/ActorTypes:KeychainSecurityActor (0 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraImplementations/Sources/KeychainServices/ActorTypes:KeychainSecurityActor (0 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraImplementations/Sources/KeychainServices/ActorTypes:KeychainSecurityActor (0 packages loaded, 0 targets configured).\nERROR: /Users/mpy/CascadeProjects/UmbraCore/packages/UmbraImplementations/Sources/LoggingServices/BUILD.bazel:3:20: Compiling Swift module //packages/UmbraImplementations/Sources/LoggingServices:LoggingServices failed: (Exit 1): worker failed: error executing SwiftCompile command (from target //packages/UmbraImplementations/Sources/LoggingServices:LoggingServices) \n  (cd /Users/mpy/.bazel/execroot/_main \u0026\u0026 \\\n  exec env - \\\n    APPLE_SDK_PLATFORM=MacOSX \\\n    APPLE_SDK_VERSION_OVERRIDE=15.4 \\\n    CC=clang \\\n    PATH=/Users/mpy/Library/Caches/bazelisk/downloads/sha256/ac72ad67f7a8c6b18bf605d8602425182b417de4369715bf89146daf62f7ae48/bin:/Users/mpy/.rbenv/bin:/Users/mpy/.codeium/windsurf/bin:/opt/homebrew/opt/node@18/bin:/opt/homebrew/opt/node@20/bin:/Users/mpy/.docker/bin:/opt/homebrew/opt/openjdk/bin:/Users/mpy/bin:/opt/homebrew/bin:/opt/homebrew/sbin:/usr/local/bin:/System/Cryptexes/App/usr/bin:/usr/bin:/bin:/usr/sbin:/sbin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/local/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/appleinternal/bin:/Library/Apple/usr/bin:/usr/local/go/bin:/Users/mpy/.rbenv/bin:/Users/mpy/.codeium/windsurf/bin:/opt/homebrew/opt/node@18/bin:/opt/homebrew/opt/node@20/bin:/opt/anaconda3/bin:/opt/anaconda3/condabin:/Users/mpy/.docker/bin:/opt/homebrew/opt/openjdk/bin:/Users/mpy/bin:/Users/mpy/.cargo/bin:/Users/mpy/Library/Python/3.8/bin:/Users/mpy/go/bin:/Users/mpy/.scripts:/Users/mpy/.fzf/bin:/Users/mpy/.windsurf/extensions/ms-python.debugpy-2025.6.0-darwin-arm64/bundled/scripts/noConfigScripts:/Users/mpy/Library/Python/3.8/bin:/Users/mpy/go/bin:/Users/mpy/.scripts \\\n    XCODE_VERSION_OVERRIDE=16.3.0.16E140 \\\n  bazel-out/darwin_arm64-opt-exec-ST-d57f47055a04/bin/external/rules_swift+/tools/worker/worker swiftc @bazel-out/darwin_arm64-fastbuild/bin/packages/UmbraImplementations/Sources/LoggingServices/LoggingServices.swiftmodule-0.params)\n# Configuration: 76a1bf3a80f2d50513004915454165d2f164db794b63e4666809cbd93e1abeaa\n# Execution platform: @@platforms//host:host\nerror: emit-module command failed with exit code 1 (use -v to see invocation)\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:147:17: error: invalid redeclaration of 'log(_:_:context:)'\n145 |         - context: The logging context\n146 |      */\n147 |     public func log(_ level: LogLevel, _ message: String, context: any LogContextDTO) async {\n    |                 `- error: invalid redeclaration of 'log(_:_:context:)'\n148 |         // Convert to privacy string and use privacy-aware logging\n149 |         let privacyString = PrivacyString(stringLiteral: message)\npackages/UmbraImplementations/Sources/LoggingServices/Commands/AddDestinationCommand.swift:68:31: error: cannot find 'getDestination' in scope\n 66 |         do {\n 67 |             // Check if destination already exists\n 68 |             if let existing = getDestination(id: destination.id) {\n    |                               `- error: cannot find 'getDestination' in scope\n 69 |                 if !options.overwriteExisting {\n 70 |                     throw LoggingError.destinationAlreadyExists(identifier: \"Destination with ID \\(destination.id) already exists\")\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/AddDestinationCommand.swift:82:40: error: cannot find 'validateDestination' in scope\n 80 |             // Validate destination configuration if requested\n 81 |             if options.validateConfiguration {\n 82 |                 let validationResult = validateDestination(destination, for: provider)\n    |                                        `- error: cannot find 'validateDestination' in scope\n 83 |                 \n 84 |                 if !validationResult.isValid {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/AddDestinationCommand.swift:121:13: error: expression is 'async' but is not marked with 'await'\n119 |             \n120 |             // Register the destination\n121 |             registerDestination(destination)\n    |             |- error: expression is 'async' but is not marked with 'await'\n    |             `- note: calls to instance method 'registerDestination' from outside of its actor context are implicitly asynchronous\n122 |             \n123 |             // Log success\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ArchiveLogsCommand.swift:57:84: error: type 'LogPrivacyLevel' has no member 'protected'\n 55 |             destinationId: destinationId,\n 56 |             additionalMetadata: [\n 57 |                 \"destinationPath\": (value: options.destinationPath, privacyLevel: .protected),\n    |                                                                                    `- error: type 'LogPrivacyLevel' has no member 'protected'\n 58 |                 \"compress\": (value: String(options.compress), privacyLevel: .public),\n 59 |                 \"format\": (value: options.format.rawValue, privacyLevel: .public),\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ArchiveLogsCommand.swift:70:37: error: cannot find 'getDestination' in scope\n 68 |         do {\n 69 |             // Check if destination exists\n 70 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 71 |                 throw LoggingError.destinationNotFound(\n 72 |                     \"Cannot archive logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ArchiveLogsCommand.swift:113:103: error: type 'LogPrivacyLevel' has no member 'protected'\n111 |                     context: operationContext,\n112 |                     additionalMetadata: [\n113 |                         \"archivePath\": (value: archiveResult.archivePath ?? \"unknown\", privacyLevel: .protected),\n    |                                                                                                       `- error: type 'LogPrivacyLevel' has no member 'protected'\n114 |                         \"archiveSizeBytes\": (value: String(archiveResult.archiveSizeBytes ?? 0), privacyLevel: .public),\n115 |                         \"archivedEntryCount\": (value: String(archiveResult.archivedEntryCount ?? 0), privacyLevel: .public)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ExportLogsCommand.swift:70:37: error: cannot find 'getDestination' in scope\n 68 |         do {\n 69 |             // Check if destination exists\n 70 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 71 |                 throw LoggingError.destinationNotFound(\n 72 |                     \"Cannot export logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:79:50: error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n 77 |                 key: key,\n 78 |                 value: value.value,\n 79 |                 privacyLevel: value.privacyLevel.toPrivacyClassification()\n    |                                                  `- error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n 80 |             )\n 81 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:122:54: error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n120 |                     key: key,\n121 |                     value: value.value,\n122 |                     privacyLevel: value.privacyLevel.toPrivacyClassification()\n    |                                                      `- error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n123 |                 )\n124 |             )\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:229:21: error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n227 |         \n228 |         // Process special fields first\n229 |         switch rule.field {\n    |                     `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n230 |         case \"level\":\n231 |             fieldValue = entry.level.rawValue\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:238:96: error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n236 |         default:\n237 |             // Check metadata fields\n238 |             if let metadata = entry.metadata, let metadataValue = metadata.getString(key: rule.field) {\n    |                                                                                                `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n239 |                 fieldValue = metadataValue\n240 |             } else {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:246:21: error: value of type 'UmbraLogFilterRuleDTO' has no member 'operation'\n244 |         \n245 |         // Apply the operation\n246 |         switch rule.operation {\n    |                     `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'operation'\n247 |         case .equals:\n248 |             return fieldValue == rule.value\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:248:39: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n246 |         switch rule.operation {\n247 |         case .equals:\n248 |             return fieldValue == rule.value\n    |                                       `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n249 |         case .contains:\n250 |             return fieldValue.contains(rule.value)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:250:45: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n248 |             return fieldValue == rule.value\n249 |         case .contains:\n250 |             return fieldValue.contains(rule.value)\n    |                                             `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n251 |         case .startsWith:\n252 |             return fieldValue.hasPrefix(rule.value)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:252:46: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n250 |             return fieldValue.contains(rule.value)\n251 |         case .startsWith:\n252 |             return fieldValue.hasPrefix(rule.value)\n    |                                              `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n253 |         case .endsWith:\n254 |             return fieldValue.hasSuffix(rule.value)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:254:46: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n252 |             return fieldValue.hasPrefix(rule.value)\n253 |         case .endsWith:\n254 |             return fieldValue.hasSuffix(rule.value)\n    |                                              `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n255 |         case .matches:\n256 |             if let regex = try? NSRegularExpression(pattern: rule.value) {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:256:67: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n254 |             return fieldValue.hasSuffix(rule.value)\n255 |         case .matches:\n256 |             if let regex = try? NSRegularExpression(pattern: rule.value) {\n    |                                                                   `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n257 |                 let range = NSRange(location: 0, length: fieldValue.utf16.count)\n258 |                 return regex.firstMatch(in: fieldValue, options: [], range: range) != nil\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:262:86: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n260 |             return false\n261 |         case .greaterThan:\n262 |             if let fieldNumeric = Double(fieldValue), let valueNumeric = Double(rule.value) {\n    |                                                                                      `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n263 |                 return fieldNumeric \u003e valueNumeric\n264 |             }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:267:86: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n265 |             return false\n266 |         case .lessThan:\n267 |             if let fieldNumeric = Double(fieldValue), let valueNumeric = Double(rule.value) {\n    |                                                                                      `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n268 |                 return fieldNumeric \u003c valueNumeric\n269 |             }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:293:13: warning: variable 'redactedMetadata' was never mutated; consider changing to 'let' constant\n291 |         // Create mutable copies\n292 |         var redactedMessage = entry.message\n293 |         var redactedMetadata = entry.metadata\n    |             `- warning: variable 'redactedMetadata' was never mutated; consider changing to 'let' constant\n294 |         \n295 |         for rule in rules {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:395:47: error: value of type 'String' has no member 'stringByReplacingMatches'\n393 |             if rule.targetFields.isEmpty || rule.targetFields.contains(\"message\") {\n394 |                 if let pattern = rule.pattern {\n395 |                     redactedMessage = pattern.stringByReplacingMatches(\n    |                                               `- error: value of type 'String' has no member 'stringByReplacingMatches'\n396 |                         in: redactedMessage,\n397 |                         options: [],\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:394:20: error: initializer for conditional binding must have Optional type, not 'String'\n392 |             // Apply rule to message if it matches\n393 |             if rule.targetFields.isEmpty || rule.targetFields.contains(\"message\") {\n394 |                 if let pattern = rule.pattern {\n    |                    `- error: initializer for conditional binding must have Optional type, not 'String'\n395 |                     redactedMessage = pattern.stringByReplacingMatches(\n396 |                         in: redactedMessage,\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:405:24: error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getKeys' of wrapped base type 'LogMetadataDTOCollection'\n403 |             \n404 |             // Process metadata fields\n405 |             for key in redactedMetadata.getKeys() {\n    |                        |- error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getKeys' of wrapped base type 'LogMetadataDTOCollection'\n    |                        |- note: chain the optional using '?' to access member 'getKeys' only for non-'nil' base values\n    |                        `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n406 |                 if rule.targetFields.isEmpty || rule.targetFields.contains(key) {\n407 |                     if let stringValue = redactedMetadata.getString(key: key) {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:407:42: error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getString' of wrapped base type 'LogMetadataDTOCollection'\n405 |             for key in redactedMetadata.getKeys() {\n406 |                 if rule.targetFields.isEmpty || rule.targetFields.contains(key) {\n407 |                     if let stringValue = redactedMetadata.getString(key: key) {\n    |                                          |- error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getString' of wrapped base type 'LogMetadataDTOCollection'\n    |                                          |- note: chain the optional using '?' to access member 'getString' only for non-'nil' base values\n    |                                          `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n408 |                         // Skip fields that should be preserved\n409 |                         if rule.preserveFields.contains(key) {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:468:15: error: type 'LogPrivacyLevel' has no member 'never'\n466 |         case .auto:\n467 |             return .auto\n468 |         case .never:\n    |               `- error: type 'LogPrivacyLevel' has no member 'never'\n469 |             return .public // Map 'never' to public classification\n470 |         case .protected:\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:470:15: error: type 'LogPrivacyLevel' has no member 'protected'\n468 |         case .never:\n469 |             return .public // Map 'never' to public classification\n470 |         case .protected:\n    |               `- error: type 'LogPrivacyLevel' has no member 'protected'\n471 |             return .private // Map 'protected' to private classification\n472 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:58:84: error: type 'LogPrivacyLevel' has no member 'protected'\n 56 |             additionalMetadata: [\n 57 |                 \"createBackup\": (value: String(options.createBackup), privacyLevel: .public),\n 58 |                 \"backupPath\": (value: options.backupPath ?? \"none\", privacyLevel: .protected),\n    |                                                                                    `- error: type 'LogPrivacyLevel' has no member 'protected'\n 59 |                 \"dryRun\": (value: String(options.dryRun), privacyLevel: .public),\n 60 |                 \"hasFilterCriteria\": (value: String(options.filterCriteria != nil), privacyLevel: .public),\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:184:34: error: cannot find 'getDestination' in scope\n182 |         if let destinationId = destinationId {\n183 |             // Use specific destination\n184 |             if let destination = getDestination(id: destinationId) {\n    |                                  `- error: cannot find 'getDestination' in scope\n185 |                 return [destination]\n186 |             } else {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:196:38: error: cannot find 'getDestination' in scope\n194 |             \n195 |             for id in options.destinationIds {\n196 |                 if let destination = getDestination(id: id) {\n    |                                      `- error: cannot find 'getDestination' in scope\n197 |                     result.append(destination)\n198 |                 } else {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:208:20: error: cannot find 'getAllDestinations' in scope\n206 |         } else {\n207 |             // Use all registered destinations\n208 |             return getAllDestinations()\n    |                    `- error: cannot find 'getAllDestinations' in scope\n209 |         }\n210 |     }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/QueryLogsCommand.swift:71:37: error: cannot find 'getDestination' in scope\n 69 |         do {\n 70 |             // Check if destination exists\n 71 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 72 |                 throw LoggingError.destinationNotFound(\n 73 |                     \"Cannot query logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RedactionRule.swift:123:72: error: missing argument for parameter 'privacyLevel' in call\n121 |                 if value != redactedValue {\n122 |                     // Only update if actually changed\n123 |                     result = result.with(key: key, value: redactedValue)\n    |                                                                        `- error: missing argument for parameter 'privacyLevel' in call\n124 |                 }\n125 |             }\n\n/Users/mpy/.bazel/execroot/_main/packages/UmbraCoreTypes/Sources/LoggingTypes/LogMetadataDTOCollection.swift:78:15: note: 'with(key:value:privacyLevel:)' declared here\n 76 |   ///   - privacyLevel: The privacy classification for this entry\n 77 |   /// - Returns: The updated collection\n 78 |   public func with(\n    |               `- note: 'with(key:value:privacyLevel:)' declared here\n 79 |     key: String,\n 80 |     value: String,\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RedactionRule.swift:101:26: warning: no calls to throwing functions occur within 'try' expression\n 99 |     public func redact(metadata: LogMetadataDTOCollection) -\u003e LogMetadataDTOCollection {\n100 |         // No redaction needed for empty metadata\n101 |         guard let keys = try? metadata.getKeys() else {\n    |                          `- warning: no calls to throwing functions occur within 'try' expression\n102 |             return metadata\n103 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RedactionRule.swift:119:28: warning: no calls to throwing functions occur within 'try' expression\n117 |             \n118 |             // Get string value and apply redaction\n119 |             if let value = try? metadata.getString(key: key) {\n    |                            `- warning: no calls to throwing functions occur within 'try' expression\n120 |                 let redactedValue = redact(value)\n121 |                 if value != redactedValue {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RemoveDestinationCommand.swift:67:37: error: cannot find 'getDestination' in scope\n 65 |         do {\n 66 |             // Check if destination exists\n 67 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 68 |                 throw LoggingError.destinationNotFound(\n 69 |                     \"Cannot remove destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RemoveDestinationCommand.swift:128:13: error: expression is 'async' but is not marked with 'await'\n126 |             \n127 |             // Unregister the destination\n128 |             unregisterDestination(id: destinationId)\n    |             |- error: expression is 'async' but is not marked with 'await'\n    |             `- note: calls to instance method 'unregisterDestination(id:)' from outside of its actor context are implicitly asynchronous\n129 |             \n130 |             // Log success\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RotateLogsCommand.swift:67:37: error: cannot find 'getDestination' in scope\n 65 |         do {\n 66 |             // Check if destination exists\n 67 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 68 |                 throw LoggingError.destinationNotFound(\n 69 |                     \"Cannot rotate logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RotateLogsCommand.swift:74:37: error: cannot infer contextual base in reference to member 'file'\n 72 |             \n 73 |             // Check if the destination type supports rotation\n 74 |             if destination.type != .file {\n    |                                     `- error: cannot infer contextual base in reference to member 'file'\n 75 |                 throw LoggingError.invalidDestinationConfig(\n 76 |                     \"Log rotation is only supported for file destinations\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RotateLogsCommand.swift:92:112: error: type 'LogPrivacyLevel' has no member 'protected'\n 90 |                     context: operationContext,\n 91 |                     additionalMetadata: [\n 92 |                         \"rotatedFilePath\": (value: rotationResult.rotatedFilePath ?? \"unknown\", privacyLevel: .protected),\n    |                                                                                                                `- error: type 'LogPrivacyLevel' has no member 'protected'\n 93 |                         \"rotatedSizeBytes\": (value: String(rotationResult.rotatedSizeBytes ?? 0), privacyLevel: .public),\n 94 |                         \"rotatedEntryCount\": (value: String(rotationResult.rotatedEntryCount ?? 0), privacyLevel: .public)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/WriteLogCommand.swift:159:20: error: cannot find 'getAllDestinations' in scope\n157 |         if destinationIds.isEmpty {\n158 |             // Use all registered destinations\n159 |             return getAllDestinations().filter { $0.isEnabled }\n    |                    `- error: cannot find 'getAllDestinations' in scope\n160 |         } else {\n161 |             // Use specific destinations\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/WriteLogCommand.swift:165:38: error: cannot find 'getDestination' in scope\n163 |             \n164 |             for destinationId in destinationIds {\n165 |                 if let destination = getDestination(id: destinationId) {\n    |                                      `- error: cannot find 'getDestination' in scope\n166 |                     if destination.isEnabled {\n167 |                         result.append(destination)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/WriteLogCommand.swift:193:16: error: cannot find 'applyFilterRules' in scope\n191 |         \n192 |         // Apply filter rules if they exist\n193 |         return applyFilterRules(\n    |                `- error: cannot find 'applyFilterRules' in scope\n194 |             to: entry,\n195 |             rules: destination.configuration.filterRules\n\npackages/UmbraImplementations/Sources/LoggingServices/DefaultLoggingServiceImpl.swift:39:36: warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 37 |     let contextDTO=BaseLogContextDTO(\n 38 |       domainName: \"Legacy\",\n 39 |       operation: context.operation ?? \"unknown\",\n    |                                    `- warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 40 |       category: context.category ?? \"General\",\n 41 |       source: context.source ?? \"Unknown\",\n\npackages/UmbraImplementations/Sources/LoggingServices/DefaultLoggingServiceImpl.swift:40:34: warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 38 |       domainName: \"Legacy\",\n 39 |       operation: context.operation ?? \"unknown\",\n 40 |       category: context.category ?? \"General\",\n    |                                  `- warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 41 |       source: context.source ?? \"Unknown\",\n 42 |       metadata: context.metadata\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:147:17: error: invalid redeclaration of 'log(_:_:context:)'\n145 |         - context: The logging context\n146 |      */\n147 |     public func log(_ level: LogLevel, _ message: String, context: any LogContextDTO) async {\n    |                 `- error: invalid redeclaration of 'log(_:_:context:)'\n148 |         // Convert to privacy string and use privacy-aware logging\n149 |         let privacyString = PrivacyString(stringLiteral: message)\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:92:48: error: value of type 'any LoggingProviderProtocol' has no member 'writeLogEntry'\n 90 |                     do {\n 91 |                         // Write log entry to destination\n 92 |                         _ = try await provider.writeLogEntry(entry, to: destination)\n    |                                                `- error: value of type 'any LoggingProviderProtocol' has no member 'writeLogEntry'\n 93 |                     } catch {\n 94 |                         // Silently ignore provider errors for now\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:122:28: error: value of type 'PrivacyString' has no member 'privacy'\n120 |         enrichedMetadata = enrichedMetadata.withPrivate(\n121 |             key: \"__privacy_annotation\", \n122 |             value: message.privacy.description\n    |                            `- error: value of type 'PrivacyString' has no member 'privacy'\n123 |         )\n124 |         \n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:136:34: error: value of type 'PrivacyString' has no member 'content'\n134 |         \n135 |         // Log the message using the standard log method\n136 |         await log(level, message.content, context: privacyContext)\n    |                                  `- error: value of type 'PrivacyString' has no member 'content'\n137 |     }\n138 |     \n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:167:71: error: value of type 'PrivacyAnnotatedString' has no member 'stringValue'\n165 |     ) async {\n166 |         let annotatedString = privacyScope()\n167 |         await log(level, PrivacyString(stringLiteral: annotatedString.stringValue), context: context) \n    |                                                                       `- error: value of type 'PrivacyAnnotatedString' has no member 'stringValue'\n168 |     }\n169 |     \n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:190:29: error: for-in loop requires 'LogMetadata' to conform to 'Sequence'\n188 |         // Create a metadata collection with sensitive values\n189 |         var metadataCollection = context.metadata\n190 |         for (key, value) in sensitiveValues {\n    |                             `- error: for-in loop requires 'LogMetadata' to conform to 'Sequence'\n191 |             metadataCollection = metadataCollection.withSensitive(key: key, value: String(describing: value))\n192 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:228:9: error: switch must be exhaustive\n226 |         \n227 |         // Add error information to metadata with appropriate privacy level\n228 |         switch privacyLevel {\n    |         |- error: switch must be exhaustive\n    |         `- note: add missing case: '.auto'\n229 |         case .public:\n230 |             metadataCollection = metadataCollection.withPublic(key: \"error_description\", value: error.localizedDescription)\npackages/UmbraImplementations/Sources/LoggingServices/PrivacyAwareLogDTO.swift:217:24: error: value of type 'LogMetadataDTOCollection' has no member 'set'\n215 |     for key in self.metadata.getKeys() {\n216 |       if let value = self.metadata.getString(key: key) {\n217 |         mergedMetadata.set(key: key, value: value)\n    |                        `- error: value of type 'LogMetadataDTOCollection' has no member 'set'\n218 |       }\n219 |     }\n\npackages/UmbraImplementations/Sources/LoggingServices/PrivacyAwareLogDTO.swift:224:24: error: value of type 'LogMetadataDTOCollection' has no member 'set'\n222 |     for key in additionalMetadata.getKeys() {\n223 |       if let value = additionalMetadata.getString(key: key) {\n224 |         mergedMetadata.set(key: key, value: value)\n    |                        `- error: value of type 'LogMetadataDTOCollection' has no member 'set'\n225 |       }\n226 |     }\n\npackages/UmbraImplementations/Sources/LoggingServices/PrivacyAwareLogDTO.swift:235:17: error: cannot convert value of type 'LogMetadataDTOCollection' to expected argument type '[String : (value: Any, privacy: LogPrivacyLevel)]'\n233 |       category: category,\n234 |       correlationID: correlationID,\n235 |       metadata: mergedMetadata,\n    |                 `- error: cannot convert value of type 'LogMetadataDTOCollection' to expected argument type '[String : (value: Any, privacy: LogPrivacyLevel)]'\n236 |       environment: environment\n237 |     )\nTarget //packages/UmbraImplementations/Sources/KeychainServices/ActorTypes:KeychainSecurityActor failed to build\nINFO: Elapsed time: 1.131s, Critical Path: 1.00s\nINFO: 2 processes: 2 internal.\nERROR: Build did NOT complete successfully\n"
  },
  {
    "target": "rule //packages/UmbraImplementations/Sources/KeychainServices/Fallbacks:Fallbacks",
    "success": true,
    "start_time": "2025-04-11T17:58:15.060363+01:00",
    "end_time": "2025-04-11T17:58:15.940654+01:00",
    "duration": "880.29175ms",
    "output": "INFO: Invocation ID: bbfa72f4-09d7-4396-9db4-1a8ef46315fb\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraImplementations/Sources/KeychainServices/Fallbacks:Fallbacks (0 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraImplementations/Sources/KeychainServices/Fallbacks:Fallbacks (0 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraImplementations/Sources/KeychainServices/Fallbacks:Fallbacks (0 packages loaded, 0 targets configured).\nINFO: Found 1 target...\nTarget //packages/UmbraImplementations/Sources/KeychainServices/Fallbacks:Fallbacks up-to-date:\n  bazel-bin/packages/UmbraImplementations/Sources/KeychainServices/Fallbacks/Fallbacks.swiftdoc\n  bazel-bin/packages/UmbraImplementations/Sources/KeychainServices/Fallbacks/Fallbacks.swiftmodule\n  bazel-bin/packages/UmbraImplementations/Sources/KeychainServices/Fallbacks/Fallbacks.swiftsourceinfo\n  bazel-bin/packages/UmbraImplementations/Sources/KeychainServices/Fallbacks/libFallbacks.a\nINFO: Elapsed time: 0.158s, Critical Path: 0.03s\nINFO: 2 processes: 1 internal, 1 local.\nINFO: Build completed successfully, 2 total actions\n"
  },
  {
    "target": "rule //packages/UmbraImplementations/Sources/KeychainServices/Logging:KeychainLogger",
    "success": false,
    "start_time": "2025-04-11T17:58:15.940666+01:00",
    "end_time": "2025-04-11T17:58:18.14285+01:00",
    "duration": "2.202186333s",
    "output": "INFO: Invocation ID: 8426dc53-3b98-4b58-bcb5-669d3e19dec5\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraImplementations/Sources/KeychainServices/Logging:KeychainLogger (0 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraImplementations/Sources/KeychainServices/Logging:KeychainLogger (0 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraImplementations/Sources/KeychainServices/Logging:KeychainLogger (0 packages loaded, 0 targets configured).\nERROR: /Users/mpy/CascadeProjects/UmbraCore/packages/UmbraImplementations/Sources/LoggingServices/BUILD.bazel:3:20: Compiling Swift module //packages/UmbraImplementations/Sources/LoggingServices:LoggingServices failed: (Exit 1): worker failed: error executing SwiftCompile command (from target //packages/UmbraImplementations/Sources/LoggingServices:LoggingServices) \n  (cd /Users/mpy/.bazel/execroot/_main \u0026\u0026 \\\n  exec env - \\\n    APPLE_SDK_PLATFORM=MacOSX \\\n    APPLE_SDK_VERSION_OVERRIDE=15.4 \\\n    CC=clang \\\n    PATH=/Users/mpy/Library/Caches/bazelisk/downloads/sha256/ac72ad67f7a8c6b18bf605d8602425182b417de4369715bf89146daf62f7ae48/bin:/Users/mpy/.rbenv/bin:/Users/mpy/.codeium/windsurf/bin:/opt/homebrew/opt/node@18/bin:/opt/homebrew/opt/node@20/bin:/Users/mpy/.docker/bin:/opt/homebrew/opt/openjdk/bin:/Users/mpy/bin:/opt/homebrew/bin:/opt/homebrew/sbin:/usr/local/bin:/System/Cryptexes/App/usr/bin:/usr/bin:/bin:/usr/sbin:/sbin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/local/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/appleinternal/bin:/Library/Apple/usr/bin:/usr/local/go/bin:/Users/mpy/.rbenv/bin:/Users/mpy/.codeium/windsurf/bin:/opt/homebrew/opt/node@18/bin:/opt/homebrew/opt/node@20/bin:/opt/anaconda3/bin:/opt/anaconda3/condabin:/Users/mpy/.docker/bin:/opt/homebrew/opt/openjdk/bin:/Users/mpy/bin:/Users/mpy/.cargo/bin:/Users/mpy/Library/Python/3.8/bin:/Users/mpy/go/bin:/Users/mpy/.scripts:/Users/mpy/.fzf/bin:/Users/mpy/.windsurf/extensions/ms-python.debugpy-2025.6.0-darwin-arm64/bundled/scripts/noConfigScripts:/Users/mpy/Library/Python/3.8/bin:/Users/mpy/go/bin:/Users/mpy/.scripts \\\n    XCODE_VERSION_OVERRIDE=16.3.0.16E140 \\\n  bazel-out/darwin_arm64-opt-exec-ST-d57f47055a04/bin/external/rules_swift+/tools/worker/worker swiftc @bazel-out/darwin_arm64-fastbuild/bin/packages/UmbraImplementations/Sources/LoggingServices/LoggingServices.swiftmodule-0.params)\n# Configuration: 76a1bf3a80f2d50513004915454165d2f164db794b63e4666809cbd93e1abeaa\n# Execution platform: @@platforms//host:host\nerror: emit-module command failed with exit code 1 (use -v to see invocation)\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:147:17: error: invalid redeclaration of 'log(_:_:context:)'\n145 |         - context: The logging context\n146 |      */\n147 |     public func log(_ level: LogLevel, _ message: String, context: any LogContextDTO) async {\n    |                 `- error: invalid redeclaration of 'log(_:_:context:)'\n148 |         // Convert to privacy string and use privacy-aware logging\n149 |         let privacyString = PrivacyString(stringLiteral: message)\npackages/UmbraImplementations/Sources/LoggingServices/Commands/AddDestinationCommand.swift:68:31: error: cannot find 'getDestination' in scope\n 66 |         do {\n 67 |             // Check if destination already exists\n 68 |             if let existing = getDestination(id: destination.id) {\n    |                               `- error: cannot find 'getDestination' in scope\n 69 |                 if !options.overwriteExisting {\n 70 |                     throw LoggingError.destinationAlreadyExists(identifier: \"Destination with ID \\(destination.id) already exists\")\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/AddDestinationCommand.swift:82:40: error: cannot find 'validateDestination' in scope\n 80 |             // Validate destination configuration if requested\n 81 |             if options.validateConfiguration {\n 82 |                 let validationResult = validateDestination(destination, for: provider)\n    |                                        `- error: cannot find 'validateDestination' in scope\n 83 |                 \n 84 |                 if !validationResult.isValid {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/AddDestinationCommand.swift:121:13: error: expression is 'async' but is not marked with 'await'\n119 |             \n120 |             // Register the destination\n121 |             registerDestination(destination)\n    |             |- error: expression is 'async' but is not marked with 'await'\n    |             `- note: calls to instance method 'registerDestination' from outside of its actor context are implicitly asynchronous\n122 |             \n123 |             // Log success\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ArchiveLogsCommand.swift:57:84: error: type 'LogPrivacyLevel' has no member 'protected'\n 55 |             destinationId: destinationId,\n 56 |             additionalMetadata: [\n 57 |                 \"destinationPath\": (value: options.destinationPath, privacyLevel: .protected),\n    |                                                                                    `- error: type 'LogPrivacyLevel' has no member 'protected'\n 58 |                 \"compress\": (value: String(options.compress), privacyLevel: .public),\n 59 |                 \"format\": (value: options.format.rawValue, privacyLevel: .public),\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ArchiveLogsCommand.swift:70:37: error: cannot find 'getDestination' in scope\n 68 |         do {\n 69 |             // Check if destination exists\n 70 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 71 |                 throw LoggingError.destinationNotFound(\n 72 |                     \"Cannot archive logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ArchiveLogsCommand.swift:113:103: error: type 'LogPrivacyLevel' has no member 'protected'\n111 |                     context: operationContext,\n112 |                     additionalMetadata: [\n113 |                         \"archivePath\": (value: archiveResult.archivePath ?? \"unknown\", privacyLevel: .protected),\n    |                                                                                                       `- error: type 'LogPrivacyLevel' has no member 'protected'\n114 |                         \"archiveSizeBytes\": (value: String(archiveResult.archiveSizeBytes ?? 0), privacyLevel: .public),\n115 |                         \"archivedEntryCount\": (value: String(archiveResult.archivedEntryCount ?? 0), privacyLevel: .public)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ExportLogsCommand.swift:70:37: error: cannot find 'getDestination' in scope\n 68 |         do {\n 69 |             // Check if destination exists\n 70 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 71 |                 throw LoggingError.destinationNotFound(\n 72 |                     \"Cannot export logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:79:50: error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n 77 |                 key: key,\n 78 |                 value: value.value,\n 79 |                 privacyLevel: value.privacyLevel.toPrivacyClassification()\n    |                                                  `- error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n 80 |             )\n 81 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:122:54: error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n120 |                     key: key,\n121 |                     value: value.value,\n122 |                     privacyLevel: value.privacyLevel.toPrivacyClassification()\n    |                                                      `- error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n123 |                 )\n124 |             )\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:229:21: error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n227 |         \n228 |         // Process special fields first\n229 |         switch rule.field {\n    |                     `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n230 |         case \"level\":\n231 |             fieldValue = entry.level.rawValue\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:238:96: error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n236 |         default:\n237 |             // Check metadata fields\n238 |             if let metadata = entry.metadata, let metadataValue = metadata.getString(key: rule.field) {\n    |                                                                                                `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n239 |                 fieldValue = metadataValue\n240 |             } else {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:246:21: error: value of type 'UmbraLogFilterRuleDTO' has no member 'operation'\n244 |         \n245 |         // Apply the operation\n246 |         switch rule.operation {\n    |                     `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'operation'\n247 |         case .equals:\n248 |             return fieldValue == rule.value\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:248:39: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n246 |         switch rule.operation {\n247 |         case .equals:\n248 |             return fieldValue == rule.value\n    |                                       `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n249 |         case .contains:\n250 |             return fieldValue.contains(rule.value)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:250:45: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n248 |             return fieldValue == rule.value\n249 |         case .contains:\n250 |             return fieldValue.contains(rule.value)\n    |                                             `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n251 |         case .startsWith:\n252 |             return fieldValue.hasPrefix(rule.value)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:252:46: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n250 |             return fieldValue.contains(rule.value)\n251 |         case .startsWith:\n252 |             return fieldValue.hasPrefix(rule.value)\n    |                                              `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n253 |         case .endsWith:\n254 |             return fieldValue.hasSuffix(rule.value)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:254:46: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n252 |             return fieldValue.hasPrefix(rule.value)\n253 |         case .endsWith:\n254 |             return fieldValue.hasSuffix(rule.value)\n    |                                              `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n255 |         case .matches:\n256 |             if let regex = try? NSRegularExpression(pattern: rule.value) {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:256:67: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n254 |             return fieldValue.hasSuffix(rule.value)\n255 |         case .matches:\n256 |             if let regex = try? NSRegularExpression(pattern: rule.value) {\n    |                                                                   `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n257 |                 let range = NSRange(location: 0, length: fieldValue.utf16.count)\n258 |                 return regex.firstMatch(in: fieldValue, options: [], range: range) != nil\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:262:86: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n260 |             return false\n261 |         case .greaterThan:\n262 |             if let fieldNumeric = Double(fieldValue), let valueNumeric = Double(rule.value) {\n    |                                                                                      `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n263 |                 return fieldNumeric \u003e valueNumeric\n264 |             }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:267:86: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n265 |             return false\n266 |         case .lessThan:\n267 |             if let fieldNumeric = Double(fieldValue), let valueNumeric = Double(rule.value) {\n    |                                                                                      `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n268 |                 return fieldNumeric \u003c valueNumeric\n269 |             }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:293:13: warning: variable 'redactedMetadata' was never mutated; consider changing to 'let' constant\n291 |         // Create mutable copies\n292 |         var redactedMessage = entry.message\n293 |         var redactedMetadata = entry.metadata\n    |             `- warning: variable 'redactedMetadata' was never mutated; consider changing to 'let' constant\n294 |         \n295 |         for rule in rules {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:395:47: error: value of type 'String' has no member 'stringByReplacingMatches'\n393 |             if rule.targetFields.isEmpty || rule.targetFields.contains(\"message\") {\n394 |                 if let pattern = rule.pattern {\n395 |                     redactedMessage = pattern.stringByReplacingMatches(\n    |                                               `- error: value of type 'String' has no member 'stringByReplacingMatches'\n396 |                         in: redactedMessage,\n397 |                         options: [],\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:394:20: error: initializer for conditional binding must have Optional type, not 'String'\n392 |             // Apply rule to message if it matches\n393 |             if rule.targetFields.isEmpty || rule.targetFields.contains(\"message\") {\n394 |                 if let pattern = rule.pattern {\n    |                    `- error: initializer for conditional binding must have Optional type, not 'String'\n395 |                     redactedMessage = pattern.stringByReplacingMatches(\n396 |                         in: redactedMessage,\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:405:24: error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getKeys' of wrapped base type 'LogMetadataDTOCollection'\n403 |             \n404 |             // Process metadata fields\n405 |             for key in redactedMetadata.getKeys() {\n    |                        |- error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getKeys' of wrapped base type 'LogMetadataDTOCollection'\n    |                        |- note: chain the optional using '?' to access member 'getKeys' only for non-'nil' base values\n    |                        `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n406 |                 if rule.targetFields.isEmpty || rule.targetFields.contains(key) {\n407 |                     if let stringValue = redactedMetadata.getString(key: key) {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:407:42: error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getString' of wrapped base type 'LogMetadataDTOCollection'\n405 |             for key in redactedMetadata.getKeys() {\n406 |                 if rule.targetFields.isEmpty || rule.targetFields.contains(key) {\n407 |                     if let stringValue = redactedMetadata.getString(key: key) {\n    |                                          |- error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getString' of wrapped base type 'LogMetadataDTOCollection'\n    |                                          |- note: chain the optional using '?' to access member 'getString' only for non-'nil' base values\n    |                                          `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n408 |                         // Skip fields that should be preserved\n409 |                         if rule.preserveFields.contains(key) {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:468:15: error: type 'LogPrivacyLevel' has no member 'never'\n466 |         case .auto:\n467 |             return .auto\n468 |         case .never:\n    |               `- error: type 'LogPrivacyLevel' has no member 'never'\n469 |             return .public // Map 'never' to public classification\n470 |         case .protected:\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:470:15: error: type 'LogPrivacyLevel' has no member 'protected'\n468 |         case .never:\n469 |             return .public // Map 'never' to public classification\n470 |         case .protected:\n    |               `- error: type 'LogPrivacyLevel' has no member 'protected'\n471 |             return .private // Map 'protected' to private classification\n472 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:58:84: error: type 'LogPrivacyLevel' has no member 'protected'\n 56 |             additionalMetadata: [\n 57 |                 \"createBackup\": (value: String(options.createBackup), privacyLevel: .public),\n 58 |                 \"backupPath\": (value: options.backupPath ?? \"none\", privacyLevel: .protected),\n    |                                                                                    `- error: type 'LogPrivacyLevel' has no member 'protected'\n 59 |                 \"dryRun\": (value: String(options.dryRun), privacyLevel: .public),\n 60 |                 \"hasFilterCriteria\": (value: String(options.filterCriteria != nil), privacyLevel: .public),\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:184:34: error: cannot find 'getDestination' in scope\n182 |         if let destinationId = destinationId {\n183 |             // Use specific destination\n184 |             if let destination = getDestination(id: destinationId) {\n    |                                  `- error: cannot find 'getDestination' in scope\n185 |                 return [destination]\n186 |             } else {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:196:38: error: cannot find 'getDestination' in scope\n194 |             \n195 |             for id in options.destinationIds {\n196 |                 if let destination = getDestination(id: id) {\n    |                                      `- error: cannot find 'getDestination' in scope\n197 |                     result.append(destination)\n198 |                 } else {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:208:20: error: cannot find 'getAllDestinations' in scope\n206 |         } else {\n207 |             // Use all registered destinations\n208 |             return getAllDestinations()\n    |                    `- error: cannot find 'getAllDestinations' in scope\n209 |         }\n210 |     }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/QueryLogsCommand.swift:71:37: error: cannot find 'getDestination' in scope\n 69 |         do {\n 70 |             // Check if destination exists\n 71 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 72 |                 throw LoggingError.destinationNotFound(\n 73 |                     \"Cannot query logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RedactionRule.swift:123:72: error: missing argument for parameter 'privacyLevel' in call\n121 |                 if value != redactedValue {\n122 |                     // Only update if actually changed\n123 |                     result = result.with(key: key, value: redactedValue)\n    |                                                                        `- error: missing argument for parameter 'privacyLevel' in call\n124 |                 }\n125 |             }\n\n/Users/mpy/.bazel/execroot/_main/packages/UmbraCoreTypes/Sources/LoggingTypes/LogMetadataDTOCollection.swift:78:15: note: 'with(key:value:privacyLevel:)' declared here\n 76 |   ///   - privacyLevel: The privacy classification for this entry\n 77 |   /// - Returns: The updated collection\n 78 |   public func with(\n    |               `- note: 'with(key:value:privacyLevel:)' declared here\n 79 |     key: String,\n 80 |     value: String,\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RedactionRule.swift:101:26: warning: no calls to throwing functions occur within 'try' expression\n 99 |     public func redact(metadata: LogMetadataDTOCollection) -\u003e LogMetadataDTOCollection {\n100 |         // No redaction needed for empty metadata\n101 |         guard let keys = try? metadata.getKeys() else {\n    |                          `- warning: no calls to throwing functions occur within 'try' expression\n102 |             return metadata\n103 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RedactionRule.swift:119:28: warning: no calls to throwing functions occur within 'try' expression\n117 |             \n118 |             // Get string value and apply redaction\n119 |             if let value = try? metadata.getString(key: key) {\n    |                            `- warning: no calls to throwing functions occur within 'try' expression\n120 |                 let redactedValue = redact(value)\n121 |                 if value != redactedValue {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RemoveDestinationCommand.swift:67:37: error: cannot find 'getDestination' in scope\n 65 |         do {\n 66 |             // Check if destination exists\n 67 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 68 |                 throw LoggingError.destinationNotFound(\n 69 |                     \"Cannot remove destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RemoveDestinationCommand.swift:128:13: error: expression is 'async' but is not marked with 'await'\n126 |             \n127 |             // Unregister the destination\n128 |             unregisterDestination(id: destinationId)\n    |             |- error: expression is 'async' but is not marked with 'await'\n    |             `- note: calls to instance method 'unregisterDestination(id:)' from outside of its actor context are implicitly asynchronous\n129 |             \n130 |             // Log success\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RotateLogsCommand.swift:67:37: error: cannot find 'getDestination' in scope\n 65 |         do {\n 66 |             // Check if destination exists\n 67 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 68 |                 throw LoggingError.destinationNotFound(\n 69 |                     \"Cannot rotate logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RotateLogsCommand.swift:74:37: error: cannot infer contextual base in reference to member 'file'\n 72 |             \n 73 |             // Check if the destination type supports rotation\n 74 |             if destination.type != .file {\n    |                                     `- error: cannot infer contextual base in reference to member 'file'\n 75 |                 throw LoggingError.invalidDestinationConfig(\n 76 |                     \"Log rotation is only supported for file destinations\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RotateLogsCommand.swift:92:112: error: type 'LogPrivacyLevel' has no member 'protected'\n 90 |                     context: operationContext,\n 91 |                     additionalMetadata: [\n 92 |                         \"rotatedFilePath\": (value: rotationResult.rotatedFilePath ?? \"unknown\", privacyLevel: .protected),\n    |                                                                                                                `- error: type 'LogPrivacyLevel' has no member 'protected'\n 93 |                         \"rotatedSizeBytes\": (value: String(rotationResult.rotatedSizeBytes ?? 0), privacyLevel: .public),\n 94 |                         \"rotatedEntryCount\": (value: String(rotationResult.rotatedEntryCount ?? 0), privacyLevel: .public)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/WriteLogCommand.swift:159:20: error: cannot find 'getAllDestinations' in scope\n157 |         if destinationIds.isEmpty {\n158 |             // Use all registered destinations\n159 |             return getAllDestinations().filter { $0.isEnabled }\n    |                    `- error: cannot find 'getAllDestinations' in scope\n160 |         } else {\n161 |             // Use specific destinations\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/WriteLogCommand.swift:165:38: error: cannot find 'getDestination' in scope\n163 |             \n164 |             for destinationId in destinationIds {\n165 |                 if let destination = getDestination(id: destinationId) {\n    |                                      `- error: cannot find 'getDestination' in scope\n166 |                     if destination.isEnabled {\n167 |                         result.append(destination)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/WriteLogCommand.swift:193:16: error: cannot find 'applyFilterRules' in scope\n191 |         \n192 |         // Apply filter rules if they exist\n193 |         return applyFilterRules(\n    |                `- error: cannot find 'applyFilterRules' in scope\n194 |             to: entry,\n195 |             rules: destination.configuration.filterRules\n\npackages/UmbraImplementations/Sources/LoggingServices/DefaultLoggingServiceImpl.swift:39:36: warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 37 |     let contextDTO=BaseLogContextDTO(\n 38 |       domainName: \"Legacy\",\n 39 |       operation: context.operation ?? \"unknown\",\n    |                                    `- warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 40 |       category: context.category ?? \"General\",\n 41 |       source: context.source ?? \"Unknown\",\n\npackages/UmbraImplementations/Sources/LoggingServices/DefaultLoggingServiceImpl.swift:40:34: warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 38 |       domainName: \"Legacy\",\n 39 |       operation: context.operation ?? \"unknown\",\n 40 |       category: context.category ?? \"General\",\n    |                                  `- warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 41 |       source: context.source ?? \"Unknown\",\n 42 |       metadata: context.metadata\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:147:17: error: invalid redeclaration of 'log(_:_:context:)'\n145 |         - context: The logging context\n146 |      */\n147 |     public func log(_ level: LogLevel, _ message: String, context: any LogContextDTO) async {\n    |                 `- error: invalid redeclaration of 'log(_:_:context:)'\n148 |         // Convert to privacy string and use privacy-aware logging\n149 |         let privacyString = PrivacyString(stringLiteral: message)\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:92:48: error: value of type 'any LoggingProviderProtocol' has no member 'writeLogEntry'\n 90 |                     do {\n 91 |                         // Write log entry to destination\n 92 |                         _ = try await provider.writeLogEntry(entry, to: destination)\n    |                                                `- error: value of type 'any LoggingProviderProtocol' has no member 'writeLogEntry'\n 93 |                     } catch {\n 94 |                         // Silently ignore provider errors for now\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:122:28: error: value of type 'PrivacyString' has no member 'privacy'\n120 |         enrichedMetadata = enrichedMetadata.withPrivate(\n121 |             key: \"__privacy_annotation\", \n122 |             value: message.privacy.description\n    |                            `- error: value of type 'PrivacyString' has no member 'privacy'\n123 |         )\n124 |         \n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:136:34: error: value of type 'PrivacyString' has no member 'content'\n134 |         \n135 |         // Log the message using the standard log method\n136 |         await log(level, message.content, context: privacyContext)\n    |                                  `- error: value of type 'PrivacyString' has no member 'content'\n137 |     }\n138 |     \n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:167:71: error: value of type 'PrivacyAnnotatedString' has no member 'stringValue'\n165 |     ) async {\n166 |         let annotatedString = privacyScope()\n167 |         await log(level, PrivacyString(stringLiteral: annotatedString.stringValue), context: context) \n    |                                                                       `- error: value of type 'PrivacyAnnotatedString' has no member 'stringValue'\n168 |     }\n169 |     \n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:190:29: error: for-in loop requires 'LogMetadata' to conform to 'Sequence'\n188 |         // Create a metadata collection with sensitive values\n189 |         var metadataCollection = context.metadata\n190 |         for (key, value) in sensitiveValues {\n    |                             `- error: for-in loop requires 'LogMetadata' to conform to 'Sequence'\n191 |             metadataCollection = metadataCollection.withSensitive(key: key, value: String(describing: value))\n192 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:228:9: error: switch must be exhaustive\n226 |         \n227 |         // Add error information to metadata with appropriate privacy level\n228 |         switch privacyLevel {\n    |         |- error: switch must be exhaustive\n    |         `- note: add missing case: '.auto'\n229 |         case .public:\n230 |             metadataCollection = metadataCollection.withPublic(key: \"error_description\", value: error.localizedDescription)\npackages/UmbraImplementations/Sources/LoggingServices/PrivacyAwareLogDTO.swift:217:24: error: value of type 'LogMetadataDTOCollection' has no member 'set'\n215 |     for key in self.metadata.getKeys() {\n216 |       if let value = self.metadata.getString(key: key) {\n217 |         mergedMetadata.set(key: key, value: value)\n    |                        `- error: value of type 'LogMetadataDTOCollection' has no member 'set'\n218 |       }\n219 |     }\n\npackages/UmbraImplementations/Sources/LoggingServices/PrivacyAwareLogDTO.swift:224:24: error: value of type 'LogMetadataDTOCollection' has no member 'set'\n222 |     for key in additionalMetadata.getKeys() {\n223 |       if let value = additionalMetadata.getString(key: key) {\n224 |         mergedMetadata.set(key: key, value: value)\n    |                        `- error: value of type 'LogMetadataDTOCollection' has no member 'set'\n225 |       }\n226 |     }\n\npackages/UmbraImplementations/Sources/LoggingServices/PrivacyAwareLogDTO.swift:235:17: error: cannot convert value of type 'LogMetadataDTOCollection' to expected argument type '[String : (value: Any, privacy: LogPrivacyLevel)]'\n233 |       category: category,\n234 |       correlationID: correlationID,\n235 |       metadata: mergedMetadata,\n    |                 `- error: cannot convert value of type 'LogMetadataDTOCollection' to expected argument type '[String : (value: Any, privacy: LogPrivacyLevel)]'\n236 |       environment: environment\n237 |     )\nTarget //packages/UmbraImplementations/Sources/KeychainServices/Logging:KeychainLogger failed to build\nINFO: Elapsed time: 1.124s, Critical Path: 1.00s\nINFO: 2 processes: 2 internal.\nERROR: Build did NOT complete successfully\n"
  },
  {
    "target": "rule //packages/UmbraImplementations/Sources/LoggingAdapters:LoggingAdapters",
    "success": false,
    "start_time": "2025-04-11T17:58:18.142865+01:00",
    "end_time": "2025-04-11T17:58:19.972015+01:00",
    "duration": "1.82915225s",
    "output": "INFO: Invocation ID: 26834626-24e6-4a98-8177-44c9c5b601a0\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraImplementations/Sources/LoggingAdapters:LoggingAdapters (0 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraImplementations/Sources/LoggingAdapters:LoggingAdapters (0 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraImplementations/Sources/LoggingAdapters:LoggingAdapters (0 packages loaded, 0 targets configured).\nERROR: /Users/mpy/CascadeProjects/UmbraCore/packages/UmbraImplementations/Sources/LoggingServices/BUILD.bazel:3:20: Compiling Swift module //packages/UmbraImplementations/Sources/LoggingServices:LoggingServices failed: (Exit 1): worker failed: error executing SwiftCompile command (from target //packages/UmbraImplementations/Sources/LoggingServices:LoggingServices) \n  (cd /Users/mpy/.bazel/execroot/_main \u0026\u0026 \\\n  exec env - \\\n    APPLE_SDK_PLATFORM=MacOSX \\\n    APPLE_SDK_VERSION_OVERRIDE=15.4 \\\n    CC=clang \\\n    PATH=/Users/mpy/Library/Caches/bazelisk/downloads/sha256/ac72ad67f7a8c6b18bf605d8602425182b417de4369715bf89146daf62f7ae48/bin:/Users/mpy/.rbenv/bin:/Users/mpy/.codeium/windsurf/bin:/opt/homebrew/opt/node@18/bin:/opt/homebrew/opt/node@20/bin:/Users/mpy/.docker/bin:/opt/homebrew/opt/openjdk/bin:/Users/mpy/bin:/opt/homebrew/bin:/opt/homebrew/sbin:/usr/local/bin:/System/Cryptexes/App/usr/bin:/usr/bin:/bin:/usr/sbin:/sbin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/local/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/appleinternal/bin:/Library/Apple/usr/bin:/usr/local/go/bin:/Users/mpy/.rbenv/bin:/Users/mpy/.codeium/windsurf/bin:/opt/homebrew/opt/node@18/bin:/opt/homebrew/opt/node@20/bin:/opt/anaconda3/bin:/opt/anaconda3/condabin:/Users/mpy/.docker/bin:/opt/homebrew/opt/openjdk/bin:/Users/mpy/bin:/Users/mpy/.cargo/bin:/Users/mpy/Library/Python/3.8/bin:/Users/mpy/go/bin:/Users/mpy/.scripts:/Users/mpy/.fzf/bin:/Users/mpy/.windsurf/extensions/ms-python.debugpy-2025.6.0-darwin-arm64/bundled/scripts/noConfigScripts:/Users/mpy/Library/Python/3.8/bin:/Users/mpy/go/bin:/Users/mpy/.scripts \\\n    XCODE_VERSION_OVERRIDE=16.3.0.16E140 \\\n  bazel-out/darwin_arm64-opt-exec-ST-d57f47055a04/bin/external/rules_swift+/tools/worker/worker swiftc @bazel-out/darwin_arm64-fastbuild/bin/packages/UmbraImplementations/Sources/LoggingServices/LoggingServices.swiftmodule-0.params)\n# Configuration: 76a1bf3a80f2d50513004915454165d2f164db794b63e4666809cbd93e1abeaa\n# Execution platform: @@platforms//host:host\nerror: emit-module command failed with exit code 1 (use -v to see invocation)\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:147:17: error: invalid redeclaration of 'log(_:_:context:)'\n145 |         - context: The logging context\n146 |      */\n147 |     public func log(_ level: LogLevel, _ message: String, context: any LogContextDTO) async {\n    |                 `- error: invalid redeclaration of 'log(_:_:context:)'\n148 |         // Convert to privacy string and use privacy-aware logging\n149 |         let privacyString = PrivacyString(stringLiteral: message)\npackages/UmbraImplementations/Sources/LoggingServices/Commands/AddDestinationCommand.swift:68:31: error: cannot find 'getDestination' in scope\n 66 |         do {\n 67 |             // Check if destination already exists\n 68 |             if let existing = getDestination(id: destination.id) {\n    |                               `- error: cannot find 'getDestination' in scope\n 69 |                 if !options.overwriteExisting {\n 70 |                     throw LoggingError.destinationAlreadyExists(identifier: \"Destination with ID \\(destination.id) already exists\")\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/AddDestinationCommand.swift:82:40: error: cannot find 'validateDestination' in scope\n 80 |             // Validate destination configuration if requested\n 81 |             if options.validateConfiguration {\n 82 |                 let validationResult = validateDestination(destination, for: provider)\n    |                                        `- error: cannot find 'validateDestination' in scope\n 83 |                 \n 84 |                 if !validationResult.isValid {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/AddDestinationCommand.swift:121:13: error: expression is 'async' but is not marked with 'await'\n119 |             \n120 |             // Register the destination\n121 |             registerDestination(destination)\n    |             |- error: expression is 'async' but is not marked with 'await'\n    |             `- note: calls to instance method 'registerDestination' from outside of its actor context are implicitly asynchronous\n122 |             \n123 |             // Log success\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ArchiveLogsCommand.swift:57:84: error: type 'LogPrivacyLevel' has no member 'protected'\n 55 |             destinationId: destinationId,\n 56 |             additionalMetadata: [\n 57 |                 \"destinationPath\": (value: options.destinationPath, privacyLevel: .protected),\n    |                                                                                    `- error: type 'LogPrivacyLevel' has no member 'protected'\n 58 |                 \"compress\": (value: String(options.compress), privacyLevel: .public),\n 59 |                 \"format\": (value: options.format.rawValue, privacyLevel: .public),\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ArchiveLogsCommand.swift:70:37: error: cannot find 'getDestination' in scope\n 68 |         do {\n 69 |             // Check if destination exists\n 70 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 71 |                 throw LoggingError.destinationNotFound(\n 72 |                     \"Cannot archive logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ArchiveLogsCommand.swift:113:103: error: type 'LogPrivacyLevel' has no member 'protected'\n111 |                     context: operationContext,\n112 |                     additionalMetadata: [\n113 |                         \"archivePath\": (value: archiveResult.archivePath ?? \"unknown\", privacyLevel: .protected),\n    |                                                                                                       `- error: type 'LogPrivacyLevel' has no member 'protected'\n114 |                         \"archiveSizeBytes\": (value: String(archiveResult.archiveSizeBytes ?? 0), privacyLevel: .public),\n115 |                         \"archivedEntryCount\": (value: String(archiveResult.archivedEntryCount ?? 0), privacyLevel: .public)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ExportLogsCommand.swift:70:37: error: cannot find 'getDestination' in scope\n 68 |         do {\n 69 |             // Check if destination exists\n 70 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 71 |                 throw LoggingError.destinationNotFound(\n 72 |                     \"Cannot export logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:79:50: error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n 77 |                 key: key,\n 78 |                 value: value.value,\n 79 |                 privacyLevel: value.privacyLevel.toPrivacyClassification()\n    |                                                  `- error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n 80 |             )\n 81 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:122:54: error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n120 |                     key: key,\n121 |                     value: value.value,\n122 |                     privacyLevel: value.privacyLevel.toPrivacyClassification()\n    |                                                      `- error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n123 |                 )\n124 |             )\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:229:21: error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n227 |         \n228 |         // Process special fields first\n229 |         switch rule.field {\n    |                     `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n230 |         case \"level\":\n231 |             fieldValue = entry.level.rawValue\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:238:96: error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n236 |         default:\n237 |             // Check metadata fields\n238 |             if let metadata = entry.metadata, let metadataValue = metadata.getString(key: rule.field) {\n    |                                                                                                `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n239 |                 fieldValue = metadataValue\n240 |             } else {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:246:21: error: value of type 'UmbraLogFilterRuleDTO' has no member 'operation'\n244 |         \n245 |         // Apply the operation\n246 |         switch rule.operation {\n    |                     `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'operation'\n247 |         case .equals:\n248 |             return fieldValue == rule.value\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:248:39: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n246 |         switch rule.operation {\n247 |         case .equals:\n248 |             return fieldValue == rule.value\n    |                                       `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n249 |         case .contains:\n250 |             return fieldValue.contains(rule.value)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:250:45: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n248 |             return fieldValue == rule.value\n249 |         case .contains:\n250 |             return fieldValue.contains(rule.value)\n    |                                             `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n251 |         case .startsWith:\n252 |             return fieldValue.hasPrefix(rule.value)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:252:46: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n250 |             return fieldValue.contains(rule.value)\n251 |         case .startsWith:\n252 |             return fieldValue.hasPrefix(rule.value)\n    |                                              `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n253 |         case .endsWith:\n254 |             return fieldValue.hasSuffix(rule.value)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:254:46: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n252 |             return fieldValue.hasPrefix(rule.value)\n253 |         case .endsWith:\n254 |             return fieldValue.hasSuffix(rule.value)\n    |                                              `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n255 |         case .matches:\n256 |             if let regex = try? NSRegularExpression(pattern: rule.value) {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:256:67: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n254 |             return fieldValue.hasSuffix(rule.value)\n255 |         case .matches:\n256 |             if let regex = try? NSRegularExpression(pattern: rule.value) {\n    |                                                                   `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n257 |                 let range = NSRange(location: 0, length: fieldValue.utf16.count)\n258 |                 return regex.firstMatch(in: fieldValue, options: [], range: range) != nil\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:262:86: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n260 |             return false\n261 |         case .greaterThan:\n262 |             if let fieldNumeric = Double(fieldValue), let valueNumeric = Double(rule.value) {\n    |                                                                                      `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n263 |                 return fieldNumeric \u003e valueNumeric\n264 |             }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:267:86: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n265 |             return false\n266 |         case .lessThan:\n267 |             if let fieldNumeric = Double(fieldValue), let valueNumeric = Double(rule.value) {\n    |                                                                                      `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n268 |                 return fieldNumeric \u003c valueNumeric\n269 |             }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:293:13: warning: variable 'redactedMetadata' was never mutated; consider changing to 'let' constant\n291 |         // Create mutable copies\n292 |         var redactedMessage = entry.message\n293 |         var redactedMetadata = entry.metadata\n    |             `- warning: variable 'redactedMetadata' was never mutated; consider changing to 'let' constant\n294 |         \n295 |         for rule in rules {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:395:47: error: value of type 'String' has no member 'stringByReplacingMatches'\n393 |             if rule.targetFields.isEmpty || rule.targetFields.contains(\"message\") {\n394 |                 if let pattern = rule.pattern {\n395 |                     redactedMessage = pattern.stringByReplacingMatches(\n    |                                               `- error: value of type 'String' has no member 'stringByReplacingMatches'\n396 |                         in: redactedMessage,\n397 |                         options: [],\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:394:20: error: initializer for conditional binding must have Optional type, not 'String'\n392 |             // Apply rule to message if it matches\n393 |             if rule.targetFields.isEmpty || rule.targetFields.contains(\"message\") {\n394 |                 if let pattern = rule.pattern {\n    |                    `- error: initializer for conditional binding must have Optional type, not 'String'\n395 |                     redactedMessage = pattern.stringByReplacingMatches(\n396 |                         in: redactedMessage,\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:405:24: error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getKeys' of wrapped base type 'LogMetadataDTOCollection'\n403 |             \n404 |             // Process metadata fields\n405 |             for key in redactedMetadata.getKeys() {\n    |                        |- error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getKeys' of wrapped base type 'LogMetadataDTOCollection'\n    |                        |- note: chain the optional using '?' to access member 'getKeys' only for non-'nil' base values\n    |                        `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n406 |                 if rule.targetFields.isEmpty || rule.targetFields.contains(key) {\n407 |                     if let stringValue = redactedMetadata.getString(key: key) {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:407:42: error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getString' of wrapped base type 'LogMetadataDTOCollection'\n405 |             for key in redactedMetadata.getKeys() {\n406 |                 if rule.targetFields.isEmpty || rule.targetFields.contains(key) {\n407 |                     if let stringValue = redactedMetadata.getString(key: key) {\n    |                                          |- error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getString' of wrapped base type 'LogMetadataDTOCollection'\n    |                                          |- note: chain the optional using '?' to access member 'getString' only for non-'nil' base values\n    |                                          `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n408 |                         // Skip fields that should be preserved\n409 |                         if rule.preserveFields.contains(key) {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:468:15: error: type 'LogPrivacyLevel' has no member 'never'\n466 |         case .auto:\n467 |             return .auto\n468 |         case .never:\n    |               `- error: type 'LogPrivacyLevel' has no member 'never'\n469 |             return .public // Map 'never' to public classification\n470 |         case .protected:\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:470:15: error: type 'LogPrivacyLevel' has no member 'protected'\n468 |         case .never:\n469 |             return .public // Map 'never' to public classification\n470 |         case .protected:\n    |               `- error: type 'LogPrivacyLevel' has no member 'protected'\n471 |             return .private // Map 'protected' to private classification\n472 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:58:84: error: type 'LogPrivacyLevel' has no member 'protected'\n 56 |             additionalMetadata: [\n 57 |                 \"createBackup\": (value: String(options.createBackup), privacyLevel: .public),\n 58 |                 \"backupPath\": (value: options.backupPath ?? \"none\", privacyLevel: .protected),\n    |                                                                                    `- error: type 'LogPrivacyLevel' has no member 'protected'\n 59 |                 \"dryRun\": (value: String(options.dryRun), privacyLevel: .public),\n 60 |                 \"hasFilterCriteria\": (value: String(options.filterCriteria != nil), privacyLevel: .public),\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:184:34: error: cannot find 'getDestination' in scope\n182 |         if let destinationId = destinationId {\n183 |             // Use specific destination\n184 |             if let destination = getDestination(id: destinationId) {\n    |                                  `- error: cannot find 'getDestination' in scope\n185 |                 return [destination]\n186 |             } else {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:196:38: error: cannot find 'getDestination' in scope\n194 |             \n195 |             for id in options.destinationIds {\n196 |                 if let destination = getDestination(id: id) {\n    |                                      `- error: cannot find 'getDestination' in scope\n197 |                     result.append(destination)\n198 |                 } else {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:208:20: error: cannot find 'getAllDestinations' in scope\n206 |         } else {\n207 |             // Use all registered destinations\n208 |             return getAllDestinations()\n    |                    `- error: cannot find 'getAllDestinations' in scope\n209 |         }\n210 |     }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/QueryLogsCommand.swift:71:37: error: cannot find 'getDestination' in scope\n 69 |         do {\n 70 |             // Check if destination exists\n 71 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 72 |                 throw LoggingError.destinationNotFound(\n 73 |                     \"Cannot query logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RedactionRule.swift:123:72: error: missing argument for parameter 'privacyLevel' in call\n121 |                 if value != redactedValue {\n122 |                     // Only update if actually changed\n123 |                     result = result.with(key: key, value: redactedValue)\n    |                                                                        `- error: missing argument for parameter 'privacyLevel' in call\n124 |                 }\n125 |             }\n\n/Users/mpy/.bazel/execroot/_main/packages/UmbraCoreTypes/Sources/LoggingTypes/LogMetadataDTOCollection.swift:78:15: note: 'with(key:value:privacyLevel:)' declared here\n 76 |   ///   - privacyLevel: The privacy classification for this entry\n 77 |   /// - Returns: The updated collection\n 78 |   public func with(\n    |               `- note: 'with(key:value:privacyLevel:)' declared here\n 79 |     key: String,\n 80 |     value: String,\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RedactionRule.swift:101:26: warning: no calls to throwing functions occur within 'try' expression\n 99 |     public func redact(metadata: LogMetadataDTOCollection) -\u003e LogMetadataDTOCollection {\n100 |         // No redaction needed for empty metadata\n101 |         guard let keys = try? metadata.getKeys() else {\n    |                          `- warning: no calls to throwing functions occur within 'try' expression\n102 |             return metadata\n103 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RedactionRule.swift:119:28: warning: no calls to throwing functions occur within 'try' expression\n117 |             \n118 |             // Get string value and apply redaction\n119 |             if let value = try? metadata.getString(key: key) {\n    |                            `- warning: no calls to throwing functions occur within 'try' expression\n120 |                 let redactedValue = redact(value)\n121 |                 if value != redactedValue {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RemoveDestinationCommand.swift:67:37: error: cannot find 'getDestination' in scope\n 65 |         do {\n 66 |             // Check if destination exists\n 67 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 68 |                 throw LoggingError.destinationNotFound(\n 69 |                     \"Cannot remove destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RemoveDestinationCommand.swift:128:13: error: expression is 'async' but is not marked with 'await'\n126 |             \n127 |             // Unregister the destination\n128 |             unregisterDestination(id: destinationId)\n    |             |- error: expression is 'async' but is not marked with 'await'\n    |             `- note: calls to instance method 'unregisterDestination(id:)' from outside of its actor context are implicitly asynchronous\n129 |             \n130 |             // Log success\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RotateLogsCommand.swift:67:37: error: cannot find 'getDestination' in scope\n 65 |         do {\n 66 |             // Check if destination exists\n 67 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 68 |                 throw LoggingError.destinationNotFound(\n 69 |                     \"Cannot rotate logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RotateLogsCommand.swift:74:37: error: cannot infer contextual base in reference to member 'file'\n 72 |             \n 73 |             // Check if the destination type supports rotation\n 74 |             if destination.type != .file {\n    |                                     `- error: cannot infer contextual base in reference to member 'file'\n 75 |                 throw LoggingError.invalidDestinationConfig(\n 76 |                     \"Log rotation is only supported for file destinations\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RotateLogsCommand.swift:92:112: error: type 'LogPrivacyLevel' has no member 'protected'\n 90 |                     context: operationContext,\n 91 |                     additionalMetadata: [\n 92 |                         \"rotatedFilePath\": (value: rotationResult.rotatedFilePath ?? \"unknown\", privacyLevel: .protected),\n    |                                                                                                                `- error: type 'LogPrivacyLevel' has no member 'protected'\n 93 |                         \"rotatedSizeBytes\": (value: String(rotationResult.rotatedSizeBytes ?? 0), privacyLevel: .public),\n 94 |                         \"rotatedEntryCount\": (value: String(rotationResult.rotatedEntryCount ?? 0), privacyLevel: .public)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/WriteLogCommand.swift:159:20: error: cannot find 'getAllDestinations' in scope\n157 |         if destinationIds.isEmpty {\n158 |             // Use all registered destinations\n159 |             return getAllDestinations().filter { $0.isEnabled }\n    |                    `- error: cannot find 'getAllDestinations' in scope\n160 |         } else {\n161 |             // Use specific destinations\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/WriteLogCommand.swift:165:38: error: cannot find 'getDestination' in scope\n163 |             \n164 |             for destinationId in destinationIds {\n165 |                 if let destination = getDestination(id: destinationId) {\n    |                                      `- error: cannot find 'getDestination' in scope\n166 |                     if destination.isEnabled {\n167 |                         result.append(destination)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/WriteLogCommand.swift:193:16: error: cannot find 'applyFilterRules' in scope\n191 |         \n192 |         // Apply filter rules if they exist\n193 |         return applyFilterRules(\n    |                `- error: cannot find 'applyFilterRules' in scope\n194 |             to: entry,\n195 |             rules: destination.configuration.filterRules\n\npackages/UmbraImplementations/Sources/LoggingServices/DefaultLoggingServiceImpl.swift:39:36: warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 37 |     let contextDTO=BaseLogContextDTO(\n 38 |       domainName: \"Legacy\",\n 39 |       operation: context.operation ?? \"unknown\",\n    |                                    `- warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 40 |       category: context.category ?? \"General\",\n 41 |       source: context.source ?? \"Unknown\",\n\npackages/UmbraImplementations/Sources/LoggingServices/DefaultLoggingServiceImpl.swift:40:34: warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 38 |       domainName: \"Legacy\",\n 39 |       operation: context.operation ?? \"unknown\",\n 40 |       category: context.category ?? \"General\",\n    |                                  `- warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 41 |       source: context.source ?? \"Unknown\",\n 42 |       metadata: context.metadata\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:147:17: error: invalid redeclaration of 'log(_:_:context:)'\n145 |         - context: The logging context\n146 |      */\n147 |     public func log(_ level: LogLevel, _ message: String, context: any LogContextDTO) async {\n    |                 `- error: invalid redeclaration of 'log(_:_:context:)'\n148 |         // Convert to privacy string and use privacy-aware logging\n149 |         let privacyString = PrivacyString(stringLiteral: message)\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:92:48: error: value of type 'any LoggingProviderProtocol' has no member 'writeLogEntry'\n 90 |                     do {\n 91 |                         // Write log entry to destination\n 92 |                         _ = try await provider.writeLogEntry(entry, to: destination)\n    |                                                `- error: value of type 'any LoggingProviderProtocol' has no member 'writeLogEntry'\n 93 |                     } catch {\n 94 |                         // Silently ignore provider errors for now\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:122:28: error: value of type 'PrivacyString' has no member 'privacy'\n120 |         enrichedMetadata = enrichedMetadata.withPrivate(\n121 |             key: \"__privacy_annotation\", \n122 |             value: message.privacy.description\n    |                            `- error: value of type 'PrivacyString' has no member 'privacy'\n123 |         )\n124 |         \n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:136:34: error: value of type 'PrivacyString' has no member 'content'\n134 |         \n135 |         // Log the message using the standard log method\n136 |         await log(level, message.content, context: privacyContext)\n    |                                  `- error: value of type 'PrivacyString' has no member 'content'\n137 |     }\n138 |     \n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:167:71: error: value of type 'PrivacyAnnotatedString' has no member 'stringValue'\n165 |     ) async {\n166 |         let annotatedString = privacyScope()\n167 |         await log(level, PrivacyString(stringLiteral: annotatedString.stringValue), context: context) \n    |                                                                       `- error: value of type 'PrivacyAnnotatedString' has no member 'stringValue'\n168 |     }\n169 |     \n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:190:29: error: for-in loop requires 'LogMetadata' to conform to 'Sequence'\n188 |         // Create a metadata collection with sensitive values\n189 |         var metadataCollection = context.metadata\n190 |         for (key, value) in sensitiveValues {\n    |                             `- error: for-in loop requires 'LogMetadata' to conform to 'Sequence'\n191 |             metadataCollection = metadataCollection.withSensitive(key: key, value: String(describing: value))\n192 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:228:9: error: switch must be exhaustive\n226 |         \n227 |         // Add error information to metadata with appropriate privacy level\n228 |         switch privacyLevel {\n    |         |- error: switch must be exhaustive\n    |         `- note: add missing case: '.auto'\n229 |         case .public:\n230 |             metadataCollection = metadataCollection.withPublic(key: \"error_description\", value: error.localizedDescription)\npackages/UmbraImplementations/Sources/LoggingServices/PrivacyAwareLogDTO.swift:217:24: error: value of type 'LogMetadataDTOCollection' has no member 'set'\n215 |     for key in self.metadata.getKeys() {\n216 |       if let value = self.metadata.getString(key: key) {\n217 |         mergedMetadata.set(key: key, value: value)\n    |                        `- error: value of type 'LogMetadataDTOCollection' has no member 'set'\n218 |       }\n219 |     }\n\npackages/UmbraImplementations/Sources/LoggingServices/PrivacyAwareLogDTO.swift:224:24: error: value of type 'LogMetadataDTOCollection' has no member 'set'\n222 |     for key in additionalMetadata.getKeys() {\n223 |       if let value = additionalMetadata.getString(key: key) {\n224 |         mergedMetadata.set(key: key, value: value)\n    |                        `- error: value of type 'LogMetadataDTOCollection' has no member 'set'\n225 |       }\n226 |     }\n\npackages/UmbraImplementations/Sources/LoggingServices/PrivacyAwareLogDTO.swift:235:17: error: cannot convert value of type 'LogMetadataDTOCollection' to expected argument type '[String : (value: Any, privacy: LogPrivacyLevel)]'\n233 |       category: category,\n234 |       correlationID: correlationID,\n235 |       metadata: mergedMetadata,\n    |                 `- error: cannot convert value of type 'LogMetadataDTOCollection' to expected argument type '[String : (value: Any, privacy: LogPrivacyLevel)]'\n236 |       environment: environment\n237 |     )\nTarget //packages/UmbraImplementations/Sources/LoggingAdapters:LoggingAdapters failed to build\nINFO: Elapsed time: 1.123s, Critical Path: 1.00s\nINFO: 2 processes: 2 internal.\nERROR: Build did NOT complete successfully\n"
  },
  {
    "target": "rule //packages/UmbraImplementations/Sources/LoggingServices:LoggingServices",
    "success": false,
    "start_time": "2025-04-11T17:58:19.972033+01:00",
    "end_time": "2025-04-11T17:58:21.79156+01:00",
    "duration": "1.819529208s",
    "output": "INFO: Invocation ID: 264d78b4-4e34-4b6b-bb9a-6b586de473ae\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraImplementations/Sources/LoggingServices:LoggingServices (0 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraImplementations/Sources/LoggingServices:LoggingServices (0 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraImplementations/Sources/LoggingServices:LoggingServices (0 packages loaded, 0 targets configured).\nERROR: /Users/mpy/CascadeProjects/UmbraCore/packages/UmbraImplementations/Sources/LoggingServices/BUILD.bazel:3:20: Compiling Swift module //packages/UmbraImplementations/Sources/LoggingServices:LoggingServices failed: (Exit 1): worker failed: error executing SwiftCompile command (from target //packages/UmbraImplementations/Sources/LoggingServices:LoggingServices) \n  (cd /Users/mpy/.bazel/execroot/_main \u0026\u0026 \\\n  exec env - \\\n    APPLE_SDK_PLATFORM=MacOSX \\\n    APPLE_SDK_VERSION_OVERRIDE=15.4 \\\n    CC=clang \\\n    PATH=/Users/mpy/Library/Caches/bazelisk/downloads/sha256/ac72ad67f7a8c6b18bf605d8602425182b417de4369715bf89146daf62f7ae48/bin:/Users/mpy/.rbenv/bin:/Users/mpy/.codeium/windsurf/bin:/opt/homebrew/opt/node@18/bin:/opt/homebrew/opt/node@20/bin:/Users/mpy/.docker/bin:/opt/homebrew/opt/openjdk/bin:/Users/mpy/bin:/opt/homebrew/bin:/opt/homebrew/sbin:/usr/local/bin:/System/Cryptexes/App/usr/bin:/usr/bin:/bin:/usr/sbin:/sbin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/local/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/appleinternal/bin:/Library/Apple/usr/bin:/usr/local/go/bin:/Users/mpy/.rbenv/bin:/Users/mpy/.codeium/windsurf/bin:/opt/homebrew/opt/node@18/bin:/opt/homebrew/opt/node@20/bin:/opt/anaconda3/bin:/opt/anaconda3/condabin:/Users/mpy/.docker/bin:/opt/homebrew/opt/openjdk/bin:/Users/mpy/bin:/Users/mpy/.cargo/bin:/Users/mpy/Library/Python/3.8/bin:/Users/mpy/go/bin:/Users/mpy/.scripts:/Users/mpy/.fzf/bin:/Users/mpy/.windsurf/extensions/ms-python.debugpy-2025.6.0-darwin-arm64/bundled/scripts/noConfigScripts:/Users/mpy/Library/Python/3.8/bin:/Users/mpy/go/bin:/Users/mpy/.scripts \\\n    XCODE_VERSION_OVERRIDE=16.3.0.16E140 \\\n  bazel-out/darwin_arm64-opt-exec-ST-d57f47055a04/bin/external/rules_swift+/tools/worker/worker swiftc @bazel-out/darwin_arm64-fastbuild/bin/packages/UmbraImplementations/Sources/LoggingServices/LoggingServices.swiftmodule-0.params)\n# Configuration: 76a1bf3a80f2d50513004915454165d2f164db794b63e4666809cbd93e1abeaa\n# Execution platform: @@platforms//host:host\nerror: emit-module command failed with exit code 1 (use -v to see invocation)\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:147:17: error: invalid redeclaration of 'log(_:_:context:)'\n145 |         - context: The logging context\n146 |      */\n147 |     public func log(_ level: LogLevel, _ message: String, context: any LogContextDTO) async {\n    |                 `- error: invalid redeclaration of 'log(_:_:context:)'\n148 |         // Convert to privacy string and use privacy-aware logging\n149 |         let privacyString = PrivacyString(stringLiteral: message)\npackages/UmbraImplementations/Sources/LoggingServices/Commands/AddDestinationCommand.swift:68:31: error: cannot find 'getDestination' in scope\n 66 |         do {\n 67 |             // Check if destination already exists\n 68 |             if let existing = getDestination(id: destination.id) {\n    |                               `- error: cannot find 'getDestination' in scope\n 69 |                 if !options.overwriteExisting {\n 70 |                     throw LoggingError.destinationAlreadyExists(identifier: \"Destination with ID \\(destination.id) already exists\")\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/AddDestinationCommand.swift:82:40: error: cannot find 'validateDestination' in scope\n 80 |             // Validate destination configuration if requested\n 81 |             if options.validateConfiguration {\n 82 |                 let validationResult = validateDestination(destination, for: provider)\n    |                                        `- error: cannot find 'validateDestination' in scope\n 83 |                 \n 84 |                 if !validationResult.isValid {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/AddDestinationCommand.swift:121:13: error: expression is 'async' but is not marked with 'await'\n119 |             \n120 |             // Register the destination\n121 |             registerDestination(destination)\n    |             |- error: expression is 'async' but is not marked with 'await'\n    |             `- note: calls to instance method 'registerDestination' from outside of its actor context are implicitly asynchronous\n122 |             \n123 |             // Log success\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ArchiveLogsCommand.swift:57:84: error: type 'LogPrivacyLevel' has no member 'protected'\n 55 |             destinationId: destinationId,\n 56 |             additionalMetadata: [\n 57 |                 \"destinationPath\": (value: options.destinationPath, privacyLevel: .protected),\n    |                                                                                    `- error: type 'LogPrivacyLevel' has no member 'protected'\n 58 |                 \"compress\": (value: String(options.compress), privacyLevel: .public),\n 59 |                 \"format\": (value: options.format.rawValue, privacyLevel: .public),\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ArchiveLogsCommand.swift:70:37: error: cannot find 'getDestination' in scope\n 68 |         do {\n 69 |             // Check if destination exists\n 70 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 71 |                 throw LoggingError.destinationNotFound(\n 72 |                     \"Cannot archive logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ArchiveLogsCommand.swift:113:103: error: type 'LogPrivacyLevel' has no member 'protected'\n111 |                     context: operationContext,\n112 |                     additionalMetadata: [\n113 |                         \"archivePath\": (value: archiveResult.archivePath ?? \"unknown\", privacyLevel: .protected),\n    |                                                                                                       `- error: type 'LogPrivacyLevel' has no member 'protected'\n114 |                         \"archiveSizeBytes\": (value: String(archiveResult.archiveSizeBytes ?? 0), privacyLevel: .public),\n115 |                         \"archivedEntryCount\": (value: String(archiveResult.archivedEntryCount ?? 0), privacyLevel: .public)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ExportLogsCommand.swift:70:37: error: cannot find 'getDestination' in scope\n 68 |         do {\n 69 |             // Check if destination exists\n 70 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 71 |                 throw LoggingError.destinationNotFound(\n 72 |                     \"Cannot export logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:79:50: error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n 77 |                 key: key,\n 78 |                 value: value.value,\n 79 |                 privacyLevel: value.privacyLevel.toPrivacyClassification()\n    |                                                  `- error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n 80 |             )\n 81 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:122:54: error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n120 |                     key: key,\n121 |                     value: value.value,\n122 |                     privacyLevel: value.privacyLevel.toPrivacyClassification()\n    |                                                      `- error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n123 |                 )\n124 |             )\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:229:21: error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n227 |         \n228 |         // Process special fields first\n229 |         switch rule.field {\n    |                     `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n230 |         case \"level\":\n231 |             fieldValue = entry.level.rawValue\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:238:96: error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n236 |         default:\n237 |             // Check metadata fields\n238 |             if let metadata = entry.metadata, let metadataValue = metadata.getString(key: rule.field) {\n    |                                                                                                `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n239 |                 fieldValue = metadataValue\n240 |             } else {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:246:21: error: value of type 'UmbraLogFilterRuleDTO' has no member 'operation'\n244 |         \n245 |         // Apply the operation\n246 |         switch rule.operation {\n    |                     `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'operation'\n247 |         case .equals:\n248 |             return fieldValue == rule.value\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:248:39: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n246 |         switch rule.operation {\n247 |         case .equals:\n248 |             return fieldValue == rule.value\n    |                                       `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n249 |         case .contains:\n250 |             return fieldValue.contains(rule.value)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:250:45: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n248 |             return fieldValue == rule.value\n249 |         case .contains:\n250 |             return fieldValue.contains(rule.value)\n    |                                             `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n251 |         case .startsWith:\n252 |             return fieldValue.hasPrefix(rule.value)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:252:46: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n250 |             return fieldValue.contains(rule.value)\n251 |         case .startsWith:\n252 |             return fieldValue.hasPrefix(rule.value)\n    |                                              `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n253 |         case .endsWith:\n254 |             return fieldValue.hasSuffix(rule.value)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:254:46: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n252 |             return fieldValue.hasPrefix(rule.value)\n253 |         case .endsWith:\n254 |             return fieldValue.hasSuffix(rule.value)\n    |                                              `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n255 |         case .matches:\n256 |             if let regex = try? NSRegularExpression(pattern: rule.value) {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:256:67: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n254 |             return fieldValue.hasSuffix(rule.value)\n255 |         case .matches:\n256 |             if let regex = try? NSRegularExpression(pattern: rule.value) {\n    |                                                                   `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n257 |                 let range = NSRange(location: 0, length: fieldValue.utf16.count)\n258 |                 return regex.firstMatch(in: fieldValue, options: [], range: range) != nil\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:262:86: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n260 |             return false\n261 |         case .greaterThan:\n262 |             if let fieldNumeric = Double(fieldValue), let valueNumeric = Double(rule.value) {\n    |                                                                                      `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n263 |                 return fieldNumeric \u003e valueNumeric\n264 |             }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:267:86: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n265 |             return false\n266 |         case .lessThan:\n267 |             if let fieldNumeric = Double(fieldValue), let valueNumeric = Double(rule.value) {\n    |                                                                                      `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n268 |                 return fieldNumeric \u003c valueNumeric\n269 |             }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:293:13: warning: variable 'redactedMetadata' was never mutated; consider changing to 'let' constant\n291 |         // Create mutable copies\n292 |         var redactedMessage = entry.message\n293 |         var redactedMetadata = entry.metadata\n    |             `- warning: variable 'redactedMetadata' was never mutated; consider changing to 'let' constant\n294 |         \n295 |         for rule in rules {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:395:47: error: value of type 'String' has no member 'stringByReplacingMatches'\n393 |             if rule.targetFields.isEmpty || rule.targetFields.contains(\"message\") {\n394 |                 if let pattern = rule.pattern {\n395 |                     redactedMessage = pattern.stringByReplacingMatches(\n    |                                               `- error: value of type 'String' has no member 'stringByReplacingMatches'\n396 |                         in: redactedMessage,\n397 |                         options: [],\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:394:20: error: initializer for conditional binding must have Optional type, not 'String'\n392 |             // Apply rule to message if it matches\n393 |             if rule.targetFields.isEmpty || rule.targetFields.contains(\"message\") {\n394 |                 if let pattern = rule.pattern {\n    |                    `- error: initializer for conditional binding must have Optional type, not 'String'\n395 |                     redactedMessage = pattern.stringByReplacingMatches(\n396 |                         in: redactedMessage,\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:405:24: error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getKeys' of wrapped base type 'LogMetadataDTOCollection'\n403 |             \n404 |             // Process metadata fields\n405 |             for key in redactedMetadata.getKeys() {\n    |                        |- error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getKeys' of wrapped base type 'LogMetadataDTOCollection'\n    |                        |- note: chain the optional using '?' to access member 'getKeys' only for non-'nil' base values\n    |                        `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n406 |                 if rule.targetFields.isEmpty || rule.targetFields.contains(key) {\n407 |                     if let stringValue = redactedMetadata.getString(key: key) {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:407:42: error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getString' of wrapped base type 'LogMetadataDTOCollection'\n405 |             for key in redactedMetadata.getKeys() {\n406 |                 if rule.targetFields.isEmpty || rule.targetFields.contains(key) {\n407 |                     if let stringValue = redactedMetadata.getString(key: key) {\n    |                                          |- error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getString' of wrapped base type 'LogMetadataDTOCollection'\n    |                                          |- note: chain the optional using '?' to access member 'getString' only for non-'nil' base values\n    |                                          `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n408 |                         // Skip fields that should be preserved\n409 |                         if rule.preserveFields.contains(key) {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:468:15: error: type 'LogPrivacyLevel' has no member 'never'\n466 |         case .auto:\n467 |             return .auto\n468 |         case .never:\n    |               `- error: type 'LogPrivacyLevel' has no member 'never'\n469 |             return .public // Map 'never' to public classification\n470 |         case .protected:\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:470:15: error: type 'LogPrivacyLevel' has no member 'protected'\n468 |         case .never:\n469 |             return .public // Map 'never' to public classification\n470 |         case .protected:\n    |               `- error: type 'LogPrivacyLevel' has no member 'protected'\n471 |             return .private // Map 'protected' to private classification\n472 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:58:84: error: type 'LogPrivacyLevel' has no member 'protected'\n 56 |             additionalMetadata: [\n 57 |                 \"createBackup\": (value: String(options.createBackup), privacyLevel: .public),\n 58 |                 \"backupPath\": (value: options.backupPath ?? \"none\", privacyLevel: .protected),\n    |                                                                                    `- error: type 'LogPrivacyLevel' has no member 'protected'\n 59 |                 \"dryRun\": (value: String(options.dryRun), privacyLevel: .public),\n 60 |                 \"hasFilterCriteria\": (value: String(options.filterCriteria != nil), privacyLevel: .public),\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:184:34: error: cannot find 'getDestination' in scope\n182 |         if let destinationId = destinationId {\n183 |             // Use specific destination\n184 |             if let destination = getDestination(id: destinationId) {\n    |                                  `- error: cannot find 'getDestination' in scope\n185 |                 return [destination]\n186 |             } else {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:196:38: error: cannot find 'getDestination' in scope\n194 |             \n195 |             for id in options.destinationIds {\n196 |                 if let destination = getDestination(id: id) {\n    |                                      `- error: cannot find 'getDestination' in scope\n197 |                     result.append(destination)\n198 |                 } else {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:208:20: error: cannot find 'getAllDestinations' in scope\n206 |         } else {\n207 |             // Use all registered destinations\n208 |             return getAllDestinations()\n    |                    `- error: cannot find 'getAllDestinations' in scope\n209 |         }\n210 |     }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/QueryLogsCommand.swift:71:37: error: cannot find 'getDestination' in scope\n 69 |         do {\n 70 |             // Check if destination exists\n 71 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 72 |                 throw LoggingError.destinationNotFound(\n 73 |                     \"Cannot query logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RedactionRule.swift:123:72: error: missing argument for parameter 'privacyLevel' in call\n121 |                 if value != redactedValue {\n122 |                     // Only update if actually changed\n123 |                     result = result.with(key: key, value: redactedValue)\n    |                                                                        `- error: missing argument for parameter 'privacyLevel' in call\n124 |                 }\n125 |             }\n\n/Users/mpy/.bazel/execroot/_main/packages/UmbraCoreTypes/Sources/LoggingTypes/LogMetadataDTOCollection.swift:78:15: note: 'with(key:value:privacyLevel:)' declared here\n 76 |   ///   - privacyLevel: The privacy classification for this entry\n 77 |   /// - Returns: The updated collection\n 78 |   public func with(\n    |               `- note: 'with(key:value:privacyLevel:)' declared here\n 79 |     key: String,\n 80 |     value: String,\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RedactionRule.swift:101:26: warning: no calls to throwing functions occur within 'try' expression\n 99 |     public func redact(metadata: LogMetadataDTOCollection) -\u003e LogMetadataDTOCollection {\n100 |         // No redaction needed for empty metadata\n101 |         guard let keys = try? metadata.getKeys() else {\n    |                          `- warning: no calls to throwing functions occur within 'try' expression\n102 |             return metadata\n103 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RedactionRule.swift:119:28: warning: no calls to throwing functions occur within 'try' expression\n117 |             \n118 |             // Get string value and apply redaction\n119 |             if let value = try? metadata.getString(key: key) {\n    |                            `- warning: no calls to throwing functions occur within 'try' expression\n120 |                 let redactedValue = redact(value)\n121 |                 if value != redactedValue {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RemoveDestinationCommand.swift:67:37: error: cannot find 'getDestination' in scope\n 65 |         do {\n 66 |             // Check if destination exists\n 67 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 68 |                 throw LoggingError.destinationNotFound(\n 69 |                     \"Cannot remove destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RemoveDestinationCommand.swift:128:13: error: expression is 'async' but is not marked with 'await'\n126 |             \n127 |             // Unregister the destination\n128 |             unregisterDestination(id: destinationId)\n    |             |- error: expression is 'async' but is not marked with 'await'\n    |             `- note: calls to instance method 'unregisterDestination(id:)' from outside of its actor context are implicitly asynchronous\n129 |             \n130 |             // Log success\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RotateLogsCommand.swift:67:37: error: cannot find 'getDestination' in scope\n 65 |         do {\n 66 |             // Check if destination exists\n 67 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 68 |                 throw LoggingError.destinationNotFound(\n 69 |                     \"Cannot rotate logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RotateLogsCommand.swift:74:37: error: cannot infer contextual base in reference to member 'file'\n 72 |             \n 73 |             // Check if the destination type supports rotation\n 74 |             if destination.type != .file {\n    |                                     `- error: cannot infer contextual base in reference to member 'file'\n 75 |                 throw LoggingError.invalidDestinationConfig(\n 76 |                     \"Log rotation is only supported for file destinations\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RotateLogsCommand.swift:92:112: error: type 'LogPrivacyLevel' has no member 'protected'\n 90 |                     context: operationContext,\n 91 |                     additionalMetadata: [\n 92 |                         \"rotatedFilePath\": (value: rotationResult.rotatedFilePath ?? \"unknown\", privacyLevel: .protected),\n    |                                                                                                                `- error: type 'LogPrivacyLevel' has no member 'protected'\n 93 |                         \"rotatedSizeBytes\": (value: String(rotationResult.rotatedSizeBytes ?? 0), privacyLevel: .public),\n 94 |                         \"rotatedEntryCount\": (value: String(rotationResult.rotatedEntryCount ?? 0), privacyLevel: .public)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/WriteLogCommand.swift:159:20: error: cannot find 'getAllDestinations' in scope\n157 |         if destinationIds.isEmpty {\n158 |             // Use all registered destinations\n159 |             return getAllDestinations().filter { $0.isEnabled }\n    |                    `- error: cannot find 'getAllDestinations' in scope\n160 |         } else {\n161 |             // Use specific destinations\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/WriteLogCommand.swift:165:38: error: cannot find 'getDestination' in scope\n163 |             \n164 |             for destinationId in destinationIds {\n165 |                 if let destination = getDestination(id: destinationId) {\n    |                                      `- error: cannot find 'getDestination' in scope\n166 |                     if destination.isEnabled {\n167 |                         result.append(destination)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/WriteLogCommand.swift:193:16: error: cannot find 'applyFilterRules' in scope\n191 |         \n192 |         // Apply filter rules if they exist\n193 |         return applyFilterRules(\n    |                `- error: cannot find 'applyFilterRules' in scope\n194 |             to: entry,\n195 |             rules: destination.configuration.filterRules\n\npackages/UmbraImplementations/Sources/LoggingServices/DefaultLoggingServiceImpl.swift:39:36: warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 37 |     let contextDTO=BaseLogContextDTO(\n 38 |       domainName: \"Legacy\",\n 39 |       operation: context.operation ?? \"unknown\",\n    |                                    `- warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 40 |       category: context.category ?? \"General\",\n 41 |       source: context.source ?? \"Unknown\",\n\npackages/UmbraImplementations/Sources/LoggingServices/DefaultLoggingServiceImpl.swift:40:34: warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 38 |       domainName: \"Legacy\",\n 39 |       operation: context.operation ?? \"unknown\",\n 40 |       category: context.category ?? \"General\",\n    |                                  `- warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 41 |       source: context.source ?? \"Unknown\",\n 42 |       metadata: context.metadata\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:147:17: error: invalid redeclaration of 'log(_:_:context:)'\n145 |         - context: The logging context\n146 |      */\n147 |     public func log(_ level: LogLevel, _ message: String, context: any LogContextDTO) async {\n    |                 `- error: invalid redeclaration of 'log(_:_:context:)'\n148 |         // Convert to privacy string and use privacy-aware logging\n149 |         let privacyString = PrivacyString(stringLiteral: message)\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:92:48: error: value of type 'any LoggingProviderProtocol' has no member 'writeLogEntry'\n 90 |                     do {\n 91 |                         // Write log entry to destination\n 92 |                         _ = try await provider.writeLogEntry(entry, to: destination)\n    |                                                `- error: value of type 'any LoggingProviderProtocol' has no member 'writeLogEntry'\n 93 |                     } catch {\n 94 |                         // Silently ignore provider errors for now\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:122:28: error: value of type 'PrivacyString' has no member 'privacy'\n120 |         enrichedMetadata = enrichedMetadata.withPrivate(\n121 |             key: \"__privacy_annotation\", \n122 |             value: message.privacy.description\n    |                            `- error: value of type 'PrivacyString' has no member 'privacy'\n123 |         )\n124 |         \n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:136:34: error: value of type 'PrivacyString' has no member 'content'\n134 |         \n135 |         // Log the message using the standard log method\n136 |         await log(level, message.content, context: privacyContext)\n    |                                  `- error: value of type 'PrivacyString' has no member 'content'\n137 |     }\n138 |     \n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:167:71: error: value of type 'PrivacyAnnotatedString' has no member 'stringValue'\n165 |     ) async {\n166 |         let annotatedString = privacyScope()\n167 |         await log(level, PrivacyString(stringLiteral: annotatedString.stringValue), context: context) \n    |                                                                       `- error: value of type 'PrivacyAnnotatedString' has no member 'stringValue'\n168 |     }\n169 |     \n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:190:29: error: for-in loop requires 'LogMetadata' to conform to 'Sequence'\n188 |         // Create a metadata collection with sensitive values\n189 |         var metadataCollection = context.metadata\n190 |         for (key, value) in sensitiveValues {\n    |                             `- error: for-in loop requires 'LogMetadata' to conform to 'Sequence'\n191 |             metadataCollection = metadataCollection.withSensitive(key: key, value: String(describing: value))\n192 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:228:9: error: switch must be exhaustive\n226 |         \n227 |         // Add error information to metadata with appropriate privacy level\n228 |         switch privacyLevel {\n    |         |- error: switch must be exhaustive\n    |         `- note: add missing case: '.auto'\n229 |         case .public:\n230 |             metadataCollection = metadataCollection.withPublic(key: \"error_description\", value: error.localizedDescription)\npackages/UmbraImplementations/Sources/LoggingServices/PrivacyAwareLogDTO.swift:217:24: error: value of type 'LogMetadataDTOCollection' has no member 'set'\n215 |     for key in self.metadata.getKeys() {\n216 |       if let value = self.metadata.getString(key: key) {\n217 |         mergedMetadata.set(key: key, value: value)\n    |                        `- error: value of type 'LogMetadataDTOCollection' has no member 'set'\n218 |       }\n219 |     }\n\npackages/UmbraImplementations/Sources/LoggingServices/PrivacyAwareLogDTO.swift:224:24: error: value of type 'LogMetadataDTOCollection' has no member 'set'\n222 |     for key in additionalMetadata.getKeys() {\n223 |       if let value = additionalMetadata.getString(key: key) {\n224 |         mergedMetadata.set(key: key, value: value)\n    |                        `- error: value of type 'LogMetadataDTOCollection' has no member 'set'\n225 |       }\n226 |     }\n\npackages/UmbraImplementations/Sources/LoggingServices/PrivacyAwareLogDTO.swift:235:17: error: cannot convert value of type 'LogMetadataDTOCollection' to expected argument type '[String : (value: Any, privacy: LogPrivacyLevel)]'\n233 |       category: category,\n234 |       correlationID: correlationID,\n235 |       metadata: mergedMetadata,\n    |                 `- error: cannot convert value of type 'LogMetadataDTOCollection' to expected argument type '[String : (value: Any, privacy: LogPrivacyLevel)]'\n236 |       environment: environment\n237 |     )\nTarget //packages/UmbraImplementations/Sources/LoggingServices:LoggingServices failed to build\nINFO: Elapsed time: 1.127s, Critical Path: 1.01s\nINFO: 2 processes: 2 internal.\nERROR: Build did NOT complete successfully\n"
  },
  {
    "target": "rule //packages/UmbraImplementations/Sources/LoggingWrapperServices:LoggingWrapperServices",
    "success": true,
    "start_time": "2025-04-11T17:58:21.791575+01:00",
    "end_time": "2025-04-11T17:58:22.63772+01:00",
    "duration": "846.146166ms",
    "output": "INFO: Invocation ID: eafb0e4a-dd53-43dc-ad11-9d3ce25dcc19\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraImplementations/Sources/LoggingWrapperServices:LoggingWrapperServices (0 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraImplementations/Sources/LoggingWrapperServices:LoggingWrapperServices (0 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraImplementations/Sources/LoggingWrapperServices:LoggingWrapperServices (0 packages loaded, 0 targets configured).\nINFO: Found 1 target...\nTarget //packages/UmbraImplementations/Sources/LoggingWrapperServices:LoggingWrapperServices up-to-date:\n  bazel-bin/packages/UmbraImplementations/Sources/LoggingWrapperServices/LoggingWrapperServices.swiftdoc\n  bazel-bin/packages/UmbraImplementations/Sources/LoggingWrapperServices/LoggingWrapperServices.swiftmodule\n  bazel-bin/packages/UmbraImplementations/Sources/LoggingWrapperServices/LoggingWrapperServices.swiftsourceinfo\n  bazel-bin/packages/UmbraImplementations/Sources/LoggingWrapperServices/libLoggingWrapperServices.a\nINFO: Elapsed time: 0.120s, Critical Path: 0.00s\nINFO: 1 process: 1 action cache hit, 1 internal.\nINFO: Build completed successfully, 1 total action\n"
  },
  {
    "target": "rule //packages/UmbraImplementations/Sources/NetworkServices:NetworkServices",
    "success": false,
    "start_time": "2025-04-11T17:58:22.637742+01:00",
    "end_time": "2025-04-11T17:58:24.484956+01:00",
    "duration": "1.847215959s",
    "output": "INFO: Invocation ID: 23c4c680-c8aa-4f66-bdab-20beeeddf1f5\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraImplementations/Sources/NetworkServices:NetworkServices (1 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraImplementations/Sources/NetworkServices:NetworkServices (1 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraImplementations/Sources/NetworkServices:NetworkServices (2 packages loaded, 18 targets configured).\nERROR: /Users/mpy/CascadeProjects/UmbraCore/packages/UmbraImplementations/Sources/LoggingServices/BUILD.bazel:3:20: Compiling Swift module //packages/UmbraImplementations/Sources/LoggingServices:LoggingServices failed: (Exit 1): worker failed: error executing SwiftCompile command (from target //packages/UmbraImplementations/Sources/LoggingServices:LoggingServices) \n  (cd /Users/mpy/.bazel/execroot/_main \u0026\u0026 \\\n  exec env - \\\n    APPLE_SDK_PLATFORM=MacOSX \\\n    APPLE_SDK_VERSION_OVERRIDE=15.4 \\\n    CC=clang \\\n    PATH=/Users/mpy/Library/Caches/bazelisk/downloads/sha256/ac72ad67f7a8c6b18bf605d8602425182b417de4369715bf89146daf62f7ae48/bin:/Users/mpy/.rbenv/bin:/Users/mpy/.codeium/windsurf/bin:/opt/homebrew/opt/node@18/bin:/opt/homebrew/opt/node@20/bin:/Users/mpy/.docker/bin:/opt/homebrew/opt/openjdk/bin:/Users/mpy/bin:/opt/homebrew/bin:/opt/homebrew/sbin:/usr/local/bin:/System/Cryptexes/App/usr/bin:/usr/bin:/bin:/usr/sbin:/sbin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/local/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/appleinternal/bin:/Library/Apple/usr/bin:/usr/local/go/bin:/Users/mpy/.rbenv/bin:/Users/mpy/.codeium/windsurf/bin:/opt/homebrew/opt/node@18/bin:/opt/homebrew/opt/node@20/bin:/opt/anaconda3/bin:/opt/anaconda3/condabin:/Users/mpy/.docker/bin:/opt/homebrew/opt/openjdk/bin:/Users/mpy/bin:/Users/mpy/.cargo/bin:/Users/mpy/Library/Python/3.8/bin:/Users/mpy/go/bin:/Users/mpy/.scripts:/Users/mpy/.fzf/bin:/Users/mpy/.windsurf/extensions/ms-python.debugpy-2025.6.0-darwin-arm64/bundled/scripts/noConfigScripts:/Users/mpy/Library/Python/3.8/bin:/Users/mpy/go/bin:/Users/mpy/.scripts \\\n    XCODE_VERSION_OVERRIDE=16.3.0.16E140 \\\n  bazel-out/darwin_arm64-opt-exec-ST-d57f47055a04/bin/external/rules_swift+/tools/worker/worker swiftc @bazel-out/darwin_arm64-fastbuild/bin/packages/UmbraImplementations/Sources/LoggingServices/LoggingServices.swiftmodule-0.params)\n# Configuration: 76a1bf3a80f2d50513004915454165d2f164db794b63e4666809cbd93e1abeaa\n# Execution platform: @@platforms//host:host\nerror: emit-module command failed with exit code 1 (use -v to see invocation)\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:147:17: error: invalid redeclaration of 'log(_:_:context:)'\n145 |         - context: The logging context\n146 |      */\n147 |     public func log(_ level: LogLevel, _ message: String, context: any LogContextDTO) async {\n    |                 `- error: invalid redeclaration of 'log(_:_:context:)'\n148 |         // Convert to privacy string and use privacy-aware logging\n149 |         let privacyString = PrivacyString(stringLiteral: message)\npackages/UmbraImplementations/Sources/LoggingServices/Commands/AddDestinationCommand.swift:68:31: error: cannot find 'getDestination' in scope\n 66 |         do {\n 67 |             // Check if destination already exists\n 68 |             if let existing = getDestination(id: destination.id) {\n    |                               `- error: cannot find 'getDestination' in scope\n 69 |                 if !options.overwriteExisting {\n 70 |                     throw LoggingError.destinationAlreadyExists(identifier: \"Destination with ID \\(destination.id) already exists\")\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/AddDestinationCommand.swift:82:40: error: cannot find 'validateDestination' in scope\n 80 |             // Validate destination configuration if requested\n 81 |             if options.validateConfiguration {\n 82 |                 let validationResult = validateDestination(destination, for: provider)\n    |                                        `- error: cannot find 'validateDestination' in scope\n 83 |                 \n 84 |                 if !validationResult.isValid {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/AddDestinationCommand.swift:121:13: error: expression is 'async' but is not marked with 'await'\n119 |             \n120 |             // Register the destination\n121 |             registerDestination(destination)\n    |             |- error: expression is 'async' but is not marked with 'await'\n    |             `- note: calls to instance method 'registerDestination' from outside of its actor context are implicitly asynchronous\n122 |             \n123 |             // Log success\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ArchiveLogsCommand.swift:57:84: error: type 'LogPrivacyLevel' has no member 'protected'\n 55 |             destinationId: destinationId,\n 56 |             additionalMetadata: [\n 57 |                 \"destinationPath\": (value: options.destinationPath, privacyLevel: .protected),\n    |                                                                                    `- error: type 'LogPrivacyLevel' has no member 'protected'\n 58 |                 \"compress\": (value: String(options.compress), privacyLevel: .public),\n 59 |                 \"format\": (value: options.format.rawValue, privacyLevel: .public),\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ArchiveLogsCommand.swift:70:37: error: cannot find 'getDestination' in scope\n 68 |         do {\n 69 |             // Check if destination exists\n 70 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 71 |                 throw LoggingError.destinationNotFound(\n 72 |                     \"Cannot archive logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ArchiveLogsCommand.swift:113:103: error: type 'LogPrivacyLevel' has no member 'protected'\n111 |                     context: operationContext,\n112 |                     additionalMetadata: [\n113 |                         \"archivePath\": (value: archiveResult.archivePath ?? \"unknown\", privacyLevel: .protected),\n    |                                                                                                       `- error: type 'LogPrivacyLevel' has no member 'protected'\n114 |                         \"archiveSizeBytes\": (value: String(archiveResult.archiveSizeBytes ?? 0), privacyLevel: .public),\n115 |                         \"archivedEntryCount\": (value: String(archiveResult.archivedEntryCount ?? 0), privacyLevel: .public)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ExportLogsCommand.swift:70:37: error: cannot find 'getDestination' in scope\n 68 |         do {\n 69 |             // Check if destination exists\n 70 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 71 |                 throw LoggingError.destinationNotFound(\n 72 |                     \"Cannot export logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:79:50: error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n 77 |                 key: key,\n 78 |                 value: value.value,\n 79 |                 privacyLevel: value.privacyLevel.toPrivacyClassification()\n    |                                                  `- error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n 80 |             )\n 81 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:122:54: error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n120 |                     key: key,\n121 |                     value: value.value,\n122 |                     privacyLevel: value.privacyLevel.toPrivacyClassification()\n    |                                                      `- error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n123 |                 )\n124 |             )\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:229:21: error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n227 |         \n228 |         // Process special fields first\n229 |         switch rule.field {\n    |                     `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n230 |         case \"level\":\n231 |             fieldValue = entry.level.rawValue\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:238:96: error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n236 |         default:\n237 |             // Check metadata fields\n238 |             if let metadata = entry.metadata, let metadataValue = metadata.getString(key: rule.field) {\n    |                                                                                                `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n239 |                 fieldValue = metadataValue\n240 |             } else {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:246:21: error: value of type 'UmbraLogFilterRuleDTO' has no member 'operation'\n244 |         \n245 |         // Apply the operation\n246 |         switch rule.operation {\n    |                     `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'operation'\n247 |         case .equals:\n248 |             return fieldValue == rule.value\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:248:39: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n246 |         switch rule.operation {\n247 |         case .equals:\n248 |             return fieldValue == rule.value\n    |                                       `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n249 |         case .contains:\n250 |             return fieldValue.contains(rule.value)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:250:45: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n248 |             return fieldValue == rule.value\n249 |         case .contains:\n250 |             return fieldValue.contains(rule.value)\n    |                                             `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n251 |         case .startsWith:\n252 |             return fieldValue.hasPrefix(rule.value)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:252:46: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n250 |             return fieldValue.contains(rule.value)\n251 |         case .startsWith:\n252 |             return fieldValue.hasPrefix(rule.value)\n    |                                              `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n253 |         case .endsWith:\n254 |             return fieldValue.hasSuffix(rule.value)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:254:46: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n252 |             return fieldValue.hasPrefix(rule.value)\n253 |         case .endsWith:\n254 |             return fieldValue.hasSuffix(rule.value)\n    |                                              `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n255 |         case .matches:\n256 |             if let regex = try? NSRegularExpression(pattern: rule.value) {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:256:67: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n254 |             return fieldValue.hasSuffix(rule.value)\n255 |         case .matches:\n256 |             if let regex = try? NSRegularExpression(pattern: rule.value) {\n    |                                                                   `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n257 |                 let range = NSRange(location: 0, length: fieldValue.utf16.count)\n258 |                 return regex.firstMatch(in: fieldValue, options: [], range: range) != nil\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:262:86: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n260 |             return false\n261 |         case .greaterThan:\n262 |             if let fieldNumeric = Double(fieldValue), let valueNumeric = Double(rule.value) {\n    |                                                                                      `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n263 |                 return fieldNumeric \u003e valueNumeric\n264 |             }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:267:86: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n265 |             return false\n266 |         case .lessThan:\n267 |             if let fieldNumeric = Double(fieldValue), let valueNumeric = Double(rule.value) {\n    |                                                                                      `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n268 |                 return fieldNumeric \u003c valueNumeric\n269 |             }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:293:13: warning: variable 'redactedMetadata' was never mutated; consider changing to 'let' constant\n291 |         // Create mutable copies\n292 |         var redactedMessage = entry.message\n293 |         var redactedMetadata = entry.metadata\n    |             `- warning: variable 'redactedMetadata' was never mutated; consider changing to 'let' constant\n294 |         \n295 |         for rule in rules {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:395:47: error: value of type 'String' has no member 'stringByReplacingMatches'\n393 |             if rule.targetFields.isEmpty || rule.targetFields.contains(\"message\") {\n394 |                 if let pattern = rule.pattern {\n395 |                     redactedMessage = pattern.stringByReplacingMatches(\n    |                                               `- error: value of type 'String' has no member 'stringByReplacingMatches'\n396 |                         in: redactedMessage,\n397 |                         options: [],\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:394:20: error: initializer for conditional binding must have Optional type, not 'String'\n392 |             // Apply rule to message if it matches\n393 |             if rule.targetFields.isEmpty || rule.targetFields.contains(\"message\") {\n394 |                 if let pattern = rule.pattern {\n    |                    `- error: initializer for conditional binding must have Optional type, not 'String'\n395 |                     redactedMessage = pattern.stringByReplacingMatches(\n396 |                         in: redactedMessage,\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:405:24: error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getKeys' of wrapped base type 'LogMetadataDTOCollection'\n403 |             \n404 |             // Process metadata fields\n405 |             for key in redactedMetadata.getKeys() {\n    |                        |- error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getKeys' of wrapped base type 'LogMetadataDTOCollection'\n    |                        |- note: chain the optional using '?' to access member 'getKeys' only for non-'nil' base values\n    |                        `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n406 |                 if rule.targetFields.isEmpty || rule.targetFields.contains(key) {\n407 |                     if let stringValue = redactedMetadata.getString(key: key) {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:407:42: error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getString' of wrapped base type 'LogMetadataDTOCollection'\n405 |             for key in redactedMetadata.getKeys() {\n406 |                 if rule.targetFields.isEmpty || rule.targetFields.contains(key) {\n407 |                     if let stringValue = redactedMetadata.getString(key: key) {\n    |                                          |- error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getString' of wrapped base type 'LogMetadataDTOCollection'\n    |                                          |- note: chain the optional using '?' to access member 'getString' only for non-'nil' base values\n    |                                          `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n408 |                         // Skip fields that should be preserved\n409 |                         if rule.preserveFields.contains(key) {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:468:15: error: type 'LogPrivacyLevel' has no member 'never'\n466 |         case .auto:\n467 |             return .auto\n468 |         case .never:\n    |               `- error: type 'LogPrivacyLevel' has no member 'never'\n469 |             return .public // Map 'never' to public classification\n470 |         case .protected:\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:470:15: error: type 'LogPrivacyLevel' has no member 'protected'\n468 |         case .never:\n469 |             return .public // Map 'never' to public classification\n470 |         case .protected:\n    |               `- error: type 'LogPrivacyLevel' has no member 'protected'\n471 |             return .private // Map 'protected' to private classification\n472 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:58:84: error: type 'LogPrivacyLevel' has no member 'protected'\n 56 |             additionalMetadata: [\n 57 |                 \"createBackup\": (value: String(options.createBackup), privacyLevel: .public),\n 58 |                 \"backupPath\": (value: options.backupPath ?? \"none\", privacyLevel: .protected),\n    |                                                                                    `- error: type 'LogPrivacyLevel' has no member 'protected'\n 59 |                 \"dryRun\": (value: String(options.dryRun), privacyLevel: .public),\n 60 |                 \"hasFilterCriteria\": (value: String(options.filterCriteria != nil), privacyLevel: .public),\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:184:34: error: cannot find 'getDestination' in scope\n182 |         if let destinationId = destinationId {\n183 |             // Use specific destination\n184 |             if let destination = getDestination(id: destinationId) {\n    |                                  `- error: cannot find 'getDestination' in scope\n185 |                 return [destination]\n186 |             } else {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:196:38: error: cannot find 'getDestination' in scope\n194 |             \n195 |             for id in options.destinationIds {\n196 |                 if let destination = getDestination(id: id) {\n    |                                      `- error: cannot find 'getDestination' in scope\n197 |                     result.append(destination)\n198 |                 } else {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:208:20: error: cannot find 'getAllDestinations' in scope\n206 |         } else {\n207 |             // Use all registered destinations\n208 |             return getAllDestinations()\n    |                    `- error: cannot find 'getAllDestinations' in scope\n209 |         }\n210 |     }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/QueryLogsCommand.swift:71:37: error: cannot find 'getDestination' in scope\n 69 |         do {\n 70 |             // Check if destination exists\n 71 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 72 |                 throw LoggingError.destinationNotFound(\n 73 |                     \"Cannot query logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RedactionRule.swift:123:72: error: missing argument for parameter 'privacyLevel' in call\n121 |                 if value != redactedValue {\n122 |                     // Only update if actually changed\n123 |                     result = result.with(key: key, value: redactedValue)\n    |                                                                        `- error: missing argument for parameter 'privacyLevel' in call\n124 |                 }\n125 |             }\n\n/Users/mpy/.bazel/execroot/_main/packages/UmbraCoreTypes/Sources/LoggingTypes/LogMetadataDTOCollection.swift:78:15: note: 'with(key:value:privacyLevel:)' declared here\n 76 |   ///   - privacyLevel: The privacy classification for this entry\n 77 |   /// - Returns: The updated collection\n 78 |   public func with(\n    |               `- note: 'with(key:value:privacyLevel:)' declared here\n 79 |     key: String,\n 80 |     value: String,\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RedactionRule.swift:101:26: warning: no calls to throwing functions occur within 'try' expression\n 99 |     public func redact(metadata: LogMetadataDTOCollection) -\u003e LogMetadataDTOCollection {\n100 |         // No redaction needed for empty metadata\n101 |         guard let keys = try? metadata.getKeys() else {\n    |                          `- warning: no calls to throwing functions occur within 'try' expression\n102 |             return metadata\n103 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RedactionRule.swift:119:28: warning: no calls to throwing functions occur within 'try' expression\n117 |             \n118 |             // Get string value and apply redaction\n119 |             if let value = try? metadata.getString(key: key) {\n    |                            `- warning: no calls to throwing functions occur within 'try' expression\n120 |                 let redactedValue = redact(value)\n121 |                 if value != redactedValue {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RemoveDestinationCommand.swift:67:37: error: cannot find 'getDestination' in scope\n 65 |         do {\n 66 |             // Check if destination exists\n 67 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 68 |                 throw LoggingError.destinationNotFound(\n 69 |                     \"Cannot remove destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RemoveDestinationCommand.swift:128:13: error: expression is 'async' but is not marked with 'await'\n126 |             \n127 |             // Unregister the destination\n128 |             unregisterDestination(id: destinationId)\n    |             |- error: expression is 'async' but is not marked with 'await'\n    |             `- note: calls to instance method 'unregisterDestination(id:)' from outside of its actor context are implicitly asynchronous\n129 |             \n130 |             // Log success\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RotateLogsCommand.swift:67:37: error: cannot find 'getDestination' in scope\n 65 |         do {\n 66 |             // Check if destination exists\n 67 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 68 |                 throw LoggingError.destinationNotFound(\n 69 |                     \"Cannot rotate logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RotateLogsCommand.swift:74:37: error: cannot infer contextual base in reference to member 'file'\n 72 |             \n 73 |             // Check if the destination type supports rotation\n 74 |             if destination.type != .file {\n    |                                     `- error: cannot infer contextual base in reference to member 'file'\n 75 |                 throw LoggingError.invalidDestinationConfig(\n 76 |                     \"Log rotation is only supported for file destinations\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RotateLogsCommand.swift:92:112: error: type 'LogPrivacyLevel' has no member 'protected'\n 90 |                     context: operationContext,\n 91 |                     additionalMetadata: [\n 92 |                         \"rotatedFilePath\": (value: rotationResult.rotatedFilePath ?? \"unknown\", privacyLevel: .protected),\n    |                                                                                                                `- error: type 'LogPrivacyLevel' has no member 'protected'\n 93 |                         \"rotatedSizeBytes\": (value: String(rotationResult.rotatedSizeBytes ?? 0), privacyLevel: .public),\n 94 |                         \"rotatedEntryCount\": (value: String(rotationResult.rotatedEntryCount ?? 0), privacyLevel: .public)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/WriteLogCommand.swift:159:20: error: cannot find 'getAllDestinations' in scope\n157 |         if destinationIds.isEmpty {\n158 |             // Use all registered destinations\n159 |             return getAllDestinations().filter { $0.isEnabled }\n    |                    `- error: cannot find 'getAllDestinations' in scope\n160 |         } else {\n161 |             // Use specific destinations\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/WriteLogCommand.swift:165:38: error: cannot find 'getDestination' in scope\n163 |             \n164 |             for destinationId in destinationIds {\n165 |                 if let destination = getDestination(id: destinationId) {\n    |                                      `- error: cannot find 'getDestination' in scope\n166 |                     if destination.isEnabled {\n167 |                         result.append(destination)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/WriteLogCommand.swift:193:16: error: cannot find 'applyFilterRules' in scope\n191 |         \n192 |         // Apply filter rules if they exist\n193 |         return applyFilterRules(\n    |                `- error: cannot find 'applyFilterRules' in scope\n194 |             to: entry,\n195 |             rules: destination.configuration.filterRules\n\npackages/UmbraImplementations/Sources/LoggingServices/DefaultLoggingServiceImpl.swift:39:36: warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 37 |     let contextDTO=BaseLogContextDTO(\n 38 |       domainName: \"Legacy\",\n 39 |       operation: context.operation ?? \"unknown\",\n    |                                    `- warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 40 |       category: context.category ?? \"General\",\n 41 |       source: context.source ?? \"Unknown\",\n\npackages/UmbraImplementations/Sources/LoggingServices/DefaultLoggingServiceImpl.swift:40:34: warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 38 |       domainName: \"Legacy\",\n 39 |       operation: context.operation ?? \"unknown\",\n 40 |       category: context.category ?? \"General\",\n    |                                  `- warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 41 |       source: context.source ?? \"Unknown\",\n 42 |       metadata: context.metadata\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:147:17: error: invalid redeclaration of 'log(_:_:context:)'\n145 |         - context: The logging context\n146 |      */\n147 |     public func log(_ level: LogLevel, _ message: String, context: any LogContextDTO) async {\n    |                 `- error: invalid redeclaration of 'log(_:_:context:)'\n148 |         // Convert to privacy string and use privacy-aware logging\n149 |         let privacyString = PrivacyString(stringLiteral: message)\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:92:48: error: value of type 'any LoggingProviderProtocol' has no member 'writeLogEntry'\n 90 |                     do {\n 91 |                         // Write log entry to destination\n 92 |                         _ = try await provider.writeLogEntry(entry, to: destination)\n    |                                                `- error: value of type 'any LoggingProviderProtocol' has no member 'writeLogEntry'\n 93 |                     } catch {\n 94 |                         // Silently ignore provider errors for now\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:122:28: error: value of type 'PrivacyString' has no member 'privacy'\n120 |         enrichedMetadata = enrichedMetadata.withPrivate(\n121 |             key: \"__privacy_annotation\", \n122 |             value: message.privacy.description\n    |                            `- error: value of type 'PrivacyString' has no member 'privacy'\n123 |         )\n124 |         \n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:136:34: error: value of type 'PrivacyString' has no member 'content'\n134 |         \n135 |         // Log the message using the standard log method\n136 |         await log(level, message.content, context: privacyContext)\n    |                                  `- error: value of type 'PrivacyString' has no member 'content'\n137 |     }\n138 |     \n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:167:71: error: value of type 'PrivacyAnnotatedString' has no member 'stringValue'\n165 |     ) async {\n166 |         let annotatedString = privacyScope()\n167 |         await log(level, PrivacyString(stringLiteral: annotatedString.stringValue), context: context) \n    |                                                                       `- error: value of type 'PrivacyAnnotatedString' has no member 'stringValue'\n168 |     }\n169 |     \n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:190:29: error: for-in loop requires 'LogMetadata' to conform to 'Sequence'\n188 |         // Create a metadata collection with sensitive values\n189 |         var metadataCollection = context.metadata\n190 |         for (key, value) in sensitiveValues {\n    |                             `- error: for-in loop requires 'LogMetadata' to conform to 'Sequence'\n191 |             metadataCollection = metadataCollection.withSensitive(key: key, value: String(describing: value))\n192 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:228:9: error: switch must be exhaustive\n226 |         \n227 |         // Add error information to metadata with appropriate privacy level\n228 |         switch privacyLevel {\n    |         |- error: switch must be exhaustive\n    |         `- note: add missing case: '.auto'\n229 |         case .public:\n230 |             metadataCollection = metadataCollection.withPublic(key: \"error_description\", value: error.localizedDescription)\npackages/UmbraImplementations/Sources/LoggingServices/PrivacyAwareLogDTO.swift:217:24: error: value of type 'LogMetadataDTOCollection' has no member 'set'\n215 |     for key in self.metadata.getKeys() {\n216 |       if let value = self.metadata.getString(key: key) {\n217 |         mergedMetadata.set(key: key, value: value)\n    |                        `- error: value of type 'LogMetadataDTOCollection' has no member 'set'\n218 |       }\n219 |     }\n\npackages/UmbraImplementations/Sources/LoggingServices/PrivacyAwareLogDTO.swift:224:24: error: value of type 'LogMetadataDTOCollection' has no member 'set'\n222 |     for key in additionalMetadata.getKeys() {\n223 |       if let value = additionalMetadata.getString(key: key) {\n224 |         mergedMetadata.set(key: key, value: value)\n    |                        `- error: value of type 'LogMetadataDTOCollection' has no member 'set'\n225 |       }\n226 |     }\n\npackages/UmbraImplementations/Sources/LoggingServices/PrivacyAwareLogDTO.swift:235:17: error: cannot convert value of type 'LogMetadataDTOCollection' to expected argument type '[String : (value: Any, privacy: LogPrivacyLevel)]'\n233 |       category: category,\n234 |       correlationID: correlationID,\n235 |       metadata: mergedMetadata,\n    |                 `- error: cannot convert value of type 'LogMetadataDTOCollection' to expected argument type '[String : (value: Any, privacy: LogPrivacyLevel)]'\n236 |       environment: environment\n237 |     )\nTarget //packages/UmbraImplementations/Sources/NetworkServices:NetworkServices failed to build\nINFO: Elapsed time: 1.139s, Critical Path: 1.01s\nINFO: 3 processes: 2 action cache hit, 2 internal, 1 worker.\nERROR: Build did NOT complete successfully\n"
  },
  {
    "target": "rule //packages/UmbraImplementations/Sources/RepositoryServices:RepositoryServices",
    "success": false,
    "start_time": "2025-04-11T17:58:24.484979+01:00",
    "end_time": "2025-04-11T17:58:26.318153+01:00",
    "duration": "1.833176208s",
    "output": "INFO: Invocation ID: 290ae061-fc95-4a1c-87b0-b7db4fdde2a8\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraImplementations/Sources/RepositoryServices:RepositoryServices (1 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraImplementations/Sources/RepositoryServices:RepositoryServices (1 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraImplementations/Sources/RepositoryServices:RepositoryServices (1 packages loaded, 7 targets configured).\nERROR: /Users/mpy/CascadeProjects/UmbraCore/packages/UmbraImplementations/Sources/LoggingServices/BUILD.bazel:3:20: Compiling Swift module //packages/UmbraImplementations/Sources/LoggingServices:LoggingServices failed: (Exit 1): worker failed: error executing SwiftCompile command (from target //packages/UmbraImplementations/Sources/LoggingServices:LoggingServices) \n  (cd /Users/mpy/.bazel/execroot/_main \u0026\u0026 \\\n  exec env - \\\n    APPLE_SDK_PLATFORM=MacOSX \\\n    APPLE_SDK_VERSION_OVERRIDE=15.4 \\\n    CC=clang \\\n    PATH=/Users/mpy/Library/Caches/bazelisk/downloads/sha256/ac72ad67f7a8c6b18bf605d8602425182b417de4369715bf89146daf62f7ae48/bin:/Users/mpy/.rbenv/bin:/Users/mpy/.codeium/windsurf/bin:/opt/homebrew/opt/node@18/bin:/opt/homebrew/opt/node@20/bin:/Users/mpy/.docker/bin:/opt/homebrew/opt/openjdk/bin:/Users/mpy/bin:/opt/homebrew/bin:/opt/homebrew/sbin:/usr/local/bin:/System/Cryptexes/App/usr/bin:/usr/bin:/bin:/usr/sbin:/sbin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/local/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/appleinternal/bin:/Library/Apple/usr/bin:/usr/local/go/bin:/Users/mpy/.rbenv/bin:/Users/mpy/.codeium/windsurf/bin:/opt/homebrew/opt/node@18/bin:/opt/homebrew/opt/node@20/bin:/opt/anaconda3/bin:/opt/anaconda3/condabin:/Users/mpy/.docker/bin:/opt/homebrew/opt/openjdk/bin:/Users/mpy/bin:/Users/mpy/.cargo/bin:/Users/mpy/Library/Python/3.8/bin:/Users/mpy/go/bin:/Users/mpy/.scripts:/Users/mpy/.fzf/bin:/Users/mpy/.windsurf/extensions/ms-python.debugpy-2025.6.0-darwin-arm64/bundled/scripts/noConfigScripts:/Users/mpy/Library/Python/3.8/bin:/Users/mpy/go/bin:/Users/mpy/.scripts \\\n    XCODE_VERSION_OVERRIDE=16.3.0.16E140 \\\n  bazel-out/darwin_arm64-opt-exec-ST-d57f47055a04/bin/external/rules_swift+/tools/worker/worker swiftc @bazel-out/darwin_arm64-fastbuild/bin/packages/UmbraImplementations/Sources/LoggingServices/LoggingServices.swiftmodule-0.params)\n# Configuration: 76a1bf3a80f2d50513004915454165d2f164db794b63e4666809cbd93e1abeaa\n# Execution platform: @@platforms//host:host\nerror: emit-module command failed with exit code 1 (use -v to see invocation)\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:147:17: error: invalid redeclaration of 'log(_:_:context:)'\n145 |         - context: The logging context\n146 |      */\n147 |     public func log(_ level: LogLevel, _ message: String, context: any LogContextDTO) async {\n    |                 `- error: invalid redeclaration of 'log(_:_:context:)'\n148 |         // Convert to privacy string and use privacy-aware logging\n149 |         let privacyString = PrivacyString(stringLiteral: message)\npackages/UmbraImplementations/Sources/LoggingServices/Commands/AddDestinationCommand.swift:68:31: error: cannot find 'getDestination' in scope\n 66 |         do {\n 67 |             // Check if destination already exists\n 68 |             if let existing = getDestination(id: destination.id) {\n    |                               `- error: cannot find 'getDestination' in scope\n 69 |                 if !options.overwriteExisting {\n 70 |                     throw LoggingError.destinationAlreadyExists(identifier: \"Destination with ID \\(destination.id) already exists\")\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/AddDestinationCommand.swift:82:40: error: cannot find 'validateDestination' in scope\n 80 |             // Validate destination configuration if requested\n 81 |             if options.validateConfiguration {\n 82 |                 let validationResult = validateDestination(destination, for: provider)\n    |                                        `- error: cannot find 'validateDestination' in scope\n 83 |                 \n 84 |                 if !validationResult.isValid {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/AddDestinationCommand.swift:121:13: error: expression is 'async' but is not marked with 'await'\n119 |             \n120 |             // Register the destination\n121 |             registerDestination(destination)\n    |             |- error: expression is 'async' but is not marked with 'await'\n    |             `- note: calls to instance method 'registerDestination' from outside of its actor context are implicitly asynchronous\n122 |             \n123 |             // Log success\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ArchiveLogsCommand.swift:57:84: error: type 'LogPrivacyLevel' has no member 'protected'\n 55 |             destinationId: destinationId,\n 56 |             additionalMetadata: [\n 57 |                 \"destinationPath\": (value: options.destinationPath, privacyLevel: .protected),\n    |                                                                                    `- error: type 'LogPrivacyLevel' has no member 'protected'\n 58 |                 \"compress\": (value: String(options.compress), privacyLevel: .public),\n 59 |                 \"format\": (value: options.format.rawValue, privacyLevel: .public),\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ArchiveLogsCommand.swift:70:37: error: cannot find 'getDestination' in scope\n 68 |         do {\n 69 |             // Check if destination exists\n 70 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 71 |                 throw LoggingError.destinationNotFound(\n 72 |                     \"Cannot archive logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ArchiveLogsCommand.swift:113:103: error: type 'LogPrivacyLevel' has no member 'protected'\n111 |                     context: operationContext,\n112 |                     additionalMetadata: [\n113 |                         \"archivePath\": (value: archiveResult.archivePath ?? \"unknown\", privacyLevel: .protected),\n    |                                                                                                       `- error: type 'LogPrivacyLevel' has no member 'protected'\n114 |                         \"archiveSizeBytes\": (value: String(archiveResult.archiveSizeBytes ?? 0), privacyLevel: .public),\n115 |                         \"archivedEntryCount\": (value: String(archiveResult.archivedEntryCount ?? 0), privacyLevel: .public)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ExportLogsCommand.swift:70:37: error: cannot find 'getDestination' in scope\n 68 |         do {\n 69 |             // Check if destination exists\n 70 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 71 |                 throw LoggingError.destinationNotFound(\n 72 |                     \"Cannot export logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:79:50: error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n 77 |                 key: key,\n 78 |                 value: value.value,\n 79 |                 privacyLevel: value.privacyLevel.toPrivacyClassification()\n    |                                                  `- error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n 80 |             )\n 81 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:122:54: error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n120 |                     key: key,\n121 |                     value: value.value,\n122 |                     privacyLevel: value.privacyLevel.toPrivacyClassification()\n    |                                                      `- error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n123 |                 )\n124 |             )\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:229:21: error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n227 |         \n228 |         // Process special fields first\n229 |         switch rule.field {\n    |                     `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n230 |         case \"level\":\n231 |             fieldValue = entry.level.rawValue\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:238:96: error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n236 |         default:\n237 |             // Check metadata fields\n238 |             if let metadata = entry.metadata, let metadataValue = metadata.getString(key: rule.field) {\n    |                                                                                                `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n239 |                 fieldValue = metadataValue\n240 |             } else {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:246:21: error: value of type 'UmbraLogFilterRuleDTO' has no member 'operation'\n244 |         \n245 |         // Apply the operation\n246 |         switch rule.operation {\n    |                     `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'operation'\n247 |         case .equals:\n248 |             return fieldValue == rule.value\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:248:39: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n246 |         switch rule.operation {\n247 |         case .equals:\n248 |             return fieldValue == rule.value\n    |                                       `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n249 |         case .contains:\n250 |             return fieldValue.contains(rule.value)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:250:45: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n248 |             return fieldValue == rule.value\n249 |         case .contains:\n250 |             return fieldValue.contains(rule.value)\n    |                                             `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n251 |         case .startsWith:\n252 |             return fieldValue.hasPrefix(rule.value)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:252:46: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n250 |             return fieldValue.contains(rule.value)\n251 |         case .startsWith:\n252 |             return fieldValue.hasPrefix(rule.value)\n    |                                              `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n253 |         case .endsWith:\n254 |             return fieldValue.hasSuffix(rule.value)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:254:46: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n252 |             return fieldValue.hasPrefix(rule.value)\n253 |         case .endsWith:\n254 |             return fieldValue.hasSuffix(rule.value)\n    |                                              `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n255 |         case .matches:\n256 |             if let regex = try? NSRegularExpression(pattern: rule.value) {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:256:67: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n254 |             return fieldValue.hasSuffix(rule.value)\n255 |         case .matches:\n256 |             if let regex = try? NSRegularExpression(pattern: rule.value) {\n    |                                                                   `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n257 |                 let range = NSRange(location: 0, length: fieldValue.utf16.count)\n258 |                 return regex.firstMatch(in: fieldValue, options: [], range: range) != nil\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:262:86: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n260 |             return false\n261 |         case .greaterThan:\n262 |             if let fieldNumeric = Double(fieldValue), let valueNumeric = Double(rule.value) {\n    |                                                                                      `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n263 |                 return fieldNumeric \u003e valueNumeric\n264 |             }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:267:86: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n265 |             return false\n266 |         case .lessThan:\n267 |             if let fieldNumeric = Double(fieldValue), let valueNumeric = Double(rule.value) {\n    |                                                                                      `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n268 |                 return fieldNumeric \u003c valueNumeric\n269 |             }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:293:13: warning: variable 'redactedMetadata' was never mutated; consider changing to 'let' constant\n291 |         // Create mutable copies\n292 |         var redactedMessage = entry.message\n293 |         var redactedMetadata = entry.metadata\n    |             `- warning: variable 'redactedMetadata' was never mutated; consider changing to 'let' constant\n294 |         \n295 |         for rule in rules {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:395:47: error: value of type 'String' has no member 'stringByReplacingMatches'\n393 |             if rule.targetFields.isEmpty || rule.targetFields.contains(\"message\") {\n394 |                 if let pattern = rule.pattern {\n395 |                     redactedMessage = pattern.stringByReplacingMatches(\n    |                                               `- error: value of type 'String' has no member 'stringByReplacingMatches'\n396 |                         in: redactedMessage,\n397 |                         options: [],\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:394:20: error: initializer for conditional binding must have Optional type, not 'String'\n392 |             // Apply rule to message if it matches\n393 |             if rule.targetFields.isEmpty || rule.targetFields.contains(\"message\") {\n394 |                 if let pattern = rule.pattern {\n    |                    `- error: initializer for conditional binding must have Optional type, not 'String'\n395 |                     redactedMessage = pattern.stringByReplacingMatches(\n396 |                         in: redactedMessage,\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:405:24: error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getKeys' of wrapped base type 'LogMetadataDTOCollection'\n403 |             \n404 |             // Process metadata fields\n405 |             for key in redactedMetadata.getKeys() {\n    |                        |- error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getKeys' of wrapped base type 'LogMetadataDTOCollection'\n    |                        |- note: chain the optional using '?' to access member 'getKeys' only for non-'nil' base values\n    |                        `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n406 |                 if rule.targetFields.isEmpty || rule.targetFields.contains(key) {\n407 |                     if let stringValue = redactedMetadata.getString(key: key) {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:407:42: error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getString' of wrapped base type 'LogMetadataDTOCollection'\n405 |             for key in redactedMetadata.getKeys() {\n406 |                 if rule.targetFields.isEmpty || rule.targetFields.contains(key) {\n407 |                     if let stringValue = redactedMetadata.getString(key: key) {\n    |                                          |- error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getString' of wrapped base type 'LogMetadataDTOCollection'\n    |                                          |- note: chain the optional using '?' to access member 'getString' only for non-'nil' base values\n    |                                          `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n408 |                         // Skip fields that should be preserved\n409 |                         if rule.preserveFields.contains(key) {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:468:15: error: type 'LogPrivacyLevel' has no member 'never'\n466 |         case .auto:\n467 |             return .auto\n468 |         case .never:\n    |               `- error: type 'LogPrivacyLevel' has no member 'never'\n469 |             return .public // Map 'never' to public classification\n470 |         case .protected:\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:470:15: error: type 'LogPrivacyLevel' has no member 'protected'\n468 |         case .never:\n469 |             return .public // Map 'never' to public classification\n470 |         case .protected:\n    |               `- error: type 'LogPrivacyLevel' has no member 'protected'\n471 |             return .private // Map 'protected' to private classification\n472 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:58:84: error: type 'LogPrivacyLevel' has no member 'protected'\n 56 |             additionalMetadata: [\n 57 |                 \"createBackup\": (value: String(options.createBackup), privacyLevel: .public),\n 58 |                 \"backupPath\": (value: options.backupPath ?? \"none\", privacyLevel: .protected),\n    |                                                                                    `- error: type 'LogPrivacyLevel' has no member 'protected'\n 59 |                 \"dryRun\": (value: String(options.dryRun), privacyLevel: .public),\n 60 |                 \"hasFilterCriteria\": (value: String(options.filterCriteria != nil), privacyLevel: .public),\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:184:34: error: cannot find 'getDestination' in scope\n182 |         if let destinationId = destinationId {\n183 |             // Use specific destination\n184 |             if let destination = getDestination(id: destinationId) {\n    |                                  `- error: cannot find 'getDestination' in scope\n185 |                 return [destination]\n186 |             } else {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:196:38: error: cannot find 'getDestination' in scope\n194 |             \n195 |             for id in options.destinationIds {\n196 |                 if let destination = getDestination(id: id) {\n    |                                      `- error: cannot find 'getDestination' in scope\n197 |                     result.append(destination)\n198 |                 } else {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:208:20: error: cannot find 'getAllDestinations' in scope\n206 |         } else {\n207 |             // Use all registered destinations\n208 |             return getAllDestinations()\n    |                    `- error: cannot find 'getAllDestinations' in scope\n209 |         }\n210 |     }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/QueryLogsCommand.swift:71:37: error: cannot find 'getDestination' in scope\n 69 |         do {\n 70 |             // Check if destination exists\n 71 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 72 |                 throw LoggingError.destinationNotFound(\n 73 |                     \"Cannot query logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RedactionRule.swift:123:72: error: missing argument for parameter 'privacyLevel' in call\n121 |                 if value != redactedValue {\n122 |                     // Only update if actually changed\n123 |                     result = result.with(key: key, value: redactedValue)\n    |                                                                        `- error: missing argument for parameter 'privacyLevel' in call\n124 |                 }\n125 |             }\n\n/Users/mpy/.bazel/execroot/_main/packages/UmbraCoreTypes/Sources/LoggingTypes/LogMetadataDTOCollection.swift:78:15: note: 'with(key:value:privacyLevel:)' declared here\n 76 |   ///   - privacyLevel: The privacy classification for this entry\n 77 |   /// - Returns: The updated collection\n 78 |   public func with(\n    |               `- note: 'with(key:value:privacyLevel:)' declared here\n 79 |     key: String,\n 80 |     value: String,\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RedactionRule.swift:101:26: warning: no calls to throwing functions occur within 'try' expression\n 99 |     public func redact(metadata: LogMetadataDTOCollection) -\u003e LogMetadataDTOCollection {\n100 |         // No redaction needed for empty metadata\n101 |         guard let keys = try? metadata.getKeys() else {\n    |                          `- warning: no calls to throwing functions occur within 'try' expression\n102 |             return metadata\n103 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RedactionRule.swift:119:28: warning: no calls to throwing functions occur within 'try' expression\n117 |             \n118 |             // Get string value and apply redaction\n119 |             if let value = try? metadata.getString(key: key) {\n    |                            `- warning: no calls to throwing functions occur within 'try' expression\n120 |                 let redactedValue = redact(value)\n121 |                 if value != redactedValue {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RemoveDestinationCommand.swift:67:37: error: cannot find 'getDestination' in scope\n 65 |         do {\n 66 |             // Check if destination exists\n 67 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 68 |                 throw LoggingError.destinationNotFound(\n 69 |                     \"Cannot remove destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RemoveDestinationCommand.swift:128:13: error: expression is 'async' but is not marked with 'await'\n126 |             \n127 |             // Unregister the destination\n128 |             unregisterDestination(id: destinationId)\n    |             |- error: expression is 'async' but is not marked with 'await'\n    |             `- note: calls to instance method 'unregisterDestination(id:)' from outside of its actor context are implicitly asynchronous\n129 |             \n130 |             // Log success\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RotateLogsCommand.swift:67:37: error: cannot find 'getDestination' in scope\n 65 |         do {\n 66 |             // Check if destination exists\n 67 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 68 |                 throw LoggingError.destinationNotFound(\n 69 |                     \"Cannot rotate logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RotateLogsCommand.swift:74:37: error: cannot infer contextual base in reference to member 'file'\n 72 |             \n 73 |             // Check if the destination type supports rotation\n 74 |             if destination.type != .file {\n    |                                     `- error: cannot infer contextual base in reference to member 'file'\n 75 |                 throw LoggingError.invalidDestinationConfig(\n 76 |                     \"Log rotation is only supported for file destinations\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RotateLogsCommand.swift:92:112: error: type 'LogPrivacyLevel' has no member 'protected'\n 90 |                     context: operationContext,\n 91 |                     additionalMetadata: [\n 92 |                         \"rotatedFilePath\": (value: rotationResult.rotatedFilePath ?? \"unknown\", privacyLevel: .protected),\n    |                                                                                                                `- error: type 'LogPrivacyLevel' has no member 'protected'\n 93 |                         \"rotatedSizeBytes\": (value: String(rotationResult.rotatedSizeBytes ?? 0), privacyLevel: .public),\n 94 |                         \"rotatedEntryCount\": (value: String(rotationResult.rotatedEntryCount ?? 0), privacyLevel: .public)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/WriteLogCommand.swift:159:20: error: cannot find 'getAllDestinations' in scope\n157 |         if destinationIds.isEmpty {\n158 |             // Use all registered destinations\n159 |             return getAllDestinations().filter { $0.isEnabled }\n    |                    `- error: cannot find 'getAllDestinations' in scope\n160 |         } else {\n161 |             // Use specific destinations\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/WriteLogCommand.swift:165:38: error: cannot find 'getDestination' in scope\n163 |             \n164 |             for destinationId in destinationIds {\n165 |                 if let destination = getDestination(id: destinationId) {\n    |                                      `- error: cannot find 'getDestination' in scope\n166 |                     if destination.isEnabled {\n167 |                         result.append(destination)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/WriteLogCommand.swift:193:16: error: cannot find 'applyFilterRules' in scope\n191 |         \n192 |         // Apply filter rules if they exist\n193 |         return applyFilterRules(\n    |                `- error: cannot find 'applyFilterRules' in scope\n194 |             to: entry,\n195 |             rules: destination.configuration.filterRules\n\npackages/UmbraImplementations/Sources/LoggingServices/DefaultLoggingServiceImpl.swift:39:36: warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 37 |     let contextDTO=BaseLogContextDTO(\n 38 |       domainName: \"Legacy\",\n 39 |       operation: context.operation ?? \"unknown\",\n    |                                    `- warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 40 |       category: context.category ?? \"General\",\n 41 |       source: context.source ?? \"Unknown\",\n\npackages/UmbraImplementations/Sources/LoggingServices/DefaultLoggingServiceImpl.swift:40:34: warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 38 |       domainName: \"Legacy\",\n 39 |       operation: context.operation ?? \"unknown\",\n 40 |       category: context.category ?? \"General\",\n    |                                  `- warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 41 |       source: context.source ?? \"Unknown\",\n 42 |       metadata: context.metadata\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:147:17: error: invalid redeclaration of 'log(_:_:context:)'\n145 |         - context: The logging context\n146 |      */\n147 |     public func log(_ level: LogLevel, _ message: String, context: any LogContextDTO) async {\n    |                 `- error: invalid redeclaration of 'log(_:_:context:)'\n148 |         // Convert to privacy string and use privacy-aware logging\n149 |         let privacyString = PrivacyString(stringLiteral: message)\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:92:48: error: value of type 'any LoggingProviderProtocol' has no member 'writeLogEntry'\n 90 |                     do {\n 91 |                         // Write log entry to destination\n 92 |                         _ = try await provider.writeLogEntry(entry, to: destination)\n    |                                                `- error: value of type 'any LoggingProviderProtocol' has no member 'writeLogEntry'\n 93 |                     } catch {\n 94 |                         // Silently ignore provider errors for now\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:122:28: error: value of type 'PrivacyString' has no member 'privacy'\n120 |         enrichedMetadata = enrichedMetadata.withPrivate(\n121 |             key: \"__privacy_annotation\", \n122 |             value: message.privacy.description\n    |                            `- error: value of type 'PrivacyString' has no member 'privacy'\n123 |         )\n124 |         \n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:136:34: error: value of type 'PrivacyString' has no member 'content'\n134 |         \n135 |         // Log the message using the standard log method\n136 |         await log(level, message.content, context: privacyContext)\n    |                                  `- error: value of type 'PrivacyString' has no member 'content'\n137 |     }\n138 |     \n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:167:71: error: value of type 'PrivacyAnnotatedString' has no member 'stringValue'\n165 |     ) async {\n166 |         let annotatedString = privacyScope()\n167 |         await log(level, PrivacyString(stringLiteral: annotatedString.stringValue), context: context) \n    |                                                                       `- error: value of type 'PrivacyAnnotatedString' has no member 'stringValue'\n168 |     }\n169 |     \n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:190:29: error: for-in loop requires 'LogMetadata' to conform to 'Sequence'\n188 |         // Create a metadata collection with sensitive values\n189 |         var metadataCollection = context.metadata\n190 |         for (key, value) in sensitiveValues {\n    |                             `- error: for-in loop requires 'LogMetadata' to conform to 'Sequence'\n191 |             metadataCollection = metadataCollection.withSensitive(key: key, value: String(describing: value))\n192 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:228:9: error: switch must be exhaustive\n226 |         \n227 |         // Add error information to metadata with appropriate privacy level\n228 |         switch privacyLevel {\n    |         |- error: switch must be exhaustive\n    |         `- note: add missing case: '.auto'\n229 |         case .public:\n230 |             metadataCollection = metadataCollection.withPublic(key: \"error_description\", value: error.localizedDescription)\npackages/UmbraImplementations/Sources/LoggingServices/PrivacyAwareLogDTO.swift:217:24: error: value of type 'LogMetadataDTOCollection' has no member 'set'\n215 |     for key in self.metadata.getKeys() {\n216 |       if let value = self.metadata.getString(key: key) {\n217 |         mergedMetadata.set(key: key, value: value)\n    |                        `- error: value of type 'LogMetadataDTOCollection' has no member 'set'\n218 |       }\n219 |     }\n\npackages/UmbraImplementations/Sources/LoggingServices/PrivacyAwareLogDTO.swift:224:24: error: value of type 'LogMetadataDTOCollection' has no member 'set'\n222 |     for key in additionalMetadata.getKeys() {\n223 |       if let value = additionalMetadata.getString(key: key) {\n224 |         mergedMetadata.set(key: key, value: value)\n    |                        `- error: value of type 'LogMetadataDTOCollection' has no member 'set'\n225 |       }\n226 |     }\n\npackages/UmbraImplementations/Sources/LoggingServices/PrivacyAwareLogDTO.swift:235:17: error: cannot convert value of type 'LogMetadataDTOCollection' to expected argument type '[String : (value: Any, privacy: LogPrivacyLevel)]'\n233 |       category: category,\n234 |       correlationID: correlationID,\n235 |       metadata: mergedMetadata,\n    |                 `- error: cannot convert value of type 'LogMetadataDTOCollection' to expected argument type '[String : (value: Any, privacy: LogPrivacyLevel)]'\n236 |       environment: environment\n237 |     )\nTarget //packages/UmbraImplementations/Sources/RepositoryServices:RepositoryServices failed to build\nINFO: Elapsed time: 1.137s, Critical Path: 1.01s\nINFO: 2 processes: 1 action cache hit, 2 internal.\nERROR: Build did NOT complete successfully\n"
  },
  {
    "target": "rule //packages/UmbraImplementations/Sources/ResticServices:ResticServices",
    "success": false,
    "start_time": "2025-04-11T17:58:26.31817+01:00",
    "end_time": "2025-04-11T17:58:28.117746+01:00",
    "duration": "1.799578083s",
    "output": "INFO: Invocation ID: f9731259-b9cf-4835-9e2c-7af949a8add2\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraImplementations/Sources/ResticServices:ResticServices (0 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraImplementations/Sources/ResticServices:ResticServices (0 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraImplementations/Sources/ResticServices:ResticServices (0 packages loaded, 0 targets configured).\nERROR: /Users/mpy/CascadeProjects/UmbraCore/packages/UmbraImplementations/Sources/LoggingServices/BUILD.bazel:3:20: Compiling Swift module //packages/UmbraImplementations/Sources/LoggingServices:LoggingServices failed: (Exit 1): worker failed: error executing SwiftCompile command (from target //packages/UmbraImplementations/Sources/LoggingServices:LoggingServices) \n  (cd /Users/mpy/.bazel/execroot/_main \u0026\u0026 \\\n  exec env - \\\n    APPLE_SDK_PLATFORM=MacOSX \\\n    APPLE_SDK_VERSION_OVERRIDE=15.4 \\\n    CC=clang \\\n    PATH=/Users/mpy/Library/Caches/bazelisk/downloads/sha256/ac72ad67f7a8c6b18bf605d8602425182b417de4369715bf89146daf62f7ae48/bin:/Users/mpy/.rbenv/bin:/Users/mpy/.codeium/windsurf/bin:/opt/homebrew/opt/node@18/bin:/opt/homebrew/opt/node@20/bin:/Users/mpy/.docker/bin:/opt/homebrew/opt/openjdk/bin:/Users/mpy/bin:/opt/homebrew/bin:/opt/homebrew/sbin:/usr/local/bin:/System/Cryptexes/App/usr/bin:/usr/bin:/bin:/usr/sbin:/sbin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/local/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/appleinternal/bin:/Library/Apple/usr/bin:/usr/local/go/bin:/Users/mpy/.rbenv/bin:/Users/mpy/.codeium/windsurf/bin:/opt/homebrew/opt/node@18/bin:/opt/homebrew/opt/node@20/bin:/opt/anaconda3/bin:/opt/anaconda3/condabin:/Users/mpy/.docker/bin:/opt/homebrew/opt/openjdk/bin:/Users/mpy/bin:/Users/mpy/.cargo/bin:/Users/mpy/Library/Python/3.8/bin:/Users/mpy/go/bin:/Users/mpy/.scripts:/Users/mpy/.fzf/bin:/Users/mpy/.windsurf/extensions/ms-python.debugpy-2025.6.0-darwin-arm64/bundled/scripts/noConfigScripts:/Users/mpy/Library/Python/3.8/bin:/Users/mpy/go/bin:/Users/mpy/.scripts \\\n    XCODE_VERSION_OVERRIDE=16.3.0.16E140 \\\n  bazel-out/darwin_arm64-opt-exec-ST-d57f47055a04/bin/external/rules_swift+/tools/worker/worker swiftc @bazel-out/darwin_arm64-fastbuild/bin/packages/UmbraImplementations/Sources/LoggingServices/LoggingServices.swiftmodule-0.params)\n# Configuration: 76a1bf3a80f2d50513004915454165d2f164db794b63e4666809cbd93e1abeaa\n# Execution platform: @@platforms//host:host\nerror: emit-module command failed with exit code 1 (use -v to see invocation)\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:147:17: error: invalid redeclaration of 'log(_:_:context:)'\n145 |         - context: The logging context\n146 |      */\n147 |     public func log(_ level: LogLevel, _ message: String, context: any LogContextDTO) async {\n    |                 `- error: invalid redeclaration of 'log(_:_:context:)'\n148 |         // Convert to privacy string and use privacy-aware logging\n149 |         let privacyString = PrivacyString(stringLiteral: message)\npackages/UmbraImplementations/Sources/LoggingServices/Commands/AddDestinationCommand.swift:68:31: error: cannot find 'getDestination' in scope\n 66 |         do {\n 67 |             // Check if destination already exists\n 68 |             if let existing = getDestination(id: destination.id) {\n    |                               `- error: cannot find 'getDestination' in scope\n 69 |                 if !options.overwriteExisting {\n 70 |                     throw LoggingError.destinationAlreadyExists(identifier: \"Destination with ID \\(destination.id) already exists\")\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/AddDestinationCommand.swift:82:40: error: cannot find 'validateDestination' in scope\n 80 |             // Validate destination configuration if requested\n 81 |             if options.validateConfiguration {\n 82 |                 let validationResult = validateDestination(destination, for: provider)\n    |                                        `- error: cannot find 'validateDestination' in scope\n 83 |                 \n 84 |                 if !validationResult.isValid {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/AddDestinationCommand.swift:121:13: error: expression is 'async' but is not marked with 'await'\n119 |             \n120 |             // Register the destination\n121 |             registerDestination(destination)\n    |             |- error: expression is 'async' but is not marked with 'await'\n    |             `- note: calls to instance method 'registerDestination' from outside of its actor context are implicitly asynchronous\n122 |             \n123 |             // Log success\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ArchiveLogsCommand.swift:57:84: error: type 'LogPrivacyLevel' has no member 'protected'\n 55 |             destinationId: destinationId,\n 56 |             additionalMetadata: [\n 57 |                 \"destinationPath\": (value: options.destinationPath, privacyLevel: .protected),\n    |                                                                                    `- error: type 'LogPrivacyLevel' has no member 'protected'\n 58 |                 \"compress\": (value: String(options.compress), privacyLevel: .public),\n 59 |                 \"format\": (value: options.format.rawValue, privacyLevel: .public),\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ArchiveLogsCommand.swift:70:37: error: cannot find 'getDestination' in scope\n 68 |         do {\n 69 |             // Check if destination exists\n 70 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 71 |                 throw LoggingError.destinationNotFound(\n 72 |                     \"Cannot archive logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ArchiveLogsCommand.swift:113:103: error: type 'LogPrivacyLevel' has no member 'protected'\n111 |                     context: operationContext,\n112 |                     additionalMetadata: [\n113 |                         \"archivePath\": (value: archiveResult.archivePath ?? \"unknown\", privacyLevel: .protected),\n    |                                                                                                       `- error: type 'LogPrivacyLevel' has no member 'protected'\n114 |                         \"archiveSizeBytes\": (value: String(archiveResult.archiveSizeBytes ?? 0), privacyLevel: .public),\n115 |                         \"archivedEntryCount\": (value: String(archiveResult.archivedEntryCount ?? 0), privacyLevel: .public)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ExportLogsCommand.swift:70:37: error: cannot find 'getDestination' in scope\n 68 |         do {\n 69 |             // Check if destination exists\n 70 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 71 |                 throw LoggingError.destinationNotFound(\n 72 |                     \"Cannot export logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:79:50: error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n 77 |                 key: key,\n 78 |                 value: value.value,\n 79 |                 privacyLevel: value.privacyLevel.toPrivacyClassification()\n    |                                                  `- error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n 80 |             )\n 81 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:122:54: error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n120 |                     key: key,\n121 |                     value: value.value,\n122 |                     privacyLevel: value.privacyLevel.toPrivacyClassification()\n    |                                                      `- error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n123 |                 )\n124 |             )\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:229:21: error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n227 |         \n228 |         // Process special fields first\n229 |         switch rule.field {\n    |                     `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n230 |         case \"level\":\n231 |             fieldValue = entry.level.rawValue\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:238:96: error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n236 |         default:\n237 |             // Check metadata fields\n238 |             if let metadata = entry.metadata, let metadataValue = metadata.getString(key: rule.field) {\n    |                                                                                                `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n239 |                 fieldValue = metadataValue\n240 |             } else {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:246:21: error: value of type 'UmbraLogFilterRuleDTO' has no member 'operation'\n244 |         \n245 |         // Apply the operation\n246 |         switch rule.operation {\n    |                     `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'operation'\n247 |         case .equals:\n248 |             return fieldValue == rule.value\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:248:39: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n246 |         switch rule.operation {\n247 |         case .equals:\n248 |             return fieldValue == rule.value\n    |                                       `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n249 |         case .contains:\n250 |             return fieldValue.contains(rule.value)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:250:45: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n248 |             return fieldValue == rule.value\n249 |         case .contains:\n250 |             return fieldValue.contains(rule.value)\n    |                                             `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n251 |         case .startsWith:\n252 |             return fieldValue.hasPrefix(rule.value)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:252:46: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n250 |             return fieldValue.contains(rule.value)\n251 |         case .startsWith:\n252 |             return fieldValue.hasPrefix(rule.value)\n    |                                              `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n253 |         case .endsWith:\n254 |             return fieldValue.hasSuffix(rule.value)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:254:46: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n252 |             return fieldValue.hasPrefix(rule.value)\n253 |         case .endsWith:\n254 |             return fieldValue.hasSuffix(rule.value)\n    |                                              `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n255 |         case .matches:\n256 |             if let regex = try? NSRegularExpression(pattern: rule.value) {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:256:67: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n254 |             return fieldValue.hasSuffix(rule.value)\n255 |         case .matches:\n256 |             if let regex = try? NSRegularExpression(pattern: rule.value) {\n    |                                                                   `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n257 |                 let range = NSRange(location: 0, length: fieldValue.utf16.count)\n258 |                 return regex.firstMatch(in: fieldValue, options: [], range: range) != nil\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:262:86: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n260 |             return false\n261 |         case .greaterThan:\n262 |             if let fieldNumeric = Double(fieldValue), let valueNumeric = Double(rule.value) {\n    |                                                                                      `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n263 |                 return fieldNumeric \u003e valueNumeric\n264 |             }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:267:86: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n265 |             return false\n266 |         case .lessThan:\n267 |             if let fieldNumeric = Double(fieldValue), let valueNumeric = Double(rule.value) {\n    |                                                                                      `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n268 |                 return fieldNumeric \u003c valueNumeric\n269 |             }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:293:13: warning: variable 'redactedMetadata' was never mutated; consider changing to 'let' constant\n291 |         // Create mutable copies\n292 |         var redactedMessage = entry.message\n293 |         var redactedMetadata = entry.metadata\n    |             `- warning: variable 'redactedMetadata' was never mutated; consider changing to 'let' constant\n294 |         \n295 |         for rule in rules {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:395:47: error: value of type 'String' has no member 'stringByReplacingMatches'\n393 |             if rule.targetFields.isEmpty || rule.targetFields.contains(\"message\") {\n394 |                 if let pattern = rule.pattern {\n395 |                     redactedMessage = pattern.stringByReplacingMatches(\n    |                                               `- error: value of type 'String' has no member 'stringByReplacingMatches'\n396 |                         in: redactedMessage,\n397 |                         options: [],\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:394:20: error: initializer for conditional binding must have Optional type, not 'String'\n392 |             // Apply rule to message if it matches\n393 |             if rule.targetFields.isEmpty || rule.targetFields.contains(\"message\") {\n394 |                 if let pattern = rule.pattern {\n    |                    `- error: initializer for conditional binding must have Optional type, not 'String'\n395 |                     redactedMessage = pattern.stringByReplacingMatches(\n396 |                         in: redactedMessage,\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:405:24: error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getKeys' of wrapped base type 'LogMetadataDTOCollection'\n403 |             \n404 |             // Process metadata fields\n405 |             for key in redactedMetadata.getKeys() {\n    |                        |- error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getKeys' of wrapped base type 'LogMetadataDTOCollection'\n    |                        |- note: chain the optional using '?' to access member 'getKeys' only for non-'nil' base values\n    |                        `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n406 |                 if rule.targetFields.isEmpty || rule.targetFields.contains(key) {\n407 |                     if let stringValue = redactedMetadata.getString(key: key) {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:407:42: error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getString' of wrapped base type 'LogMetadataDTOCollection'\n405 |             for key in redactedMetadata.getKeys() {\n406 |                 if rule.targetFields.isEmpty || rule.targetFields.contains(key) {\n407 |                     if let stringValue = redactedMetadata.getString(key: key) {\n    |                                          |- error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getString' of wrapped base type 'LogMetadataDTOCollection'\n    |                                          |- note: chain the optional using '?' to access member 'getString' only for non-'nil' base values\n    |                                          `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n408 |                         // Skip fields that should be preserved\n409 |                         if rule.preserveFields.contains(key) {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:468:15: error: type 'LogPrivacyLevel' has no member 'never'\n466 |         case .auto:\n467 |             return .auto\n468 |         case .never:\n    |               `- error: type 'LogPrivacyLevel' has no member 'never'\n469 |             return .public // Map 'never' to public classification\n470 |         case .protected:\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:470:15: error: type 'LogPrivacyLevel' has no member 'protected'\n468 |         case .never:\n469 |             return .public // Map 'never' to public classification\n470 |         case .protected:\n    |               `- error: type 'LogPrivacyLevel' has no member 'protected'\n471 |             return .private // Map 'protected' to private classification\n472 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:58:84: error: type 'LogPrivacyLevel' has no member 'protected'\n 56 |             additionalMetadata: [\n 57 |                 \"createBackup\": (value: String(options.createBackup), privacyLevel: .public),\n 58 |                 \"backupPath\": (value: options.backupPath ?? \"none\", privacyLevel: .protected),\n    |                                                                                    `- error: type 'LogPrivacyLevel' has no member 'protected'\n 59 |                 \"dryRun\": (value: String(options.dryRun), privacyLevel: .public),\n 60 |                 \"hasFilterCriteria\": (value: String(options.filterCriteria != nil), privacyLevel: .public),\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:184:34: error: cannot find 'getDestination' in scope\n182 |         if let destinationId = destinationId {\n183 |             // Use specific destination\n184 |             if let destination = getDestination(id: destinationId) {\n    |                                  `- error: cannot find 'getDestination' in scope\n185 |                 return [destination]\n186 |             } else {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:196:38: error: cannot find 'getDestination' in scope\n194 |             \n195 |             for id in options.destinationIds {\n196 |                 if let destination = getDestination(id: id) {\n    |                                      `- error: cannot find 'getDestination' in scope\n197 |                     result.append(destination)\n198 |                 } else {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:208:20: error: cannot find 'getAllDestinations' in scope\n206 |         } else {\n207 |             // Use all registered destinations\n208 |             return getAllDestinations()\n    |                    `- error: cannot find 'getAllDestinations' in scope\n209 |         }\n210 |     }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/QueryLogsCommand.swift:71:37: error: cannot find 'getDestination' in scope\n 69 |         do {\n 70 |             // Check if destination exists\n 71 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 72 |                 throw LoggingError.destinationNotFound(\n 73 |                     \"Cannot query logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RedactionRule.swift:123:72: error: missing argument for parameter 'privacyLevel' in call\n121 |                 if value != redactedValue {\n122 |                     // Only update if actually changed\n123 |                     result = result.with(key: key, value: redactedValue)\n    |                                                                        `- error: missing argument for parameter 'privacyLevel' in call\n124 |                 }\n125 |             }\n\n/Users/mpy/.bazel/execroot/_main/packages/UmbraCoreTypes/Sources/LoggingTypes/LogMetadataDTOCollection.swift:78:15: note: 'with(key:value:privacyLevel:)' declared here\n 76 |   ///   - privacyLevel: The privacy classification for this entry\n 77 |   /// - Returns: The updated collection\n 78 |   public func with(\n    |               `- note: 'with(key:value:privacyLevel:)' declared here\n 79 |     key: String,\n 80 |     value: String,\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RedactionRule.swift:101:26: warning: no calls to throwing functions occur within 'try' expression\n 99 |     public func redact(metadata: LogMetadataDTOCollection) -\u003e LogMetadataDTOCollection {\n100 |         // No redaction needed for empty metadata\n101 |         guard let keys = try? metadata.getKeys() else {\n    |                          `- warning: no calls to throwing functions occur within 'try' expression\n102 |             return metadata\n103 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RedactionRule.swift:119:28: warning: no calls to throwing functions occur within 'try' expression\n117 |             \n118 |             // Get string value and apply redaction\n119 |             if let value = try? metadata.getString(key: key) {\n    |                            `- warning: no calls to throwing functions occur within 'try' expression\n120 |                 let redactedValue = redact(value)\n121 |                 if value != redactedValue {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RemoveDestinationCommand.swift:67:37: error: cannot find 'getDestination' in scope\n 65 |         do {\n 66 |             // Check if destination exists\n 67 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 68 |                 throw LoggingError.destinationNotFound(\n 69 |                     \"Cannot remove destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RemoveDestinationCommand.swift:128:13: error: expression is 'async' but is not marked with 'await'\n126 |             \n127 |             // Unregister the destination\n128 |             unregisterDestination(id: destinationId)\n    |             |- error: expression is 'async' but is not marked with 'await'\n    |             `- note: calls to instance method 'unregisterDestination(id:)' from outside of its actor context are implicitly asynchronous\n129 |             \n130 |             // Log success\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RotateLogsCommand.swift:67:37: error: cannot find 'getDestination' in scope\n 65 |         do {\n 66 |             // Check if destination exists\n 67 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 68 |                 throw LoggingError.destinationNotFound(\n 69 |                     \"Cannot rotate logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RotateLogsCommand.swift:74:37: error: cannot infer contextual base in reference to member 'file'\n 72 |             \n 73 |             // Check if the destination type supports rotation\n 74 |             if destination.type != .file {\n    |                                     `- error: cannot infer contextual base in reference to member 'file'\n 75 |                 throw LoggingError.invalidDestinationConfig(\n 76 |                     \"Log rotation is only supported for file destinations\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RotateLogsCommand.swift:92:112: error: type 'LogPrivacyLevel' has no member 'protected'\n 90 |                     context: operationContext,\n 91 |                     additionalMetadata: [\n 92 |                         \"rotatedFilePath\": (value: rotationResult.rotatedFilePath ?? \"unknown\", privacyLevel: .protected),\n    |                                                                                                                `- error: type 'LogPrivacyLevel' has no member 'protected'\n 93 |                         \"rotatedSizeBytes\": (value: String(rotationResult.rotatedSizeBytes ?? 0), privacyLevel: .public),\n 94 |                         \"rotatedEntryCount\": (value: String(rotationResult.rotatedEntryCount ?? 0), privacyLevel: .public)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/WriteLogCommand.swift:159:20: error: cannot find 'getAllDestinations' in scope\n157 |         if destinationIds.isEmpty {\n158 |             // Use all registered destinations\n159 |             return getAllDestinations().filter { $0.isEnabled }\n    |                    `- error: cannot find 'getAllDestinations' in scope\n160 |         } else {\n161 |             // Use specific destinations\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/WriteLogCommand.swift:165:38: error: cannot find 'getDestination' in scope\n163 |             \n164 |             for destinationId in destinationIds {\n165 |                 if let destination = getDestination(id: destinationId) {\n    |                                      `- error: cannot find 'getDestination' in scope\n166 |                     if destination.isEnabled {\n167 |                         result.append(destination)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/WriteLogCommand.swift:193:16: error: cannot find 'applyFilterRules' in scope\n191 |         \n192 |         // Apply filter rules if they exist\n193 |         return applyFilterRules(\n    |                `- error: cannot find 'applyFilterRules' in scope\n194 |             to: entry,\n195 |             rules: destination.configuration.filterRules\n\npackages/UmbraImplementations/Sources/LoggingServices/DefaultLoggingServiceImpl.swift:39:36: warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 37 |     let contextDTO=BaseLogContextDTO(\n 38 |       domainName: \"Legacy\",\n 39 |       operation: context.operation ?? \"unknown\",\n    |                                    `- warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 40 |       category: context.category ?? \"General\",\n 41 |       source: context.source ?? \"Unknown\",\n\npackages/UmbraImplementations/Sources/LoggingServices/DefaultLoggingServiceImpl.swift:40:34: warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 38 |       domainName: \"Legacy\",\n 39 |       operation: context.operation ?? \"unknown\",\n 40 |       category: context.category ?? \"General\",\n    |                                  `- warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 41 |       source: context.source ?? \"Unknown\",\n 42 |       metadata: context.metadata\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:147:17: error: invalid redeclaration of 'log(_:_:context:)'\n145 |         - context: The logging context\n146 |      */\n147 |     public func log(_ level: LogLevel, _ message: String, context: any LogContextDTO) async {\n    |                 `- error: invalid redeclaration of 'log(_:_:context:)'\n148 |         // Convert to privacy string and use privacy-aware logging\n149 |         let privacyString = PrivacyString(stringLiteral: message)\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:92:48: error: value of type 'any LoggingProviderProtocol' has no member 'writeLogEntry'\n 90 |                     do {\n 91 |                         // Write log entry to destination\n 92 |                         _ = try await provider.writeLogEntry(entry, to: destination)\n    |                                                `- error: value of type 'any LoggingProviderProtocol' has no member 'writeLogEntry'\n 93 |                     } catch {\n 94 |                         // Silently ignore provider errors for now\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:122:28: error: value of type 'PrivacyString' has no member 'privacy'\n120 |         enrichedMetadata = enrichedMetadata.withPrivate(\n121 |             key: \"__privacy_annotation\", \n122 |             value: message.privacy.description\n    |                            `- error: value of type 'PrivacyString' has no member 'privacy'\n123 |         )\n124 |         \n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:136:34: error: value of type 'PrivacyString' has no member 'content'\n134 |         \n135 |         // Log the message using the standard log method\n136 |         await log(level, message.content, context: privacyContext)\n    |                                  `- error: value of type 'PrivacyString' has no member 'content'\n137 |     }\n138 |     \n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:167:71: error: value of type 'PrivacyAnnotatedString' has no member 'stringValue'\n165 |     ) async {\n166 |         let annotatedString = privacyScope()\n167 |         await log(level, PrivacyString(stringLiteral: annotatedString.stringValue), context: context) \n    |                                                                       `- error: value of type 'PrivacyAnnotatedString' has no member 'stringValue'\n168 |     }\n169 |     \n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:190:29: error: for-in loop requires 'LogMetadata' to conform to 'Sequence'\n188 |         // Create a metadata collection with sensitive values\n189 |         var metadataCollection = context.metadata\n190 |         for (key, value) in sensitiveValues {\n    |                             `- error: for-in loop requires 'LogMetadata' to conform to 'Sequence'\n191 |             metadataCollection = metadataCollection.withSensitive(key: key, value: String(describing: value))\n192 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:228:9: error: switch must be exhaustive\n226 |         \n227 |         // Add error information to metadata with appropriate privacy level\n228 |         switch privacyLevel {\n    |         |- error: switch must be exhaustive\n    |         `- note: add missing case: '.auto'\n229 |         case .public:\n230 |             metadataCollection = metadataCollection.withPublic(key: \"error_description\", value: error.localizedDescription)\npackages/UmbraImplementations/Sources/LoggingServices/PrivacyAwareLogDTO.swift:217:24: error: value of type 'LogMetadataDTOCollection' has no member 'set'\n215 |     for key in self.metadata.getKeys() {\n216 |       if let value = self.metadata.getString(key: key) {\n217 |         mergedMetadata.set(key: key, value: value)\n    |                        `- error: value of type 'LogMetadataDTOCollection' has no member 'set'\n218 |       }\n219 |     }\n\npackages/UmbraImplementations/Sources/LoggingServices/PrivacyAwareLogDTO.swift:224:24: error: value of type 'LogMetadataDTOCollection' has no member 'set'\n222 |     for key in additionalMetadata.getKeys() {\n223 |       if let value = additionalMetadata.getString(key: key) {\n224 |         mergedMetadata.set(key: key, value: value)\n    |                        `- error: value of type 'LogMetadataDTOCollection' has no member 'set'\n225 |       }\n226 |     }\n\npackages/UmbraImplementations/Sources/LoggingServices/PrivacyAwareLogDTO.swift:235:17: error: cannot convert value of type 'LogMetadataDTOCollection' to expected argument type '[String : (value: Any, privacy: LogPrivacyLevel)]'\n233 |       category: category,\n234 |       correlationID: correlationID,\n235 |       metadata: mergedMetadata,\n    |                 `- error: cannot convert value of type 'LogMetadataDTOCollection' to expected argument type '[String : (value: Any, privacy: LogPrivacyLevel)]'\n236 |       environment: environment\n237 |     )\nTarget //packages/UmbraImplementations/Sources/ResticServices:ResticServices failed to build\nINFO: Elapsed time: 1.129s, Critical Path: 1.00s\nINFO: 2 processes: 2 internal.\nERROR: Build did NOT complete successfully\n"
  },
  {
    "target": "rule //packages/UmbraImplementations/Sources/SecureFileOperations:SecureFileOperations",
    "success": false,
    "start_time": "2025-04-11T17:58:28.117771+01:00",
    "end_time": "2025-04-11T17:58:29.603708+01:00",
    "duration": "1.485938667s",
    "output": "INFO: Invocation ID: c9b2d55f-d1eb-4b85-b8b5-9fcbaab72a32\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraImplementations/Sources/SecureFileOperations:SecureFileOperations (0 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraImplementations/Sources/SecureFileOperations:SecureFileOperations (0 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraImplementations/Sources/SecureFileOperations:SecureFileOperations (0 packages loaded, 0 targets configured).\nERROR: /Users/mpy/CascadeProjects/UmbraCore/packages/UmbraImplementations/Sources/SecureFileOperations/BUILD.bazel:3:14: Compiling Swift module //packages/UmbraImplementations/Sources/SecureFileOperations:SecureFileOperations failed: (Exit 1): worker failed: error executing SwiftCompile command (from target //packages/UmbraImplementations/Sources/SecureFileOperations:SecureFileOperations) \n  (cd /Users/mpy/.bazel/execroot/_main \u0026\u0026 \\\n  exec env - \\\n    APPLE_SDK_PLATFORM=MacOSX \\\n    APPLE_SDK_VERSION_OVERRIDE=15.4 \\\n    CC=clang \\\n    PATH=/Users/mpy/Library/Caches/bazelisk/downloads/sha256/ac72ad67f7a8c6b18bf605d8602425182b417de4369715bf89146daf62f7ae48/bin:/Users/mpy/.rbenv/bin:/Users/mpy/.codeium/windsurf/bin:/opt/homebrew/opt/node@18/bin:/opt/homebrew/opt/node@20/bin:/Users/mpy/.docker/bin:/opt/homebrew/opt/openjdk/bin:/Users/mpy/bin:/opt/homebrew/bin:/opt/homebrew/sbin:/usr/local/bin:/System/Cryptexes/App/usr/bin:/usr/bin:/bin:/usr/sbin:/sbin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/local/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/appleinternal/bin:/Library/Apple/usr/bin:/usr/local/go/bin:/Users/mpy/.rbenv/bin:/Users/mpy/.codeium/windsurf/bin:/opt/homebrew/opt/node@18/bin:/opt/homebrew/opt/node@20/bin:/opt/anaconda3/bin:/opt/anaconda3/condabin:/Users/mpy/.docker/bin:/opt/homebrew/opt/openjdk/bin:/Users/mpy/bin:/Users/mpy/.cargo/bin:/Users/mpy/Library/Python/3.8/bin:/Users/mpy/go/bin:/Users/mpy/.scripts:/Users/mpy/.fzf/bin:/Users/mpy/.windsurf/extensions/ms-python.debugpy-2025.6.0-darwin-arm64/bundled/scripts/noConfigScripts:/Users/mpy/Library/Python/3.8/bin:/Users/mpy/go/bin:/Users/mpy/.scripts \\\n    XCODE_VERSION_OVERRIDE=16.3.0.16E140 \\\n  bazel-out/darwin_arm64-opt-exec-ST-d57f47055a04/bin/external/rules_swift+/tools/worker/worker swiftc @bazel-out/darwin_arm64-fastbuild/bin/packages/UmbraImplementations/Sources/SecureFileOperations/SecureFileOperations.swiftmodule-0.params)\n# Configuration: 76a1bf3a80f2d50513004915454165d2f164db794b63e4666809cbd93e1abeaa\n# Execution platform: @@platforms//host:host\npackages/UmbraImplementations/Sources/SecureFileOperations/Implementation/SecureFileOperationsImpl.swift:58:29: error: missing arguments for parameters 'operation', 'category' in call\n 56 |     }\n 57 | \n 58 |     return BaseLogContextDTO(\n    |                             `- error: missing arguments for parameters 'operation', 'category' in call\n 59 |       domainName: \"SecureFileOperations\",\n 60 |       source: \"SecureFileOperationsImpl\",\n\n/Users/mpy/.bazel/execroot/_main/packages/UmbraCoreTypes/Sources/LoggingTypes/LogContextDTO.swift:60:10: note: 'init(domainName:operation:category:source:metadata:correlationID:)' declared here\n58 |   ///   - metadata: Privacy metadata as a LogMetadataDTOCollection instance\n59 |   ///   - correlationID: Optional correlation ID\n60 |   public init(\n   |          `- note: 'init(domainName:operation:category:source:metadata:correlationID:)' declared here\n61 |     domainName: String,\n62 |     operation: String,\n\npackages/UmbraImplementations/Sources/SecureFileOperations/Implementation/SecureFileOperationsImpl.swift:232:7: warning: 'catch' block is unreachable because no errors are thrown in 'do' block\n230 |       await logger.debug(\"Access to security-scoped resource status\", context: successContext)\n231 |       return (accessGranted, result)\n232 |     } catch {\n    |       `- warning: 'catch' block is unreachable because no errors are thrown in 'do' block\n233 |       let securityError=FileSystemError.securityError(\n234 |         path: path.path,\n\npackages/UmbraImplementations/Sources/SecureFileOperations/Implementation/SecureFileOperationsImpl.swift:432:9: warning: variable 'dataToWrite' was never mutated; consider changing to 'let' constant\n430 | \n431 |     // Implement encryption logic based on specific write options\n432 |     var dataToWrite=data\n    |         `- warning: variable 'dataToWrite' was never mutated; consider changing to 'let' constant\n433 | \n434 |     // Apply encryption based on the algorithm in the options\n\npackages/UmbraImplementations/Sources/SecureFileOperations/Implementation/SecureFileOperationsImpl.swift:716:29: error: missing arguments for parameters 'operation', 'category' in call\n714 |       collection.withPublic(key: pair.key, value: pair.value)\n715 |     }\n716 |     return BaseLogContextDTO(\n    |                             `- error: missing arguments for parameters 'operation', 'category' in call\n717 |       domainName: \"SecureFileOperations\",\n718 |       source: \"SecureFileOperationsImpl\",\n\n/Users/mpy/.bazel/execroot/_main/packages/UmbraCoreTypes/Sources/LoggingTypes/LogContextDTO.swift:60:10: note: 'init(domainName:operation:category:source:metadata:correlationID:)' declared here\n58 |   ///   - metadata: Privacy metadata as a LogMetadataDTOCollection instance\n59 |   ///   - correlationID: Optional correlation ID\n60 |   public init(\n   |          `- note: 'init(domainName:operation:category:source:metadata:correlationID:)' declared here\n61 |     domainName: String,\n62 |     operation: String,\nTarget //packages/UmbraImplementations/Sources/SecureFileOperations:SecureFileOperations failed to build\nINFO: Elapsed time: 0.523s, Critical Path: 0.40s\nINFO: 2 processes: 2 internal.\nERROR: Build did NOT complete successfully\n"
  },
  {
    "target": "rule //packages/UmbraImplementations/Sources/SecurityCore:SecurityCore",
    "success": true,
    "start_time": "2025-04-11T17:58:29.603738+01:00",
    "end_time": "2025-04-11T17:58:30.393298+01:00",
    "duration": "789.56075ms",
    "output": "INFO: Invocation ID: 72d7f0fa-1d81-4fe4-9268-b4f5e8db21a4\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraImplementations/Sources/SecurityCore:SecurityCore (0 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraImplementations/Sources/SecurityCore:SecurityCore (0 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraImplementations/Sources/SecurityCore:SecurityCore (0 packages loaded, 0 targets configured).\nINFO: Found 1 target...\nTarget //packages/UmbraImplementations/Sources/SecurityCore:SecurityCore up-to-date:\n  bazel-bin/packages/UmbraImplementations/Sources/SecurityCore/SecurityCore.swiftdoc\n  bazel-bin/packages/UmbraImplementations/Sources/SecurityCore/SecurityCore.swiftmodule\n  bazel-bin/packages/UmbraImplementations/Sources/SecurityCore/SecurityCore.swiftsourceinfo\n  bazel-bin/packages/UmbraImplementations/Sources/SecurityCore/libSecurityCore.a\nINFO: Elapsed time: 0.120s, Critical Path: 0.00s\nINFO: 1 process: 1 action cache hit, 1 internal.\nINFO: Build completed successfully, 1 total action\n"
  },
  {
    "target": "rule //packages/UmbraImplementations/Sources/SecurityCryptoServices:SecurityCryptoServices",
    "success": false,
    "start_time": "2025-04-11T17:58:30.393318+01:00",
    "end_time": "2025-04-11T17:58:32.242697+01:00",
    "duration": "1.849381208s",
    "output": "INFO: Invocation ID: dcc97f21-9961-4af2-8af4-f3df7bcb3eb5\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraImplementations/Sources/SecurityCryptoServices:SecurityCryptoServices (1 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraImplementations/Sources/SecurityCryptoServices:SecurityCryptoServices (1 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraImplementations/Sources/SecurityCryptoServices:SecurityCryptoServices (3 packages loaded, 14 targets configured).\nERROR: /Users/mpy/CascadeProjects/UmbraCore/packages/UmbraImplementations/Sources/LoggingServices/BUILD.bazel:3:20: Compiling Swift module //packages/UmbraImplementations/Sources/LoggingServices:LoggingServices failed: (Exit 1): worker failed: error executing SwiftCompile command (from target //packages/UmbraImplementations/Sources/LoggingServices:LoggingServices) \n  (cd /Users/mpy/.bazel/execroot/_main \u0026\u0026 \\\n  exec env - \\\n    APPLE_SDK_PLATFORM=MacOSX \\\n    APPLE_SDK_VERSION_OVERRIDE=15.4 \\\n    CC=clang \\\n    PATH=/Users/mpy/Library/Caches/bazelisk/downloads/sha256/ac72ad67f7a8c6b18bf605d8602425182b417de4369715bf89146daf62f7ae48/bin:/Users/mpy/.rbenv/bin:/Users/mpy/.codeium/windsurf/bin:/opt/homebrew/opt/node@18/bin:/opt/homebrew/opt/node@20/bin:/Users/mpy/.docker/bin:/opt/homebrew/opt/openjdk/bin:/Users/mpy/bin:/opt/homebrew/bin:/opt/homebrew/sbin:/usr/local/bin:/System/Cryptexes/App/usr/bin:/usr/bin:/bin:/usr/sbin:/sbin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/local/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/appleinternal/bin:/Library/Apple/usr/bin:/usr/local/go/bin:/Users/mpy/.rbenv/bin:/Users/mpy/.codeium/windsurf/bin:/opt/homebrew/opt/node@18/bin:/opt/homebrew/opt/node@20/bin:/opt/anaconda3/bin:/opt/anaconda3/condabin:/Users/mpy/.docker/bin:/opt/homebrew/opt/openjdk/bin:/Users/mpy/bin:/Users/mpy/.cargo/bin:/Users/mpy/Library/Python/3.8/bin:/Users/mpy/go/bin:/Users/mpy/.scripts:/Users/mpy/.fzf/bin:/Users/mpy/.windsurf/extensions/ms-python.debugpy-2025.6.0-darwin-arm64/bundled/scripts/noConfigScripts:/Users/mpy/Library/Python/3.8/bin:/Users/mpy/go/bin:/Users/mpy/.scripts \\\n    XCODE_VERSION_OVERRIDE=16.3.0.16E140 \\\n  bazel-out/darwin_arm64-opt-exec-ST-d57f47055a04/bin/external/rules_swift+/tools/worker/worker swiftc @bazel-out/darwin_arm64-fastbuild/bin/packages/UmbraImplementations/Sources/LoggingServices/LoggingServices.swiftmodule-0.params)\n# Configuration: 76a1bf3a80f2d50513004915454165d2f164db794b63e4666809cbd93e1abeaa\n# Execution platform: @@platforms//host:host\nerror: emit-module command failed with exit code 1 (use -v to see invocation)\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:147:17: error: invalid redeclaration of 'log(_:_:context:)'\n145 |         - context: The logging context\n146 |      */\n147 |     public func log(_ level: LogLevel, _ message: String, context: any LogContextDTO) async {\n    |                 `- error: invalid redeclaration of 'log(_:_:context:)'\n148 |         // Convert to privacy string and use privacy-aware logging\n149 |         let privacyString = PrivacyString(stringLiteral: message)\npackages/UmbraImplementations/Sources/LoggingServices/Commands/AddDestinationCommand.swift:68:31: error: cannot find 'getDestination' in scope\n 66 |         do {\n 67 |             // Check if destination already exists\n 68 |             if let existing = getDestination(id: destination.id) {\n    |                               `- error: cannot find 'getDestination' in scope\n 69 |                 if !options.overwriteExisting {\n 70 |                     throw LoggingError.destinationAlreadyExists(identifier: \"Destination with ID \\(destination.id) already exists\")\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/AddDestinationCommand.swift:82:40: error: cannot find 'validateDestination' in scope\n 80 |             // Validate destination configuration if requested\n 81 |             if options.validateConfiguration {\n 82 |                 let validationResult = validateDestination(destination, for: provider)\n    |                                        `- error: cannot find 'validateDestination' in scope\n 83 |                 \n 84 |                 if !validationResult.isValid {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/AddDestinationCommand.swift:121:13: error: expression is 'async' but is not marked with 'await'\n119 |             \n120 |             // Register the destination\n121 |             registerDestination(destination)\n    |             |- error: expression is 'async' but is not marked with 'await'\n    |             `- note: calls to instance method 'registerDestination' from outside of its actor context are implicitly asynchronous\n122 |             \n123 |             // Log success\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ArchiveLogsCommand.swift:57:84: error: type 'LogPrivacyLevel' has no member 'protected'\n 55 |             destinationId: destinationId,\n 56 |             additionalMetadata: [\n 57 |                 \"destinationPath\": (value: options.destinationPath, privacyLevel: .protected),\n    |                                                                                    `- error: type 'LogPrivacyLevel' has no member 'protected'\n 58 |                 \"compress\": (value: String(options.compress), privacyLevel: .public),\n 59 |                 \"format\": (value: options.format.rawValue, privacyLevel: .public),\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ArchiveLogsCommand.swift:70:37: error: cannot find 'getDestination' in scope\n 68 |         do {\n 69 |             // Check if destination exists\n 70 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 71 |                 throw LoggingError.destinationNotFound(\n 72 |                     \"Cannot archive logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ArchiveLogsCommand.swift:113:103: error: type 'LogPrivacyLevel' has no member 'protected'\n111 |                     context: operationContext,\n112 |                     additionalMetadata: [\n113 |                         \"archivePath\": (value: archiveResult.archivePath ?? \"unknown\", privacyLevel: .protected),\n    |                                                                                                       `- error: type 'LogPrivacyLevel' has no member 'protected'\n114 |                         \"archiveSizeBytes\": (value: String(archiveResult.archiveSizeBytes ?? 0), privacyLevel: .public),\n115 |                         \"archivedEntryCount\": (value: String(archiveResult.archivedEntryCount ?? 0), privacyLevel: .public)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ExportLogsCommand.swift:70:37: error: cannot find 'getDestination' in scope\n 68 |         do {\n 69 |             // Check if destination exists\n 70 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 71 |                 throw LoggingError.destinationNotFound(\n 72 |                     \"Cannot export logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:79:50: error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n 77 |                 key: key,\n 78 |                 value: value.value,\n 79 |                 privacyLevel: value.privacyLevel.toPrivacyClassification()\n    |                                                  `- error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n 80 |             )\n 81 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:122:54: error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n120 |                     key: key,\n121 |                     value: value.value,\n122 |                     privacyLevel: value.privacyLevel.toPrivacyClassification()\n    |                                                      `- error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n123 |                 )\n124 |             )\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:229:21: error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n227 |         \n228 |         // Process special fields first\n229 |         switch rule.field {\n    |                     `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n230 |         case \"level\":\n231 |             fieldValue = entry.level.rawValue\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:238:96: error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n236 |         default:\n237 |             // Check metadata fields\n238 |             if let metadata = entry.metadata, let metadataValue = metadata.getString(key: rule.field) {\n    |                                                                                                `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n239 |                 fieldValue = metadataValue\n240 |             } else {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:246:21: error: value of type 'UmbraLogFilterRuleDTO' has no member 'operation'\n244 |         \n245 |         // Apply the operation\n246 |         switch rule.operation {\n    |                     `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'operation'\n247 |         case .equals:\n248 |             return fieldValue == rule.value\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:248:39: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n246 |         switch rule.operation {\n247 |         case .equals:\n248 |             return fieldValue == rule.value\n    |                                       `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n249 |         case .contains:\n250 |             return fieldValue.contains(rule.value)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:250:45: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n248 |             return fieldValue == rule.value\n249 |         case .contains:\n250 |             return fieldValue.contains(rule.value)\n    |                                             `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n251 |         case .startsWith:\n252 |             return fieldValue.hasPrefix(rule.value)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:252:46: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n250 |             return fieldValue.contains(rule.value)\n251 |         case .startsWith:\n252 |             return fieldValue.hasPrefix(rule.value)\n    |                                              `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n253 |         case .endsWith:\n254 |             return fieldValue.hasSuffix(rule.value)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:254:46: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n252 |             return fieldValue.hasPrefix(rule.value)\n253 |         case .endsWith:\n254 |             return fieldValue.hasSuffix(rule.value)\n    |                                              `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n255 |         case .matches:\n256 |             if let regex = try? NSRegularExpression(pattern: rule.value) {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:256:67: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n254 |             return fieldValue.hasSuffix(rule.value)\n255 |         case .matches:\n256 |             if let regex = try? NSRegularExpression(pattern: rule.value) {\n    |                                                                   `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n257 |                 let range = NSRange(location: 0, length: fieldValue.utf16.count)\n258 |                 return regex.firstMatch(in: fieldValue, options: [], range: range) != nil\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:262:86: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n260 |             return false\n261 |         case .greaterThan:\n262 |             if let fieldNumeric = Double(fieldValue), let valueNumeric = Double(rule.value) {\n    |                                                                                      `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n263 |                 return fieldNumeric \u003e valueNumeric\n264 |             }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:267:86: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n265 |             return false\n266 |         case .lessThan:\n267 |             if let fieldNumeric = Double(fieldValue), let valueNumeric = Double(rule.value) {\n    |                                                                                      `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n268 |                 return fieldNumeric \u003c valueNumeric\n269 |             }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:293:13: warning: variable 'redactedMetadata' was never mutated; consider changing to 'let' constant\n291 |         // Create mutable copies\n292 |         var redactedMessage = entry.message\n293 |         var redactedMetadata = entry.metadata\n    |             `- warning: variable 'redactedMetadata' was never mutated; consider changing to 'let' constant\n294 |         \n295 |         for rule in rules {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:395:47: error: value of type 'String' has no member 'stringByReplacingMatches'\n393 |             if rule.targetFields.isEmpty || rule.targetFields.contains(\"message\") {\n394 |                 if let pattern = rule.pattern {\n395 |                     redactedMessage = pattern.stringByReplacingMatches(\n    |                                               `- error: value of type 'String' has no member 'stringByReplacingMatches'\n396 |                         in: redactedMessage,\n397 |                         options: [],\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:394:20: error: initializer for conditional binding must have Optional type, not 'String'\n392 |             // Apply rule to message if it matches\n393 |             if rule.targetFields.isEmpty || rule.targetFields.contains(\"message\") {\n394 |                 if let pattern = rule.pattern {\n    |                    `- error: initializer for conditional binding must have Optional type, not 'String'\n395 |                     redactedMessage = pattern.stringByReplacingMatches(\n396 |                         in: redactedMessage,\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:405:24: error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getKeys' of wrapped base type 'LogMetadataDTOCollection'\n403 |             \n404 |             // Process metadata fields\n405 |             for key in redactedMetadata.getKeys() {\n    |                        |- error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getKeys' of wrapped base type 'LogMetadataDTOCollection'\n    |                        |- note: chain the optional using '?' to access member 'getKeys' only for non-'nil' base values\n    |                        `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n406 |                 if rule.targetFields.isEmpty || rule.targetFields.contains(key) {\n407 |                     if let stringValue = redactedMetadata.getString(key: key) {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:407:42: error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getString' of wrapped base type 'LogMetadataDTOCollection'\n405 |             for key in redactedMetadata.getKeys() {\n406 |                 if rule.targetFields.isEmpty || rule.targetFields.contains(key) {\n407 |                     if let stringValue = redactedMetadata.getString(key: key) {\n    |                                          |- error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getString' of wrapped base type 'LogMetadataDTOCollection'\n    |                                          |- note: chain the optional using '?' to access member 'getString' only for non-'nil' base values\n    |                                          `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n408 |                         // Skip fields that should be preserved\n409 |                         if rule.preserveFields.contains(key) {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:468:15: error: type 'LogPrivacyLevel' has no member 'never'\n466 |         case .auto:\n467 |             return .auto\n468 |         case .never:\n    |               `- error: type 'LogPrivacyLevel' has no member 'never'\n469 |             return .public // Map 'never' to public classification\n470 |         case .protected:\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:470:15: error: type 'LogPrivacyLevel' has no member 'protected'\n468 |         case .never:\n469 |             return .public // Map 'never' to public classification\n470 |         case .protected:\n    |               `- error: type 'LogPrivacyLevel' has no member 'protected'\n471 |             return .private // Map 'protected' to private classification\n472 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:58:84: error: type 'LogPrivacyLevel' has no member 'protected'\n 56 |             additionalMetadata: [\n 57 |                 \"createBackup\": (value: String(options.createBackup), privacyLevel: .public),\n 58 |                 \"backupPath\": (value: options.backupPath ?? \"none\", privacyLevel: .protected),\n    |                                                                                    `- error: type 'LogPrivacyLevel' has no member 'protected'\n 59 |                 \"dryRun\": (value: String(options.dryRun), privacyLevel: .public),\n 60 |                 \"hasFilterCriteria\": (value: String(options.filterCriteria != nil), privacyLevel: .public),\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:184:34: error: cannot find 'getDestination' in scope\n182 |         if let destinationId = destinationId {\n183 |             // Use specific destination\n184 |             if let destination = getDestination(id: destinationId) {\n    |                                  `- error: cannot find 'getDestination' in scope\n185 |                 return [destination]\n186 |             } else {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:196:38: error: cannot find 'getDestination' in scope\n194 |             \n195 |             for id in options.destinationIds {\n196 |                 if let destination = getDestination(id: id) {\n    |                                      `- error: cannot find 'getDestination' in scope\n197 |                     result.append(destination)\n198 |                 } else {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:208:20: error: cannot find 'getAllDestinations' in scope\n206 |         } else {\n207 |             // Use all registered destinations\n208 |             return getAllDestinations()\n    |                    `- error: cannot find 'getAllDestinations' in scope\n209 |         }\n210 |     }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/QueryLogsCommand.swift:71:37: error: cannot find 'getDestination' in scope\n 69 |         do {\n 70 |             // Check if destination exists\n 71 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 72 |                 throw LoggingError.destinationNotFound(\n 73 |                     \"Cannot query logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RedactionRule.swift:123:72: error: missing argument for parameter 'privacyLevel' in call\n121 |                 if value != redactedValue {\n122 |                     // Only update if actually changed\n123 |                     result = result.with(key: key, value: redactedValue)\n    |                                                                        `- error: missing argument for parameter 'privacyLevel' in call\n124 |                 }\n125 |             }\n\n/Users/mpy/.bazel/execroot/_main/packages/UmbraCoreTypes/Sources/LoggingTypes/LogMetadataDTOCollection.swift:78:15: note: 'with(key:value:privacyLevel:)' declared here\n 76 |   ///   - privacyLevel: The privacy classification for this entry\n 77 |   /// - Returns: The updated collection\n 78 |   public func with(\n    |               `- note: 'with(key:value:privacyLevel:)' declared here\n 79 |     key: String,\n 80 |     value: String,\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RedactionRule.swift:101:26: warning: no calls to throwing functions occur within 'try' expression\n 99 |     public func redact(metadata: LogMetadataDTOCollection) -\u003e LogMetadataDTOCollection {\n100 |         // No redaction needed for empty metadata\n101 |         guard let keys = try? metadata.getKeys() else {\n    |                          `- warning: no calls to throwing functions occur within 'try' expression\n102 |             return metadata\n103 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RedactionRule.swift:119:28: warning: no calls to throwing functions occur within 'try' expression\n117 |             \n118 |             // Get string value and apply redaction\n119 |             if let value = try? metadata.getString(key: key) {\n    |                            `- warning: no calls to throwing functions occur within 'try' expression\n120 |                 let redactedValue = redact(value)\n121 |                 if value != redactedValue {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RemoveDestinationCommand.swift:67:37: error: cannot find 'getDestination' in scope\n 65 |         do {\n 66 |             // Check if destination exists\n 67 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 68 |                 throw LoggingError.destinationNotFound(\n 69 |                     \"Cannot remove destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RemoveDestinationCommand.swift:128:13: error: expression is 'async' but is not marked with 'await'\n126 |             \n127 |             // Unregister the destination\n128 |             unregisterDestination(id: destinationId)\n    |             |- error: expression is 'async' but is not marked with 'await'\n    |             `- note: calls to instance method 'unregisterDestination(id:)' from outside of its actor context are implicitly asynchronous\n129 |             \n130 |             // Log success\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RotateLogsCommand.swift:67:37: error: cannot find 'getDestination' in scope\n 65 |         do {\n 66 |             // Check if destination exists\n 67 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 68 |                 throw LoggingError.destinationNotFound(\n 69 |                     \"Cannot rotate logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RotateLogsCommand.swift:74:37: error: cannot infer contextual base in reference to member 'file'\n 72 |             \n 73 |             // Check if the destination type supports rotation\n 74 |             if destination.type != .file {\n    |                                     `- error: cannot infer contextual base in reference to member 'file'\n 75 |                 throw LoggingError.invalidDestinationConfig(\n 76 |                     \"Log rotation is only supported for file destinations\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RotateLogsCommand.swift:92:112: error: type 'LogPrivacyLevel' has no member 'protected'\n 90 |                     context: operationContext,\n 91 |                     additionalMetadata: [\n 92 |                         \"rotatedFilePath\": (value: rotationResult.rotatedFilePath ?? \"unknown\", privacyLevel: .protected),\n    |                                                                                                                `- error: type 'LogPrivacyLevel' has no member 'protected'\n 93 |                         \"rotatedSizeBytes\": (value: String(rotationResult.rotatedSizeBytes ?? 0), privacyLevel: .public),\n 94 |                         \"rotatedEntryCount\": (value: String(rotationResult.rotatedEntryCount ?? 0), privacyLevel: .public)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/WriteLogCommand.swift:159:20: error: cannot find 'getAllDestinations' in scope\n157 |         if destinationIds.isEmpty {\n158 |             // Use all registered destinations\n159 |             return getAllDestinations().filter { $0.isEnabled }\n    |                    `- error: cannot find 'getAllDestinations' in scope\n160 |         } else {\n161 |             // Use specific destinations\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/WriteLogCommand.swift:165:38: error: cannot find 'getDestination' in scope\n163 |             \n164 |             for destinationId in destinationIds {\n165 |                 if let destination = getDestination(id: destinationId) {\n    |                                      `- error: cannot find 'getDestination' in scope\n166 |                     if destination.isEnabled {\n167 |                         result.append(destination)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/WriteLogCommand.swift:193:16: error: cannot find 'applyFilterRules' in scope\n191 |         \n192 |         // Apply filter rules if they exist\n193 |         return applyFilterRules(\n    |                `- error: cannot find 'applyFilterRules' in scope\n194 |             to: entry,\n195 |             rules: destination.configuration.filterRules\n\npackages/UmbraImplementations/Sources/LoggingServices/DefaultLoggingServiceImpl.swift:39:36: warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 37 |     let contextDTO=BaseLogContextDTO(\n 38 |       domainName: \"Legacy\",\n 39 |       operation: context.operation ?? \"unknown\",\n    |                                    `- warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 40 |       category: context.category ?? \"General\",\n 41 |       source: context.source ?? \"Unknown\",\n\npackages/UmbraImplementations/Sources/LoggingServices/DefaultLoggingServiceImpl.swift:40:34: warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 38 |       domainName: \"Legacy\",\n 39 |       operation: context.operation ?? \"unknown\",\n 40 |       category: context.category ?? \"General\",\n    |                                  `- warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 41 |       source: context.source ?? \"Unknown\",\n 42 |       metadata: context.metadata\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:147:17: error: invalid redeclaration of 'log(_:_:context:)'\n145 |         - context: The logging context\n146 |      */\n147 |     public func log(_ level: LogLevel, _ message: String, context: any LogContextDTO) async {\n    |                 `- error: invalid redeclaration of 'log(_:_:context:)'\n148 |         // Convert to privacy string and use privacy-aware logging\n149 |         let privacyString = PrivacyString(stringLiteral: message)\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:92:48: error: value of type 'any LoggingProviderProtocol' has no member 'writeLogEntry'\n 90 |                     do {\n 91 |                         // Write log entry to destination\n 92 |                         _ = try await provider.writeLogEntry(entry, to: destination)\n    |                                                `- error: value of type 'any LoggingProviderProtocol' has no member 'writeLogEntry'\n 93 |                     } catch {\n 94 |                         // Silently ignore provider errors for now\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:122:28: error: value of type 'PrivacyString' has no member 'privacy'\n120 |         enrichedMetadata = enrichedMetadata.withPrivate(\n121 |             key: \"__privacy_annotation\", \n122 |             value: message.privacy.description\n    |                            `- error: value of type 'PrivacyString' has no member 'privacy'\n123 |         )\n124 |         \n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:136:34: error: value of type 'PrivacyString' has no member 'content'\n134 |         \n135 |         // Log the message using the standard log method\n136 |         await log(level, message.content, context: privacyContext)\n    |                                  `- error: value of type 'PrivacyString' has no member 'content'\n137 |     }\n138 |     \n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:167:71: error: value of type 'PrivacyAnnotatedString' has no member 'stringValue'\n165 |     ) async {\n166 |         let annotatedString = privacyScope()\n167 |         await log(level, PrivacyString(stringLiteral: annotatedString.stringValue), context: context) \n    |                                                                       `- error: value of type 'PrivacyAnnotatedString' has no member 'stringValue'\n168 |     }\n169 |     \n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:190:29: error: for-in loop requires 'LogMetadata' to conform to 'Sequence'\n188 |         // Create a metadata collection with sensitive values\n189 |         var metadataCollection = context.metadata\n190 |         for (key, value) in sensitiveValues {\n    |                             `- error: for-in loop requires 'LogMetadata' to conform to 'Sequence'\n191 |             metadataCollection = metadataCollection.withSensitive(key: key, value: String(describing: value))\n192 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:228:9: error: switch must be exhaustive\n226 |         \n227 |         // Add error information to metadata with appropriate privacy level\n228 |         switch privacyLevel {\n    |         |- error: switch must be exhaustive\n    |         `- note: add missing case: '.auto'\n229 |         case .public:\n230 |             metadataCollection = metadataCollection.withPublic(key: \"error_description\", value: error.localizedDescription)\npackages/UmbraImplementations/Sources/LoggingServices/PrivacyAwareLogDTO.swift:217:24: error: value of type 'LogMetadataDTOCollection' has no member 'set'\n215 |     for key in self.metadata.getKeys() {\n216 |       if let value = self.metadata.getString(key: key) {\n217 |         mergedMetadata.set(key: key, value: value)\n    |                        `- error: value of type 'LogMetadataDTOCollection' has no member 'set'\n218 |       }\n219 |     }\n\npackages/UmbraImplementations/Sources/LoggingServices/PrivacyAwareLogDTO.swift:224:24: error: value of type 'LogMetadataDTOCollection' has no member 'set'\n222 |     for key in additionalMetadata.getKeys() {\n223 |       if let value = additionalMetadata.getString(key: key) {\n224 |         mergedMetadata.set(key: key, value: value)\n    |                        `- error: value of type 'LogMetadataDTOCollection' has no member 'set'\n225 |       }\n226 |     }\n\npackages/UmbraImplementations/Sources/LoggingServices/PrivacyAwareLogDTO.swift:235:17: error: cannot convert value of type 'LogMetadataDTOCollection' to expected argument type '[String : (value: Any, privacy: LogPrivacyLevel)]'\n233 |       category: category,\n234 |       correlationID: correlationID,\n235 |       metadata: mergedMetadata,\n    |                 `- error: cannot convert value of type 'LogMetadataDTOCollection' to expected argument type '[String : (value: Any, privacy: LogPrivacyLevel)]'\n236 |       environment: environment\n237 |     )\nTarget //packages/UmbraImplementations/Sources/SecurityCryptoServices:SecurityCryptoServices failed to build\nINFO: Elapsed time: 1.145s, Critical Path: 1.01s\nINFO: 2 processes: 3 action cache hit, 2 internal.\nERROR: Build did NOT complete successfully\n"
  },
  {
    "target": "rule //packages/UmbraImplementations/Sources/SecurityCryptoServices/ActorTypes:CryptoActorImplementations",
    "success": false,
    "start_time": "2025-04-11T17:58:32.242709+01:00",
    "end_time": "2025-04-11T17:58:34.48383+01:00",
    "duration": "2.241123375s",
    "output": "INFO: Invocation ID: bfeac82b-8e34-4d77-83a0-e56410cde797\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraImplementations/Sources/SecurityCryptoServices/ActorTypes:CryptoActorImplementations (0 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraImplementations/Sources/SecurityCryptoServices/ActorTypes:CryptoActorImplementations (0 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraImplementations/Sources/SecurityCryptoServices/ActorTypes:CryptoActorImplementations (0 packages loaded, 0 targets configured).\nERROR: /Users/mpy/CascadeProjects/UmbraCore/packages/UmbraImplementations/Sources/LoggingServices/BUILD.bazel:3:20: Compiling Swift module //packages/UmbraImplementations/Sources/LoggingServices:LoggingServices failed: (Exit 1): worker failed: error executing SwiftCompile command (from target //packages/UmbraImplementations/Sources/LoggingServices:LoggingServices) \n  (cd /Users/mpy/.bazel/execroot/_main \u0026\u0026 \\\n  exec env - \\\n    APPLE_SDK_PLATFORM=MacOSX \\\n    APPLE_SDK_VERSION_OVERRIDE=15.4 \\\n    CC=clang \\\n    PATH=/Users/mpy/Library/Caches/bazelisk/downloads/sha256/ac72ad67f7a8c6b18bf605d8602425182b417de4369715bf89146daf62f7ae48/bin:/Users/mpy/.rbenv/bin:/Users/mpy/.codeium/windsurf/bin:/opt/homebrew/opt/node@18/bin:/opt/homebrew/opt/node@20/bin:/Users/mpy/.docker/bin:/opt/homebrew/opt/openjdk/bin:/Users/mpy/bin:/opt/homebrew/bin:/opt/homebrew/sbin:/usr/local/bin:/System/Cryptexes/App/usr/bin:/usr/bin:/bin:/usr/sbin:/sbin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/local/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/appleinternal/bin:/Library/Apple/usr/bin:/usr/local/go/bin:/Users/mpy/.rbenv/bin:/Users/mpy/.codeium/windsurf/bin:/opt/homebrew/opt/node@18/bin:/opt/homebrew/opt/node@20/bin:/opt/anaconda3/bin:/opt/anaconda3/condabin:/Users/mpy/.docker/bin:/opt/homebrew/opt/openjdk/bin:/Users/mpy/bin:/Users/mpy/.cargo/bin:/Users/mpy/Library/Python/3.8/bin:/Users/mpy/go/bin:/Users/mpy/.scripts:/Users/mpy/.fzf/bin:/Users/mpy/.windsurf/extensions/ms-python.debugpy-2025.6.0-darwin-arm64/bundled/scripts/noConfigScripts:/Users/mpy/Library/Python/3.8/bin:/Users/mpy/go/bin:/Users/mpy/.scripts \\\n    XCODE_VERSION_OVERRIDE=16.3.0.16E140 \\\n  bazel-out/darwin_arm64-opt-exec-ST-d57f47055a04/bin/external/rules_swift+/tools/worker/worker swiftc @bazel-out/darwin_arm64-fastbuild/bin/packages/UmbraImplementations/Sources/LoggingServices/LoggingServices.swiftmodule-0.params)\n# Configuration: 76a1bf3a80f2d50513004915454165d2f164db794b63e4666809cbd93e1abeaa\n# Execution platform: @@platforms//host:host\nerror: emit-module command failed with exit code 1 (use -v to see invocation)\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:147:17: error: invalid redeclaration of 'log(_:_:context:)'\n145 |         - context: The logging context\n146 |      */\n147 |     public func log(_ level: LogLevel, _ message: String, context: any LogContextDTO) async {\n    |                 `- error: invalid redeclaration of 'log(_:_:context:)'\n148 |         // Convert to privacy string and use privacy-aware logging\n149 |         let privacyString = PrivacyString(stringLiteral: message)\npackages/UmbraImplementations/Sources/LoggingServices/Commands/AddDestinationCommand.swift:68:31: error: cannot find 'getDestination' in scope\n 66 |         do {\n 67 |             // Check if destination already exists\n 68 |             if let existing = getDestination(id: destination.id) {\n    |                               `- error: cannot find 'getDestination' in scope\n 69 |                 if !options.overwriteExisting {\n 70 |                     throw LoggingError.destinationAlreadyExists(identifier: \"Destination with ID \\(destination.id) already exists\")\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/AddDestinationCommand.swift:82:40: error: cannot find 'validateDestination' in scope\n 80 |             // Validate destination configuration if requested\n 81 |             if options.validateConfiguration {\n 82 |                 let validationResult = validateDestination(destination, for: provider)\n    |                                        `- error: cannot find 'validateDestination' in scope\n 83 |                 \n 84 |                 if !validationResult.isValid {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/AddDestinationCommand.swift:121:13: error: expression is 'async' but is not marked with 'await'\n119 |             \n120 |             // Register the destination\n121 |             registerDestination(destination)\n    |             |- error: expression is 'async' but is not marked with 'await'\n    |             `- note: calls to instance method 'registerDestination' from outside of its actor context are implicitly asynchronous\n122 |             \n123 |             // Log success\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ArchiveLogsCommand.swift:57:84: error: type 'LogPrivacyLevel' has no member 'protected'\n 55 |             destinationId: destinationId,\n 56 |             additionalMetadata: [\n 57 |                 \"destinationPath\": (value: options.destinationPath, privacyLevel: .protected),\n    |                                                                                    `- error: type 'LogPrivacyLevel' has no member 'protected'\n 58 |                 \"compress\": (value: String(options.compress), privacyLevel: .public),\n 59 |                 \"format\": (value: options.format.rawValue, privacyLevel: .public),\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ArchiveLogsCommand.swift:70:37: error: cannot find 'getDestination' in scope\n 68 |         do {\n 69 |             // Check if destination exists\n 70 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 71 |                 throw LoggingError.destinationNotFound(\n 72 |                     \"Cannot archive logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ArchiveLogsCommand.swift:113:103: error: type 'LogPrivacyLevel' has no member 'protected'\n111 |                     context: operationContext,\n112 |                     additionalMetadata: [\n113 |                         \"archivePath\": (value: archiveResult.archivePath ?? \"unknown\", privacyLevel: .protected),\n    |                                                                                                       `- error: type 'LogPrivacyLevel' has no member 'protected'\n114 |                         \"archiveSizeBytes\": (value: String(archiveResult.archiveSizeBytes ?? 0), privacyLevel: .public),\n115 |                         \"archivedEntryCount\": (value: String(archiveResult.archivedEntryCount ?? 0), privacyLevel: .public)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ExportLogsCommand.swift:70:37: error: cannot find 'getDestination' in scope\n 68 |         do {\n 69 |             // Check if destination exists\n 70 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 71 |                 throw LoggingError.destinationNotFound(\n 72 |                     \"Cannot export logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:79:50: error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n 77 |                 key: key,\n 78 |                 value: value.value,\n 79 |                 privacyLevel: value.privacyLevel.toPrivacyClassification()\n    |                                                  `- error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n 80 |             )\n 81 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:122:54: error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n120 |                     key: key,\n121 |                     value: value.value,\n122 |                     privacyLevel: value.privacyLevel.toPrivacyClassification()\n    |                                                      `- error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n123 |                 )\n124 |             )\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:229:21: error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n227 |         \n228 |         // Process special fields first\n229 |         switch rule.field {\n    |                     `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n230 |         case \"level\":\n231 |             fieldValue = entry.level.rawValue\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:238:96: error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n236 |         default:\n237 |             // Check metadata fields\n238 |             if let metadata = entry.metadata, let metadataValue = metadata.getString(key: rule.field) {\n    |                                                                                                `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n239 |                 fieldValue = metadataValue\n240 |             } else {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:246:21: error: value of type 'UmbraLogFilterRuleDTO' has no member 'operation'\n244 |         \n245 |         // Apply the operation\n246 |         switch rule.operation {\n    |                     `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'operation'\n247 |         case .equals:\n248 |             return fieldValue == rule.value\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:248:39: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n246 |         switch rule.operation {\n247 |         case .equals:\n248 |             return fieldValue == rule.value\n    |                                       `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n249 |         case .contains:\n250 |             return fieldValue.contains(rule.value)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:250:45: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n248 |             return fieldValue == rule.value\n249 |         case .contains:\n250 |             return fieldValue.contains(rule.value)\n    |                                             `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n251 |         case .startsWith:\n252 |             return fieldValue.hasPrefix(rule.value)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:252:46: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n250 |             return fieldValue.contains(rule.value)\n251 |         case .startsWith:\n252 |             return fieldValue.hasPrefix(rule.value)\n    |                                              `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n253 |         case .endsWith:\n254 |             return fieldValue.hasSuffix(rule.value)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:254:46: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n252 |             return fieldValue.hasPrefix(rule.value)\n253 |         case .endsWith:\n254 |             return fieldValue.hasSuffix(rule.value)\n    |                                              `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n255 |         case .matches:\n256 |             if let regex = try? NSRegularExpression(pattern: rule.value) {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:256:67: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n254 |             return fieldValue.hasSuffix(rule.value)\n255 |         case .matches:\n256 |             if let regex = try? NSRegularExpression(pattern: rule.value) {\n    |                                                                   `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n257 |                 let range = NSRange(location: 0, length: fieldValue.utf16.count)\n258 |                 return regex.firstMatch(in: fieldValue, options: [], range: range) != nil\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:262:86: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n260 |             return false\n261 |         case .greaterThan:\n262 |             if let fieldNumeric = Double(fieldValue), let valueNumeric = Double(rule.value) {\n    |                                                                                      `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n263 |                 return fieldNumeric \u003e valueNumeric\n264 |             }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:267:86: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n265 |             return false\n266 |         case .lessThan:\n267 |             if let fieldNumeric = Double(fieldValue), let valueNumeric = Double(rule.value) {\n    |                                                                                      `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n268 |                 return fieldNumeric \u003c valueNumeric\n269 |             }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:293:13: warning: variable 'redactedMetadata' was never mutated; consider changing to 'let' constant\n291 |         // Create mutable copies\n292 |         var redactedMessage = entry.message\n293 |         var redactedMetadata = entry.metadata\n    |             `- warning: variable 'redactedMetadata' was never mutated; consider changing to 'let' constant\n294 |         \n295 |         for rule in rules {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:395:47: error: value of type 'String' has no member 'stringByReplacingMatches'\n393 |             if rule.targetFields.isEmpty || rule.targetFields.contains(\"message\") {\n394 |                 if let pattern = rule.pattern {\n395 |                     redactedMessage = pattern.stringByReplacingMatches(\n    |                                               `- error: value of type 'String' has no member 'stringByReplacingMatches'\n396 |                         in: redactedMessage,\n397 |                         options: [],\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:394:20: error: initializer for conditional binding must have Optional type, not 'String'\n392 |             // Apply rule to message if it matches\n393 |             if rule.targetFields.isEmpty || rule.targetFields.contains(\"message\") {\n394 |                 if let pattern = rule.pattern {\n    |                    `- error: initializer for conditional binding must have Optional type, not 'String'\n395 |                     redactedMessage = pattern.stringByReplacingMatches(\n396 |                         in: redactedMessage,\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:405:24: error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getKeys' of wrapped base type 'LogMetadataDTOCollection'\n403 |             \n404 |             // Process metadata fields\n405 |             for key in redactedMetadata.getKeys() {\n    |                        |- error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getKeys' of wrapped base type 'LogMetadataDTOCollection'\n    |                        |- note: chain the optional using '?' to access member 'getKeys' only for non-'nil' base values\n    |                        `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n406 |                 if rule.targetFields.isEmpty || rule.targetFields.contains(key) {\n407 |                     if let stringValue = redactedMetadata.getString(key: key) {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:407:42: error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getString' of wrapped base type 'LogMetadataDTOCollection'\n405 |             for key in redactedMetadata.getKeys() {\n406 |                 if rule.targetFields.isEmpty || rule.targetFields.contains(key) {\n407 |                     if let stringValue = redactedMetadata.getString(key: key) {\n    |                                          |- error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getString' of wrapped base type 'LogMetadataDTOCollection'\n    |                                          |- note: chain the optional using '?' to access member 'getString' only for non-'nil' base values\n    |                                          `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n408 |                         // Skip fields that should be preserved\n409 |                         if rule.preserveFields.contains(key) {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:468:15: error: type 'LogPrivacyLevel' has no member 'never'\n466 |         case .auto:\n467 |             return .auto\n468 |         case .never:\n    |               `- error: type 'LogPrivacyLevel' has no member 'never'\n469 |             return .public // Map 'never' to public classification\n470 |         case .protected:\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:470:15: error: type 'LogPrivacyLevel' has no member 'protected'\n468 |         case .never:\n469 |             return .public // Map 'never' to public classification\n470 |         case .protected:\n    |               `- error: type 'LogPrivacyLevel' has no member 'protected'\n471 |             return .private // Map 'protected' to private classification\n472 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:58:84: error: type 'LogPrivacyLevel' has no member 'protected'\n 56 |             additionalMetadata: [\n 57 |                 \"createBackup\": (value: String(options.createBackup), privacyLevel: .public),\n 58 |                 \"backupPath\": (value: options.backupPath ?? \"none\", privacyLevel: .protected),\n    |                                                                                    `- error: type 'LogPrivacyLevel' has no member 'protected'\n 59 |                 \"dryRun\": (value: String(options.dryRun), privacyLevel: .public),\n 60 |                 \"hasFilterCriteria\": (value: String(options.filterCriteria != nil), privacyLevel: .public),\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:184:34: error: cannot find 'getDestination' in scope\n182 |         if let destinationId = destinationId {\n183 |             // Use specific destination\n184 |             if let destination = getDestination(id: destinationId) {\n    |                                  `- error: cannot find 'getDestination' in scope\n185 |                 return [destination]\n186 |             } else {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:196:38: error: cannot find 'getDestination' in scope\n194 |             \n195 |             for id in options.destinationIds {\n196 |                 if let destination = getDestination(id: id) {\n    |                                      `- error: cannot find 'getDestination' in scope\n197 |                     result.append(destination)\n198 |                 } else {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:208:20: error: cannot find 'getAllDestinations' in scope\n206 |         } else {\n207 |             // Use all registered destinations\n208 |             return getAllDestinations()\n    |                    `- error: cannot find 'getAllDestinations' in scope\n209 |         }\n210 |     }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/QueryLogsCommand.swift:71:37: error: cannot find 'getDestination' in scope\n 69 |         do {\n 70 |             // Check if destination exists\n 71 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 72 |                 throw LoggingError.destinationNotFound(\n 73 |                     \"Cannot query logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RedactionRule.swift:123:72: error: missing argument for parameter 'privacyLevel' in call\n121 |                 if value != redactedValue {\n122 |                     // Only update if actually changed\n123 |                     result = result.with(key: key, value: redactedValue)\n    |                                                                        `- error: missing argument for parameter 'privacyLevel' in call\n124 |                 }\n125 |             }\n\n/Users/mpy/.bazel/execroot/_main/packages/UmbraCoreTypes/Sources/LoggingTypes/LogMetadataDTOCollection.swift:78:15: note: 'with(key:value:privacyLevel:)' declared here\n 76 |   ///   - privacyLevel: The privacy classification for this entry\n 77 |   /// - Returns: The updated collection\n 78 |   public func with(\n    |               `- note: 'with(key:value:privacyLevel:)' declared here\n 79 |     key: String,\n 80 |     value: String,\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RedactionRule.swift:101:26: warning: no calls to throwing functions occur within 'try' expression\n 99 |     public func redact(metadata: LogMetadataDTOCollection) -\u003e LogMetadataDTOCollection {\n100 |         // No redaction needed for empty metadata\n101 |         guard let keys = try? metadata.getKeys() else {\n    |                          `- warning: no calls to throwing functions occur within 'try' expression\n102 |             return metadata\n103 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RedactionRule.swift:119:28: warning: no calls to throwing functions occur within 'try' expression\n117 |             \n118 |             // Get string value and apply redaction\n119 |             if let value = try? metadata.getString(key: key) {\n    |                            `- warning: no calls to throwing functions occur within 'try' expression\n120 |                 let redactedValue = redact(value)\n121 |                 if value != redactedValue {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RemoveDestinationCommand.swift:67:37: error: cannot find 'getDestination' in scope\n 65 |         do {\n 66 |             // Check if destination exists\n 67 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 68 |                 throw LoggingError.destinationNotFound(\n 69 |                     \"Cannot remove destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RemoveDestinationCommand.swift:128:13: error: expression is 'async' but is not marked with 'await'\n126 |             \n127 |             // Unregister the destination\n128 |             unregisterDestination(id: destinationId)\n    |             |- error: expression is 'async' but is not marked with 'await'\n    |             `- note: calls to instance method 'unregisterDestination(id:)' from outside of its actor context are implicitly asynchronous\n129 |             \n130 |             // Log success\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RotateLogsCommand.swift:67:37: error: cannot find 'getDestination' in scope\n 65 |         do {\n 66 |             // Check if destination exists\n 67 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 68 |                 throw LoggingError.destinationNotFound(\n 69 |                     \"Cannot rotate logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RotateLogsCommand.swift:74:37: error: cannot infer contextual base in reference to member 'file'\n 72 |             \n 73 |             // Check if the destination type supports rotation\n 74 |             if destination.type != .file {\n    |                                     `- error: cannot infer contextual base in reference to member 'file'\n 75 |                 throw LoggingError.invalidDestinationConfig(\n 76 |                     \"Log rotation is only supported for file destinations\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RotateLogsCommand.swift:92:112: error: type 'LogPrivacyLevel' has no member 'protected'\n 90 |                     context: operationContext,\n 91 |                     additionalMetadata: [\n 92 |                         \"rotatedFilePath\": (value: rotationResult.rotatedFilePath ?? \"unknown\", privacyLevel: .protected),\n    |                                                                                                                `- error: type 'LogPrivacyLevel' has no member 'protected'\n 93 |                         \"rotatedSizeBytes\": (value: String(rotationResult.rotatedSizeBytes ?? 0), privacyLevel: .public),\n 94 |                         \"rotatedEntryCount\": (value: String(rotationResult.rotatedEntryCount ?? 0), privacyLevel: .public)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/WriteLogCommand.swift:159:20: error: cannot find 'getAllDestinations' in scope\n157 |         if destinationIds.isEmpty {\n158 |             // Use all registered destinations\n159 |             return getAllDestinations().filter { $0.isEnabled }\n    |                    `- error: cannot find 'getAllDestinations' in scope\n160 |         } else {\n161 |             // Use specific destinations\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/WriteLogCommand.swift:165:38: error: cannot find 'getDestination' in scope\n163 |             \n164 |             for destinationId in destinationIds {\n165 |                 if let destination = getDestination(id: destinationId) {\n    |                                      `- error: cannot find 'getDestination' in scope\n166 |                     if destination.isEnabled {\n167 |                         result.append(destination)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/WriteLogCommand.swift:193:16: error: cannot find 'applyFilterRules' in scope\n191 |         \n192 |         // Apply filter rules if they exist\n193 |         return applyFilterRules(\n    |                `- error: cannot find 'applyFilterRules' in scope\n194 |             to: entry,\n195 |             rules: destination.configuration.filterRules\n\npackages/UmbraImplementations/Sources/LoggingServices/DefaultLoggingServiceImpl.swift:39:36: warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 37 |     let contextDTO=BaseLogContextDTO(\n 38 |       domainName: \"Legacy\",\n 39 |       operation: context.operation ?? \"unknown\",\n    |                                    `- warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 40 |       category: context.category ?? \"General\",\n 41 |       source: context.source ?? \"Unknown\",\n\npackages/UmbraImplementations/Sources/LoggingServices/DefaultLoggingServiceImpl.swift:40:34: warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 38 |       domainName: \"Legacy\",\n 39 |       operation: context.operation ?? \"unknown\",\n 40 |       category: context.category ?? \"General\",\n    |                                  `- warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 41 |       source: context.source ?? \"Unknown\",\n 42 |       metadata: context.metadata\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:147:17: error: invalid redeclaration of 'log(_:_:context:)'\n145 |         - context: The logging context\n146 |      */\n147 |     public func log(_ level: LogLevel, _ message: String, context: any LogContextDTO) async {\n    |                 `- error: invalid redeclaration of 'log(_:_:context:)'\n148 |         // Convert to privacy string and use privacy-aware logging\n149 |         let privacyString = PrivacyString(stringLiteral: message)\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:92:48: error: value of type 'any LoggingProviderProtocol' has no member 'writeLogEntry'\n 90 |                     do {\n 91 |                         // Write log entry to destination\n 92 |                         _ = try await provider.writeLogEntry(entry, to: destination)\n    |                                                `- error: value of type 'any LoggingProviderProtocol' has no member 'writeLogEntry'\n 93 |                     } catch {\n 94 |                         // Silently ignore provider errors for now\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:122:28: error: value of type 'PrivacyString' has no member 'privacy'\n120 |         enrichedMetadata = enrichedMetadata.withPrivate(\n121 |             key: \"__privacy_annotation\", \n122 |             value: message.privacy.description\n    |                            `- error: value of type 'PrivacyString' has no member 'privacy'\n123 |         )\n124 |         \n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:136:34: error: value of type 'PrivacyString' has no member 'content'\n134 |         \n135 |         // Log the message using the standard log method\n136 |         await log(level, message.content, context: privacyContext)\n    |                                  `- error: value of type 'PrivacyString' has no member 'content'\n137 |     }\n138 |     \n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:167:71: error: value of type 'PrivacyAnnotatedString' has no member 'stringValue'\n165 |     ) async {\n166 |         let annotatedString = privacyScope()\n167 |         await log(level, PrivacyString(stringLiteral: annotatedString.stringValue), context: context) \n    |                                                                       `- error: value of type 'PrivacyAnnotatedString' has no member 'stringValue'\n168 |     }\n169 |     \n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:190:29: error: for-in loop requires 'LogMetadata' to conform to 'Sequence'\n188 |         // Create a metadata collection with sensitive values\n189 |         var metadataCollection = context.metadata\n190 |         for (key, value) in sensitiveValues {\n    |                             `- error: for-in loop requires 'LogMetadata' to conform to 'Sequence'\n191 |             metadataCollection = metadataCollection.withSensitive(key: key, value: String(describing: value))\n192 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:228:9: error: switch must be exhaustive\n226 |         \n227 |         // Add error information to metadata with appropriate privacy level\n228 |         switch privacyLevel {\n    |         |- error: switch must be exhaustive\n    |         `- note: add missing case: '.auto'\n229 |         case .public:\n230 |             metadataCollection = metadataCollection.withPublic(key: \"error_description\", value: error.localizedDescription)\npackages/UmbraImplementations/Sources/LoggingServices/PrivacyAwareLogDTO.swift:217:24: error: value of type 'LogMetadataDTOCollection' has no member 'set'\n215 |     for key in self.metadata.getKeys() {\n216 |       if let value = self.metadata.getString(key: key) {\n217 |         mergedMetadata.set(key: key, value: value)\n    |                        `- error: value of type 'LogMetadataDTOCollection' has no member 'set'\n218 |       }\n219 |     }\n\npackages/UmbraImplementations/Sources/LoggingServices/PrivacyAwareLogDTO.swift:224:24: error: value of type 'LogMetadataDTOCollection' has no member 'set'\n222 |     for key in additionalMetadata.getKeys() {\n223 |       if let value = additionalMetadata.getString(key: key) {\n224 |         mergedMetadata.set(key: key, value: value)\n    |                        `- error: value of type 'LogMetadataDTOCollection' has no member 'set'\n225 |       }\n226 |     }\n\npackages/UmbraImplementations/Sources/LoggingServices/PrivacyAwareLogDTO.swift:235:17: error: cannot convert value of type 'LogMetadataDTOCollection' to expected argument type '[String : (value: Any, privacy: LogPrivacyLevel)]'\n233 |       category: category,\n234 |       correlationID: correlationID,\n235 |       metadata: mergedMetadata,\n    |                 `- error: cannot convert value of type 'LogMetadataDTOCollection' to expected argument type '[String : (value: Any, privacy: LogPrivacyLevel)]'\n236 |       environment: environment\n237 |     )\nTarget //packages/UmbraImplementations/Sources/SecurityCryptoServices/ActorTypes:CryptoActorImplementations failed to build\nINFO: Elapsed time: 1.133s, Critical Path: 1.01s\nINFO: 2 processes: 2 internal.\nERROR: Build did NOT complete successfully\n"
  },
  {
    "target": "rule //packages/UmbraImplementations/Sources/SecurityCryptoServices/ProviderFactories:ProviderFactories",
    "success": false,
    "start_time": "2025-04-11T17:58:34.483845+01:00",
    "end_time": "2025-04-11T17:58:36.556478+01:00",
    "duration": "2.072635042s",
    "output": "INFO: Invocation ID: 269a1a68-5c88-497c-9f04-d60989332e2a\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraImplementations/Sources/SecurityCryptoServices/ProviderFactories:ProviderFactories (0 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraImplementations/Sources/SecurityCryptoServices/ProviderFactories:ProviderFactories (0 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraImplementations/Sources/SecurityCryptoServices/ProviderFactories:ProviderFactories (0 packages loaded, 0 targets configured).\nERROR: /Users/mpy/CascadeProjects/UmbraCore/packages/UmbraImplementations/Sources/LoggingServices/BUILD.bazel:3:20: Compiling Swift module //packages/UmbraImplementations/Sources/LoggingServices:LoggingServices failed: (Exit 1): worker failed: error executing SwiftCompile command (from target //packages/UmbraImplementations/Sources/LoggingServices:LoggingServices) \n  (cd /Users/mpy/.bazel/execroot/_main \u0026\u0026 \\\n  exec env - \\\n    APPLE_SDK_PLATFORM=MacOSX \\\n    APPLE_SDK_VERSION_OVERRIDE=15.4 \\\n    CC=clang \\\n    PATH=/Users/mpy/Library/Caches/bazelisk/downloads/sha256/ac72ad67f7a8c6b18bf605d8602425182b417de4369715bf89146daf62f7ae48/bin:/Users/mpy/.rbenv/bin:/Users/mpy/.codeium/windsurf/bin:/opt/homebrew/opt/node@18/bin:/opt/homebrew/opt/node@20/bin:/Users/mpy/.docker/bin:/opt/homebrew/opt/openjdk/bin:/Users/mpy/bin:/opt/homebrew/bin:/opt/homebrew/sbin:/usr/local/bin:/System/Cryptexes/App/usr/bin:/usr/bin:/bin:/usr/sbin:/sbin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/local/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/appleinternal/bin:/Library/Apple/usr/bin:/usr/local/go/bin:/Users/mpy/.rbenv/bin:/Users/mpy/.codeium/windsurf/bin:/opt/homebrew/opt/node@18/bin:/opt/homebrew/opt/node@20/bin:/opt/anaconda3/bin:/opt/anaconda3/condabin:/Users/mpy/.docker/bin:/opt/homebrew/opt/openjdk/bin:/Users/mpy/bin:/Users/mpy/.cargo/bin:/Users/mpy/Library/Python/3.8/bin:/Users/mpy/go/bin:/Users/mpy/.scripts:/Users/mpy/.fzf/bin:/Users/mpy/.windsurf/extensions/ms-python.debugpy-2025.6.0-darwin-arm64/bundled/scripts/noConfigScripts:/Users/mpy/Library/Python/3.8/bin:/Users/mpy/go/bin:/Users/mpy/.scripts \\\n    XCODE_VERSION_OVERRIDE=16.3.0.16E140 \\\n  bazel-out/darwin_arm64-opt-exec-ST-d57f47055a04/bin/external/rules_swift+/tools/worker/worker swiftc @bazel-out/darwin_arm64-fastbuild/bin/packages/UmbraImplementations/Sources/LoggingServices/LoggingServices.swiftmodule-0.params)\n# Configuration: 76a1bf3a80f2d50513004915454165d2f164db794b63e4666809cbd93e1abeaa\n# Execution platform: @@platforms//host:host\nerror: emit-module command failed with exit code 1 (use -v to see invocation)\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:147:17: error: invalid redeclaration of 'log(_:_:context:)'\n145 |         - context: The logging context\n146 |      */\n147 |     public func log(_ level: LogLevel, _ message: String, context: any LogContextDTO) async {\n    |                 `- error: invalid redeclaration of 'log(_:_:context:)'\n148 |         // Convert to privacy string and use privacy-aware logging\n149 |         let privacyString = PrivacyString(stringLiteral: message)\npackages/UmbraImplementations/Sources/LoggingServices/Commands/AddDestinationCommand.swift:68:31: error: cannot find 'getDestination' in scope\n 66 |         do {\n 67 |             // Check if destination already exists\n 68 |             if let existing = getDestination(id: destination.id) {\n    |                               `- error: cannot find 'getDestination' in scope\n 69 |                 if !options.overwriteExisting {\n 70 |                     throw LoggingError.destinationAlreadyExists(identifier: \"Destination with ID \\(destination.id) already exists\")\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/AddDestinationCommand.swift:82:40: error: cannot find 'validateDestination' in scope\n 80 |             // Validate destination configuration if requested\n 81 |             if options.validateConfiguration {\n 82 |                 let validationResult = validateDestination(destination, for: provider)\n    |                                        `- error: cannot find 'validateDestination' in scope\n 83 |                 \n 84 |                 if !validationResult.isValid {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/AddDestinationCommand.swift:121:13: error: expression is 'async' but is not marked with 'await'\n119 |             \n120 |             // Register the destination\n121 |             registerDestination(destination)\n    |             |- error: expression is 'async' but is not marked with 'await'\n    |             `- note: calls to instance method 'registerDestination' from outside of its actor context are implicitly asynchronous\n122 |             \n123 |             // Log success\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ArchiveLogsCommand.swift:57:84: error: type 'LogPrivacyLevel' has no member 'protected'\n 55 |             destinationId: destinationId,\n 56 |             additionalMetadata: [\n 57 |                 \"destinationPath\": (value: options.destinationPath, privacyLevel: .protected),\n    |                                                                                    `- error: type 'LogPrivacyLevel' has no member 'protected'\n 58 |                 \"compress\": (value: String(options.compress), privacyLevel: .public),\n 59 |                 \"format\": (value: options.format.rawValue, privacyLevel: .public),\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ArchiveLogsCommand.swift:70:37: error: cannot find 'getDestination' in scope\n 68 |         do {\n 69 |             // Check if destination exists\n 70 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 71 |                 throw LoggingError.destinationNotFound(\n 72 |                     \"Cannot archive logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ArchiveLogsCommand.swift:113:103: error: type 'LogPrivacyLevel' has no member 'protected'\n111 |                     context: operationContext,\n112 |                     additionalMetadata: [\n113 |                         \"archivePath\": (value: archiveResult.archivePath ?? \"unknown\", privacyLevel: .protected),\n    |                                                                                                       `- error: type 'LogPrivacyLevel' has no member 'protected'\n114 |                         \"archiveSizeBytes\": (value: String(archiveResult.archiveSizeBytes ?? 0), privacyLevel: .public),\n115 |                         \"archivedEntryCount\": (value: String(archiveResult.archivedEntryCount ?? 0), privacyLevel: .public)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ExportLogsCommand.swift:70:37: error: cannot find 'getDestination' in scope\n 68 |         do {\n 69 |             // Check if destination exists\n 70 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 71 |                 throw LoggingError.destinationNotFound(\n 72 |                     \"Cannot export logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:79:50: error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n 77 |                 key: key,\n 78 |                 value: value.value,\n 79 |                 privacyLevel: value.privacyLevel.toPrivacyClassification()\n    |                                                  `- error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n 80 |             )\n 81 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:122:54: error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n120 |                     key: key,\n121 |                     value: value.value,\n122 |                     privacyLevel: value.privacyLevel.toPrivacyClassification()\n    |                                                      `- error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n123 |                 )\n124 |             )\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:229:21: error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n227 |         \n228 |         // Process special fields first\n229 |         switch rule.field {\n    |                     `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n230 |         case \"level\":\n231 |             fieldValue = entry.level.rawValue\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:238:96: error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n236 |         default:\n237 |             // Check metadata fields\n238 |             if let metadata = entry.metadata, let metadataValue = metadata.getString(key: rule.field) {\n    |                                                                                                `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n239 |                 fieldValue = metadataValue\n240 |             } else {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:246:21: error: value of type 'UmbraLogFilterRuleDTO' has no member 'operation'\n244 |         \n245 |         // Apply the operation\n246 |         switch rule.operation {\n    |                     `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'operation'\n247 |         case .equals:\n248 |             return fieldValue == rule.value\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:248:39: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n246 |         switch rule.operation {\n247 |         case .equals:\n248 |             return fieldValue == rule.value\n    |                                       `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n249 |         case .contains:\n250 |             return fieldValue.contains(rule.value)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:250:45: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n248 |             return fieldValue == rule.value\n249 |         case .contains:\n250 |             return fieldValue.contains(rule.value)\n    |                                             `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n251 |         case .startsWith:\n252 |             return fieldValue.hasPrefix(rule.value)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:252:46: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n250 |             return fieldValue.contains(rule.value)\n251 |         case .startsWith:\n252 |             return fieldValue.hasPrefix(rule.value)\n    |                                              `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n253 |         case .endsWith:\n254 |             return fieldValue.hasSuffix(rule.value)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:254:46: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n252 |             return fieldValue.hasPrefix(rule.value)\n253 |         case .endsWith:\n254 |             return fieldValue.hasSuffix(rule.value)\n    |                                              `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n255 |         case .matches:\n256 |             if let regex = try? NSRegularExpression(pattern: rule.value) {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:256:67: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n254 |             return fieldValue.hasSuffix(rule.value)\n255 |         case .matches:\n256 |             if let regex = try? NSRegularExpression(pattern: rule.value) {\n    |                                                                   `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n257 |                 let range = NSRange(location: 0, length: fieldValue.utf16.count)\n258 |                 return regex.firstMatch(in: fieldValue, options: [], range: range) != nil\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:262:86: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n260 |             return false\n261 |         case .greaterThan:\n262 |             if let fieldNumeric = Double(fieldValue), let valueNumeric = Double(rule.value) {\n    |                                                                                      `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n263 |                 return fieldNumeric \u003e valueNumeric\n264 |             }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:267:86: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n265 |             return false\n266 |         case .lessThan:\n267 |             if let fieldNumeric = Double(fieldValue), let valueNumeric = Double(rule.value) {\n    |                                                                                      `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n268 |                 return fieldNumeric \u003c valueNumeric\n269 |             }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:293:13: warning: variable 'redactedMetadata' was never mutated; consider changing to 'let' constant\n291 |         // Create mutable copies\n292 |         var redactedMessage = entry.message\n293 |         var redactedMetadata = entry.metadata\n    |             `- warning: variable 'redactedMetadata' was never mutated; consider changing to 'let' constant\n294 |         \n295 |         for rule in rules {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:395:47: error: value of type 'String' has no member 'stringByReplacingMatches'\n393 |             if rule.targetFields.isEmpty || rule.targetFields.contains(\"message\") {\n394 |                 if let pattern = rule.pattern {\n395 |                     redactedMessage = pattern.stringByReplacingMatches(\n    |                                               `- error: value of type 'String' has no member 'stringByReplacingMatches'\n396 |                         in: redactedMessage,\n397 |                         options: [],\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:394:20: error: initializer for conditional binding must have Optional type, not 'String'\n392 |             // Apply rule to message if it matches\n393 |             if rule.targetFields.isEmpty || rule.targetFields.contains(\"message\") {\n394 |                 if let pattern = rule.pattern {\n    |                    `- error: initializer for conditional binding must have Optional type, not 'String'\n395 |                     redactedMessage = pattern.stringByReplacingMatches(\n396 |                         in: redactedMessage,\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:405:24: error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getKeys' of wrapped base type 'LogMetadataDTOCollection'\n403 |             \n404 |             // Process metadata fields\n405 |             for key in redactedMetadata.getKeys() {\n    |                        |- error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getKeys' of wrapped base type 'LogMetadataDTOCollection'\n    |                        |- note: chain the optional using '?' to access member 'getKeys' only for non-'nil' base values\n    |                        `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n406 |                 if rule.targetFields.isEmpty || rule.targetFields.contains(key) {\n407 |                     if let stringValue = redactedMetadata.getString(key: key) {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:407:42: error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getString' of wrapped base type 'LogMetadataDTOCollection'\n405 |             for key in redactedMetadata.getKeys() {\n406 |                 if rule.targetFields.isEmpty || rule.targetFields.contains(key) {\n407 |                     if let stringValue = redactedMetadata.getString(key: key) {\n    |                                          |- error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getString' of wrapped base type 'LogMetadataDTOCollection'\n    |                                          |- note: chain the optional using '?' to access member 'getString' only for non-'nil' base values\n    |                                          `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n408 |                         // Skip fields that should be preserved\n409 |                         if rule.preserveFields.contains(key) {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:468:15: error: type 'LogPrivacyLevel' has no member 'never'\n466 |         case .auto:\n467 |             return .auto\n468 |         case .never:\n    |               `- error: type 'LogPrivacyLevel' has no member 'never'\n469 |             return .public // Map 'never' to public classification\n470 |         case .protected:\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:470:15: error: type 'LogPrivacyLevel' has no member 'protected'\n468 |         case .never:\n469 |             return .public // Map 'never' to public classification\n470 |         case .protected:\n    |               `- error: type 'LogPrivacyLevel' has no member 'protected'\n471 |             return .private // Map 'protected' to private classification\n472 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:58:84: error: type 'LogPrivacyLevel' has no member 'protected'\n 56 |             additionalMetadata: [\n 57 |                 \"createBackup\": (value: String(options.createBackup), privacyLevel: .public),\n 58 |                 \"backupPath\": (value: options.backupPath ?? \"none\", privacyLevel: .protected),\n    |                                                                                    `- error: type 'LogPrivacyLevel' has no member 'protected'\n 59 |                 \"dryRun\": (value: String(options.dryRun), privacyLevel: .public),\n 60 |                 \"hasFilterCriteria\": (value: String(options.filterCriteria != nil), privacyLevel: .public),\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:184:34: error: cannot find 'getDestination' in scope\n182 |         if let destinationId = destinationId {\n183 |             // Use specific destination\n184 |             if let destination = getDestination(id: destinationId) {\n    |                                  `- error: cannot find 'getDestination' in scope\n185 |                 return [destination]\n186 |             } else {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:196:38: error: cannot find 'getDestination' in scope\n194 |             \n195 |             for id in options.destinationIds {\n196 |                 if let destination = getDestination(id: id) {\n    |                                      `- error: cannot find 'getDestination' in scope\n197 |                     result.append(destination)\n198 |                 } else {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:208:20: error: cannot find 'getAllDestinations' in scope\n206 |         } else {\n207 |             // Use all registered destinations\n208 |             return getAllDestinations()\n    |                    `- error: cannot find 'getAllDestinations' in scope\n209 |         }\n210 |     }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/QueryLogsCommand.swift:71:37: error: cannot find 'getDestination' in scope\n 69 |         do {\n 70 |             // Check if destination exists\n 71 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 72 |                 throw LoggingError.destinationNotFound(\n 73 |                     \"Cannot query logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RedactionRule.swift:123:72: error: missing argument for parameter 'privacyLevel' in call\n121 |                 if value != redactedValue {\n122 |                     // Only update if actually changed\n123 |                     result = result.with(key: key, value: redactedValue)\n    |                                                                        `- error: missing argument for parameter 'privacyLevel' in call\n124 |                 }\n125 |             }\n\n/Users/mpy/.bazel/execroot/_main/packages/UmbraCoreTypes/Sources/LoggingTypes/LogMetadataDTOCollection.swift:78:15: note: 'with(key:value:privacyLevel:)' declared here\n 76 |   ///   - privacyLevel: The privacy classification for this entry\n 77 |   /// - Returns: The updated collection\n 78 |   public func with(\n    |               `- note: 'with(key:value:privacyLevel:)' declared here\n 79 |     key: String,\n 80 |     value: String,\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RedactionRule.swift:101:26: warning: no calls to throwing functions occur within 'try' expression\n 99 |     public func redact(metadata: LogMetadataDTOCollection) -\u003e LogMetadataDTOCollection {\n100 |         // No redaction needed for empty metadata\n101 |         guard let keys = try? metadata.getKeys() else {\n    |                          `- warning: no calls to throwing functions occur within 'try' expression\n102 |             return metadata\n103 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RedactionRule.swift:119:28: warning: no calls to throwing functions occur within 'try' expression\n117 |             \n118 |             // Get string value and apply redaction\n119 |             if let value = try? metadata.getString(key: key) {\n    |                            `- warning: no calls to throwing functions occur within 'try' expression\n120 |                 let redactedValue = redact(value)\n121 |                 if value != redactedValue {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RemoveDestinationCommand.swift:67:37: error: cannot find 'getDestination' in scope\n 65 |         do {\n 66 |             // Check if destination exists\n 67 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 68 |                 throw LoggingError.destinationNotFound(\n 69 |                     \"Cannot remove destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RemoveDestinationCommand.swift:128:13: error: expression is 'async' but is not marked with 'await'\n126 |             \n127 |             // Unregister the destination\n128 |             unregisterDestination(id: destinationId)\n    |             |- error: expression is 'async' but is not marked with 'await'\n    |             `- note: calls to instance method 'unregisterDestination(id:)' from outside of its actor context are implicitly asynchronous\n129 |             \n130 |             // Log success\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RotateLogsCommand.swift:67:37: error: cannot find 'getDestination' in scope\n 65 |         do {\n 66 |             // Check if destination exists\n 67 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 68 |                 throw LoggingError.destinationNotFound(\n 69 |                     \"Cannot rotate logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RotateLogsCommand.swift:74:37: error: cannot infer contextual base in reference to member 'file'\n 72 |             \n 73 |             // Check if the destination type supports rotation\n 74 |             if destination.type != .file {\n    |                                     `- error: cannot infer contextual base in reference to member 'file'\n 75 |                 throw LoggingError.invalidDestinationConfig(\n 76 |                     \"Log rotation is only supported for file destinations\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RotateLogsCommand.swift:92:112: error: type 'LogPrivacyLevel' has no member 'protected'\n 90 |                     context: operationContext,\n 91 |                     additionalMetadata: [\n 92 |                         \"rotatedFilePath\": (value: rotationResult.rotatedFilePath ?? \"unknown\", privacyLevel: .protected),\n    |                                                                                                                `- error: type 'LogPrivacyLevel' has no member 'protected'\n 93 |                         \"rotatedSizeBytes\": (value: String(rotationResult.rotatedSizeBytes ?? 0), privacyLevel: .public),\n 94 |                         \"rotatedEntryCount\": (value: String(rotationResult.rotatedEntryCount ?? 0), privacyLevel: .public)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/WriteLogCommand.swift:159:20: error: cannot find 'getAllDestinations' in scope\n157 |         if destinationIds.isEmpty {\n158 |             // Use all registered destinations\n159 |             return getAllDestinations().filter { $0.isEnabled }\n    |                    `- error: cannot find 'getAllDestinations' in scope\n160 |         } else {\n161 |             // Use specific destinations\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/WriteLogCommand.swift:165:38: error: cannot find 'getDestination' in scope\n163 |             \n164 |             for destinationId in destinationIds {\n165 |                 if let destination = getDestination(id: destinationId) {\n    |                                      `- error: cannot find 'getDestination' in scope\n166 |                     if destination.isEnabled {\n167 |                         result.append(destination)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/WriteLogCommand.swift:193:16: error: cannot find 'applyFilterRules' in scope\n191 |         \n192 |         // Apply filter rules if they exist\n193 |         return applyFilterRules(\n    |                `- error: cannot find 'applyFilterRules' in scope\n194 |             to: entry,\n195 |             rules: destination.configuration.filterRules\n\npackages/UmbraImplementations/Sources/LoggingServices/DefaultLoggingServiceImpl.swift:39:36: warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 37 |     let contextDTO=BaseLogContextDTO(\n 38 |       domainName: \"Legacy\",\n 39 |       operation: context.operation ?? \"unknown\",\n    |                                    `- warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 40 |       category: context.category ?? \"General\",\n 41 |       source: context.source ?? \"Unknown\",\n\npackages/UmbraImplementations/Sources/LoggingServices/DefaultLoggingServiceImpl.swift:40:34: warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 38 |       domainName: \"Legacy\",\n 39 |       operation: context.operation ?? \"unknown\",\n 40 |       category: context.category ?? \"General\",\n    |                                  `- warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 41 |       source: context.source ?? \"Unknown\",\n 42 |       metadata: context.metadata\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:147:17: error: invalid redeclaration of 'log(_:_:context:)'\n145 |         - context: The logging context\n146 |      */\n147 |     public func log(_ level: LogLevel, _ message: String, context: any LogContextDTO) async {\n    |                 `- error: invalid redeclaration of 'log(_:_:context:)'\n148 |         // Convert to privacy string and use privacy-aware logging\n149 |         let privacyString = PrivacyString(stringLiteral: message)\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:92:48: error: value of type 'any LoggingProviderProtocol' has no member 'writeLogEntry'\n 90 |                     do {\n 91 |                         // Write log entry to destination\n 92 |                         _ = try await provider.writeLogEntry(entry, to: destination)\n    |                                                `- error: value of type 'any LoggingProviderProtocol' has no member 'writeLogEntry'\n 93 |                     } catch {\n 94 |                         // Silently ignore provider errors for now\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:122:28: error: value of type 'PrivacyString' has no member 'privacy'\n120 |         enrichedMetadata = enrichedMetadata.withPrivate(\n121 |             key: \"__privacy_annotation\", \n122 |             value: message.privacy.description\n    |                            `- error: value of type 'PrivacyString' has no member 'privacy'\n123 |         )\n124 |         \n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:136:34: error: value of type 'PrivacyString' has no member 'content'\n134 |         \n135 |         // Log the message using the standard log method\n136 |         await log(level, message.content, context: privacyContext)\n    |                                  `- error: value of type 'PrivacyString' has no member 'content'\n137 |     }\n138 |     \n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:167:71: error: value of type 'PrivacyAnnotatedString' has no member 'stringValue'\n165 |     ) async {\n166 |         let annotatedString = privacyScope()\n167 |         await log(level, PrivacyString(stringLiteral: annotatedString.stringValue), context: context) \n    |                                                                       `- error: value of type 'PrivacyAnnotatedString' has no member 'stringValue'\n168 |     }\n169 |     \n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:190:29: error: for-in loop requires 'LogMetadata' to conform to 'Sequence'\n188 |         // Create a metadata collection with sensitive values\n189 |         var metadataCollection = context.metadata\n190 |         for (key, value) in sensitiveValues {\n    |                             `- error: for-in loop requires 'LogMetadata' to conform to 'Sequence'\n191 |             metadataCollection = metadataCollection.withSensitive(key: key, value: String(describing: value))\n192 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:228:9: error: switch must be exhaustive\n226 |         \n227 |         // Add error information to metadata with appropriate privacy level\n228 |         switch privacyLevel {\n    |         |- error: switch must be exhaustive\n    |         `- note: add missing case: '.auto'\n229 |         case .public:\n230 |             metadataCollection = metadataCollection.withPublic(key: \"error_description\", value: error.localizedDescription)\npackages/UmbraImplementations/Sources/LoggingServices/PrivacyAwareLogDTO.swift:217:24: error: value of type 'LogMetadataDTOCollection' has no member 'set'\n215 |     for key in self.metadata.getKeys() {\n216 |       if let value = self.metadata.getString(key: key) {\n217 |         mergedMetadata.set(key: key, value: value)\n    |                        `- error: value of type 'LogMetadataDTOCollection' has no member 'set'\n218 |       }\n219 |     }\n\npackages/UmbraImplementations/Sources/LoggingServices/PrivacyAwareLogDTO.swift:224:24: error: value of type 'LogMetadataDTOCollection' has no member 'set'\n222 |     for key in additionalMetadata.getKeys() {\n223 |       if let value = additionalMetadata.getString(key: key) {\n224 |         mergedMetadata.set(key: key, value: value)\n    |                        `- error: value of type 'LogMetadataDTOCollection' has no member 'set'\n225 |       }\n226 |     }\n\npackages/UmbraImplementations/Sources/LoggingServices/PrivacyAwareLogDTO.swift:235:17: error: cannot convert value of type 'LogMetadataDTOCollection' to expected argument type '[String : (value: Any, privacy: LogPrivacyLevel)]'\n233 |       category: category,\n234 |       correlationID: correlationID,\n235 |       metadata: mergedMetadata,\n    |                 `- error: cannot convert value of type 'LogMetadataDTOCollection' to expected argument type '[String : (value: Any, privacy: LogPrivacyLevel)]'\n236 |       environment: environment\n237 |     )\nTarget //packages/UmbraImplementations/Sources/SecurityCryptoServices/ProviderFactories:ProviderFactories failed to build\nINFO: Elapsed time: 1.128s, Critical Path: 1.00s\nINFO: 2 processes: 2 internal.\nERROR: Build did NOT complete successfully\n"
  },
  {
    "target": "rule //packages/UmbraImplementations/Sources/SecurityImplementation:SecurityImplementation",
    "success": false,
    "start_time": "2025-04-11T17:58:36.556491+01:00",
    "end_time": "2025-04-11T17:58:38.367228+01:00",
    "duration": "1.810739s",
    "output": "INFO: Invocation ID: 8d236c83-19be-4d22-a703-838e91719d09\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraImplementations/Sources/SecurityImplementation:SecurityImplementation (0 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraImplementations/Sources/SecurityImplementation:SecurityImplementation (0 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraImplementations/Sources/SecurityImplementation:SecurityImplementation (0 packages loaded, 0 targets configured).\nERROR: /Users/mpy/CascadeProjects/UmbraCore/packages/UmbraImplementations/Sources/LoggingServices/BUILD.bazel:3:20: Compiling Swift module //packages/UmbraImplementations/Sources/LoggingServices:LoggingServices failed: (Exit 1): worker failed: error executing SwiftCompile command (from target //packages/UmbraImplementations/Sources/LoggingServices:LoggingServices) \n  (cd /Users/mpy/.bazel/execroot/_main \u0026\u0026 \\\n  exec env - \\\n    APPLE_SDK_PLATFORM=MacOSX \\\n    APPLE_SDK_VERSION_OVERRIDE=15.4 \\\n    CC=clang \\\n    PATH=/Users/mpy/Library/Caches/bazelisk/downloads/sha256/ac72ad67f7a8c6b18bf605d8602425182b417de4369715bf89146daf62f7ae48/bin:/Users/mpy/.rbenv/bin:/Users/mpy/.codeium/windsurf/bin:/opt/homebrew/opt/node@18/bin:/opt/homebrew/opt/node@20/bin:/Users/mpy/.docker/bin:/opt/homebrew/opt/openjdk/bin:/Users/mpy/bin:/opt/homebrew/bin:/opt/homebrew/sbin:/usr/local/bin:/System/Cryptexes/App/usr/bin:/usr/bin:/bin:/usr/sbin:/sbin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/local/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/appleinternal/bin:/Library/Apple/usr/bin:/usr/local/go/bin:/Users/mpy/.rbenv/bin:/Users/mpy/.codeium/windsurf/bin:/opt/homebrew/opt/node@18/bin:/opt/homebrew/opt/node@20/bin:/opt/anaconda3/bin:/opt/anaconda3/condabin:/Users/mpy/.docker/bin:/opt/homebrew/opt/openjdk/bin:/Users/mpy/bin:/Users/mpy/.cargo/bin:/Users/mpy/Library/Python/3.8/bin:/Users/mpy/go/bin:/Users/mpy/.scripts:/Users/mpy/.fzf/bin:/Users/mpy/.windsurf/extensions/ms-python.debugpy-2025.6.0-darwin-arm64/bundled/scripts/noConfigScripts:/Users/mpy/Library/Python/3.8/bin:/Users/mpy/go/bin:/Users/mpy/.scripts \\\n    XCODE_VERSION_OVERRIDE=16.3.0.16E140 \\\n  bazel-out/darwin_arm64-opt-exec-ST-d57f47055a04/bin/external/rules_swift+/tools/worker/worker swiftc @bazel-out/darwin_arm64-fastbuild/bin/packages/UmbraImplementations/Sources/LoggingServices/LoggingServices.swiftmodule-0.params)\n# Configuration: 76a1bf3a80f2d50513004915454165d2f164db794b63e4666809cbd93e1abeaa\n# Execution platform: @@platforms//host:host\nerror: emit-module command failed with exit code 1 (use -v to see invocation)\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:147:17: error: invalid redeclaration of 'log(_:_:context:)'\n145 |         - context: The logging context\n146 |      */\n147 |     public func log(_ level: LogLevel, _ message: String, context: any LogContextDTO) async {\n    |                 `- error: invalid redeclaration of 'log(_:_:context:)'\n148 |         // Convert to privacy string and use privacy-aware logging\n149 |         let privacyString = PrivacyString(stringLiteral: message)\npackages/UmbraImplementations/Sources/LoggingServices/Commands/AddDestinationCommand.swift:68:31: error: cannot find 'getDestination' in scope\n 66 |         do {\n 67 |             // Check if destination already exists\n 68 |             if let existing = getDestination(id: destination.id) {\n    |                               `- error: cannot find 'getDestination' in scope\n 69 |                 if !options.overwriteExisting {\n 70 |                     throw LoggingError.destinationAlreadyExists(identifier: \"Destination with ID \\(destination.id) already exists\")\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/AddDestinationCommand.swift:82:40: error: cannot find 'validateDestination' in scope\n 80 |             // Validate destination configuration if requested\n 81 |             if options.validateConfiguration {\n 82 |                 let validationResult = validateDestination(destination, for: provider)\n    |                                        `- error: cannot find 'validateDestination' in scope\n 83 |                 \n 84 |                 if !validationResult.isValid {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/AddDestinationCommand.swift:121:13: error: expression is 'async' but is not marked with 'await'\n119 |             \n120 |             // Register the destination\n121 |             registerDestination(destination)\n    |             |- error: expression is 'async' but is not marked with 'await'\n    |             `- note: calls to instance method 'registerDestination' from outside of its actor context are implicitly asynchronous\n122 |             \n123 |             // Log success\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ArchiveLogsCommand.swift:57:84: error: type 'LogPrivacyLevel' has no member 'protected'\n 55 |             destinationId: destinationId,\n 56 |             additionalMetadata: [\n 57 |                 \"destinationPath\": (value: options.destinationPath, privacyLevel: .protected),\n    |                                                                                    `- error: type 'LogPrivacyLevel' has no member 'protected'\n 58 |                 \"compress\": (value: String(options.compress), privacyLevel: .public),\n 59 |                 \"format\": (value: options.format.rawValue, privacyLevel: .public),\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ArchiveLogsCommand.swift:70:37: error: cannot find 'getDestination' in scope\n 68 |         do {\n 69 |             // Check if destination exists\n 70 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 71 |                 throw LoggingError.destinationNotFound(\n 72 |                     \"Cannot archive logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ArchiveLogsCommand.swift:113:103: error: type 'LogPrivacyLevel' has no member 'protected'\n111 |                     context: operationContext,\n112 |                     additionalMetadata: [\n113 |                         \"archivePath\": (value: archiveResult.archivePath ?? \"unknown\", privacyLevel: .protected),\n    |                                                                                                       `- error: type 'LogPrivacyLevel' has no member 'protected'\n114 |                         \"archiveSizeBytes\": (value: String(archiveResult.archiveSizeBytes ?? 0), privacyLevel: .public),\n115 |                         \"archivedEntryCount\": (value: String(archiveResult.archivedEntryCount ?? 0), privacyLevel: .public)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ExportLogsCommand.swift:70:37: error: cannot find 'getDestination' in scope\n 68 |         do {\n 69 |             // Check if destination exists\n 70 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 71 |                 throw LoggingError.destinationNotFound(\n 72 |                     \"Cannot export logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:79:50: error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n 77 |                 key: key,\n 78 |                 value: value.value,\n 79 |                 privacyLevel: value.privacyLevel.toPrivacyClassification()\n    |                                                  `- error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n 80 |             )\n 81 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:122:54: error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n120 |                     key: key,\n121 |                     value: value.value,\n122 |                     privacyLevel: value.privacyLevel.toPrivacyClassification()\n    |                                                      `- error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n123 |                 )\n124 |             )\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:229:21: error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n227 |         \n228 |         // Process special fields first\n229 |         switch rule.field {\n    |                     `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n230 |         case \"level\":\n231 |             fieldValue = entry.level.rawValue\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:238:96: error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n236 |         default:\n237 |             // Check metadata fields\n238 |             if let metadata = entry.metadata, let metadataValue = metadata.getString(key: rule.field) {\n    |                                                                                                `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n239 |                 fieldValue = metadataValue\n240 |             } else {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:246:21: error: value of type 'UmbraLogFilterRuleDTO' has no member 'operation'\n244 |         \n245 |         // Apply the operation\n246 |         switch rule.operation {\n    |                     `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'operation'\n247 |         case .equals:\n248 |             return fieldValue == rule.value\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:248:39: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n246 |         switch rule.operation {\n247 |         case .equals:\n248 |             return fieldValue == rule.value\n    |                                       `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n249 |         case .contains:\n250 |             return fieldValue.contains(rule.value)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:250:45: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n248 |             return fieldValue == rule.value\n249 |         case .contains:\n250 |             return fieldValue.contains(rule.value)\n    |                                             `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n251 |         case .startsWith:\n252 |             return fieldValue.hasPrefix(rule.value)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:252:46: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n250 |             return fieldValue.contains(rule.value)\n251 |         case .startsWith:\n252 |             return fieldValue.hasPrefix(rule.value)\n    |                                              `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n253 |         case .endsWith:\n254 |             return fieldValue.hasSuffix(rule.value)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:254:46: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n252 |             return fieldValue.hasPrefix(rule.value)\n253 |         case .endsWith:\n254 |             return fieldValue.hasSuffix(rule.value)\n    |                                              `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n255 |         case .matches:\n256 |             if let regex = try? NSRegularExpression(pattern: rule.value) {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:256:67: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n254 |             return fieldValue.hasSuffix(rule.value)\n255 |         case .matches:\n256 |             if let regex = try? NSRegularExpression(pattern: rule.value) {\n    |                                                                   `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n257 |                 let range = NSRange(location: 0, length: fieldValue.utf16.count)\n258 |                 return regex.firstMatch(in: fieldValue, options: [], range: range) != nil\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:262:86: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n260 |             return false\n261 |         case .greaterThan:\n262 |             if let fieldNumeric = Double(fieldValue), let valueNumeric = Double(rule.value) {\n    |                                                                                      `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n263 |                 return fieldNumeric \u003e valueNumeric\n264 |             }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:267:86: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n265 |             return false\n266 |         case .lessThan:\n267 |             if let fieldNumeric = Double(fieldValue), let valueNumeric = Double(rule.value) {\n    |                                                                                      `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n268 |                 return fieldNumeric \u003c valueNumeric\n269 |             }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:293:13: warning: variable 'redactedMetadata' was never mutated; consider changing to 'let' constant\n291 |         // Create mutable copies\n292 |         var redactedMessage = entry.message\n293 |         var redactedMetadata = entry.metadata\n    |             `- warning: variable 'redactedMetadata' was never mutated; consider changing to 'let' constant\n294 |         \n295 |         for rule in rules {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:395:47: error: value of type 'String' has no member 'stringByReplacingMatches'\n393 |             if rule.targetFields.isEmpty || rule.targetFields.contains(\"message\") {\n394 |                 if let pattern = rule.pattern {\n395 |                     redactedMessage = pattern.stringByReplacingMatches(\n    |                                               `- error: value of type 'String' has no member 'stringByReplacingMatches'\n396 |                         in: redactedMessage,\n397 |                         options: [],\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:394:20: error: initializer for conditional binding must have Optional type, not 'String'\n392 |             // Apply rule to message if it matches\n393 |             if rule.targetFields.isEmpty || rule.targetFields.contains(\"message\") {\n394 |                 if let pattern = rule.pattern {\n    |                    `- error: initializer for conditional binding must have Optional type, not 'String'\n395 |                     redactedMessage = pattern.stringByReplacingMatches(\n396 |                         in: redactedMessage,\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:405:24: error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getKeys' of wrapped base type 'LogMetadataDTOCollection'\n403 |             \n404 |             // Process metadata fields\n405 |             for key in redactedMetadata.getKeys() {\n    |                        |- error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getKeys' of wrapped base type 'LogMetadataDTOCollection'\n    |                        |- note: chain the optional using '?' to access member 'getKeys' only for non-'nil' base values\n    |                        `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n406 |                 if rule.targetFields.isEmpty || rule.targetFields.contains(key) {\n407 |                     if let stringValue = redactedMetadata.getString(key: key) {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:407:42: error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getString' of wrapped base type 'LogMetadataDTOCollection'\n405 |             for key in redactedMetadata.getKeys() {\n406 |                 if rule.targetFields.isEmpty || rule.targetFields.contains(key) {\n407 |                     if let stringValue = redactedMetadata.getString(key: key) {\n    |                                          |- error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getString' of wrapped base type 'LogMetadataDTOCollection'\n    |                                          |- note: chain the optional using '?' to access member 'getString' only for non-'nil' base values\n    |                                          `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n408 |                         // Skip fields that should be preserved\n409 |                         if rule.preserveFields.contains(key) {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:468:15: error: type 'LogPrivacyLevel' has no member 'never'\n466 |         case .auto:\n467 |             return .auto\n468 |         case .never:\n    |               `- error: type 'LogPrivacyLevel' has no member 'never'\n469 |             return .public // Map 'never' to public classification\n470 |         case .protected:\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:470:15: error: type 'LogPrivacyLevel' has no member 'protected'\n468 |         case .never:\n469 |             return .public // Map 'never' to public classification\n470 |         case .protected:\n    |               `- error: type 'LogPrivacyLevel' has no member 'protected'\n471 |             return .private // Map 'protected' to private classification\n472 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:58:84: error: type 'LogPrivacyLevel' has no member 'protected'\n 56 |             additionalMetadata: [\n 57 |                 \"createBackup\": (value: String(options.createBackup), privacyLevel: .public),\n 58 |                 \"backupPath\": (value: options.backupPath ?? \"none\", privacyLevel: .protected),\n    |                                                                                    `- error: type 'LogPrivacyLevel' has no member 'protected'\n 59 |                 \"dryRun\": (value: String(options.dryRun), privacyLevel: .public),\n 60 |                 \"hasFilterCriteria\": (value: String(options.filterCriteria != nil), privacyLevel: .public),\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:184:34: error: cannot find 'getDestination' in scope\n182 |         if let destinationId = destinationId {\n183 |             // Use specific destination\n184 |             if let destination = getDestination(id: destinationId) {\n    |                                  `- error: cannot find 'getDestination' in scope\n185 |                 return [destination]\n186 |             } else {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:196:38: error: cannot find 'getDestination' in scope\n194 |             \n195 |             for id in options.destinationIds {\n196 |                 if let destination = getDestination(id: id) {\n    |                                      `- error: cannot find 'getDestination' in scope\n197 |                     result.append(destination)\n198 |                 } else {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:208:20: error: cannot find 'getAllDestinations' in scope\n206 |         } else {\n207 |             // Use all registered destinations\n208 |             return getAllDestinations()\n    |                    `- error: cannot find 'getAllDestinations' in scope\n209 |         }\n210 |     }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/QueryLogsCommand.swift:71:37: error: cannot find 'getDestination' in scope\n 69 |         do {\n 70 |             // Check if destination exists\n 71 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 72 |                 throw LoggingError.destinationNotFound(\n 73 |                     \"Cannot query logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RedactionRule.swift:123:72: error: missing argument for parameter 'privacyLevel' in call\n121 |                 if value != redactedValue {\n122 |                     // Only update if actually changed\n123 |                     result = result.with(key: key, value: redactedValue)\n    |                                                                        `- error: missing argument for parameter 'privacyLevel' in call\n124 |                 }\n125 |             }\n\n/Users/mpy/.bazel/execroot/_main/packages/UmbraCoreTypes/Sources/LoggingTypes/LogMetadataDTOCollection.swift:78:15: note: 'with(key:value:privacyLevel:)' declared here\n 76 |   ///   - privacyLevel: The privacy classification for this entry\n 77 |   /// - Returns: The updated collection\n 78 |   public func with(\n    |               `- note: 'with(key:value:privacyLevel:)' declared here\n 79 |     key: String,\n 80 |     value: String,\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RedactionRule.swift:101:26: warning: no calls to throwing functions occur within 'try' expression\n 99 |     public func redact(metadata: LogMetadataDTOCollection) -\u003e LogMetadataDTOCollection {\n100 |         // No redaction needed for empty metadata\n101 |         guard let keys = try? metadata.getKeys() else {\n    |                          `- warning: no calls to throwing functions occur within 'try' expression\n102 |             return metadata\n103 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RedactionRule.swift:119:28: warning: no calls to throwing functions occur within 'try' expression\n117 |             \n118 |             // Get string value and apply redaction\n119 |             if let value = try? metadata.getString(key: key) {\n    |                            `- warning: no calls to throwing functions occur within 'try' expression\n120 |                 let redactedValue = redact(value)\n121 |                 if value != redactedValue {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RemoveDestinationCommand.swift:67:37: error: cannot find 'getDestination' in scope\n 65 |         do {\n 66 |             // Check if destination exists\n 67 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 68 |                 throw LoggingError.destinationNotFound(\n 69 |                     \"Cannot remove destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RemoveDestinationCommand.swift:128:13: error: expression is 'async' but is not marked with 'await'\n126 |             \n127 |             // Unregister the destination\n128 |             unregisterDestination(id: destinationId)\n    |             |- error: expression is 'async' but is not marked with 'await'\n    |             `- note: calls to instance method 'unregisterDestination(id:)' from outside of its actor context are implicitly asynchronous\n129 |             \n130 |             // Log success\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RotateLogsCommand.swift:67:37: error: cannot find 'getDestination' in scope\n 65 |         do {\n 66 |             // Check if destination exists\n 67 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 68 |                 throw LoggingError.destinationNotFound(\n 69 |                     \"Cannot rotate logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RotateLogsCommand.swift:74:37: error: cannot infer contextual base in reference to member 'file'\n 72 |             \n 73 |             // Check if the destination type supports rotation\n 74 |             if destination.type != .file {\n    |                                     `- error: cannot infer contextual base in reference to member 'file'\n 75 |                 throw LoggingError.invalidDestinationConfig(\n 76 |                     \"Log rotation is only supported for file destinations\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RotateLogsCommand.swift:92:112: error: type 'LogPrivacyLevel' has no member 'protected'\n 90 |                     context: operationContext,\n 91 |                     additionalMetadata: [\n 92 |                         \"rotatedFilePath\": (value: rotationResult.rotatedFilePath ?? \"unknown\", privacyLevel: .protected),\n    |                                                                                                                `- error: type 'LogPrivacyLevel' has no member 'protected'\n 93 |                         \"rotatedSizeBytes\": (value: String(rotationResult.rotatedSizeBytes ?? 0), privacyLevel: .public),\n 94 |                         \"rotatedEntryCount\": (value: String(rotationResult.rotatedEntryCount ?? 0), privacyLevel: .public)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/WriteLogCommand.swift:159:20: error: cannot find 'getAllDestinations' in scope\n157 |         if destinationIds.isEmpty {\n158 |             // Use all registered destinations\n159 |             return getAllDestinations().filter { $0.isEnabled }\n    |                    `- error: cannot find 'getAllDestinations' in scope\n160 |         } else {\n161 |             // Use specific destinations\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/WriteLogCommand.swift:165:38: error: cannot find 'getDestination' in scope\n163 |             \n164 |             for destinationId in destinationIds {\n165 |                 if let destination = getDestination(id: destinationId) {\n    |                                      `- error: cannot find 'getDestination' in scope\n166 |                     if destination.isEnabled {\n167 |                         result.append(destination)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/WriteLogCommand.swift:193:16: error: cannot find 'applyFilterRules' in scope\n191 |         \n192 |         // Apply filter rules if they exist\n193 |         return applyFilterRules(\n    |                `- error: cannot find 'applyFilterRules' in scope\n194 |             to: entry,\n195 |             rules: destination.configuration.filterRules\n\npackages/UmbraImplementations/Sources/LoggingServices/DefaultLoggingServiceImpl.swift:39:36: warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 37 |     let contextDTO=BaseLogContextDTO(\n 38 |       domainName: \"Legacy\",\n 39 |       operation: context.operation ?? \"unknown\",\n    |                                    `- warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 40 |       category: context.category ?? \"General\",\n 41 |       source: context.source ?? \"Unknown\",\n\npackages/UmbraImplementations/Sources/LoggingServices/DefaultLoggingServiceImpl.swift:40:34: warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 38 |       domainName: \"Legacy\",\n 39 |       operation: context.operation ?? \"unknown\",\n 40 |       category: context.category ?? \"General\",\n    |                                  `- warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 41 |       source: context.source ?? \"Unknown\",\n 42 |       metadata: context.metadata\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:147:17: error: invalid redeclaration of 'log(_:_:context:)'\n145 |         - context: The logging context\n146 |      */\n147 |     public func log(_ level: LogLevel, _ message: String, context: any LogContextDTO) async {\n    |                 `- error: invalid redeclaration of 'log(_:_:context:)'\n148 |         // Convert to privacy string and use privacy-aware logging\n149 |         let privacyString = PrivacyString(stringLiteral: message)\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:92:48: error: value of type 'any LoggingProviderProtocol' has no member 'writeLogEntry'\n 90 |                     do {\n 91 |                         // Write log entry to destination\n 92 |                         _ = try await provider.writeLogEntry(entry, to: destination)\n    |                                                `- error: value of type 'any LoggingProviderProtocol' has no member 'writeLogEntry'\n 93 |                     } catch {\n 94 |                         // Silently ignore provider errors for now\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:122:28: error: value of type 'PrivacyString' has no member 'privacy'\n120 |         enrichedMetadata = enrichedMetadata.withPrivate(\n121 |             key: \"__privacy_annotation\", \n122 |             value: message.privacy.description\n    |                            `- error: value of type 'PrivacyString' has no member 'privacy'\n123 |         )\n124 |         \n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:136:34: error: value of type 'PrivacyString' has no member 'content'\n134 |         \n135 |         // Log the message using the standard log method\n136 |         await log(level, message.content, context: privacyContext)\n    |                                  `- error: value of type 'PrivacyString' has no member 'content'\n137 |     }\n138 |     \n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:167:71: error: value of type 'PrivacyAnnotatedString' has no member 'stringValue'\n165 |     ) async {\n166 |         let annotatedString = privacyScope()\n167 |         await log(level, PrivacyString(stringLiteral: annotatedString.stringValue), context: context) \n    |                                                                       `- error: value of type 'PrivacyAnnotatedString' has no member 'stringValue'\n168 |     }\n169 |     \n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:190:29: error: for-in loop requires 'LogMetadata' to conform to 'Sequence'\n188 |         // Create a metadata collection with sensitive values\n189 |         var metadataCollection = context.metadata\n190 |         for (key, value) in sensitiveValues {\n    |                             `- error: for-in loop requires 'LogMetadata' to conform to 'Sequence'\n191 |             metadataCollection = metadataCollection.withSensitive(key: key, value: String(describing: value))\n192 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:228:9: error: switch must be exhaustive\n226 |         \n227 |         // Add error information to metadata with appropriate privacy level\n228 |         switch privacyLevel {\n    |         |- error: switch must be exhaustive\n    |         `- note: add missing case: '.auto'\n229 |         case .public:\n230 |             metadataCollection = metadataCollection.withPublic(key: \"error_description\", value: error.localizedDescription)\npackages/UmbraImplementations/Sources/LoggingServices/PrivacyAwareLogDTO.swift:217:24: error: value of type 'LogMetadataDTOCollection' has no member 'set'\n215 |     for key in self.metadata.getKeys() {\n216 |       if let value = self.metadata.getString(key: key) {\n217 |         mergedMetadata.set(key: key, value: value)\n    |                        `- error: value of type 'LogMetadataDTOCollection' has no member 'set'\n218 |       }\n219 |     }\n\npackages/UmbraImplementations/Sources/LoggingServices/PrivacyAwareLogDTO.swift:224:24: error: value of type 'LogMetadataDTOCollection' has no member 'set'\n222 |     for key in additionalMetadata.getKeys() {\n223 |       if let value = additionalMetadata.getString(key: key) {\n224 |         mergedMetadata.set(key: key, value: value)\n    |                        `- error: value of type 'LogMetadataDTOCollection' has no member 'set'\n225 |       }\n226 |     }\n\npackages/UmbraImplementations/Sources/LoggingServices/PrivacyAwareLogDTO.swift:235:17: error: cannot convert value of type 'LogMetadataDTOCollection' to expected argument type '[String : (value: Any, privacy: LogPrivacyLevel)]'\n233 |       category: category,\n234 |       correlationID: correlationID,\n235 |       metadata: mergedMetadata,\n    |                 `- error: cannot convert value of type 'LogMetadataDTOCollection' to expected argument type '[String : (value: Any, privacy: LogPrivacyLevel)]'\n236 |       environment: environment\n237 |     )\nTarget //packages/UmbraImplementations/Sources/SecurityImplementation:SecurityImplementation failed to build\nINFO: Elapsed time: 1.117s, Critical Path: 0.99s\nINFO: 2 processes: 2 internal.\nERROR: Build did NOT complete successfully\n"
  },
  {
    "target": "rule //packages/UmbraImplementations/Sources/SecurityKeyManagement:SecurityKeyManagement",
    "success": false,
    "start_time": "2025-04-11T17:58:38.36724+01:00",
    "end_time": "2025-04-11T17:58:40.60531+01:00",
    "duration": "2.238072125s",
    "output": "INFO: Invocation ID: 1bf0b44e-39a8-4e4d-a1e3-c561bf754aac\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraImplementations/Sources/SecurityKeyManagement:SecurityKeyManagement (0 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraImplementations/Sources/SecurityKeyManagement:SecurityKeyManagement (0 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraImplementations/Sources/SecurityKeyManagement:SecurityKeyManagement (0 packages loaded, 0 targets configured).\nERROR: /Users/mpy/CascadeProjects/UmbraCore/packages/UmbraImplementations/Sources/LoggingServices/BUILD.bazel:3:20: Compiling Swift module //packages/UmbraImplementations/Sources/LoggingServices:LoggingServices failed: (Exit 1): worker failed: error executing SwiftCompile command (from target //packages/UmbraImplementations/Sources/LoggingServices:LoggingServices) \n  (cd /Users/mpy/.bazel/execroot/_main \u0026\u0026 \\\n  exec env - \\\n    APPLE_SDK_PLATFORM=MacOSX \\\n    APPLE_SDK_VERSION_OVERRIDE=15.4 \\\n    CC=clang \\\n    PATH=/Users/mpy/Library/Caches/bazelisk/downloads/sha256/ac72ad67f7a8c6b18bf605d8602425182b417de4369715bf89146daf62f7ae48/bin:/Users/mpy/.rbenv/bin:/Users/mpy/.codeium/windsurf/bin:/opt/homebrew/opt/node@18/bin:/opt/homebrew/opt/node@20/bin:/Users/mpy/.docker/bin:/opt/homebrew/opt/openjdk/bin:/Users/mpy/bin:/opt/homebrew/bin:/opt/homebrew/sbin:/usr/local/bin:/System/Cryptexes/App/usr/bin:/usr/bin:/bin:/usr/sbin:/sbin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/local/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/appleinternal/bin:/Library/Apple/usr/bin:/usr/local/go/bin:/Users/mpy/.rbenv/bin:/Users/mpy/.codeium/windsurf/bin:/opt/homebrew/opt/node@18/bin:/opt/homebrew/opt/node@20/bin:/opt/anaconda3/bin:/opt/anaconda3/condabin:/Users/mpy/.docker/bin:/opt/homebrew/opt/openjdk/bin:/Users/mpy/bin:/Users/mpy/.cargo/bin:/Users/mpy/Library/Python/3.8/bin:/Users/mpy/go/bin:/Users/mpy/.scripts:/Users/mpy/.fzf/bin:/Users/mpy/.windsurf/extensions/ms-python.debugpy-2025.6.0-darwin-arm64/bundled/scripts/noConfigScripts:/Users/mpy/Library/Python/3.8/bin:/Users/mpy/go/bin:/Users/mpy/.scripts \\\n    XCODE_VERSION_OVERRIDE=16.3.0.16E140 \\\n  bazel-out/darwin_arm64-opt-exec-ST-d57f47055a04/bin/external/rules_swift+/tools/worker/worker swiftc @bazel-out/darwin_arm64-fastbuild/bin/packages/UmbraImplementations/Sources/LoggingServices/LoggingServices.swiftmodule-0.params)\n# Configuration: 76a1bf3a80f2d50513004915454165d2f164db794b63e4666809cbd93e1abeaa\n# Execution platform: @@platforms//host:host\nerror: emit-module command failed with exit code 1 (use -v to see invocation)\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:147:17: error: invalid redeclaration of 'log(_:_:context:)'\n145 |         - context: The logging context\n146 |      */\n147 |     public func log(_ level: LogLevel, _ message: String, context: any LogContextDTO) async {\n    |                 `- error: invalid redeclaration of 'log(_:_:context:)'\n148 |         // Convert to privacy string and use privacy-aware logging\n149 |         let privacyString = PrivacyString(stringLiteral: message)\npackages/UmbraImplementations/Sources/LoggingServices/Commands/AddDestinationCommand.swift:68:31: error: cannot find 'getDestination' in scope\n 66 |         do {\n 67 |             // Check if destination already exists\n 68 |             if let existing = getDestination(id: destination.id) {\n    |                               `- error: cannot find 'getDestination' in scope\n 69 |                 if !options.overwriteExisting {\n 70 |                     throw LoggingError.destinationAlreadyExists(identifier: \"Destination with ID \\(destination.id) already exists\")\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/AddDestinationCommand.swift:82:40: error: cannot find 'validateDestination' in scope\n 80 |             // Validate destination configuration if requested\n 81 |             if options.validateConfiguration {\n 82 |                 let validationResult = validateDestination(destination, for: provider)\n    |                                        `- error: cannot find 'validateDestination' in scope\n 83 |                 \n 84 |                 if !validationResult.isValid {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/AddDestinationCommand.swift:121:13: error: expression is 'async' but is not marked with 'await'\n119 |             \n120 |             // Register the destination\n121 |             registerDestination(destination)\n    |             |- error: expression is 'async' but is not marked with 'await'\n    |             `- note: calls to instance method 'registerDestination' from outside of its actor context are implicitly asynchronous\n122 |             \n123 |             // Log success\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ArchiveLogsCommand.swift:57:84: error: type 'LogPrivacyLevel' has no member 'protected'\n 55 |             destinationId: destinationId,\n 56 |             additionalMetadata: [\n 57 |                 \"destinationPath\": (value: options.destinationPath, privacyLevel: .protected),\n    |                                                                                    `- error: type 'LogPrivacyLevel' has no member 'protected'\n 58 |                 \"compress\": (value: String(options.compress), privacyLevel: .public),\n 59 |                 \"format\": (value: options.format.rawValue, privacyLevel: .public),\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ArchiveLogsCommand.swift:70:37: error: cannot find 'getDestination' in scope\n 68 |         do {\n 69 |             // Check if destination exists\n 70 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 71 |                 throw LoggingError.destinationNotFound(\n 72 |                     \"Cannot archive logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ArchiveLogsCommand.swift:113:103: error: type 'LogPrivacyLevel' has no member 'protected'\n111 |                     context: operationContext,\n112 |                     additionalMetadata: [\n113 |                         \"archivePath\": (value: archiveResult.archivePath ?? \"unknown\", privacyLevel: .protected),\n    |                                                                                                       `- error: type 'LogPrivacyLevel' has no member 'protected'\n114 |                         \"archiveSizeBytes\": (value: String(archiveResult.archiveSizeBytes ?? 0), privacyLevel: .public),\n115 |                         \"archivedEntryCount\": (value: String(archiveResult.archivedEntryCount ?? 0), privacyLevel: .public)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ExportLogsCommand.swift:70:37: error: cannot find 'getDestination' in scope\n 68 |         do {\n 69 |             // Check if destination exists\n 70 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 71 |                 throw LoggingError.destinationNotFound(\n 72 |                     \"Cannot export logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:79:50: error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n 77 |                 key: key,\n 78 |                 value: value.value,\n 79 |                 privacyLevel: value.privacyLevel.toPrivacyClassification()\n    |                                                  `- error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n 80 |             )\n 81 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:122:54: error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n120 |                     key: key,\n121 |                     value: value.value,\n122 |                     privacyLevel: value.privacyLevel.toPrivacyClassification()\n    |                                                      `- error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n123 |                 )\n124 |             )\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:229:21: error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n227 |         \n228 |         // Process special fields first\n229 |         switch rule.field {\n    |                     `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n230 |         case \"level\":\n231 |             fieldValue = entry.level.rawValue\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:238:96: error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n236 |         default:\n237 |             // Check metadata fields\n238 |             if let metadata = entry.metadata, let metadataValue = metadata.getString(key: rule.field) {\n    |                                                                                                `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n239 |                 fieldValue = metadataValue\n240 |             } else {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:246:21: error: value of type 'UmbraLogFilterRuleDTO' has no member 'operation'\n244 |         \n245 |         // Apply the operation\n246 |         switch rule.operation {\n    |                     `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'operation'\n247 |         case .equals:\n248 |             return fieldValue == rule.value\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:248:39: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n246 |         switch rule.operation {\n247 |         case .equals:\n248 |             return fieldValue == rule.value\n    |                                       `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n249 |         case .contains:\n250 |             return fieldValue.contains(rule.value)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:250:45: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n248 |             return fieldValue == rule.value\n249 |         case .contains:\n250 |             return fieldValue.contains(rule.value)\n    |                                             `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n251 |         case .startsWith:\n252 |             return fieldValue.hasPrefix(rule.value)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:252:46: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n250 |             return fieldValue.contains(rule.value)\n251 |         case .startsWith:\n252 |             return fieldValue.hasPrefix(rule.value)\n    |                                              `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n253 |         case .endsWith:\n254 |             return fieldValue.hasSuffix(rule.value)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:254:46: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n252 |             return fieldValue.hasPrefix(rule.value)\n253 |         case .endsWith:\n254 |             return fieldValue.hasSuffix(rule.value)\n    |                                              `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n255 |         case .matches:\n256 |             if let regex = try? NSRegularExpression(pattern: rule.value) {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:256:67: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n254 |             return fieldValue.hasSuffix(rule.value)\n255 |         case .matches:\n256 |             if let regex = try? NSRegularExpression(pattern: rule.value) {\n    |                                                                   `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n257 |                 let range = NSRange(location: 0, length: fieldValue.utf16.count)\n258 |                 return regex.firstMatch(in: fieldValue, options: [], range: range) != nil\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:262:86: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n260 |             return false\n261 |         case .greaterThan:\n262 |             if let fieldNumeric = Double(fieldValue), let valueNumeric = Double(rule.value) {\n    |                                                                                      `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n263 |                 return fieldNumeric \u003e valueNumeric\n264 |             }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:267:86: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n265 |             return false\n266 |         case .lessThan:\n267 |             if let fieldNumeric = Double(fieldValue), let valueNumeric = Double(rule.value) {\n    |                                                                                      `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n268 |                 return fieldNumeric \u003c valueNumeric\n269 |             }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:293:13: warning: variable 'redactedMetadata' was never mutated; consider changing to 'let' constant\n291 |         // Create mutable copies\n292 |         var redactedMessage = entry.message\n293 |         var redactedMetadata = entry.metadata\n    |             `- warning: variable 'redactedMetadata' was never mutated; consider changing to 'let' constant\n294 |         \n295 |         for rule in rules {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:395:47: error: value of type 'String' has no member 'stringByReplacingMatches'\n393 |             if rule.targetFields.isEmpty || rule.targetFields.contains(\"message\") {\n394 |                 if let pattern = rule.pattern {\n395 |                     redactedMessage = pattern.stringByReplacingMatches(\n    |                                               `- error: value of type 'String' has no member 'stringByReplacingMatches'\n396 |                         in: redactedMessage,\n397 |                         options: [],\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:394:20: error: initializer for conditional binding must have Optional type, not 'String'\n392 |             // Apply rule to message if it matches\n393 |             if rule.targetFields.isEmpty || rule.targetFields.contains(\"message\") {\n394 |                 if let pattern = rule.pattern {\n    |                    `- error: initializer for conditional binding must have Optional type, not 'String'\n395 |                     redactedMessage = pattern.stringByReplacingMatches(\n396 |                         in: redactedMessage,\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:405:24: error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getKeys' of wrapped base type 'LogMetadataDTOCollection'\n403 |             \n404 |             // Process metadata fields\n405 |             for key in redactedMetadata.getKeys() {\n    |                        |- error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getKeys' of wrapped base type 'LogMetadataDTOCollection'\n    |                        |- note: chain the optional using '?' to access member 'getKeys' only for non-'nil' base values\n    |                        `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n406 |                 if rule.targetFields.isEmpty || rule.targetFields.contains(key) {\n407 |                     if let stringValue = redactedMetadata.getString(key: key) {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:407:42: error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getString' of wrapped base type 'LogMetadataDTOCollection'\n405 |             for key in redactedMetadata.getKeys() {\n406 |                 if rule.targetFields.isEmpty || rule.targetFields.contains(key) {\n407 |                     if let stringValue = redactedMetadata.getString(key: key) {\n    |                                          |- error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getString' of wrapped base type 'LogMetadataDTOCollection'\n    |                                          |- note: chain the optional using '?' to access member 'getString' only for non-'nil' base values\n    |                                          `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n408 |                         // Skip fields that should be preserved\n409 |                         if rule.preserveFields.contains(key) {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:468:15: error: type 'LogPrivacyLevel' has no member 'never'\n466 |         case .auto:\n467 |             return .auto\n468 |         case .never:\n    |               `- error: type 'LogPrivacyLevel' has no member 'never'\n469 |             return .public // Map 'never' to public classification\n470 |         case .protected:\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:470:15: error: type 'LogPrivacyLevel' has no member 'protected'\n468 |         case .never:\n469 |             return .public // Map 'never' to public classification\n470 |         case .protected:\n    |               `- error: type 'LogPrivacyLevel' has no member 'protected'\n471 |             return .private // Map 'protected' to private classification\n472 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:58:84: error: type 'LogPrivacyLevel' has no member 'protected'\n 56 |             additionalMetadata: [\n 57 |                 \"createBackup\": (value: String(options.createBackup), privacyLevel: .public),\n 58 |                 \"backupPath\": (value: options.backupPath ?? \"none\", privacyLevel: .protected),\n    |                                                                                    `- error: type 'LogPrivacyLevel' has no member 'protected'\n 59 |                 \"dryRun\": (value: String(options.dryRun), privacyLevel: .public),\n 60 |                 \"hasFilterCriteria\": (value: String(options.filterCriteria != nil), privacyLevel: .public),\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:184:34: error: cannot find 'getDestination' in scope\n182 |         if let destinationId = destinationId {\n183 |             // Use specific destination\n184 |             if let destination = getDestination(id: destinationId) {\n    |                                  `- error: cannot find 'getDestination' in scope\n185 |                 return [destination]\n186 |             } else {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:196:38: error: cannot find 'getDestination' in scope\n194 |             \n195 |             for id in options.destinationIds {\n196 |                 if let destination = getDestination(id: id) {\n    |                                      `- error: cannot find 'getDestination' in scope\n197 |                     result.append(destination)\n198 |                 } else {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:208:20: error: cannot find 'getAllDestinations' in scope\n206 |         } else {\n207 |             // Use all registered destinations\n208 |             return getAllDestinations()\n    |                    `- error: cannot find 'getAllDestinations' in scope\n209 |         }\n210 |     }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/QueryLogsCommand.swift:71:37: error: cannot find 'getDestination' in scope\n 69 |         do {\n 70 |             // Check if destination exists\n 71 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 72 |                 throw LoggingError.destinationNotFound(\n 73 |                     \"Cannot query logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RedactionRule.swift:123:72: error: missing argument for parameter 'privacyLevel' in call\n121 |                 if value != redactedValue {\n122 |                     // Only update if actually changed\n123 |                     result = result.with(key: key, value: redactedValue)\n    |                                                                        `- error: missing argument for parameter 'privacyLevel' in call\n124 |                 }\n125 |             }\n\n/Users/mpy/.bazel/execroot/_main/packages/UmbraCoreTypes/Sources/LoggingTypes/LogMetadataDTOCollection.swift:78:15: note: 'with(key:value:privacyLevel:)' declared here\n 76 |   ///   - privacyLevel: The privacy classification for this entry\n 77 |   /// - Returns: The updated collection\n 78 |   public func with(\n    |               `- note: 'with(key:value:privacyLevel:)' declared here\n 79 |     key: String,\n 80 |     value: String,\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RedactionRule.swift:101:26: warning: no calls to throwing functions occur within 'try' expression\n 99 |     public func redact(metadata: LogMetadataDTOCollection) -\u003e LogMetadataDTOCollection {\n100 |         // No redaction needed for empty metadata\n101 |         guard let keys = try? metadata.getKeys() else {\n    |                          `- warning: no calls to throwing functions occur within 'try' expression\n102 |             return metadata\n103 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RedactionRule.swift:119:28: warning: no calls to throwing functions occur within 'try' expression\n117 |             \n118 |             // Get string value and apply redaction\n119 |             if let value = try? metadata.getString(key: key) {\n    |                            `- warning: no calls to throwing functions occur within 'try' expression\n120 |                 let redactedValue = redact(value)\n121 |                 if value != redactedValue {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RemoveDestinationCommand.swift:67:37: error: cannot find 'getDestination' in scope\n 65 |         do {\n 66 |             // Check if destination exists\n 67 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 68 |                 throw LoggingError.destinationNotFound(\n 69 |                     \"Cannot remove destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RemoveDestinationCommand.swift:128:13: error: expression is 'async' but is not marked with 'await'\n126 |             \n127 |             // Unregister the destination\n128 |             unregisterDestination(id: destinationId)\n    |             |- error: expression is 'async' but is not marked with 'await'\n    |             `- note: calls to instance method 'unregisterDestination(id:)' from outside of its actor context are implicitly asynchronous\n129 |             \n130 |             // Log success\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RotateLogsCommand.swift:67:37: error: cannot find 'getDestination' in scope\n 65 |         do {\n 66 |             // Check if destination exists\n 67 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 68 |                 throw LoggingError.destinationNotFound(\n 69 |                     \"Cannot rotate logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RotateLogsCommand.swift:74:37: error: cannot infer contextual base in reference to member 'file'\n 72 |             \n 73 |             // Check if the destination type supports rotation\n 74 |             if destination.type != .file {\n    |                                     `- error: cannot infer contextual base in reference to member 'file'\n 75 |                 throw LoggingError.invalidDestinationConfig(\n 76 |                     \"Log rotation is only supported for file destinations\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RotateLogsCommand.swift:92:112: error: type 'LogPrivacyLevel' has no member 'protected'\n 90 |                     context: operationContext,\n 91 |                     additionalMetadata: [\n 92 |                         \"rotatedFilePath\": (value: rotationResult.rotatedFilePath ?? \"unknown\", privacyLevel: .protected),\n    |                                                                                                                `- error: type 'LogPrivacyLevel' has no member 'protected'\n 93 |                         \"rotatedSizeBytes\": (value: String(rotationResult.rotatedSizeBytes ?? 0), privacyLevel: .public),\n 94 |                         \"rotatedEntryCount\": (value: String(rotationResult.rotatedEntryCount ?? 0), privacyLevel: .public)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/WriteLogCommand.swift:159:20: error: cannot find 'getAllDestinations' in scope\n157 |         if destinationIds.isEmpty {\n158 |             // Use all registered destinations\n159 |             return getAllDestinations().filter { $0.isEnabled }\n    |                    `- error: cannot find 'getAllDestinations' in scope\n160 |         } else {\n161 |             // Use specific destinations\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/WriteLogCommand.swift:165:38: error: cannot find 'getDestination' in scope\n163 |             \n164 |             for destinationId in destinationIds {\n165 |                 if let destination = getDestination(id: destinationId) {\n    |                                      `- error: cannot find 'getDestination' in scope\n166 |                     if destination.isEnabled {\n167 |                         result.append(destination)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/WriteLogCommand.swift:193:16: error: cannot find 'applyFilterRules' in scope\n191 |         \n192 |         // Apply filter rules if they exist\n193 |         return applyFilterRules(\n    |                `- error: cannot find 'applyFilterRules' in scope\n194 |             to: entry,\n195 |             rules: destination.configuration.filterRules\n\npackages/UmbraImplementations/Sources/LoggingServices/DefaultLoggingServiceImpl.swift:39:36: warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 37 |     let contextDTO=BaseLogContextDTO(\n 38 |       domainName: \"Legacy\",\n 39 |       operation: context.operation ?? \"unknown\",\n    |                                    `- warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 40 |       category: context.category ?? \"General\",\n 41 |       source: context.source ?? \"Unknown\",\n\npackages/UmbraImplementations/Sources/LoggingServices/DefaultLoggingServiceImpl.swift:40:34: warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 38 |       domainName: \"Legacy\",\n 39 |       operation: context.operation ?? \"unknown\",\n 40 |       category: context.category ?? \"General\",\n    |                                  `- warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 41 |       source: context.source ?? \"Unknown\",\n 42 |       metadata: context.metadata\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:147:17: error: invalid redeclaration of 'log(_:_:context:)'\n145 |         - context: The logging context\n146 |      */\n147 |     public func log(_ level: LogLevel, _ message: String, context: any LogContextDTO) async {\n    |                 `- error: invalid redeclaration of 'log(_:_:context:)'\n148 |         // Convert to privacy string and use privacy-aware logging\n149 |         let privacyString = PrivacyString(stringLiteral: message)\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:92:48: error: value of type 'any LoggingProviderProtocol' has no member 'writeLogEntry'\n 90 |                     do {\n 91 |                         // Write log entry to destination\n 92 |                         _ = try await provider.writeLogEntry(entry, to: destination)\n    |                                                `- error: value of type 'any LoggingProviderProtocol' has no member 'writeLogEntry'\n 93 |                     } catch {\n 94 |                         // Silently ignore provider errors for now\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:122:28: error: value of type 'PrivacyString' has no member 'privacy'\n120 |         enrichedMetadata = enrichedMetadata.withPrivate(\n121 |             key: \"__privacy_annotation\", \n122 |             value: message.privacy.description\n    |                            `- error: value of type 'PrivacyString' has no member 'privacy'\n123 |         )\n124 |         \n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:136:34: error: value of type 'PrivacyString' has no member 'content'\n134 |         \n135 |         // Log the message using the standard log method\n136 |         await log(level, message.content, context: privacyContext)\n    |                                  `- error: value of type 'PrivacyString' has no member 'content'\n137 |     }\n138 |     \n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:167:71: error: value of type 'PrivacyAnnotatedString' has no member 'stringValue'\n165 |     ) async {\n166 |         let annotatedString = privacyScope()\n167 |         await log(level, PrivacyString(stringLiteral: annotatedString.stringValue), context: context) \n    |                                                                       `- error: value of type 'PrivacyAnnotatedString' has no member 'stringValue'\n168 |     }\n169 |     \n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:190:29: error: for-in loop requires 'LogMetadata' to conform to 'Sequence'\n188 |         // Create a metadata collection with sensitive values\n189 |         var metadataCollection = context.metadata\n190 |         for (key, value) in sensitiveValues {\n    |                             `- error: for-in loop requires 'LogMetadata' to conform to 'Sequence'\n191 |             metadataCollection = metadataCollection.withSensitive(key: key, value: String(describing: value))\n192 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:228:9: error: switch must be exhaustive\n226 |         \n227 |         // Add error information to metadata with appropriate privacy level\n228 |         switch privacyLevel {\n    |         |- error: switch must be exhaustive\n    |         `- note: add missing case: '.auto'\n229 |         case .public:\n230 |             metadataCollection = metadataCollection.withPublic(key: \"error_description\", value: error.localizedDescription)\npackages/UmbraImplementations/Sources/LoggingServices/PrivacyAwareLogDTO.swift:217:24: error: value of type 'LogMetadataDTOCollection' has no member 'set'\n215 |     for key in self.metadata.getKeys() {\n216 |       if let value = self.metadata.getString(key: key) {\n217 |         mergedMetadata.set(key: key, value: value)\n    |                        `- error: value of type 'LogMetadataDTOCollection' has no member 'set'\n218 |       }\n219 |     }\n\npackages/UmbraImplementations/Sources/LoggingServices/PrivacyAwareLogDTO.swift:224:24: error: value of type 'LogMetadataDTOCollection' has no member 'set'\n222 |     for key in additionalMetadata.getKeys() {\n223 |       if let value = additionalMetadata.getString(key: key) {\n224 |         mergedMetadata.set(key: key, value: value)\n    |                        `- error: value of type 'LogMetadataDTOCollection' has no member 'set'\n225 |       }\n226 |     }\n\npackages/UmbraImplementations/Sources/LoggingServices/PrivacyAwareLogDTO.swift:235:17: error: cannot convert value of type 'LogMetadataDTOCollection' to expected argument type '[String : (value: Any, privacy: LogPrivacyLevel)]'\n233 |       category: category,\n234 |       correlationID: correlationID,\n235 |       metadata: mergedMetadata,\n    |                 `- error: cannot convert value of type 'LogMetadataDTOCollection' to expected argument type '[String : (value: Any, privacy: LogPrivacyLevel)]'\n236 |       environment: environment\n237 |     )\nTarget //packages/UmbraImplementations/Sources/SecurityKeyManagement:SecurityKeyManagement failed to build\nINFO: Elapsed time: 1.120s, Critical Path: 1.00s\nINFO: 2 processes: 2 internal.\nERROR: Build did NOT complete successfully\n"
  },
  {
    "target": "rule //packages/UmbraImplementations/Sources/SecurityKeyManagement/Actor:KeyManagementActor",
    "success": false,
    "start_time": "2025-04-11T17:58:40.605324+01:00",
    "end_time": "2025-04-11T17:58:42.46774+01:00",
    "duration": "1.862417625s",
    "output": "INFO: Invocation ID: 58cc421b-5794-415b-83b4-9b505733343f\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraImplementations/Sources/SecurityKeyManagement/Actor:KeyManagementActor (1 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraImplementations/Sources/SecurityKeyManagement/Actor:KeyManagementActor (1 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraImplementations/Sources/SecurityKeyManagement/Actor:KeyManagementActor (2 packages loaded, 4 targets configured).\nERROR: /Users/mpy/CascadeProjects/UmbraCore/packages/UmbraImplementations/Sources/LoggingServices/BUILD.bazel:3:20: Compiling Swift module //packages/UmbraImplementations/Sources/LoggingServices:LoggingServices failed: (Exit 1): worker failed: error executing SwiftCompile command (from target //packages/UmbraImplementations/Sources/LoggingServices:LoggingServices) \n  (cd /Users/mpy/.bazel/execroot/_main \u0026\u0026 \\\n  exec env - \\\n    APPLE_SDK_PLATFORM=MacOSX \\\n    APPLE_SDK_VERSION_OVERRIDE=15.4 \\\n    CC=clang \\\n    PATH=/Users/mpy/Library/Caches/bazelisk/downloads/sha256/ac72ad67f7a8c6b18bf605d8602425182b417de4369715bf89146daf62f7ae48/bin:/Users/mpy/.rbenv/bin:/Users/mpy/.codeium/windsurf/bin:/opt/homebrew/opt/node@18/bin:/opt/homebrew/opt/node@20/bin:/Users/mpy/.docker/bin:/opt/homebrew/opt/openjdk/bin:/Users/mpy/bin:/opt/homebrew/bin:/opt/homebrew/sbin:/usr/local/bin:/System/Cryptexes/App/usr/bin:/usr/bin:/bin:/usr/sbin:/sbin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/local/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/appleinternal/bin:/Library/Apple/usr/bin:/usr/local/go/bin:/Users/mpy/.rbenv/bin:/Users/mpy/.codeium/windsurf/bin:/opt/homebrew/opt/node@18/bin:/opt/homebrew/opt/node@20/bin:/opt/anaconda3/bin:/opt/anaconda3/condabin:/Users/mpy/.docker/bin:/opt/homebrew/opt/openjdk/bin:/Users/mpy/bin:/Users/mpy/.cargo/bin:/Users/mpy/Library/Python/3.8/bin:/Users/mpy/go/bin:/Users/mpy/.scripts:/Users/mpy/.fzf/bin:/Users/mpy/.windsurf/extensions/ms-python.debugpy-2025.6.0-darwin-arm64/bundled/scripts/noConfigScripts:/Users/mpy/Library/Python/3.8/bin:/Users/mpy/go/bin:/Users/mpy/.scripts \\\n    XCODE_VERSION_OVERRIDE=16.3.0.16E140 \\\n  bazel-out/darwin_arm64-opt-exec-ST-d57f47055a04/bin/external/rules_swift+/tools/worker/worker swiftc @bazel-out/darwin_arm64-fastbuild/bin/packages/UmbraImplementations/Sources/LoggingServices/LoggingServices.swiftmodule-0.params)\n# Configuration: 76a1bf3a80f2d50513004915454165d2f164db794b63e4666809cbd93e1abeaa\n# Execution platform: @@platforms//host:host\nerror: emit-module command failed with exit code 1 (use -v to see invocation)\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:147:17: error: invalid redeclaration of 'log(_:_:context:)'\n145 |         - context: The logging context\n146 |      */\n147 |     public func log(_ level: LogLevel, _ message: String, context: any LogContextDTO) async {\n    |                 `- error: invalid redeclaration of 'log(_:_:context:)'\n148 |         // Convert to privacy string and use privacy-aware logging\n149 |         let privacyString = PrivacyString(stringLiteral: message)\npackages/UmbraImplementations/Sources/LoggingServices/Commands/AddDestinationCommand.swift:68:31: error: cannot find 'getDestination' in scope\n 66 |         do {\n 67 |             // Check if destination already exists\n 68 |             if let existing = getDestination(id: destination.id) {\n    |                               `- error: cannot find 'getDestination' in scope\n 69 |                 if !options.overwriteExisting {\n 70 |                     throw LoggingError.destinationAlreadyExists(identifier: \"Destination with ID \\(destination.id) already exists\")\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/AddDestinationCommand.swift:82:40: error: cannot find 'validateDestination' in scope\n 80 |             // Validate destination configuration if requested\n 81 |             if options.validateConfiguration {\n 82 |                 let validationResult = validateDestination(destination, for: provider)\n    |                                        `- error: cannot find 'validateDestination' in scope\n 83 |                 \n 84 |                 if !validationResult.isValid {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/AddDestinationCommand.swift:121:13: error: expression is 'async' but is not marked with 'await'\n119 |             \n120 |             // Register the destination\n121 |             registerDestination(destination)\n    |             |- error: expression is 'async' but is not marked with 'await'\n    |             `- note: calls to instance method 'registerDestination' from outside of its actor context are implicitly asynchronous\n122 |             \n123 |             // Log success\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ArchiveLogsCommand.swift:57:84: error: type 'LogPrivacyLevel' has no member 'protected'\n 55 |             destinationId: destinationId,\n 56 |             additionalMetadata: [\n 57 |                 \"destinationPath\": (value: options.destinationPath, privacyLevel: .protected),\n    |                                                                                    `- error: type 'LogPrivacyLevel' has no member 'protected'\n 58 |                 \"compress\": (value: String(options.compress), privacyLevel: .public),\n 59 |                 \"format\": (value: options.format.rawValue, privacyLevel: .public),\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ArchiveLogsCommand.swift:70:37: error: cannot find 'getDestination' in scope\n 68 |         do {\n 69 |             // Check if destination exists\n 70 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 71 |                 throw LoggingError.destinationNotFound(\n 72 |                     \"Cannot archive logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ArchiveLogsCommand.swift:113:103: error: type 'LogPrivacyLevel' has no member 'protected'\n111 |                     context: operationContext,\n112 |                     additionalMetadata: [\n113 |                         \"archivePath\": (value: archiveResult.archivePath ?? \"unknown\", privacyLevel: .protected),\n    |                                                                                                       `- error: type 'LogPrivacyLevel' has no member 'protected'\n114 |                         \"archiveSizeBytes\": (value: String(archiveResult.archiveSizeBytes ?? 0), privacyLevel: .public),\n115 |                         \"archivedEntryCount\": (value: String(archiveResult.archivedEntryCount ?? 0), privacyLevel: .public)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/ExportLogsCommand.swift:70:37: error: cannot find 'getDestination' in scope\n 68 |         do {\n 69 |             // Check if destination exists\n 70 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 71 |                 throw LoggingError.destinationNotFound(\n 72 |                     \"Cannot export logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:79:50: error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n 77 |                 key: key,\n 78 |                 value: value.value,\n 79 |                 privacyLevel: value.privacyLevel.toPrivacyClassification()\n    |                                                  `- error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n 80 |             )\n 81 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:122:54: error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n120 |                     key: key,\n121 |                     value: value.value,\n122 |                     privacyLevel: value.privacyLevel.toPrivacyClassification()\n    |                                                      `- error: value of type 'LogPrivacyLevel' has no member 'toPrivacyClassification'\n123 |                 )\n124 |             )\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:229:21: error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n227 |         \n228 |         // Process special fields first\n229 |         switch rule.field {\n    |                     `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n230 |         case \"level\":\n231 |             fieldValue = entry.level.rawValue\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:238:96: error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n236 |         default:\n237 |             // Check metadata fields\n238 |             if let metadata = entry.metadata, let metadataValue = metadata.getString(key: rule.field) {\n    |                                                                                                `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'field'\n239 |                 fieldValue = metadataValue\n240 |             } else {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:246:21: error: value of type 'UmbraLogFilterRuleDTO' has no member 'operation'\n244 |         \n245 |         // Apply the operation\n246 |         switch rule.operation {\n    |                     `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'operation'\n247 |         case .equals:\n248 |             return fieldValue == rule.value\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:248:39: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n246 |         switch rule.operation {\n247 |         case .equals:\n248 |             return fieldValue == rule.value\n    |                                       `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n249 |         case .contains:\n250 |             return fieldValue.contains(rule.value)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:250:45: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n248 |             return fieldValue == rule.value\n249 |         case .contains:\n250 |             return fieldValue.contains(rule.value)\n    |                                             `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n251 |         case .startsWith:\n252 |             return fieldValue.hasPrefix(rule.value)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:252:46: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n250 |             return fieldValue.contains(rule.value)\n251 |         case .startsWith:\n252 |             return fieldValue.hasPrefix(rule.value)\n    |                                              `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n253 |         case .endsWith:\n254 |             return fieldValue.hasSuffix(rule.value)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:254:46: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n252 |             return fieldValue.hasPrefix(rule.value)\n253 |         case .endsWith:\n254 |             return fieldValue.hasSuffix(rule.value)\n    |                                              `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n255 |         case .matches:\n256 |             if let regex = try? NSRegularExpression(pattern: rule.value) {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:256:67: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n254 |             return fieldValue.hasSuffix(rule.value)\n255 |         case .matches:\n256 |             if let regex = try? NSRegularExpression(pattern: rule.value) {\n    |                                                                   `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n257 |                 let range = NSRange(location: 0, length: fieldValue.utf16.count)\n258 |                 return regex.firstMatch(in: fieldValue, options: [], range: range) != nil\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:262:86: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n260 |             return false\n261 |         case .greaterThan:\n262 |             if let fieldNumeric = Double(fieldValue), let valueNumeric = Double(rule.value) {\n    |                                                                                      `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n263 |                 return fieldNumeric \u003e valueNumeric\n264 |             }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:267:86: error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n265 |             return false\n266 |         case .lessThan:\n267 |             if let fieldNumeric = Double(fieldValue), let valueNumeric = Double(rule.value) {\n    |                                                                                      `- error: value of type 'UmbraLogFilterRuleDTO' has no member 'value'\n268 |                 return fieldNumeric \u003c valueNumeric\n269 |             }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:293:13: warning: variable 'redactedMetadata' was never mutated; consider changing to 'let' constant\n291 |         // Create mutable copies\n292 |         var redactedMessage = entry.message\n293 |         var redactedMetadata = entry.metadata\n    |             `- warning: variable 'redactedMetadata' was never mutated; consider changing to 'let' constant\n294 |         \n295 |         for rule in rules {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:395:47: error: value of type 'String' has no member 'stringByReplacingMatches'\n393 |             if rule.targetFields.isEmpty || rule.targetFields.contains(\"message\") {\n394 |                 if let pattern = rule.pattern {\n395 |                     redactedMessage = pattern.stringByReplacingMatches(\n    |                                               `- error: value of type 'String' has no member 'stringByReplacingMatches'\n396 |                         in: redactedMessage,\n397 |                         options: [],\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:394:20: error: initializer for conditional binding must have Optional type, not 'String'\n392 |             // Apply rule to message if it matches\n393 |             if rule.targetFields.isEmpty || rule.targetFields.contains(\"message\") {\n394 |                 if let pattern = rule.pattern {\n    |                    `- error: initializer for conditional binding must have Optional type, not 'String'\n395 |                     redactedMessage = pattern.stringByReplacingMatches(\n396 |                         in: redactedMessage,\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:405:24: error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getKeys' of wrapped base type 'LogMetadataDTOCollection'\n403 |             \n404 |             // Process metadata fields\n405 |             for key in redactedMetadata.getKeys() {\n    |                        |- error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getKeys' of wrapped base type 'LogMetadataDTOCollection'\n    |                        |- note: chain the optional using '?' to access member 'getKeys' only for non-'nil' base values\n    |                        `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n406 |                 if rule.targetFields.isEmpty || rule.targetFields.contains(key) {\n407 |                     if let stringValue = redactedMetadata.getString(key: key) {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:407:42: error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getString' of wrapped base type 'LogMetadataDTOCollection'\n405 |             for key in redactedMetadata.getKeys() {\n406 |                 if rule.targetFields.isEmpty || rule.targetFields.contains(key) {\n407 |                     if let stringValue = redactedMetadata.getString(key: key) {\n    |                                          |- error: value of optional type 'LogMetadataDTOCollection?' must be unwrapped to refer to member 'getString' of wrapped base type 'LogMetadataDTOCollection'\n    |                                          |- note: chain the optional using '?' to access member 'getString' only for non-'nil' base values\n    |                                          `- note: force-unwrap using '!' to abort execution if the optional value contains 'nil'\n408 |                         // Skip fields that should be preserved\n409 |                         if rule.preserveFields.contains(key) {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:468:15: error: type 'LogPrivacyLevel' has no member 'never'\n466 |         case .auto:\n467 |             return .auto\n468 |         case .never:\n    |               `- error: type 'LogPrivacyLevel' has no member 'never'\n469 |             return .public // Map 'never' to public classification\n470 |         case .protected:\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/LogCommand.swift:470:15: error: type 'LogPrivacyLevel' has no member 'protected'\n468 |         case .never:\n469 |             return .public // Map 'never' to public classification\n470 |         case .protected:\n    |               `- error: type 'LogPrivacyLevel' has no member 'protected'\n471 |             return .private // Map 'protected' to private classification\n472 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:58:84: error: type 'LogPrivacyLevel' has no member 'protected'\n 56 |             additionalMetadata: [\n 57 |                 \"createBackup\": (value: String(options.createBackup), privacyLevel: .public),\n 58 |                 \"backupPath\": (value: options.backupPath ?? \"none\", privacyLevel: .protected),\n    |                                                                                    `- error: type 'LogPrivacyLevel' has no member 'protected'\n 59 |                 \"dryRun\": (value: String(options.dryRun), privacyLevel: .public),\n 60 |                 \"hasFilterCriteria\": (value: String(options.filterCriteria != nil), privacyLevel: .public),\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:184:34: error: cannot find 'getDestination' in scope\n182 |         if let destinationId = destinationId {\n183 |             // Use specific destination\n184 |             if let destination = getDestination(id: destinationId) {\n    |                                  `- error: cannot find 'getDestination' in scope\n185 |                 return [destination]\n186 |             } else {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:196:38: error: cannot find 'getDestination' in scope\n194 |             \n195 |             for id in options.destinationIds {\n196 |                 if let destination = getDestination(id: id) {\n    |                                      `- error: cannot find 'getDestination' in scope\n197 |                     result.append(destination)\n198 |                 } else {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/PurgeLogsCommand.swift:208:20: error: cannot find 'getAllDestinations' in scope\n206 |         } else {\n207 |             // Use all registered destinations\n208 |             return getAllDestinations()\n    |                    `- error: cannot find 'getAllDestinations' in scope\n209 |         }\n210 |     }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/QueryLogsCommand.swift:71:37: error: cannot find 'getDestination' in scope\n 69 |         do {\n 70 |             // Check if destination exists\n 71 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 72 |                 throw LoggingError.destinationNotFound(\n 73 |                     \"Cannot query logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RedactionRule.swift:123:72: error: missing argument for parameter 'privacyLevel' in call\n121 |                 if value != redactedValue {\n122 |                     // Only update if actually changed\n123 |                     result = result.with(key: key, value: redactedValue)\n    |                                                                        `- error: missing argument for parameter 'privacyLevel' in call\n124 |                 }\n125 |             }\n\n/Users/mpy/.bazel/execroot/_main/packages/UmbraCoreTypes/Sources/LoggingTypes/LogMetadataDTOCollection.swift:78:15: note: 'with(key:value:privacyLevel:)' declared here\n 76 |   ///   - privacyLevel: The privacy classification for this entry\n 77 |   /// - Returns: The updated collection\n 78 |   public func with(\n    |               `- note: 'with(key:value:privacyLevel:)' declared here\n 79 |     key: String,\n 80 |     value: String,\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RedactionRule.swift:101:26: warning: no calls to throwing functions occur within 'try' expression\n 99 |     public func redact(metadata: LogMetadataDTOCollection) -\u003e LogMetadataDTOCollection {\n100 |         // No redaction needed for empty metadata\n101 |         guard let keys = try? metadata.getKeys() else {\n    |                          `- warning: no calls to throwing functions occur within 'try' expression\n102 |             return metadata\n103 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RedactionRule.swift:119:28: warning: no calls to throwing functions occur within 'try' expression\n117 |             \n118 |             // Get string value and apply redaction\n119 |             if let value = try? metadata.getString(key: key) {\n    |                            `- warning: no calls to throwing functions occur within 'try' expression\n120 |                 let redactedValue = redact(value)\n121 |                 if value != redactedValue {\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RemoveDestinationCommand.swift:67:37: error: cannot find 'getDestination' in scope\n 65 |         do {\n 66 |             // Check if destination exists\n 67 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 68 |                 throw LoggingError.destinationNotFound(\n 69 |                     \"Cannot remove destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RemoveDestinationCommand.swift:128:13: error: expression is 'async' but is not marked with 'await'\n126 |             \n127 |             // Unregister the destination\n128 |             unregisterDestination(id: destinationId)\n    |             |- error: expression is 'async' but is not marked with 'await'\n    |             `- note: calls to instance method 'unregisterDestination(id:)' from outside of its actor context are implicitly asynchronous\n129 |             \n130 |             // Log success\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RotateLogsCommand.swift:67:37: error: cannot find 'getDestination' in scope\n 65 |         do {\n 66 |             // Check if destination exists\n 67 |             guard let destination = getDestination(id: destinationId) else {\n    |                                     `- error: cannot find 'getDestination' in scope\n 68 |                 throw LoggingError.destinationNotFound(\n 69 |                     \"Cannot rotate logs for destination with ID \\(destinationId): not found\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RotateLogsCommand.swift:74:37: error: cannot infer contextual base in reference to member 'file'\n 72 |             \n 73 |             // Check if the destination type supports rotation\n 74 |             if destination.type != .file {\n    |                                     `- error: cannot infer contextual base in reference to member 'file'\n 75 |                 throw LoggingError.invalidDestinationConfig(\n 76 |                     \"Log rotation is only supported for file destinations\"\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/RotateLogsCommand.swift:92:112: error: type 'LogPrivacyLevel' has no member 'protected'\n 90 |                     context: operationContext,\n 91 |                     additionalMetadata: [\n 92 |                         \"rotatedFilePath\": (value: rotationResult.rotatedFilePath ?? \"unknown\", privacyLevel: .protected),\n    |                                                                                                                `- error: type 'LogPrivacyLevel' has no member 'protected'\n 93 |                         \"rotatedSizeBytes\": (value: String(rotationResult.rotatedSizeBytes ?? 0), privacyLevel: .public),\n 94 |                         \"rotatedEntryCount\": (value: String(rotationResult.rotatedEntryCount ?? 0), privacyLevel: .public)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/WriteLogCommand.swift:159:20: error: cannot find 'getAllDestinations' in scope\n157 |         if destinationIds.isEmpty {\n158 |             // Use all registered destinations\n159 |             return getAllDestinations().filter { $0.isEnabled }\n    |                    `- error: cannot find 'getAllDestinations' in scope\n160 |         } else {\n161 |             // Use specific destinations\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/WriteLogCommand.swift:165:38: error: cannot find 'getDestination' in scope\n163 |             \n164 |             for destinationId in destinationIds {\n165 |                 if let destination = getDestination(id: destinationId) {\n    |                                      `- error: cannot find 'getDestination' in scope\n166 |                     if destination.isEnabled {\n167 |                         result.append(destination)\n\npackages/UmbraImplementations/Sources/LoggingServices/Commands/WriteLogCommand.swift:193:16: error: cannot find 'applyFilterRules' in scope\n191 |         \n192 |         // Apply filter rules if they exist\n193 |         return applyFilterRules(\n    |                `- error: cannot find 'applyFilterRules' in scope\n194 |             to: entry,\n195 |             rules: destination.configuration.filterRules\n\npackages/UmbraImplementations/Sources/LoggingServices/DefaultLoggingServiceImpl.swift:39:36: warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 37 |     let contextDTO=BaseLogContextDTO(\n 38 |       domainName: \"Legacy\",\n 39 |       operation: context.operation ?? \"unknown\",\n    |                                    `- warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 40 |       category: context.category ?? \"General\",\n 41 |       source: context.source ?? \"Unknown\",\n\npackages/UmbraImplementations/Sources/LoggingServices/DefaultLoggingServiceImpl.swift:40:34: warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 38 |       domainName: \"Legacy\",\n 39 |       operation: context.operation ?? \"unknown\",\n 40 |       category: context.category ?? \"General\",\n    |                                  `- warning: left side of nil coalescing operator '??' has non-optional type 'String', so the right side is never used\n 41 |       source: context.source ?? \"Unknown\",\n 42 |       metadata: context.metadata\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:147:17: error: invalid redeclaration of 'log(_:_:context:)'\n145 |         - context: The logging context\n146 |      */\n147 |     public func log(_ level: LogLevel, _ message: String, context: any LogContextDTO) async {\n    |                 `- error: invalid redeclaration of 'log(_:_:context:)'\n148 |         // Convert to privacy string and use privacy-aware logging\n149 |         let privacyString = PrivacyString(stringLiteral: message)\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:92:48: error: value of type 'any LoggingProviderProtocol' has no member 'writeLogEntry'\n 90 |                     do {\n 91 |                         // Write log entry to destination\n 92 |                         _ = try await provider.writeLogEntry(entry, to: destination)\n    |                                                `- error: value of type 'any LoggingProviderProtocol' has no member 'writeLogEntry'\n 93 |                     } catch {\n 94 |                         // Silently ignore provider errors for now\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:122:28: error: value of type 'PrivacyString' has no member 'privacy'\n120 |         enrichedMetadata = enrichedMetadata.withPrivate(\n121 |             key: \"__privacy_annotation\", \n122 |             value: message.privacy.description\n    |                            `- error: value of type 'PrivacyString' has no member 'privacy'\n123 |         )\n124 |         \n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:136:34: error: value of type 'PrivacyString' has no member 'content'\n134 |         \n135 |         // Log the message using the standard log method\n136 |         await log(level, message.content, context: privacyContext)\n    |                                  `- error: value of type 'PrivacyString' has no member 'content'\n137 |     }\n138 |     \n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:167:71: error: value of type 'PrivacyAnnotatedString' has no member 'stringValue'\n165 |     ) async {\n166 |         let annotatedString = privacyScope()\n167 |         await log(level, PrivacyString(stringLiteral: annotatedString.stringValue), context: context) \n    |                                                                       `- error: value of type 'PrivacyAnnotatedString' has no member 'stringValue'\n168 |     }\n169 |     \n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:190:29: error: for-in loop requires 'LogMetadata' to conform to 'Sequence'\n188 |         // Create a metadata collection with sensitive values\n189 |         var metadataCollection = context.metadata\n190 |         for (key, value) in sensitiveValues {\n    |                             `- error: for-in loop requires 'LogMetadata' to conform to 'Sequence'\n191 |             metadataCollection = metadataCollection.withSensitive(key: key, value: String(describing: value))\n192 |         }\n\npackages/UmbraImplementations/Sources/LoggingServices/Implementation/LoggingServicesActor.swift:228:9: error: switch must be exhaustive\n226 |         \n227 |         // Add error information to metadata with appropriate privacy level\n228 |         switch privacyLevel {\n    |         |- error: switch must be exhaustive\n    |         `- note: add missing case: '.auto'\n229 |         case .public:\n230 |             metadataCollection = metadataCollection.withPublic(key: \"error_description\", value: error.localizedDescription)\npackages/UmbraImplementations/Sources/LoggingServices/PrivacyAwareLogDTO.swift:217:24: error: value of type 'LogMetadataDTOCollection' has no member 'set'\n215 |     for key in self.metadata.getKeys() {\n216 |       if let value = self.metadata.getString(key: key) {\n217 |         mergedMetadata.set(key: key, value: value)\n    |                        `- error: value of type 'LogMetadataDTOCollection' has no member 'set'\n218 |       }\n219 |     }\n\npackages/UmbraImplementations/Sources/LoggingServices/PrivacyAwareLogDTO.swift:224:24: error: value of type 'LogMetadataDTOCollection' has no member 'set'\n222 |     for key in additionalMetadata.getKeys() {\n223 |       if let value = additionalMetadata.getString(key: key) {\n224 |         mergedMetadata.set(key: key, value: value)\n    |                        `- error: value of type 'LogMetadataDTOCollection' has no member 'set'\n225 |       }\n226 |     }\n\npackages/UmbraImplementations/Sources/LoggingServices/PrivacyAwareLogDTO.swift:235:17: error: cannot convert value of type 'LogMetadataDTOCollection' to expected argument type '[String : (value: Any, privacy: LogPrivacyLevel)]'\n233 |       category: category,\n234 |       correlationID: correlationID,\n235 |       metadata: mergedMetadata,\n    |                 `- error: cannot convert value of type 'LogMetadataDTOCollection' to expected argument type '[String : (value: Any, privacy: LogPrivacyLevel)]'\n236 |       environment: environment\n237 |     )\nTarget //packages/UmbraImplementations/Sources/SecurityKeyManagement/Actor:KeyManagementActor failed to build\nINFO: Elapsed time: 1.140s, Critical Path: 1.01s\nINFO: 3 processes: 2 action cache hit, 2 internal, 1 worker.\nERROR: Build did NOT complete successfully\n"
  },
  {
    "target": "rule //packages/UmbraImplementations/Sources/SecurityKeyManagement/ActorTypes:KeyManagementActorTypes",
    "success": true,
    "start_time": "2025-04-11T17:58:42.467753+01:00",
    "end_time": "2025-04-11T17:58:43.311535+01:00",
    "duration": "843.783125ms",
    "output": "INFO: Invocation ID: ce525ceb-f999-447c-8283-457dd3c36c0a\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraImplementations/Sources/SecurityKeyManagement/ActorTypes:KeyManagementActorTypes (0 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraImplementations/Sources/SecurityKeyManagement/ActorTypes:KeyManagementActorTypes (0 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraImplementations/Sources/SecurityKeyManagement/ActorTypes:KeyManagementActorTypes (0 packages loaded, 0 targets configured).\nINFO: Found 1 target...\nTarget //packages/UmbraImplementations/Sources/SecurityKeyManagement/ActorTypes:KeyManagementActorTypes up-to-date:\n  bazel-bin/packages/UmbraImplementations/Sources/SecurityKeyManagement/ActorTypes/KeyManagementActorTypes.swiftdoc\n  bazel-bin/packages/UmbraImplementations/Sources/SecurityKeyManagement/ActorTypes/KeyManagementActorTypes.swiftmodule\n  bazel-bin/packages/UmbraImplementations/Sources/SecurityKeyManagement/ActorTypes/KeyManagementActorTypes.swiftsourceinfo\n  bazel-bin/packages/UmbraImplementations/Sources/SecurityKeyManagement/ActorTypes/libKeyManagementActorTypes.a\nINFO: Elapsed time: 0.117s, Critical Path: 0.00s\nINFO: 1 process: 1 action cache hit, 1 internal.\nINFO: Build completed successfully, 1 total action\n"
  },
  {
    "target": "rule //packages/UmbraImplementations/Sources/SecurityKeyManagement/Storage:KeyStorage",
    "success": true,
    "start_time": "2025-04-11T17:58:43.311547+01:00",
    "end_time": "2025-04-11T17:58:44.148326+01:00",
    "duration": "836.779875ms",
    "output": "INFO: Invocation ID: e76a0875-4647-4d75-9751-c09209b87783\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraImplementations/Sources/SecurityKeyManagement/Storage:KeyStorage (0 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraImplementations/Sources/SecurityKeyManagement/Storage:KeyStorage (0 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraImplementations/Sources/SecurityKeyManagement/Storage:KeyStorage (0 packages loaded, 0 targets configured).\nINFO: Found 1 target...\nTarget //packages/UmbraImplementations/Sources/SecurityKeyManagement/Storage:KeyStorage up-to-date:\n  bazel-bin/packages/UmbraImplementations/Sources/SecurityKeyManagement/Storage/KeyStorage.swiftdoc\n  bazel-bin/packages/UmbraImplementations/Sources/SecurityKeyManagement/Storage/KeyStorage.swiftmodule\n  bazel-bin/packages/UmbraImplementations/Sources/SecurityKeyManagement/Storage/KeyStorage.swiftsourceinfo\n  bazel-bin/packages/UmbraImplementations/Sources/SecurityKeyManagement/Storage/libKeyStorage.a\nINFO: Elapsed time: 0.118s, Critical Path: 0.00s\nINFO: 1 process: 1 action cache hit, 1 internal.\nINFO: Build completed successfully, 1 total action\n"
  },
  {
    "target": "rule //packages/UmbraImplementations/Sources/SecurityKeyManagement/Types:SecurityKeyTypes",
    "success": true,
    "start_time": "2025-04-11T17:58:44.148345+01:00",
    "end_time": "2025-04-11T17:58:44.980127+01:00",
    "duration": "831.782792ms",
    "output": "INFO: Invocation ID: cbf10049-7a2e-4942-8186-39598b88d289\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraImplementations/Sources/SecurityKeyManagement/Types:SecurityKeyTypes (0 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraImplementations/Sources/SecurityKeyManagement/Types:SecurityKeyTypes (0 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraImplementations/Sources/SecurityKeyManagement/Types:SecurityKeyTypes (0 packages loaded, 0 targets configured).\nINFO: Found 1 target...\nTarget //packages/UmbraImplementations/Sources/SecurityKeyManagement/Types:SecurityKeyTypes up-to-date:\n  bazel-bin/packages/UmbraImplementations/Sources/SecurityKeyManagement/Types/SecurityKeyTypes.swiftdoc\n  bazel-bin/packages/UmbraImplementations/Sources/SecurityKeyManagement/Types/SecurityKeyTypes.swiftmodule\n  bazel-bin/packages/UmbraImplementations/Sources/SecurityKeyManagement/Types/SecurityKeyTypes.swiftsourceinfo\n  bazel-bin/packages/UmbraImplementations/Sources/SecurityKeyManagement/Types/libSecurityKeyTypes.a\nINFO: Elapsed time: 0.125s, Critical Path: 0.00s\nINFO: 1 process: 1 action cache hit, 1 internal.\nINFO: Build completed successfully, 1 total action\n"
  },
  {
    "target": "rule //packages/UmbraImplementations/Sources/SecurityProviders:SecurityProviders",
    "success": true,
    "start_time": "2025-04-11T17:58:44.980134+01:00",
    "end_time": "2025-04-11T17:58:45.850293+01:00",
    "duration": "870.16025ms",
    "output": "INFO: Invocation ID: f00b6644-9c82-48f5-8b34-21087a82f8e8\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraImplementations/Sources/SecurityProviders:SecurityProviders (0 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraImplementations/Sources/SecurityProviders:SecurityProviders (0 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraImplementations/Sources/SecurityProviders:SecurityProviders (0 packages loaded, 0 targets configured).\nINFO: Found 1 target...\nTarget //packages/UmbraImplementations/Sources/SecurityProviders:SecurityProviders up-to-date:\n  bazel-bin/packages/UmbraImplementations/Sources/SecurityProviders/SecurityProviders.swiftdoc\n  bazel-bin/packages/UmbraImplementations/Sources/SecurityProviders/SecurityProviders.swiftmodule\n  bazel-bin/packages/UmbraImplementations/Sources/SecurityProviders/SecurityProviders.swiftsourceinfo\n  bazel-bin/packages/UmbraImplementations/Sources/SecurityProviders/libSecurityProviders.a\nINFO: Elapsed time: 0.156s, Critical Path: 0.03s\nINFO: 2 processes: 1 internal, 1 local.\nINFO: Build completed successfully, 2 total actions\n"
  },
  {
    "target": "rule //packages/UmbraImplementations/Sources/SecurityUtils:SecurityUtils",
    "success": true,
    "start_time": "2025-04-11T17:58:45.850299+01:00",
    "end_time": "2025-04-11T17:58:46.673356+01:00",
    "duration": "823.057833ms",
    "output": "INFO: Invocation ID: ca1155a6-1e40-4a53-8285-e1e63caa7861\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraImplementations/Sources/SecurityUtils:SecurityUtils (0 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraImplementations/Sources/SecurityUtils:SecurityUtils (0 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraImplementations/Sources/SecurityUtils:SecurityUtils (0 packages loaded, 0 targets configured).\nINFO: Found 1 target...\nTarget //packages/UmbraImplementations/Sources/SecurityUtils:SecurityUtils up-to-date:\n  bazel-bin/packages/UmbraImplementations/Sources/SecurityUtils/SecurityUtils.swiftdoc\n  bazel-bin/packages/UmbraImplementations/Sources/SecurityUtils/SecurityUtils.swiftmodule\n  bazel-bin/packages/UmbraImplementations/Sources/SecurityUtils/SecurityUtils.swiftsourceinfo\n  bazel-bin/packages/UmbraImplementations/Sources/SecurityUtils/libSecurityUtils.a\nINFO: Elapsed time: 0.130s, Critical Path: 0.00s\nINFO: 2 processes: 1 disk cache hit, 1 internal.\nINFO: Build completed successfully, 2 total actions\n"
  },
  {
    "target": "rule //packages/UmbraImplementations/Sources/XPCServices:XPCServices",
    "success": true,
    "start_time": "2025-04-11T17:58:46.673368+01:00",
    "end_time": "2025-04-11T17:58:47.505028+01:00",
    "duration": "831.661125ms",
    "output": "INFO: Invocation ID: 39226104-9962-41f7-ac7d-3ecda69459d6\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraImplementations/Sources/XPCServices:XPCServices (0 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraImplementations/Sources/XPCServices:XPCServices (0 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraImplementations/Sources/XPCServices:XPCServices (0 packages loaded, 0 targets configured).\nINFO: Found 1 target...\nTarget //packages/UmbraImplementations/Sources/XPCServices:XPCServices up-to-date:\n  bazel-bin/packages/UmbraImplementations/Sources/XPCServices/XPCServices.swiftdoc\n  bazel-bin/packages/UmbraImplementations/Sources/XPCServices/XPCServices.swiftmodule\n  bazel-bin/packages/UmbraImplementations/Sources/XPCServices/XPCServices.swiftsourceinfo\n  bazel-bin/packages/UmbraImplementations/Sources/XPCServices/libXPCServices.a\nINFO: Elapsed time: 0.148s, Critical Path: 0.03s\nINFO: 2 processes: 1 internal, 1 local.\nINFO: Build completed successfully, 2 total actions\n"
  },
  {
    "target": "rule //packages/UmbraInterfaces:UmbraInterfaces",
    "success": false,
    "start_time": "2025-04-11T17:58:47.505035+01:00",
    "end_time": "2025-04-11T17:58:48.891765+01:00",
    "duration": "1.386731625s",
    "output": "INFO: Invocation ID: ce3ed867-ea82-49d7-91b7-eeaae7ef6157\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraInterfaces:UmbraInterfaces (1 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraInterfaces:UmbraInterfaces (1 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraInterfaces:UmbraInterfaces (1 packages loaded, 19 targets configured).\nERROR: /Users/mpy/CascadeProjects/UmbraCore/packages/UmbraInterfaces/BUILD.bazel:3:20: Compiling Swift module //packages/UmbraInterfaces:UmbraInterfaces failed: (Exit 1): worker failed: error executing SwiftCompile command (from target //packages/UmbraInterfaces:UmbraInterfaces) \n  (cd /Users/mpy/.bazel/execroot/_main \u0026\u0026 \\\n  exec env - \\\n    APPLE_SDK_PLATFORM=MacOSX \\\n    APPLE_SDK_VERSION_OVERRIDE=15.4 \\\n    CC=clang \\\n    PATH=/Users/mpy/Library/Caches/bazelisk/downloads/sha256/ac72ad67f7a8c6b18bf605d8602425182b417de4369715bf89146daf62f7ae48/bin:/Users/mpy/.rbenv/bin:/Users/mpy/.codeium/windsurf/bin:/opt/homebrew/opt/node@18/bin:/opt/homebrew/opt/node@20/bin:/Users/mpy/.docker/bin:/opt/homebrew/opt/openjdk/bin:/Users/mpy/bin:/opt/homebrew/bin:/opt/homebrew/sbin:/usr/local/bin:/System/Cryptexes/App/usr/bin:/usr/bin:/bin:/usr/sbin:/sbin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/local/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/appleinternal/bin:/Library/Apple/usr/bin:/usr/local/go/bin:/Users/mpy/.rbenv/bin:/Users/mpy/.codeium/windsurf/bin:/opt/homebrew/opt/node@18/bin:/opt/homebrew/opt/node@20/bin:/opt/anaconda3/bin:/opt/anaconda3/condabin:/Users/mpy/.docker/bin:/opt/homebrew/opt/openjdk/bin:/Users/mpy/bin:/Users/mpy/.cargo/bin:/Users/mpy/Library/Python/3.8/bin:/Users/mpy/go/bin:/Users/mpy/.scripts:/Users/mpy/.fzf/bin:/Users/mpy/.windsurf/extensions/ms-python.debugpy-2025.6.0-darwin-arm64/bundled/scripts/noConfigScripts:/Users/mpy/Library/Python/3.8/bin:/Users/mpy/go/bin:/Users/mpy/.scripts \\\n    XCODE_VERSION_OVERRIDE=16.3.0.16E140 \\\n  bazel-out/darwin_arm64-opt-exec-ST-d57f47055a04/bin/external/rules_swift+/tools/worker/worker swiftc @bazel-out/darwin_arm64-fastbuild/bin/packages/UmbraInterfaces/UmbraInterfaces.swiftmodule-0.params)\n# Configuration: 76a1bf3a80f2d50513004915454165d2f164db794b63e4666809cbd93e1abeaa\n# Execution platform: @@platforms//host:host\nerror: emit-module command failed with exit code 1 (use -v to see invocation)\npackages/UmbraInterfaces/Sources/ConfigurationInterfaces/Models/ConfigValidationDTO.swift:45:20: error: value type 'ConfigSchemaDTO.PropertyDefinition' cannot have a stored property that recursively contains it\n 43 |         \n 44 |         /// Array item definition for array types\n 45 |         public let items: PropertyDefinition?\n    |                    |- error: value type 'ConfigSchemaDTO.PropertyDefinition' cannot have a stored property that recursively contains it\n    |                    `- note: cycle beginning here: ConfigSchemaDTO.PropertyDefinition? -\u003e (some(_:): ConfigSchemaDTO.PropertyDefinition)\n 46 |         \n 47 |         /// Validation constraints\n\npackages/UmbraInterfaces/Sources/ConfigurationInterfaces/Protocol/ConfigurationServiceProtocol.swift:53:23: error: cannot find type 'ConfigSaveResultDTO' in scope\n 51 |         to destination: ConfigSourceDTO,\n 52 |         options: ConfigSaveOptionsDTO\n 53 |     ) async throws -\u003e ConfigSaveResultDTO\n    |                       `- error: cannot find type 'ConfigSaveResultDTO' in scope\n 54 |     \n 55 |     /**\n\npackages/UmbraInterfaces/Sources/PersistenceInterfaces/Models/PersistenceContextDTO.swift:18:26: error: cannot find type 'MetadataDTOCollection' in scope\n16 |     \n17 |     /// Metadata associated with the operation\n18 |     public let metadata: MetadataDTOCollection\n   |                          `- error: cannot find type 'MetadataDTOCollection' in scope\n19 |     \n20 |     /// Optional correlation ID for tracking related operations\n\npackages/UmbraInterfaces/Sources/PersistenceInterfaces/Models/PersistenceContextDTO.swift:35:19: error: cannot find type 'MetadataDTOCollection' in scope\n33 |         operation: String,\n34 |         category: String,\n35 |         metadata: MetadataDTOCollection = MetadataDTOCollection(),\n   |                   `- error: cannot find type 'MetadataDTOCollection' in scope\n36 |         correlationId: String? = nil\n37 |     ) {\n\npackages/UmbraInterfaces/Sources/PersistenceInterfaces/Models/PersistenceContextDTO.swift:50:52: error: cannot find type 'MetadataDTOCollection' in scope\n48 |      - Returns: A new context with the combined metadata\n49 |      */\n50 |     public func withMetadata(_ additionalMetadata: MetadataDTOCollection) -\u003e PersistenceContextDTO {\n   |                                                    `- error: cannot find type 'MetadataDTOCollection' in scope\n51 |         var combinedMetadata = self.metadata\n52 |         for (key, value) in additionalMetadata.items {\npackages/UmbraInterfaces/Sources/ConfigurationInterfaces/Models/ConfigValidationDTO.swift:45:20: error: value type 'ConfigSchemaDTO.PropertyDefinition' cannot have a stored property that recursively contains it\n 43 |         \n 44 |         /// Array item definition for array types\n 45 |         public let items: PropertyDefinition?\n    |                    |- error: value type 'ConfigSchemaDTO.PropertyDefinition' cannot have a stored property that recursively contains it\n    |                    `- note: cycle beginning here: ConfigSchemaDTO.PropertyDefinition? -\u003e (some(_:): ConfigSchemaDTO.PropertyDefinition)\n 46 |         \n 47 |         /// Validation constraints\n\npackages/UmbraInterfaces/Sources/ConfigurationInterfaces/Protocol/ConfigurationServiceProtocol.swift:53:23: error: cannot find type 'ConfigSaveResultDTO' in scope\n 51 |         to destination: ConfigSourceDTO,\n 52 |         options: ConfigSaveOptionsDTO\n 53 |     ) async throws -\u003e ConfigSaveResultDTO\n    |                       `- error: cannot find type 'ConfigSaveResultDTO' in scope\n 54 |     \n 55 |     /**\n\npackages/UmbraInterfaces/Sources/PersistenceInterfaces/Models/PersistenceContextDTO.swift:18:26: error: cannot find type 'MetadataDTOCollection' in scope\n16 |     \n17 |     /// Metadata associated with the operation\n18 |     public let metadata: MetadataDTOCollection\n   |                          `- error: cannot find type 'MetadataDTOCollection' in scope\n19 |     \n20 |     /// Optional correlation ID for tracking related operations\n\npackages/UmbraInterfaces/Sources/PersistenceInterfaces/Models/PersistenceContextDTO.swift:35:19: error: cannot find type 'MetadataDTOCollection' in scope\n33 |         operation: String,\n34 |         category: String,\n35 |         metadata: MetadataDTOCollection = MetadataDTOCollection(),\n   |                   `- error: cannot find type 'MetadataDTOCollection' in scope\n36 |         correlationId: String? = nil\n37 |     ) {\n\npackages/UmbraInterfaces/Sources/PersistenceInterfaces/Models/PersistenceContextDTO.swift:50:52: error: cannot find type 'MetadataDTOCollection' in scope\n48 |      - Returns: A new context with the combined metadata\n49 |      */\n50 |     public func withMetadata(_ additionalMetadata: MetadataDTOCollection) -\u003e PersistenceContextDTO {\n   |                                                    `- error: cannot find type 'MetadataDTOCollection' in scope\n51 |         var combinedMetadata = self.metadata\n52 |         for (key, value) in additionalMetadata.items {\n\npackages/UmbraInterfaces/Sources/PersistenceInterfaces/Models/QueryOptionsDTO.swift:86:30: error: no exact matches in call to instance method 'decodeIfPresent'\n 84 |         let container = try decoder.container(keyedBy: CodingKeys.self)\n 85 |         \n 86 |         sort = try container.decodeIfPresent([(String, SortDirection)].self, forKey: .sort)\n    |                              `- error: no exact matches in call to instance method 'decodeIfPresent'\n 87 |         limit = try container.decodeIfPresent(Int.self, forKey: .limit)\n 88 |         offset = try container.decodeIfPresent(Int.self, forKey: .offset)\n\nSwift.Array:1:11: note: candidate requires that '(String, SortDirection)' conform to 'Decodable' (requirement specified as '(String, SortDirection)' : 'Decodable')\n1 | extension Array : Decodable where Element : Decodable {\n  |           |- note: candidate requires that '(String, SortDirection)' conform to 'Decodable' (requirement specified as '(String, SortDirection)' : 'Decodable')\n  |           `- note: candidate requires that '(String, SortDirection)' conform to 'Decodable' (requirement specified as '(String, SortDirection)' : 'Decodable')\n2 |     public init(from decoder: any Decoder) throws\n3 | }\n\npackages/UmbraInterfaces/Sources/PersistenceInterfaces/Models/QueryOptionsDTO.swift:103:23: error: no exact matches in call to instance method 'encodeIfPresent'\n101 |         var container = encoder.container(keyedBy: CodingKeys.self)\n102 |         \n103 |         try container.encodeIfPresent(sort, forKey: .sort)\n    |                       `- error: no exact matches in call to instance method 'encodeIfPresent'\n104 |         try container.encodeIfPresent(limit, forKey: .limit)\n105 |         try container.encodeIfPresent(offset, forKey: .offset)\n\nSwift.Array:1:11: note: candidate requires that '(field: String, direction: SortDirection)' conform to 'Encodable' (requirement specified as '(field: String, direction: SortDirection)' : 'Encodable')\n1 | extension Array : Encodable where Element : Encodable {\n  |           |- note: candidate requires that '(field: String, direction: SortDirection)' conform to 'Encodable' (requirement specified as '(field: String, direction: SortDirection)' : 'Encodable')\n  |           `- note: candidate requires that '(field: String, direction: SortDirection)' conform to 'Encodable' (requirement specified as '(field: String, direction: SortDirection)' : 'Encodable')\n2 |     public func encode(to encoder: any Encoder) throws\n3 | }\nTarget //packages/UmbraInterfaces:UmbraInterfaces failed to build\nINFO: Elapsed time: 0.704s, Critical Path: 0.58s\nINFO: 2 processes: 1 action cache hit, 2 internal.\nERROR: Build did NOT complete successfully\n"
  },
  {
    "target": "rule //packages/UmbraInterfaces/Sources/APIInterfaces:APIInterfaces",
    "success": true,
    "start_time": "2025-04-11T17:58:48.89178+01:00",
    "end_time": "2025-04-11T17:58:49.949956+01:00",
    "duration": "1.058177042s",
    "output": "INFO: Invocation ID: 6621c286-ff33-44a6-b325-6d55b3789cae\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraInterfaces/Sources/APIInterfaces:APIInterfaces (0 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraInterfaces/Sources/APIInterfaces:APIInterfaces (0 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraInterfaces/Sources/APIInterfaces:APIInterfaces (0 packages loaded, 0 targets configured).\nINFO: Found 1 target...\nTarget //packages/UmbraInterfaces/Sources/APIInterfaces:APIInterfaces up-to-date:\n  bazel-bin/packages/UmbraInterfaces/Sources/APIInterfaces/APIInterfaces.swiftdoc\n  bazel-bin/packages/UmbraInterfaces/Sources/APIInterfaces/APIInterfaces.swiftmodule\n  bazel-bin/packages/UmbraInterfaces/Sources/APIInterfaces/APIInterfaces.swiftsourceinfo\n  bazel-bin/packages/UmbraInterfaces/Sources/APIInterfaces/libAPIInterfaces.a\nINFO: Elapsed time: 0.117s, Critical Path: 0.00s\nINFO: 1 process: 1 action cache hit, 1 internal.\nINFO: Build completed successfully, 1 total action\n"
  },
  {
    "target": "rule //packages/UmbraInterfaces/Sources/BackupInterfaces:BackupInterfaces",
    "success": true,
    "start_time": "2025-04-11T17:58:49.949971+01:00",
    "end_time": "2025-04-11T17:58:52.298387+01:00",
    "duration": "2.348418667s",
    "output": "INFO: Invocation ID: 4164fa7f-f28d-4aaa-a9df-c95ebda2aa74\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraInterfaces/Sources/BackupInterfaces:BackupInterfaces (0 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraInterfaces/Sources/BackupInterfaces:BackupInterfaces (0 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraInterfaces/Sources/BackupInterfaces:BackupInterfaces (0 packages loaded, 0 targets configured).\n[2 / 3] [Prepa] Linking packages/UmbraInterfaces/Sources/BackupInterfaces/libBackupInterfaces.a\nINFO: Found 1 target...\nTarget //packages/UmbraInterfaces/Sources/BackupInterfaces:BackupInterfaces up-to-date:\n  bazel-bin/packages/UmbraInterfaces/Sources/BackupInterfaces/BackupInterfaces.swiftdoc\n  bazel-bin/packages/UmbraInterfaces/Sources/BackupInterfaces/BackupInterfaces.swiftmodule\n  bazel-bin/packages/UmbraInterfaces/Sources/BackupInterfaces/BackupInterfaces.swiftsourceinfo\n  bazel-bin/packages/UmbraInterfaces/Sources/BackupInterfaces/libBackupInterfaces.a\nINFO: Elapsed time: 1.663s, Critical Path: 1.54s\nINFO: 3 processes: 1 disk cache hit, 1 internal, 1 worker.\nINFO: Build completed successfully, 3 total actions\n"
  },
  {
    "target": "rule //packages/UmbraInterfaces/Sources/CoreInterfaces:CoreInterfaces",
    "success": true,
    "start_time": "2025-04-11T17:58:52.298403+01:00",
    "end_time": "2025-04-11T17:58:53.11554+01:00",
    "duration": "817.137625ms",
    "output": "INFO: Invocation ID: 73a09b2f-9f48-402b-b163-4c4fb7ea77e1\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraInterfaces/Sources/CoreInterfaces:CoreInterfaces (0 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraInterfaces/Sources/CoreInterfaces:CoreInterfaces (0 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraInterfaces/Sources/CoreInterfaces:CoreInterfaces (0 packages loaded, 0 targets configured).\nINFO: Found 1 target...\nTarget //packages/UmbraInterfaces/Sources/CoreInterfaces:CoreInterfaces up-to-date:\n  bazel-bin/packages/UmbraInterfaces/Sources/CoreInterfaces/CoreInterfaces.swiftdoc\n  bazel-bin/packages/UmbraInterfaces/Sources/CoreInterfaces/CoreInterfaces.swiftmodule\n  bazel-bin/packages/UmbraInterfaces/Sources/CoreInterfaces/CoreInterfaces.swiftsourceinfo\n  bazel-bin/packages/UmbraInterfaces/Sources/CoreInterfaces/libCoreInterfaces.a\nINFO: Elapsed time: 0.120s, Critical Path: 0.00s\nINFO: 1 process: 1 action cache hit, 1 internal.\nINFO: Build completed successfully, 1 total action\n"
  },
  {
    "target": "rule //packages/UmbraInterfaces/Sources/CryptoInterfaces:CryptoInterfaces",
    "success": true,
    "start_time": "2025-04-11T17:58:53.115547+01:00",
    "end_time": "2025-04-11T17:58:53.922238+01:00",
    "duration": "806.69225ms",
    "output": "INFO: Invocation ID: a477e2af-0b20-489e-8c55-7f7db83a9fc4\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraInterfaces/Sources/CryptoInterfaces:CryptoInterfaces (0 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraInterfaces/Sources/CryptoInterfaces:CryptoInterfaces (0 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraInterfaces/Sources/CryptoInterfaces:CryptoInterfaces (0 packages loaded, 0 targets configured).\nINFO: Found 1 target...\nTarget //packages/UmbraInterfaces/Sources/CryptoInterfaces:CryptoInterfaces up-to-date:\n  bazel-bin/packages/UmbraInterfaces/Sources/CryptoInterfaces/CryptoInterfaces.swiftdoc\n  bazel-bin/packages/UmbraInterfaces/Sources/CryptoInterfaces/CryptoInterfaces.swiftmodule\n  bazel-bin/packages/UmbraInterfaces/Sources/CryptoInterfaces/CryptoInterfaces.swiftsourceinfo\n  bazel-bin/packages/UmbraInterfaces/Sources/CryptoInterfaces/libCryptoInterfaces.a\nINFO: Elapsed time: 0.123s, Critical Path: 0.00s\nINFO: 1 process: 1 action cache hit, 1 internal.\nINFO: Build completed successfully, 1 total action\n"
  },
  {
    "target": "rule //packages/UmbraInterfaces/Sources/DateTimeInterfaces:DateTimeInterfaces",
    "success": true,
    "start_time": "2025-04-11T17:58:53.922248+01:00",
    "end_time": "2025-04-11T17:58:54.775703+01:00",
    "duration": "853.45525ms",
    "output": "INFO: Invocation ID: 90c00a29-f18d-465b-b808-17f3e30568ab\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraInterfaces/Sources/DateTimeInterfaces:DateTimeInterfaces (0 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraInterfaces/Sources/DateTimeInterfaces:DateTimeInterfaces (0 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraInterfaces/Sources/DateTimeInterfaces:DateTimeInterfaces (0 packages loaded, 0 targets configured).\nINFO: Found 1 target...\nTarget //packages/UmbraInterfaces/Sources/DateTimeInterfaces:DateTimeInterfaces up-to-date:\n  bazel-bin/packages/UmbraInterfaces/Sources/DateTimeInterfaces/DateTimeInterfaces.swiftdoc\n  bazel-bin/packages/UmbraInterfaces/Sources/DateTimeInterfaces/DateTimeInterfaces.swiftmodule\n  bazel-bin/packages/UmbraInterfaces/Sources/DateTimeInterfaces/DateTimeInterfaces.swiftsourceinfo\n  bazel-bin/packages/UmbraInterfaces/Sources/DateTimeInterfaces/libDateTimeInterfaces.a\nINFO: Elapsed time: 0.130s, Critical Path: 0.00s\nINFO: 2 processes: 1 disk cache hit, 1 internal.\nINFO: Build completed successfully, 2 total actions\n"
  },
  {
    "target": "rule //packages/UmbraInterfaces/Sources/ErrorHandlingInterfaces:ErrorHandlingInterfaces",
    "success": true,
    "start_time": "2025-04-11T17:58:54.775711+01:00",
    "end_time": "2025-04-11T17:58:55.561055+01:00",
    "duration": "785.345209ms",
    "output": "INFO: Invocation ID: c71524b7-239a-4982-bc5f-a7ae3596a5e1\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraInterfaces/Sources/ErrorHandlingInterfaces:ErrorHandlingInterfaces (0 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraInterfaces/Sources/ErrorHandlingInterfaces:ErrorHandlingInterfaces (0 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraInterfaces/Sources/ErrorHandlingInterfaces:ErrorHandlingInterfaces (0 packages loaded, 0 targets configured).\nINFO: Found 1 target...\nTarget //packages/UmbraInterfaces/Sources/ErrorHandlingInterfaces:ErrorHandlingInterfaces up-to-date:\n  bazel-bin/packages/UmbraInterfaces/Sources/ErrorHandlingInterfaces/ErrorHandlingInterfaces.swiftdoc\n  bazel-bin/packages/UmbraInterfaces/Sources/ErrorHandlingInterfaces/ErrorHandlingInterfaces.swiftmodule\n  bazel-bin/packages/UmbraInterfaces/Sources/ErrorHandlingInterfaces/ErrorHandlingInterfaces.swiftsourceinfo\n  bazel-bin/packages/UmbraInterfaces/Sources/ErrorHandlingInterfaces/libErrorHandlingInterfaces.a\nINFO: Elapsed time: 0.121s, Critical Path: 0.00s\nINFO: 1 process: 1 action cache hit, 1 internal.\nINFO: Build completed successfully, 1 total action\n"
  },
  {
    "target": "rule //packages/UmbraInterfaces/Sources/ErrorLoggingInterfaces:ErrorLoggingInterfaces",
    "success": true,
    "start_time": "2025-04-11T17:58:55.561063+01:00",
    "end_time": "2025-04-11T17:58:56.402018+01:00",
    "duration": "840.955792ms",
    "output": "INFO: Invocation ID: d00734e7-c9b0-4f3e-a2da-4e9a5fdfd028\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraInterfaces/Sources/ErrorLoggingInterfaces:ErrorLoggingInterfaces (0 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraInterfaces/Sources/ErrorLoggingInterfaces:ErrorLoggingInterfaces (0 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraInterfaces/Sources/ErrorLoggingInterfaces:ErrorLoggingInterfaces (0 packages loaded, 0 targets configured).\nINFO: Found 1 target...\nTarget //packages/UmbraInterfaces/Sources/ErrorLoggingInterfaces:ErrorLoggingInterfaces up-to-date:\n  bazel-bin/packages/UmbraInterfaces/Sources/ErrorLoggingInterfaces/ErrorLoggingInterfaces.swiftdoc\n  bazel-bin/packages/UmbraInterfaces/Sources/ErrorLoggingInterfaces/ErrorLoggingInterfaces.swiftmodule\n  bazel-bin/packages/UmbraInterfaces/Sources/ErrorLoggingInterfaces/ErrorLoggingInterfaces.swiftsourceinfo\n  bazel-bin/packages/UmbraInterfaces/Sources/ErrorLoggingInterfaces/libErrorLoggingInterfaces.a\nINFO: Elapsed time: 0.120s, Critical Path: 0.00s\nINFO: 1 process: 1 action cache hit, 1 internal.\nINFO: Build completed successfully, 1 total action\n"
  },
  {
    "target": "rule //packages/UmbraInterfaces/Sources/FileSystemInterfaces:FileSystemInterfaces",
    "success": true,
    "start_time": "2025-04-11T17:58:56.402024+01:00",
    "end_time": "2025-04-11T17:58:57.219669+01:00",
    "duration": "817.645333ms",
    "output": "INFO: Invocation ID: 53a4868e-912e-45ef-8362-68275c5caa02\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraInterfaces/Sources/FileSystemInterfaces:FileSystemInterfaces (0 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraInterfaces/Sources/FileSystemInterfaces:FileSystemInterfaces (0 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraInterfaces/Sources/FileSystemInterfaces:FileSystemInterfaces (0 packages loaded, 0 targets configured).\nINFO: Found 1 target...\nTarget //packages/UmbraInterfaces/Sources/FileSystemInterfaces:FileSystemInterfaces up-to-date:\n  bazel-bin/packages/UmbraInterfaces/Sources/FileSystemInterfaces/FileSystemInterfaces.swiftdoc\n  bazel-bin/packages/UmbraInterfaces/Sources/FileSystemInterfaces/FileSystemInterfaces.swiftmodule\n  bazel-bin/packages/UmbraInterfaces/Sources/FileSystemInterfaces/FileSystemInterfaces.swiftsourceinfo\n  bazel-bin/packages/UmbraInterfaces/Sources/FileSystemInterfaces/libFileSystemInterfaces.a\nINFO: Elapsed time: 0.127s, Critical Path: 0.00s\nINFO: 2 processes: 1 disk cache hit, 1 internal.\nINFO: Build completed successfully, 2 total actions\n"
  },
  {
    "target": "rule //packages/UmbraInterfaces/Sources/KeychainInterfaces:KeychainInterfaces",
    "success": true,
    "start_time": "2025-04-11T17:58:57.219689+01:00",
    "end_time": "2025-04-11T17:58:58.033412+01:00",
    "duration": "813.723584ms",
    "output": "INFO: Invocation ID: 48b7d911-bc8d-44a9-9d75-b16756d3af24\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraInterfaces/Sources/KeychainInterfaces:KeychainInterfaces (0 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraInterfaces/Sources/KeychainInterfaces:KeychainInterfaces (0 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraInterfaces/Sources/KeychainInterfaces:KeychainInterfaces (0 packages loaded, 0 targets configured).\nINFO: Found 1 target...\nTarget //packages/UmbraInterfaces/Sources/KeychainInterfaces:KeychainInterfaces up-to-date:\n  bazel-bin/packages/UmbraInterfaces/Sources/KeychainInterfaces/KeychainInterfaces.swiftdoc\n  bazel-bin/packages/UmbraInterfaces/Sources/KeychainInterfaces/KeychainInterfaces.swiftmodule\n  bazel-bin/packages/UmbraInterfaces/Sources/KeychainInterfaces/KeychainInterfaces.swiftsourceinfo\n  bazel-bin/packages/UmbraInterfaces/Sources/KeychainInterfaces/libKeychainInterfaces.a\nINFO: Elapsed time: 0.123s, Critical Path: 0.00s\nINFO: 1 process: 1 action cache hit, 1 internal.\nINFO: Build completed successfully, 1 total action\n"
  },
  {
    "target": "rule //packages/UmbraInterfaces/Sources/LoggingInterfaces:LoggingInterfaces",
    "success": true,
    "start_time": "2025-04-11T17:58:58.033418+01:00",
    "end_time": "2025-04-11T17:58:58.8167+01:00",
    "duration": "783.282458ms",
    "output": "INFO: Invocation ID: d786393d-972f-470c-8a4b-182ad597d57f\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraInterfaces/Sources/LoggingInterfaces:LoggingInterfaces (0 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraInterfaces/Sources/LoggingInterfaces:LoggingInterfaces (0 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraInterfaces/Sources/LoggingInterfaces:LoggingInterfaces (0 packages loaded, 0 targets configured).\nINFO: Found 1 target...\nTarget //packages/UmbraInterfaces/Sources/LoggingInterfaces:LoggingInterfaces up-to-date:\n  bazel-bin/packages/UmbraInterfaces/Sources/LoggingInterfaces/LoggingInterfaces.swiftdoc\n  bazel-bin/packages/UmbraInterfaces/Sources/LoggingInterfaces/LoggingInterfaces.swiftmodule\n  bazel-bin/packages/UmbraInterfaces/Sources/LoggingInterfaces/LoggingInterfaces.swiftsourceinfo\n  bazel-bin/packages/UmbraInterfaces/Sources/LoggingInterfaces/libLoggingInterfaces.a\nINFO: Elapsed time: 0.119s, Critical Path: 0.00s\nINFO: 1 process: 1 action cache hit, 1 internal.\nINFO: Build completed successfully, 1 total action\n"
  },
  {
    "target": "rule //packages/UmbraInterfaces/Sources/LoggingWrapperInterfaces:LoggingWrapperInterfaces",
    "success": true,
    "start_time": "2025-04-11T17:58:58.816706+01:00",
    "end_time": "2025-04-11T17:58:59.598833+01:00",
    "duration": "782.128208ms",
    "output": "INFO: Invocation ID: 8c25a181-26ca-47ef-a69c-e7c756a3a67a\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraInterfaces/Sources/LoggingWrapperInterfaces:LoggingWrapperInterfaces (0 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraInterfaces/Sources/LoggingWrapperInterfaces:LoggingWrapperInterfaces (0 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraInterfaces/Sources/LoggingWrapperInterfaces:LoggingWrapperInterfaces (0 packages loaded, 0 targets configured).\nINFO: Found 1 target...\nTarget //packages/UmbraInterfaces/Sources/LoggingWrapperInterfaces:LoggingWrapperInterfaces up-to-date:\n  bazel-bin/packages/UmbraInterfaces/Sources/LoggingWrapperInterfaces/LoggingWrapperInterfaces.swiftdoc\n  bazel-bin/packages/UmbraInterfaces/Sources/LoggingWrapperInterfaces/LoggingWrapperInterfaces.swiftmodule\n  bazel-bin/packages/UmbraInterfaces/Sources/LoggingWrapperInterfaces/LoggingWrapperInterfaces.swiftsourceinfo\n  bazel-bin/packages/UmbraInterfaces/Sources/LoggingWrapperInterfaces/libLoggingWrapperInterfaces.a\nINFO: Elapsed time: 0.120s, Critical Path: 0.00s\nINFO: 1 process: 1 action cache hit, 1 internal.\nINFO: Build completed successfully, 1 total action\n"
  },
  {
    "target": "rule //packages/UmbraInterfaces/Sources/NetworkInterfaces:NetworkInterfaces",
    "success": true,
    "start_time": "2025-04-11T17:58:59.598843+01:00",
    "end_time": "2025-04-11T17:59:00.669425+01:00",
    "duration": "1.070583167s",
    "output": "INFO: Invocation ID: 059d4b9a-1fd4-4d03-b104-2fc11677f20d\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraInterfaces/Sources/NetworkInterfaces:NetworkInterfaces (0 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraInterfaces/Sources/NetworkInterfaces:NetworkInterfaces (0 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraInterfaces/Sources/NetworkInterfaces:NetworkInterfaces (0 packages loaded, 0 targets configured).\nINFO: Found 1 target...\nTarget //packages/UmbraInterfaces/Sources/NetworkInterfaces:NetworkInterfaces up-to-date:\n  bazel-bin/packages/UmbraInterfaces/Sources/NetworkInterfaces/NetworkInterfaces.swiftdoc\n  bazel-bin/packages/UmbraInterfaces/Sources/NetworkInterfaces/NetworkInterfaces.swiftmodule\n  bazel-bin/packages/UmbraInterfaces/Sources/NetworkInterfaces/NetworkInterfaces.swiftsourceinfo\n  bazel-bin/packages/UmbraInterfaces/Sources/NetworkInterfaces/libNetworkInterfaces.a\nINFO: Elapsed time: 0.124s, Critical Path: 0.00s\nINFO: 2 processes: 1 disk cache hit, 1 internal.\nINFO: Build completed successfully, 2 total actions\n"
  },
  {
    "target": "rule //packages/UmbraInterfaces/Sources/RepositoryInterfaces:RepositoryInterfaces",
    "success": true,
    "start_time": "2025-04-11T17:59:00.669432+01:00",
    "end_time": "2025-04-11T17:59:01.463378+01:00",
    "duration": "793.946792ms",
    "output": "INFO: Invocation ID: 1e20556f-9e7b-4e29-9eeb-cf6c020d1e95\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraInterfaces/Sources/RepositoryInterfaces:RepositoryInterfaces (0 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraInterfaces/Sources/RepositoryInterfaces:RepositoryInterfaces (0 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraInterfaces/Sources/RepositoryInterfaces:RepositoryInterfaces (0 packages loaded, 0 targets configured).\nINFO: Found 1 target...\nTarget //packages/UmbraInterfaces/Sources/RepositoryInterfaces:RepositoryInterfaces up-to-date:\n  bazel-bin/packages/UmbraInterfaces/Sources/RepositoryInterfaces/RepositoryInterfaces.swiftdoc\n  bazel-bin/packages/UmbraInterfaces/Sources/RepositoryInterfaces/RepositoryInterfaces.swiftmodule\n  bazel-bin/packages/UmbraInterfaces/Sources/RepositoryInterfaces/RepositoryInterfaces.swiftsourceinfo\n  bazel-bin/packages/UmbraInterfaces/Sources/RepositoryInterfaces/libRepositoryInterfaces.a\nINFO: Elapsed time: 0.121s, Critical Path: 0.00s\nINFO: 1 process: 1 action cache hit, 1 internal.\nINFO: Build completed successfully, 1 total action\n"
  },
  {
    "target": "rule //packages/UmbraInterfaces/Sources/ResticInterfaces:ResticInterfaces",
    "success": true,
    "start_time": "2025-04-11T17:59:01.46341+01:00",
    "end_time": "2025-04-11T17:59:02.23404+01:00",
    "duration": "770.630875ms",
    "output": "INFO: Invocation ID: f3ef3d1f-a0d2-43d3-af2e-82029d658d4e\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraInterfaces/Sources/ResticInterfaces:ResticInterfaces (0 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraInterfaces/Sources/ResticInterfaces:ResticInterfaces (0 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraInterfaces/Sources/ResticInterfaces:ResticInterfaces (0 packages loaded, 0 targets configured).\nINFO: Found 1 target...\nTarget //packages/UmbraInterfaces/Sources/ResticInterfaces:ResticInterfaces up-to-date:\n  bazel-bin/packages/UmbraInterfaces/Sources/ResticInterfaces/ResticInterfaces.swiftdoc\n  bazel-bin/packages/UmbraInterfaces/Sources/ResticInterfaces/ResticInterfaces.swiftmodule\n  bazel-bin/packages/UmbraInterfaces/Sources/ResticInterfaces/ResticInterfaces.swiftsourceinfo\n  bazel-bin/packages/UmbraInterfaces/Sources/ResticInterfaces/libResticInterfaces.a\nINFO: Elapsed time: 0.116s, Critical Path: 0.00s\nINFO: 1 process: 1 action cache hit, 1 internal.\nINFO: Build completed successfully, 1 total action\n"
  },
  {
    "target": "rule //packages/UmbraInterfaces/Sources/SecurityCoreInterfaces:SecurityCoreInterfaces",
    "success": true,
    "start_time": "2025-04-11T17:59:02.234068+01:00",
    "end_time": "2025-04-11T17:59:03.069484+01:00",
    "duration": "835.417292ms",
    "output": "INFO: Invocation ID: 13920bca-e132-4c97-9583-2c535f4004dd\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraInterfaces/Sources/SecurityCoreInterfaces:SecurityCoreInterfaces (0 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraInterfaces/Sources/SecurityCoreInterfaces:SecurityCoreInterfaces (0 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraInterfaces/Sources/SecurityCoreInterfaces:SecurityCoreInterfaces (0 packages loaded, 0 targets configured).\nINFO: Found 1 target...\nTarget //packages/UmbraInterfaces/Sources/SecurityCoreInterfaces:SecurityCoreInterfaces up-to-date:\n  bazel-bin/packages/UmbraInterfaces/Sources/SecurityCoreInterfaces/SecurityCoreInterfaces.swiftdoc\n  bazel-bin/packages/UmbraInterfaces/Sources/SecurityCoreInterfaces/SecurityCoreInterfaces.swiftmodule\n  bazel-bin/packages/UmbraInterfaces/Sources/SecurityCoreInterfaces/SecurityCoreInterfaces.swiftsourceinfo\n  bazel-bin/packages/UmbraInterfaces/Sources/SecurityCoreInterfaces/libSecurityCoreInterfaces.a\nINFO: Elapsed time: 0.124s, Critical Path: 0.00s\nINFO: 1 process: 1 action cache hit, 1 internal.\nINFO: Build completed successfully, 1 total action\n"
  },
  {
    "target": "rule //packages/UmbraInterfaces/Sources/SecurityInterfaces:SecurityInterfaces",
    "success": true,
    "start_time": "2025-04-11T17:59:03.069493+01:00",
    "end_time": "2025-04-11T17:59:03.873915+01:00",
    "duration": "804.423ms",
    "output": "INFO: Invocation ID: 8023146a-b981-471b-81ef-ee2449007429\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraInterfaces/Sources/SecurityInterfaces:SecurityInterfaces (0 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraInterfaces/Sources/SecurityInterfaces:SecurityInterfaces (0 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraInterfaces/Sources/SecurityInterfaces:SecurityInterfaces (0 packages loaded, 0 targets configured).\nINFO: Found 1 target...\nTarget //packages/UmbraInterfaces/Sources/SecurityInterfaces:SecurityInterfaces up-to-date:\n  bazel-bin/packages/UmbraInterfaces/Sources/SecurityInterfaces/SecurityInterfaces.swiftdoc\n  bazel-bin/packages/UmbraInterfaces/Sources/SecurityInterfaces/SecurityInterfaces.swiftmodule\n  bazel-bin/packages/UmbraInterfaces/Sources/SecurityInterfaces/SecurityInterfaces.swiftsourceinfo\n  bazel-bin/packages/UmbraInterfaces/Sources/SecurityInterfaces/libSecurityInterfaces.a\nINFO: Elapsed time: 0.122s, Critical Path: 0.00s\nINFO: 1 process: 1 action cache hit, 1 internal.\nINFO: Build completed successfully, 1 total action\n"
  },
  {
    "target": "rule //packages/UmbraInterfaces/Sources/XPCProtocolsCore:XPCProtocolsCore",
    "success": true,
    "start_time": "2025-04-11T17:59:03.873921+01:00",
    "end_time": "2025-04-11T17:59:04.683316+01:00",
    "duration": "809.396334ms",
    "output": "INFO: Invocation ID: a3ad7de0-f46b-49a1-b7cf-6f112d928ea1\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraInterfaces/Sources/XPCProtocolsCore:XPCProtocolsCore (0 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraInterfaces/Sources/XPCProtocolsCore:XPCProtocolsCore (0 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraInterfaces/Sources/XPCProtocolsCore:XPCProtocolsCore (0 packages loaded, 0 targets configured).\nINFO: Found 1 target...\nTarget //packages/UmbraInterfaces/Sources/XPCProtocolsCore:XPCProtocolsCore up-to-date:\n  bazel-bin/packages/UmbraInterfaces/Sources/XPCProtocolsCore/XPCProtocolsCore.swiftdoc\n  bazel-bin/packages/UmbraInterfaces/Sources/XPCProtocolsCore/XPCProtocolsCore.swiftmodule\n  bazel-bin/packages/UmbraInterfaces/Sources/XPCProtocolsCore/XPCProtocolsCore.swiftsourceinfo\n  bazel-bin/packages/UmbraInterfaces/Sources/XPCProtocolsCore/libXPCProtocolsCore.a\nINFO: Elapsed time: 0.121s, Critical Path: 0.00s\nINFO: 2 processes: 1 disk cache hit, 1 internal.\nINFO: Build completed successfully, 2 total actions\n"
  },
  {
    "target": "rule //packages/UmbraServices/Sources/LoggingServices:LoggingServices",
    "success": true,
    "start_time": "2025-04-11T17:59:04.683325+01:00",
    "end_time": "2025-04-11T17:59:05.508962+01:00",
    "duration": "825.638083ms",
    "output": "INFO: Invocation ID: 33c0db42-83a9-428a-a56c-e3cd7371edba\nComputing main repo mapping: \nLoading: \nLoading: 0 packages loaded\nAnalyzing: target //packages/UmbraServices/Sources/LoggingServices:LoggingServices (0 packages loaded, 0 targets configured)\nAnalyzing: target //packages/UmbraServices/Sources/LoggingServices:LoggingServices (0 packages loaded, 0 targets configured)\n\nINFO: Analyzed target //packages/UmbraServices/Sources/LoggingServices:LoggingServices (0 packages loaded, 0 targets configured).\nINFO: Found 1 target...\nTarget //packages/UmbraServices/Sources/LoggingServices:LoggingServices up-to-date:\n  bazel-bin/packages/UmbraServices/Sources/LoggingServices/LoggingServices.swiftdoc\n  bazel-bin/packages/UmbraServices/Sources/LoggingServices/LoggingServices.swiftmodule\n  bazel-bin/packages/UmbraServices/Sources/LoggingServices/LoggingServices.swiftsourceinfo\n  bazel-bin/packages/UmbraServices/Sources/LoggingServices/libLoggingServices.a\nINFO: Elapsed time: 0.121s, Critical Path: 0.00s\nINFO: 1 process: 1 action cache hit, 1 internal.\nINFO: Build completed successfully, 1 total action\n"
  }
]