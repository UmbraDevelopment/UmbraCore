# Error Type Migration Guide

This guide explains how to apply the error type migration generated by the Error Migrator tool.

## Overview

The Error Migrator tool has consolidated duplicate error types from across the UmbraCore codebase into a centralised `CoreErrors` module. This improves code organisation, reduces duplication, and provides a consistent error handling approach.

## Why We're Migrating

Error types in UmbraCore were previously duplicated across multiple modules, leading to:
- Code duplication and inconsistent error handling
- Difficulty in maintaining consistent error documentation
- Circular dependencies between modules
- Confusion about which error type to use

The centralised `CoreErrors` module solves these issues by providing:
- A single source of truth for all error types
- Consistent documentation and error handling patterns
- Reduced module interdependencies
- Clear naming conventions and organisation

## Migration Process Overview

The migration involves these high-level steps:
1. Generate consolidated error types using the Error Migrator tool
2. Create the CoreErrors module with the generated files
3. Add type aliases to original modules for backward compatibility
4. Update BUILD files to include the CoreErrors dependency
5. Run comprehensive tests to verify everything works

## Automated Migration

The easiest way to apply the migration is to use the `complete_migration.sh` script, which handles all the steps:

```bash
cd /Users/mpy/CascadeProjects/UmbraCore/tools/error_migrator
./complete_migration.sh
```

The script will:
1. Run the Error Migrator tool to generate code
2. Copy files to the appropriate locations
3. Update BUILD files
4. Optionally build and test the project

## Manual Migration Steps

If you prefer to apply the migration manually, follow these steps:

1. **Generate the CoreErrors module**

   Run the Error Migrator tool to generate the consolidated error types:

   ```bash
   cd /Users/mpy/CascadeProjects/UmbraCore/tools/error_migrator
   go run . --report "../../error_analysis_report.md" --config "migration_config.json" --output "./generated_code" --apply
   ```

2. **Create the CoreErrors module**

   Run the `apply_migration.sh` script to copy the CoreErrors module files to your codebase:

   ```bash
   cd /Users/mpy/CascadeProjects/UmbraCore/tools/error_migrator
   ./apply_migration.sh
   ```

3. **Update BUILD files**

   Run the `update_build_files.sh` script to automatically add the CoreErrors dependency to relevant modules:

   ```bash
   cd /Users/mpy/CascadeProjects/UmbraCore/tools/error_migrator
   ./update_build_files.sh
   ```

4. **Review changes**

   Carefully review all changes before building the project:
   
   - Check the new CoreErrors module files
   - Review the alias files added to each module
   - Verify BUILD file changes

5. **Build and test**

   Build and test the project to ensure everything works correctly:

   ```bash
   cd /Users/mpy/CascadeProjects/UmbraCore
   bazelisk build //...
   bazelisk test //...
   ```

## Understanding the Generated Code

The migration generates several types of files:

1. **CoreErrors module files**: 
   - One file per error type (e.g., SecurityError.swift, CryptoError.swift)
   - Each file contains a comprehensive enum with all cases from across modules
   - Located in `Sources/CoreErrors/`

2. **Type alias files**:
   - One file per original module (e.g., SecurityProtocolsCore_Aliases.swift)
   - Contains type aliases for backward compatibility
   - Added to the original modules

3. **Namespace helpers**:
   - NamespaceHelpers.swift contains utility types for resolving namespace conflicts
   - Only used when needed to disambiguate types

## Namespace Resolution

Be aware of potential namespace conflicts in modules that have top-level enums with the same name as the module itself (such as SecurityProtocolsCore). In these cases, you may need to:

1. Use contextual type inference to avoid explicitly qualifying the error type
2. Use import aliasing to disambiguate (e.g., `import SecurityProtocolsCore as SPC`)
3. Add explicit type annotations where needed
4. Use the provided namespace resolution helpers in some cases

### Example of Namespace Conflict Resolution

```swift
// Before migration
import SecurityProtocolsCore
func handle(error: SecurityProtocolsCore.SecurityError) { ... }

// After migration - Option 1: Use contextual type inference
import CoreErrors
func handle(error: SecurityError) { ... }

// After migration - Option 2: Use import aliasing
import CoreErrors
import SecurityProtocolsCore as SPC
func handle(error: CoreErrors.SecurityError) { ... }
```

## Common Issues and Solutions

### Missing Imports

If you see errors about undefined types, add an import for CoreErrors:

```swift
import CoreErrors
```

### Type Ambiguity

If you see "ambiguous use of 'SecurityError'" errors:

```swift
// Explicitly qualify the type
let error: CoreErrors.SecurityError = ...

// Or use import aliasing
import CoreErrors
import SecurityProtocolsCore as SPC
let error: CoreErrors.SecurityError = ...
```

### Namespace Conflicts

For modules with top-level enums that match the module name:

```swift
// Use the TypeResolver helper to specify which module's type you want
import CoreErrors
typealias ResolvedSecurityError = TypeResolver<CoreErrors.SecurityError>.ResolvedType
```

## Manual Adjustments

If you encounter build errors after applying the migration, you may need to make manual adjustments:

1. **Fix import statements**: Add or update import statements to include the CoreErrors module
2. **Update type references**: Update references to the migrated error types
3. **Resolve namespace conflicts**: Address any namespace conflicts as described above
4. **Update factory methods**: If you have factory methods creating error types, update their return types
5. **Update error handling code**: Ensure catch blocks and error handling properly work with the new types

## Verifying the Migration

After applying the migration, verify that:

1. The codebase builds successfully
2. All tests pass
3. Error handling still works correctly
4. Type aliases provide proper backward compatibility
5. No type resolution errors occur at runtime

## Reverting the Migration

If necessary, you can revert the migration by:

1. Removing the CoreErrors module
2. Removing the alias files from each module 
3. Updating BUILD files to remove the CoreErrors dependency
4. Restoring any manually modified code

## Getting Help

If you encounter issues with the migration:

1. Check the error message carefully as it often indicates the exact problem
2. Review the namespace resolution section of this guide for type conflicts
3. Look at the generated alias files for the correct type mappings
4. Try using the TypeResolver utilities for complex cases
5. Contact the UmbraCore architecture team for assistance with complex issues

## Future Improvements

This migration is part of a larger effort to improve UmbraCore's architecture. Future improvements may include:

1. Standardising error message formats
2. Adding more structured error metadata
3. Improving error localisation
4. Enhancing error reporting and analytics
