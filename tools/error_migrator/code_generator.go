package main

import (
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"regexp"
)

// GenerateCode generates Swift code for the target module and aliases
func GenerateCode(migration *Migration, errorDefinitions map[string]map[string]*ErrorDefinition) (*GeneratedCode, error) {
	if migration == nil {
		return nil, fmt.Errorf("migration cannot be nil")
	}

	result := &GeneratedCode{
		TargetModuleCode: make(map[string]string),
		AliasModuleCode:  make(map[string]string),
		UpdatedImports:   make(map[string]string),
	}

	// Create a map for easier lookup of error definitions
	errorDefsMap := make(map[string]map[string]*ErrorDefinition)
	for moduleName, moduleDefs := range errorDefinitions {
		for errorName, def := range moduleDefs {
			if _, exists := errorDefsMap[moduleName]; !exists {
				errorDefsMap[moduleName] = make(map[string]*ErrorDefinition)
			}
			errorDefsMap[moduleName][errorName] = def
		}
	}

	// Group errors by their target module
	errorsByTarget := make(map[string][]ErrorToMigrate)
	for _, errToMigrate := range migration.ErrorsToMigrate {
		errorsByTarget[errToMigrate.TargetModule] = append(
			errorsByTarget[errToMigrate.TargetModule], errToMigrate)
	}

	// Generate code for each target module
	for _, errorsToMigrate := range errorsByTarget {
		// Get all unique error names
		errorNames := make(map[string]bool)
		for _, errToMigrate := range errorsToMigrate {
			errorNames[errToMigrate.ErrorName] = true
		}

		// Sort error names for deterministic output
		var sortedErrorNames []string
		for errorName := range errorNames {
			sortedErrorNames = append(sortedErrorNames, errorName)
		}
		sort.Strings(sortedErrorNames)

		// Generate separate file for each error type
		for _, errorName := range sortedErrorNames {
			// Get definition from the first module that has it
			var errorDef *ErrorDefinition
			for _, errToMigrate := range errorsToMigrate {
				if errToMigrate.ErrorName == errorName {
					// Look up the error definition
					if def, exists := errorDefsMap[errToMigrate.SourceModule][errorName]; exists {
						errorDef = def
						break
					}
				}
			}

			if errorDef == nil {
				return nil, fmt.Errorf("failed to find definition for error %s", errorName)
			}

			// Generate code for this error type
			var codeContent strings.Builder
			codeContent.WriteString(fmt.Sprintf("// %s.swift\n", errorName))
			codeContent.WriteString("// Auto-generated by error_migrator\n\n")
			
			// Add imports
			codeContent.WriteString("import Foundation\n\n")

			// Generate code based on error type
			if errorDef.IsEnum {
				codeContent.WriteString(generateErrorEnum(errorDef))
			} else {
				codeContent.WriteString(generateErrorStruct(errorDef))
			}
			
			// Add the generated code to the result
			result.TargetModuleCode[errorName] = codeContent.String()
		}
	}

	// Group errors by source module for alias generation
	errorsBySourceModule := make(map[string][]ErrorToMigrate)
	conflictedModules := make(map[string]bool)
	
	for _, errToMigrate := range migration.ErrorsToMigrate {
		if !errToMigrate.CreateAlias {
			continue
		}
		
		errorsBySourceModule[errToMigrate.SourceModule] = append(
			errorsBySourceModule[errToMigrate.SourceModule], errToMigrate)
		
		if errToMigrate.HasNamespaceConflict {
			conflictedModules[errToMigrate.SourceModule] = true
		}
	}

	// Generate type aliases for each source module
	for sourceModule, errorsForModule := range errorsBySourceModule {
		// Skip if we've already generated code for this module
		if _, exists := result.AliasModuleCode[sourceModule]; exists {
			continue
		}
		
		isConflicted := conflictedModules[sourceModule]
		
		// Generate type alias file
		var codeContent strings.Builder
		codeContent.WriteString(fmt.Sprintf("// %s_Aliases.swift\n", sourceModule))
		codeContent.WriteString("// Auto-generated by error_migrator\n\n")
		
		// Import the target module
		if isConflicted {
			// For conflicted modules, provide both normal and aliased import options (commented out)
			codeContent.WriteString(fmt.Sprintf("import %s\n", migration.TargetModule))
			codeContent.WriteString(fmt.Sprintf("// If you encounter namespace conflicts, consider using an aliased import instead:\n"))
			codeContent.WriteString(fmt.Sprintf("// import %s as CoreErr\n\n", migration.TargetModule))
		} else {
			codeContent.WriteString(fmt.Sprintf("import %s\n\n", migration.TargetModule))
		}

		// Generate type aliases with helpful comments
		for _, err := range errorsForModule {
			if err.HasNamespaceConflict {
				// For errors with namespace conflicts, provide more detailed aliases
				codeContent.WriteString(fmt.Sprintf("// MARK: - %s (with potential namespace conflict)\n", err.ErrorName))
				codeContent.WriteString(fmt.Sprintf("// The error type %s in %s has a potential namespace conflict.\n", 
					err.ErrorName, err.SourceModule))
				codeContent.WriteString(fmt.Sprintf("// %s\n\n", err.ConflictSolution))
				
				// Standard alias
				codeContent.WriteString(generateTypeAlias(migration.TargetModule, err.ErrorName))
				codeContent.WriteString("\n\n")
				
				// Alternative alias with module prefix
				codeContent.WriteString(fmt.Sprintf("// Alternative: Using an import alias to avoid conflicts\n"))
				codeContent.WriteString(fmt.Sprintf("// When using 'import %s as CoreErr':\n", migration.TargetModule))
				codeContent.WriteString(fmt.Sprintf("// public typealias %s = CoreErr.%s\n\n", 
					err.ErrorName, err.ErrorName))
			} else {
				// Standard alias for non-conflicted errors
				codeContent.WriteString(generateTypeAlias(migration.TargetModule, err.ErrorName))
				codeContent.WriteString("\n\n")
			}
		}

		// Add the generated code to the result
		result.AliasModuleCode[sourceModule] = codeContent.String()
	}

	// Update imports in referenced files
	updatedImports, err := UpdateImports(migration, extractReferencedFiles(errorDefinitions))
	if err != nil {
		return nil, fmt.Errorf("failed to update imports: %v", err)
	}
	result.UpdatedImports = updatedImports

	return result, nil
}

// UpdateImports updates import statements in files that reference migrated error types
func UpdateImports(migration *Migration, fileReferences []string) (map[string]string, error) {
	result := make(map[string]string)

	// Skip if we're not actually updating any files
	if len(fileReferences) == 0 {
		return result, nil
	}

	// Create a map of modules to errors for quick lookup
	moduleToErrors := make(map[string]map[string]bool)
	for _, errToMigrate := range migration.ErrorsToMigrate {
		if _, exists := moduleToErrors[errToMigrate.SourceModule]; !exists {
			moduleToErrors[errToMigrate.SourceModule] = make(map[string]bool)
		}
		moduleToErrors[errToMigrate.SourceModule][errToMigrate.ErrorName] = true
	}
	
	// Create a map of conflicted modules for quick lookup
	conflictedModules := make(map[string]bool)
	for _, errToMigrate := range migration.ErrorsToMigrate {
		if errToMigrate.HasNamespaceConflict {
			conflictedModules[errToMigrate.SourceModule] = true
		}
	}

	// Process each referenced file
	for _, filePath := range fileReferences {
		// Read the file
		fileData, err := os.ReadFile(filePath)
		if err != nil {
			return nil, fmt.Errorf("failed to read file %s: %v", filePath, err)
		}

		// Convert to string
		fileContent := string(fileData)

		// Look for import statements
		importRegex := regexp.MustCompile(`import\s+(\w+)`)
		matches := importRegex.FindAllStringSubmatch(fileContent, -1)

		// Track which modules we need to import
		needToImportTarget := false
		modulesToRemove := make(map[string]bool)
		hasConflictedImports := false

		// Check each import
		for _, match := range matches {
			if len(match) < 2 {
				continue
			}

			importedModule := match[1]
			if _, exists := moduleToErrors[importedModule]; exists {
				// This file imports a module that contains errors we're migrating
				modulesToRemove[importedModule] = true
				needToImportTarget = true
				
				if conflictedModules[importedModule] {
					hasConflictedImports = true
				}
			}
		}

		// If we need to update imports
		if needToImportTarget {
			// Add target module import
			if !strings.Contains(fileContent, fmt.Sprintf("import %s", migration.TargetModule)) {
				if hasConflictedImports {
					// If we have conflicted imports, suggest using an import alias
					fileContent = fmt.Sprintf("import %s // Auto-added by error_migrator\n// If you encounter namespace conflicts, consider using: import %s as CoreErr\n%s",
						migration.TargetModule, migration.TargetModule, fileContent)
				} else {
					fileContent = fmt.Sprintf("import %s // Auto-added by error_migrator\n%s",
						migration.TargetModule, fileContent)
				}
			}

			// Update the file content
			result[filePath] = fileContent
		}
	}

	return result, nil
}

// extractReferencedFiles extracts all referenced files from error definitions
func extractReferencedFiles(errorDefinitions map[string]map[string]*ErrorDefinition) []string {
	references := make(map[string]bool)
	for _, moduleDefs := range errorDefinitions {
		for _, def := range moduleDefs {
			for _, ref := range def.ReferencedFiles {
				references[ref] = true
			}
		}
	}

	var result []string
	for ref := range references {
		result = append(result, ref)
	}
	sort.Strings(result)
	return result
}

// generateErrorEnum generates Swift code for an error enum
func generateErrorEnum(errorDef *ErrorDefinition) string {
	var builder strings.Builder

	// Add documentation
	builder.WriteString("/// " + errorDef.ErrorName + " error type\n")
	
	// Start enum definition
	builder.WriteString("public enum " + errorDef.ErrorName + ": Error {\n")
	
	// Add cases
	for i, caseName := range errorDef.CaseNames {
		builder.WriteString("    case " + caseName)
		
		// Add detail if available
		if i < len(errorDef.CaseDetails) && errorDef.CaseDetails[i] != "" {
			builder.WriteString(" " + errorDef.CaseDetails[i])
		}
		
		builder.WriteString("\n")
	}
	
	// Close enum definition
	builder.WriteString("}")
	
	return builder.String()
}

// generateErrorStruct generates Swift code for an error struct
func generateErrorStruct(errorDef *ErrorDefinition) string {
	var builder strings.Builder
	
	// Add documentation
	builder.WriteString("/// " + errorDef.ErrorName + " error type\n")
	
	// Start struct definition
	builder.WriteString("public struct " + errorDef.ErrorName + ": Error {\n")
	
	// Add properties
	builder.WriteString("    public let message: String\n")
	builder.WriteString("    public let code: Int\n")
	
	// Add initializer
	builder.WriteString("\n")
	builder.WriteString("    public init(message: String, code: Int = 0) {\n")
	builder.WriteString("        self.message = message\n")
	builder.WriteString("        self.code = code\n")
	builder.WriteString("    }\n")
	
	// Close struct definition
	builder.WriteString("}")
	
	return builder.String()
}

// generateTypeAlias generates Swift code for a type alias
func generateTypeAlias(targetModule, errorName string) string {
	var builder strings.Builder
	
	// Add documentation
	builder.WriteString("/// Type alias for backward compatibility\n")
	
	// Add type alias
	builder.WriteString("public typealias " + errorName + " = " + targetModule + "." + errorName)
	
	return builder.String()
}

// WriteGeneratedCode writes the generated code to files
func WriteGeneratedCode(generatedCode *GeneratedCode, outputDir string, dryRun bool) error {
	if dryRun {
		fmt.Println("Dry run: would create the following files:")
		
		// Target module files
		for errorName := range generatedCode.TargetModuleCode {
			fmt.Printf("  %s/%s/%s.swift\n", outputDir, "CoreErrors", errorName)
		}
		
		// Alias module files
		for module := range generatedCode.AliasModuleCode {
			fmt.Printf("  %s/%s/%s_Aliases.swift\n", outputDir, module, module)
		}
		
		// Updated files
		for filePath := range generatedCode.UpdatedImports {
			fmt.Printf("  %s (updated imports)\n", filePath)
		}
		
		return nil
	}
	
	// Create output directory if it doesn't exist
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %v", err)
	}
	
	// Write target module files
	targetModuleDir := filepath.Join(outputDir, "CoreErrors")
	if err := os.MkdirAll(targetModuleDir, 0755); err != nil {
		return fmt.Errorf("failed to create target module directory: %v", err)
	}
	
	for errorName, codeContent := range generatedCode.TargetModuleCode {
		filePath := filepath.Join(targetModuleDir, errorName+".swift")
		if err := os.WriteFile(filePath, []byte(codeContent), 0644); err != nil {
			return fmt.Errorf("failed to write error definition: %v", err)
		}
		fmt.Printf("Created %s\n", filePath)
	}
	
	// Write alias module files
	for module, codeContent := range generatedCode.AliasModuleCode {
		moduleDir := filepath.Join(outputDir, module)
		if err := os.MkdirAll(moduleDir, 0755); err != nil {
			return fmt.Errorf("failed to create module directory: %v", err)
		}
		
		filePath := filepath.Join(moduleDir, module+"_Aliases.swift")
		if err := os.WriteFile(filePath, []byte(codeContent), 0644); err != nil {
			return fmt.Errorf("failed to write alias file: %v", err)
		}
		fmt.Printf("Created %s\n", filePath)
	}
	
	// Update import statements in referenced files
	for filePath, updatedContent := range generatedCode.UpdatedImports {
		if err := os.WriteFile(filePath, []byte(updatedContent), 0644); err != nil {
			return fmt.Errorf("failed to update imports in %s: %v", filePath, err)
		}
		fmt.Printf("Updated imports in %s\n", filePath)
	}
	
	return nil
}
