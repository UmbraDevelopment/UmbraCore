# Error Migrator Tool

This tool automates the migration of error types to a centralized CoreErrors module in the UmbraCore project.

## Overview

The Error Migrator tool is designed to:

1. Parse error analysis reports generated by the `error_analyzer` tool
2. Create a migration plan for consolidating duplicated error types
3. Generate new error definitions in a central module
4. Create type aliases in original modules for backward compatibility
5. Support dry-run mode to preview changes before applying them
6. Detect and handle namespace conflicts between modules and error types

## Usage

```bash
# Initialize a default configuration file
go run . --initConfig --report /path/to/error_analysis_report.md --config migration_config.json

# Review and edit the generated configuration file
# Then run the migration in dry-run mode (default)
go run . --config migration_config.json --report /path/to/error_analysis_report.md --output /path/to/output

# Run with verbose output to see the generated code
go run . --config migration_config.json --report /path/to/error_analysis_report.md --output /path/to/output --verbose

# Apply the migration
go run . --config migration_config.json --report /path/to/error_analysis_report.md --apply --output /path/to/output
```

You can also use the provided Makefile:

```bash
# Build the tool
make build

# Run tests
make test
make test-integration
make test-conflicts
make test-all

# Run with verbose output
make run-with-verbose

# Initialize a configuration
make run-init
```

## Configuration

The migration is controlled by a JSON configuration file with the following structure:

```json
{
  "targetModule": "CoreErrors",
  "errorsToMigrate": {
    "SecurityError": ["SecurityProtocolsCore", "XPCProtocolsCore"],
    "ResourceError": ["ResourceManagementCore", "StorageCore"]
  },
  "dryRun": true,
  "outputDir": "./generated_code"
}
```

- `targetModule`: The name of the module where error types will be consolidated
- `errorsToMigrate`: Map of error names to source modules to migrate from
- `dryRun`: If true, no files will be modified (preview mode)
- `outputDir`: Directory where generated files will be placed

## Namespace Conflict Handling

The tool automatically detects and provides solutions for namespace conflicts that can occur when:

1. A module has an enum with the same name as the module itself (e.g., `SecurityProtocolsCore.SecurityProtocolsCore`)
2. Two modules define the same error type (e.g., `SecurityError` in multiple modules)

When namespace conflicts are detected, the tool:

1. Provides detailed warnings and guidance in the migration summary
2. Generates alternative import approaches in alias files
3. Inserts helpful comments in updated import statements
4. Suggests contextual type inference where possible

### Conflict Resolution Strategies

For files affected by namespace conflicts, the tool offers multiple resolution strategies:

1. **Contextual Type Inference**: Using unqualified names where Swift can infer the type
   ```swift
   throw SecurityError.unauthorized  // If type can be inferred from context
   ```

2. **Import Aliases**: Using module aliases to disambiguate imports
   ```swift
   import CoreErrors as CoreErr
   throw CoreErr.SecurityError.unauthorized
   ```

3. **Type Aliases**: Creating explicit type aliases in affected files
   ```swift
   typealias SecurityCoreError = CoreErrors.SecurityError
   throw SecurityCoreError.unauthorized
   ```

## Workflow

1. Run the `error_analyzer` tool to identify duplicated error types
2. Generate a default configuration file with the `--initConfig` flag
3. Edit the configuration file to customize the migration
4. Run in dry-run mode to review the changes
5. Run with `--apply` to apply the changes

## Example Output

The tool generates:

1. Swift files in the target module containing consolidated error definitions
2. Type alias files in the original modules for backward compatibility
3. Updated import statements in files that reference the migrated errors
4. Special handling for files affected by namespace conflicts

## Implementation Notes

The Error Migrator tool works in stages:

1. **Report Parsing**: Reads the error analysis report to extract error definitions and duplications
2. **Migration Planning**: Creates a plan based on the configuration and error definitions, detecting potential namespace conflicts
3. **Code Generation**: Generates new Swift code for the target module and aliases, with special handling for namespace conflicts
4. **File Writing**: Writes the generated code to files if not in dry-run mode

## File Organization

The tool generates a specific file structure:

1. **Error Type Files**: Individual Swift files for each error type in the target module directory
   ```
   /path/to/output/CoreErrors/SecurityError.swift
   /path/to/output/CoreErrors/ResourceError.swift
   ```

2. **Alias Files**: Module-specific alias files in original module directories
   ```
   /path/to/output/SecurityProtocolsCore/SecurityProtocolsCore_Aliases.swift
   /path/to/output/XPCProtocolsCore/XPCProtocolsCore_Aliases.swift
   ```

This organization improves maintainability by separating error types into individual files and keeping alias declarations modular.

## Conflict Detection and Resolution

The tool now offers enhanced conflict detection that specifically identifies:

1. **Module-Name Enum Conflicts**: Where a module (e.g., `SecurityProtocolsCore`) contains an enum with the same name
2. **Cross-Module Type Conflicts**: Where the same error name exists in multiple modules

When these conflicts are detected, the tool provides:

1. **Comprehensive Guidance**: Comments in alias files explaining resolution strategies
2. **Aliasing Options**: Multiple import and type alias examples
3. **Context-Specific Solutions**: Different approaches based on the specific conflict

The generated code includes verbose comments to guide developers on proper usage, helping to avoid Swift compiler ambiguity errors.

## Related Tools

- `error_analyzer`: Analyzes the codebase for error types and generates migration reports
