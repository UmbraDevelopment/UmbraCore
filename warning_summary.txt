  36 warning: \u0027SecurityError\u0027 aliases \u0027ErrorHandlingDomains.Protocols\u0027 and cannot be used here because \u0027ErrorHandlingDomains\u0027 was not imported by this file
   4 warning: switch must be exhaustive
   4 warning: stored property \u0027service\u0027 of \u0027Sendable\u0027-conforming class \u0027CryptoXPCServiceAdapter\u0027 has non-sendable type \u0027any CryptoXPCServiceProtocol\u0027
   4 warning: passing closure as a \u0027sending\u0027 parameter risks causing data races between code in the current task and concurrent execution of the closure
   4 warning: main actor-isolated class property \u0027shared\u0027 can not be referenced from a nonisolated context
   4 warning: file \u0027XPCProtocolErrors.swift\u0027 is part of module \u0027ErrorHandlingDomains\u0027
   4 warning: \u0027nonisolated\u0027 on an actor\u0027s synchronous initializer is invalid
   2 warning: sending \u0027newConnection\u0027 risks causing data races
   2 warning: sending \u0027decoder\u0027 risks causing data races
   1 warning: result of call to \u0027perform()\u0027 is unused\n205 |     if let firstOption\u003doptions.first {\n206 |       print(\"Selected: \\(firstOption.title)\")\n207 |       firstOption.perform()\n    |                   `- warning: result of call to \u0027perform()\u0027 is unused\n208 |     } else {\n209 |       print(\"No recovery options available\")\n\nSources/ErrorHandling/Utilities/ErrorHandlingExample.swift:156:7: warning: no \u0027async\u0027 operations occur within \u0027await\u0027 expression\n154 |     // Report the error\n155 |     Task {\n156 |       await errorHandler.handle(wrappedError)\n    |       `- warning: no \u0027async\u0027 operations occur within \u0027await\u0027 expression\n157 |       print(\"Security error handled.\")\n158 | \n"}}
   1 warning: \u0027catch\u0027 block is unreachable because no errors are thrown in \u0027do\u0027 block\n112 | \n113 |       return .success(SecureBytes(bytes: keyBytes))\n114 |     } catch {\n    |       `- warning: \u0027catch\u0027 block is unreachable because no errors are thrown in \u0027do\u0027 block\n115 |       return .failure(.internalError(\"Failed to generate key: \\(error.localizedDescription)\"))\n116 |     }\n\nSources/SecurityImplementation/Sources/CryptoServices/Core/CryptoServiceCore.swift:287:7: warning: \u0027catch\u0027 block is unreachable because no errors are thrown in \u0027do\u0027 block\n285 | \n286 |       return .success(SecureBytes(bytes: keyBytes))\n287 |     } catch {\n    |       `- warning: \u0027catch\u0027 block is unreachable because no errors are thrown in \u0027do\u0027 block\n288 |       return .failure(.internalError(\"Failed to generate key: \\(error.localizedDescription)\"))\n289 |     }\n\nSources/SecurityImplementation/Sources/CryptoServices/Core/CryptoServiceCore.swift:333:7: warning: \u0027catch\u0027 block is unreachable because no errors are thrown in \u0027do\u0027 block\n331 | \n332 |       return .success(SecureBytes(bytes: randomBytes))\n333 |     } catch {\n    |       `- warning: \u0027catch\u0027 block is unreachable because no errors are thrown in \u0027do\u0027 block\n334 |       return .failure(\n335 |         .randomGenerationFailed(\"Random data generation failed: \\(error.localizedDescription)\")\n\nSources/SecurityImplementation/Sources/KeyManagement/KeyManagementImpl.swift:185:7: warning: \u0027catch\u0027 block is unreachable because no errors are thrown in \u0027do\u0027 block\n183 | \n184 |       return .success((newKey: newKey, reencryptedData: reencryptedData))\n185 |     } catch {\n    |       `- warning: \u0027catch\u0027 block is unreachable because no errors are thrown in \u0027do\u0027 block\n186 |       return .failure(.internalError(\"Key rotation failed: \\(error)\"))\n187 |     }\n\nSources/SecurityImplementation/Sources/KeyManagement/KeyManager.swift:206:29: warning: no calls to throwing functions occur within \u0027try\u0027 expression\n204 |           // For re-encryption, we need to decrypt with the old key and encrypt with the new key\n205 |           let retrieveConfig\u003dSecurityConfigDTO(algorithm: \"AES-GCM\", keySizeInBits: 256)\n206 |           let decryptResult\u003dtry? await keyUtils.decryptSymmetricDTO(\n    |                             `- warning: no calls to throwing functions occur within \u0027try\u0027 expression\n207 |             data: dataToReencrypt,\n208 |             key: oldKey,\n\nSources/SecurityImplementation/Sources/KeyManagement/KeyManager.swift:225:29: warning: no calls to throwing functions occur within \u0027try\u0027 expression\n223 |           }\n224 | \n225 |           let encryptResult\u003dtry? await keyUtils.encryptSymmetricDTO(\n    |                             `- warning: no calls to throwing functions occur within \u0027try\u0027 expression\n226 |             data: reencryptedData!,\n227 |             key: newKey,\n\nSources/SecurityImplementation/Sources/KeyManagement/KeyManager.swift:273:13: warning: variable \u0027reencryptedData\u0027 was written to, but never read\n271 |     switch retrieveResult {\n272 |       case let .success(oldKey):\n273 |         var reencryptedData: SecureBytes?\n    |             `- warning: variable \u0027reencryptedData\u0027 was written to, but never read\n274 |         if let dataToReencrypt\u003dconfig.dataToReencrypt {\n275 |           // For re-encryption, we need to decrypt with the old key and encrypt with the new key\n\nSources/SecurityImplementation/Sources/KeyManagement/KeyManager.swift:277:29: warning: no calls to throwing functions occur within \u0027try\u0027 expression\n275 |           // For re-encryption, we need to decrypt with the old key and encrypt with the new key\n276 |           let retrieveConfig\u003dSecurityConfigDTO(algorithm: \"AES-GCM\", keySizeInBits: 256)\n277 |           let decryptResult\u003dtry? await keyUtils.decryptSymmetricDTO(\n    |                             `- warning: no calls to throwing functions occur within \u0027try\u0027 expression\n278 |             data: dataToReencrypt,\n279 |             key: oldKey,\n[734 / 742] [Prepa] Linking Sources/SecurityImplementation/libSecurityImplementation.a\n"}}
   1 warning: @preconcurrency attribute on conformance to \u0027ErrorNotificationProtocol\u0027 has no effect\n  6 | /// Central coordinating service for error notifications\n  7 | @MainActor\n  8 | public final class ErrorNotifier: @preconcurrency ErrorNotificationProtocol {\n    |                    `- warning: @preconcurrency attribute on conformance to \u0027ErrorNotificationProtocol\u0027 has no effect\n  9 |   /// The shared instance\n 10 |   public static let shared\u003dErrorNotifier()\nSources/ErrorHandling/Notification/ErrorNotification.swift:145:45: warning: conditional cast from \u0027any Error\u0027 to \u0027NSError\u0027 always succeeds\n143 |     recoveryOptions: [any RecoveryOption]\n144 |   ) async {\n145 |     let domain: String\u003dif let nsError\u003derror as? NSError {\n    |                                             `- warning: conditional cast from \u0027any Error\u0027 to \u0027NSError\u0027 always succeeds\n146 |       nsError.domain\n147 |     } else if let customError\u003derror as? any CustomStringConvertible {\n\nSources/ErrorHandling/Notification/ErrorNotification.swift:147:37: warning: conditional cast from \u0027any Error\u0027 to \u0027any CustomStringConvertible\u0027 always succeeds\n145 |     let domain: String\u003dif let nsError\u003derror as? NSError {\n146 |       nsError.domain\n147 |     } else if let customError\u003derror as? any CustomStringConvertible {\n    |                                     `- warning: conditional cast from \u0027any Error\u0027 to \u0027any CustomStringConvertible\u0027 always succeeds\n148 |       String(describing: type(of: customError))\n149 |     } else {\n\nSources/ErrorHandling/Notification/ErrorNotifier.swift:8:20: warning: @preconcurrency attribute on conformance to \u0027ErrorNotificationProtocol\u0027 has no effect\n  6 | /// Central coordinating service for error notifications\n  7 | @MainActor\n  8 | public final class ErrorNotifier: @preconcurrency ErrorNotificationProtocol {\n    |                    `- warning: @preconcurrency attribute on conformance to \u0027ErrorNotificationProtocol\u0027 has no effect\n  9 |   /// The shared instance\n 10 |   public static let shared\u003dErrorNotifier()\n\nSources/ErrorHandling/Notification/MacErrorNotificationService.swift:144:33: warning: conditional cast from \u0027any Error\u0027 to \u0027NSError\u0027 always succeeds\n142 |     if let umbraError\u003derror as? UmbraError {\n143 |       umbraError.domain\n144 |     } else if let nsError\u003derror as? NSError {\n    |                                 `- warning: conditional cast from \u0027any Error\u0027 to \u0027NSError\u0027 always succeeds\n145 |       nsError.domain\n146 |     } else {\n"}}
