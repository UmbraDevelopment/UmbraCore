import Foundation
import XCTest
@testable import UmbraKeychainService

/// Helper class for managing XPC service lifecycle in tests
final class XPCServiceHelper {
    private static var service: KeychainXPCService?
    private static let queue = DispatchQueue(label: "com.umbracore.keychain.test")
    private static let timeout: TimeInterval = 5.0
    
    static func startService() {
        queue.sync {
            guard service == nil else { return }
            service = KeychainXPCService()
            service?.start()
            
            // Wait for service to be ready
            let startTime = Date()
            while !isServiceReady() {
                if Date().timeIntervalSince(startTime) > timeout {
                    XCTFail("XPC service failed to start within \(timeout) seconds")
                    return
                }
                Thread.sleep(forTimeInterval: 0.1)
            }
        }
    }
    
    static func stopService() {
        queue.sync {
            service?.stop()
            service = nil
            
            // Wait for service to fully stop
            let startTime = Date()
            while service != nil {
                if Date().timeIntervalSince(startTime) > timeout {
                    XCTFail("XPC service failed to stop within \(timeout) seconds")
                    return
                }
                Thread.sleep(forTimeInterval: 0.1)
            }
        }
    }
    
    private static func isServiceReady() -> Bool {
        let connection = KeychainXPCConnection()
        defer { connection.disconnect() }
        
        do {
            let proxy = try connection.connect()
            
            // Try a simple operation
            let semaphore = DispatchSemaphore(value: 0)
            var isReady = false
            
            proxy.containsItem(account: "test",
                             service: "test",
                             accessGroup: nil) { _, error in
                isReady = error == nil
                semaphore.signal()
            }
            
            _ = semaphore.wait(timeout: .now() + 1.0)
            return isReady
        } catch {
            return false
        }
    }
    
    static func cleanupTestItems() async throws {
        let connection = KeychainXPCConnection()
        defer { connection.disconnect() }
        
        let proxy = try connection.connect()
        let semaphore = DispatchSemaphore(value: 0)
        
        proxy.deleteItem(account: "testAccount",
                        service: "com.umbracore.tests",
                        accessGroup: nil) { error in
            semaphore.signal()
        }
        
        _ = semaphore.wait(timeout: .now() + 1.0)
    }
}
