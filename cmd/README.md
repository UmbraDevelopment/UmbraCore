# UmbraCore Command-Line Tools

This document provides an overview of the command-line tools available in the UmbraCore project's `/cmd` directory. These tools help to maintain and improve the dependency management and build processes for the UmbraCore Swift codebase.

## Overview

The `/cmd` directory contains several tools that work together to help manage Swift dependencies in a Bazel build environment:

1. `swift_target_mapper` - Creates mappings between Swift module names and Bazel targets
2. `swift_deps` - Analyses and fixes dependency issues using the mapping data
   - `scanner` - Scans Swift files to identify imports and type references
   - `resolver` - Resolves and fixes dependency issues in BUILD files
   - `bazel` - Provides interfaces to the Bazel build system

## swift_target_mapper

### Purpose
The `swift_target_mapper` tool creates a JSON mapping file that connects Swift module names to their corresponding Bazel targets.

### Functionality
- Runs Bazel queries to find all Swift library targets in the project
- Creates a mapping of Swift module names to their Bazel target paths
- Adds standard library modules that don't need explicit dependencies
- Outputs the mapping to a JSON file (default: `swift_target_mapping.json`)

### Usage
```bash
./run_mapper.sh [--output OUTPUT_PATH] [--verbose]
```

### Options
- `--output`: Specify the output path for the target mapping file (default: `swift_target_mapping.json`)
- `--verbose`: Enable verbose logging

### Output
A JSON file with a structure like:
```json
{
  "importToTarget": {
    "ModuleName1": "//path/to/target:name1",
    "ModuleName2": "//path/to/target:name2",
    "Foundation": ""
  },
  "generated": "2025-03-26T17:00:00Z"
}
```

## swift_deps

### Purpose
`swift_deps` is a comprehensive tool that uses the mapping file generated by `swift_target_mapper` to analyse and fix dependency issues in the codebase.

### Components

#### 1. Scanner (`/scanner`)
- Scans Swift source files to find imports and type references
- Identifies which modules are being used by each file
- Builds a dependency graph of imports and type usages

#### 2. Resolver (`/resolver`)
- Uses the mapping data to resolve actual dependencies
- Detects missing dependencies in BUILD.bazel files
- Can fix visibility issues between targets
- Can detect circular dependencies
- Supports DTO-specific dependency resolution

#### 3. Bazel Interface (`/bazel`)
- Provides interfaces to interact with the Bazel build system
- Executes Bazel queries as needed
- Handles BUILD file modifications safely

### Usage
```bash
./run_swift_deps.sh [--dry-run] [--fix-types] [--fix-visibility] [--all] [--verbose]
```

### Options
- `--dry-run`: Preview changes without modifying files
- `--fix-types`: Fix missing imports and types
- `--fix-visibility`: Fix visibility issues
- `--fix-circular`: Check for circular dependencies
- `--fix-dtos`: Fix missing DTO types
- `--all`: Fix all issues (default if no specific fix is requested)
- `--verbose`: Enable verbose logging
- `--mapping`: Path to the target mapping file (default: `swift_target_mapping.json`)
- `--module`: Process only a specific module or directory
- `--validate-only`: Validate changes without applying them
- `--check-transitive`: Check for transitively available dependencies

## How These Tools Work Together

The tools operate in a pipeline:

1. **Generate Mapping**: 
   - First, `swift_target_mapper` is run to generate a JSON mapping file
   - This file maps Swift module names to their Bazel targets
   - Example: `ModuleName` â†’ `//Sources/ModuleName:ModuleName`

2. **Analyse Dependencies**:
   - Next, `swift_deps` uses this mapping file as input
   - It scans Swift source files to find imports and type references
   - It identifies which modules are used by each file

3. **Resolve and Fix**:
   - `swift_deps` compares actual dependencies with declared dependencies
   - It identifies missing dependencies, visibility issues, and circular dependencies
   - It can automatically update BUILD.bazel files to fix these issues

## Common Use Cases

### Finding Missing Dependencies
```bash
# Generate mapping file
./cmd/swift_target_mapper/run_mapper.sh

# Fix all dependency issues
./cmd/swift_deps/run_swift_deps.sh --all
```

### Checking for Issues Without Making Changes
```bash
# Preview changes without modifying files
./cmd/swift_deps/run_swift_deps.sh --dry-run --all
```

### Fixing Dependencies for a Specific Module
```bash
# Fix dependencies for just one module
./cmd/swift_deps/run_swift_deps.sh --module Sources/SecurityInterfaces
```

### Validating Changes
```bash
# Validate changes without applying them
./cmd/swift_deps/run_swift_deps.sh --validate-only
```

## Best Practices

1. **Run Regularly**: Include these tools in your development workflow to prevent dependency issues
2. **Run Before PR Submission**: Check for and fix dependency issues before submitting code for review
3. **Use Dry Run First**: Always start with `--dry-run` to see what changes would be made
4. **Specific Fixes**: Use targeted fix options when working on specific issues
5. **Regenerate Mapping**: Regenerate the mapping file when new modules are added to the project

## Troubleshooting

If you encounter issues:

1. Check that all commands are run from the repository root
2. Ensure that all binaries are properly built (`bazelisk build //cmd/...`)
3. For `swift_deps` issues, try regenerating the mapping file
4. Use `--verbose` to get more detailed logs
5. Check the exit codes of the commands for specific error indications

## Build & Development

To build these tools:

```bash
# Build all tools
bazelisk build //cmd/...

# Build specific tool
bazelisk build //cmd/swift_target_mapper
bazelisk build //cmd/swift_deps
```

To run the built tools directly:

```bash
# Run via the wrapper scripts (recommended)
./cmd/swift_target_mapper/run_mapper.sh
./cmd/swift_deps/run_swift_deps.sh

# Or run the binaries directly (not recommended)
./bazel-bin/cmd/swift_target_mapper/swift_target_mapper_/swift_target_mapper
./bazel-bin/cmd/swift_deps/swift_deps_/swift_deps
```
